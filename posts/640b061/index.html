<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.5.0">


  <link rel="mask-icon" href="/images/safari_pinned_tab.svg?v=6.5.0" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml">







<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Survey/Review 本文主要是对相关论文的阅读和摘要。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing is an automatic bug and vulnerability discovery technique which continuously generates inputs and reports those t">
<meta name="keywords" content="fuzz">
<meta property="og:type" content="article">
<meta property="og:title" content="IS-pwn-fuzz-theory-present-situation">
<meta property="og:url" content="https://hitworld.github.io/posts/640b061/index.html">
<meta property="og:site_name" content="w4rd3n">
<meta property="og:description" content="Survey/Review 本文主要是对相关论文的阅读和摘要。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing is an automatic bug and vulnerability discovery technique which continuously generates inputs and reports those t">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-22-46-04.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-13-09-41.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-09-55.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-40-06.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-40-26.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-40-06.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-40-26.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-17-05-33.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-17-14-22.png">
<meta property="og:updated_time" content="2021-01-11T11:07:16.856Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IS-pwn-fuzz-theory-present-situation">
<meta name="twitter:description" content="Survey/Review 本文主要是对相关论文的阅读和摘要。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing is an automatic bug and vulnerability discovery technique which continuously generates inputs and reports those t">
<meta name="twitter:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">






  <link rel="canonical" href="https://hitworld.github.io/posts/640b061/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>IS-pwn-fuzz-theory-present-situation | w4rd3n</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">w4rd3n</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">混吃等死</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>友链</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hitworld.github.io/posts/640b061/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="w4rd3n">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/apple-touch-icon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="w4rd3n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">IS-pwn-fuzz-theory-present-situation
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-01-01 23:41:38" itemprop="dateCreated datePublished" datetime="2021-01-01T23:41:38+08:00">2021-01-01</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/" itemprop="url" rel="index"><span itemprop="name">IS</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/posts/640b061/" class="leancloud_visitors" data-flag-title="IS-pwn-fuzz-theory-present-situation">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度：</span>
               
                 <span class="leancloud-visitors-count"></span>
                 <span>℃</span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">85k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:17</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="surveyreview">Survey/Review</h2>
<p>本文主要是对相关论文的阅读和摘要。</p>
<h3 id="fuzzing-challenges-and-reflections">Fuzzing: Challenges and Reflections</h3>
<p><a href="https://www.comp.nus.edu.sg/~abhik/pdf/IEEE-SW-Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>Fuzzing is an automatic bug and vulnerability discovery technique which continuously generates inputs and reports those that crash the program.</p>
<p>There are three main categories of fuzzing tools and techniques: blackbox, greybox and whitebox fuzzing.</p>
<p>自动化漏洞发现技术---通过持续不断地生成输入并报告程序crash。</p>
<h4 id="blackbox-fuzzing">Blackbox fuzzing</h4>
<p>Blackbox fuzzing generates inputs without any knowledge of the program.</p>
<p>There are two main variants of blackbox fuzzing: mutational and generational.</p>
<p>In mutational blackbox fuzzing, the fuzz campaign starts with one or more seed inputs. These seeds are modified to generate new inputs. Random mutations are applied to random locations in the input. For instance, a file fuzzer may flip random bits in a seed file. The process continues until a time budget is exhausted.</p>
<p>In generational blackbox fuzzing, inputs are generated from scratch. If a structural specification of the input format is provided, new inputs are generated that meet the grammar.</p>
<p>Peach (http://community.peachfuzzer.com) is one popular blackbox fuzzer.</p>
<p>两种黑盒模糊测试区别在于前者通过初始语料库开始变异，后者通过提供的输入格式进行生成。</p>
<h4 id="greybox-fuzzing">Greybox fuzzing</h4>
<p>Greybox fuzzing leverages program instrumentation to get lightweight feedback which is used to steer the fuzzer.</p>
<p>Typically, a few control locations in the program are instrumented at compile time and an initial seed corpus is provided.</p>
<p>Seed inputs are mutated to generate new inputs. Generated inputs that cover new control locations, and thus increase code coverage, are added to the seed corpus.</p>
<p>The coverage feedback allows a greybox fuzzer to gradually reach deeper into the code.</p>
<p>In order to identify bugs and vulnerabilities, sanitizers inject assertions into the program.</p>
<p>Existing greybox fuzzing tools include AFL (https://lcamtuf.coredump.cx/afl/), LibFuzzer (https://llvm.org/docs/LibFuzzer.html), and Honggfuzz (https://github.com/google/honggfuzz).</p>
<p>灰盒模糊测试通过在编译时对一些位置（例如代码块跳转点）进行插桩来获取运行时反馈，从而更好的筛选语料进入语料库，获取更好的覆盖率，深入代码发现漏洞。</p>
<h4 id="whitebox-fuzzing">Whitebox fuzzing</h4>
<p>Whitebox fuzzing is based on a technique called symbolic execution, which uses program analysis and constraint solvers to systematically enumerate interesting program paths. The constraint solvers used as the back-end in whitebox fuzzing are Satisfiability Modulo Theory (SMT) solvers, which allow for reasoning about (quantifier free) first-order logic formulas with equality and function/predicate symbols drawn from different background theories.</p>
<p>Whitebox fuzzers calculate the path condition of an input i—the set of inputs which traverse the same path as i. The path condition is represented as an SMTformula, e.g. i[0] = 42 ∧ i[0] − i[1] &gt; 7.</p>
<p>Given a seed input s, the path condition is calculated and mutated (as opposed to mutating the program input). The mutated path condition is then sent to a constraint solver to generate new inputs.</p>
<p>The main benefit of this technique is that by carefully keeping track of path conditions of all inputs seen so far, it always generates an input traversing a new path (new control flow).</p>
<p>Existing whitebox fuzzing tools include KLEE (https://klee. github.io/) and SAGE.</p>
<p>基于符号执行的白盒模糊测试，通过变异路径条件，然后利用约束求解器生成新的输入，这种方式总是能生成一个经过新的路径（深入代码）的输入。</p>
<h4 id="other-fuzzing-tools">Other fuzzing tools</h4>
<p>DeepState, a unit testing framework that allows developers to fuzz the various units of their system (https://github. com/trailofbits/deepstate).</p>
<p>The Mayhem system. --- Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, David Brumley. 2012. Unleashing Mayhem on Binary Code. IEEE Symposium on Security and Privacy (S&amp;P’12).</p>
<h4 id="challenges">Challenges</h4>
<p>现阶段模糊测试的挑战。</p>
<h5 id="automation">Automation</h5>
<p>自动化模糊测试方面的挑战。</p>
<h6 id="c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems">[C.1] More Software. How can we fuzz efficiently more types of software systems?</h6>
<p>How to fuzz programs that take highly-structured inputs, such as file parsers or object-oriented programs.</p>
<p>Fuzzing cyber-physical systems, which interact with the environment as part of their execution, or machine learning systems, whose behavior is determined by their training data, is an under-explored area.</p>
<p>How do we fuzz stateful software, such as protocol implementations, which can produce different outputs for the same input?</p>
<p>How do we fuzz polyglot software which is written in several languages?</p>
<p>How do we fuzz GUI-based programs that take as inputs a sequence of events executed on a user interface?</p>
<p>Given a program whose input domain is defined by a grammar and/or protocol, how can a symbolic execution tool effectively formulate constraints on such ,,structured” input domains?</p>
<p>如何扩展能够进行模糊测试的领域和范围。</p>
<h6 id="c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</h6>
<p>Vulnerabilities are often encoded as assertions on the program state.</p>
<p>Using such assertions, we already know how we can discover memory- or concurrency related errors.</p>
<p>The discovery of side-channel vulnerabilities, such as information leaks or timing, cache, or energy-related side-channels is currently an active research topic.</p>
<p>Going forward, we should invent techniques to automatically detect and invoke privilege escalation, remote code execution, and other types of critical security flaws, not only in C/C++ but also in other programming languages.</p>
<p>如何扩展模糊测试发现的漏洞类型？现在已经可以利用断言检测程序运行状态发现内存和并发漏洞。侧信道漏洞发现已经成为热门，未来应该着眼于其他的关键性安全漏洞，包括其他编程语言中的。</p>
<h6 id="c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection">[C.3] More Difficult Bugs. How can we find “deep bugs” for which efficient oracles exist, but which nevertheless evade detection?</h6>
<p>Are there certain kinds of deep bugs that can be found efficiently with specialized approaches? Structure-aware and grammar-based fuzzing as well as the integration of static analysis and symbolic execution with greybox fuzzing are promising directions.</p>
<p>Software also changes all the time—techniques that can target software patches will prove essential for finding bugs as they are introduced.</p>
<p>We should investigate strategies to boost fault finding, such as AFLFast which enables faster crash detection in greybox fuzzers, and study the utility of GPUs and other means of efficient parallelization to maximize the number of executions per unit time.</p>
<p>Ranking bugs in terms of their importance can also improve the effectiveness of fuzzing in practice.</p>
<p>如何发现更深层次的漏洞？</p>
<ol type="1">
<li>结构感知和基于语法的模糊测试，以及静态分析和符号执行与灰盒模糊测试的结合是很有前途的方向。</li>
<li>针对软件补丁的技术可能是发现错误的关键。</li>
<li>应该研究促进故障发现的策略。</li>
</ol>
<h6 id="c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</h6>
<p>Why have they evaded discovery? We need empirical studies to understand the nature and distribution of security vulnerabilities in source code.</p>
<p>需要实证研究来了解源代码中安全漏洞的性质和分布。</p>
<h5 id="the-human-component">The Human Component</h5>
<p>模糊测试中的人工成分。</p>
<h6 id="c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</h6>
<p>During our meeting, Ned Williamson, a prolific security researcher at Google, demonstrated his semi-automated approach to vulnerability discovery.</p>
<p>Ned would first audit the code to identify units that may contain a security flaw.</p>
<p>He would prepare the unit for fuzzing, run the fuzzer for a while, and identify roadblocks for the fuzzer.</p>
<p>Ned would manually patch out the roadblock to help the fuzzer make better progress.</p>
<p>If the fuzzer spends more time fuzzing less relevant portions of the code, Ned would adjust the test driver and re-focus the fuzzer.</p>
<p>Once a potential vulnerability is found, he would backtrack, add each roadblock back, and adjust the vulnerability-exposing input accordingly.</p>
<p>This semi-automated process raises several research questions. How can we facilitate a more effective communication between fuzzer and security auditor? How can the security auditor dynamically direct the fuzzer? How can the fuzzer explain what prevents it from progressing, and how can the auditor instruct the fuzzer to overcome the roadblock?</p>
<p>人在模糊测试中能起到的作用，也就是什么才是最合理的半自动化模糊测试方案？</p>
<h6 id="c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools">[C.6] Usability. How can we improve the usability of fuzzing tools?</h6>
<p>如何提高模糊工具的可用性？</p>
<h5 id="fuzzing-theory">Fuzzing Theory</h5>
<p>Why do some fuzzers work so much better than others? What are their limitations? We want to be able to explain interesting phenomena that we have observed empirically, make predictions and extrapolate from these observations.</p>
<p>To do this, we need a sound theoretical model of the fuzzing process.</p>
<h6 id="c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</h6>
<p>Blackbox and whitebox fuzzing sit on two ends of a spectrum.</p>
<p>A whitebox fuzzer might provide a formal guarantee about the absence of detectable vulnerabilities. If we assume that a symbolic execution engine can enumerate all paths in piece of code and the oracle is encoded as assertions, then whitebox fuzzing can formally verify the absence of bugs.</p>
<p>If it can enumerate only some paths in reasonable time, we can still provide partial guarantees.</p>
<p>To make symbolic execution applicable in practice, correctness or completeness are traded for scalability. How does this trade-off affect the guarantees?</p>
<p>In contrast, a blackbox fuzzer can never guarantee the absence of vulnerabilities for all inputs.</p>
<p>What is the residual risk that at the end of a fuzzing campaign a bug still exists in the program that has not been found? If we model blackbox fuzzing as a random sampling from the program’s input space, we can leverage methods from applied statistics to estimate the residual risk.</p>
<p>A greybox fuzzer uses program feedback to boost the efficiency of finding errors. However, this program feedback introduces an adaptive bias. How do we account for this adaptive bias when assessing residual risk? To answer such questions, we should develop statistical and probabilistic frameworks, and methodologies for sound estimation with quantifiable accuracy.</p>
<p>除了白盒模糊测试，灰盒模糊测试和黑盒模糊测试都不能保证没有未发现的漏洞。白盒模糊测试受限于时间和可扩展性也无法完全保证，灰盒模糊测试存在适应性偏差，黑盒模糊测试存在剩余风险。</p>
<h6 id="c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</h6>
<p>Given a program and a time budget, how can we select that fuzzing technique, or combination of techniques, which finds the most vulnerabilities within the time budget?</p>
<p>How do program size and complexity affect the scalability and performance of each technique?</p>
<p>How much more efficient is an attacker that has an order of magnitude more computational resources?</p>
<h5 id="evaluation-and-benchmarks">Evaluation and Benchmarks</h5>
<p>[C.9] How can we evaluate specialized fuzzers?</p>
<p>[C.10] How can we prevent overfitting to a specific benchmark?</p>
<p>[C.11] Are synthetic bugs representative?</p>
<p>[C.12] Are real bugs, which have previously been discovered with other fuzzers, representative?</p>
<p>[C.13] Is coverage a good measure of fuzzer effectiveness?</p>
<p>[C.14] What is a fair choice of time budget?</p>
<p>[C.15] How do we evaluate techniques instead of implementations?</p>
<h4 id="survey">Survey</h4>
<p>The survey participants marked improving automation (71%), building a theory of fuzzing (63%), and finding valid measures of fuzzer performance (63%) as their Top-3 most important challenges.</p>
<p>While practitioners and researchers were mostly in agreement, practitioners demonstrated a particularly greater interest in the development of human-in-the-loop approaches (+0.8 Likert points).</p>
<p>On average, a respondent marked all identified challenges as important or very important on a 5-point Likert-scale.</p>
<h3 id="sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv20_SoK.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>Abstract—Greybox fuzzing has been the most scalable and practical approach to software testing.</p>
<p>Most greybox fuzzing tools are coverage guided as code coverage is strongly correlated with bug coverage.</p>
<p>However, since most covered codes may not contain bugs, blindly extending code coverage is less efficient, especially for corner cases.</p>
<p>Unlike coverage-based fuzzers who extend the code coverage in an undirected manner, a directed fuzzer spends most of its time budget on reaching specific target locations (e.g., the bug-prone zone) without wasting resources stressing unrelated parts.</p>
<p>Thus, directed greybox fuzzing is particularly suitable for scenarios such as patch testing, bug reproduction, and special bug hunting.</p>
<p>与盲目扩展路径覆盖范围的基于覆盖范围的模糊测试程序不同，定向模糊测试程序将其大部分时间预算花在到达特定的目标位置（例如，容易出bug的区域）上，而不会浪费资源来测试不相关的部分。因此，定向灰盒模糊测试特别适用于补丁测试、bug复现以及与其他工具集成等场景。</p>
<p>传统的导向模糊测试是基于符号执行，但是这种方法会受到符号执行一些问题而限制（复杂的约束求解和路径爆炸等问题）。</p>
<h4 id="introduction">Introduction</h4>
<p>Traditionally, directed fuzzers are based on symbolic execution, which uses program analysis and constraint solving to generate inputs that exercise different program paths. Such directed fuzzers cast the reachability problem as iterative constraint satisfaction problem. However, since directed symbolic execution relies on heavyweight program analysis and constraint solving, it suffers from scalability and compatibility limitations.</p>
<p>By specifying a set of target sites in the program under test (PUT) and leveraging lightweight compile-time instrumentation of the PUT, a directed greybox fuzzer calculates the distance between the seed and the target to assist seed selection.</p>
<p>By giving more mutation chances to the seeds that are closer to the target, it can steer the greybox fuzzing to reach the target locations.</p>
<p>DGF casts reachability as an optimization problem to minimize the distance of the generated seeds to the targets.</p>
<p>Compared with directed symbolic execution, DGF has much better scalability and improves the efficiency by several magnitudes.</p>
<p>For now, DGF has evolved beyond the primary pattern that depends on manually labeled target sites and distance-based metrics to prioritize the seeds. A great number of variations have been realized to boost software testing under different scenarios, such as fuzzers directed by target sequence, by semantic information, by parser, by typestate, by sanitizer checks, by memory usage, and by vulnerable probability. Complex deep behavioral testing scenes, such as use-afterfree bugs, memory consumption bugs, memory violation bugs, algorithmic complexity vulnerabilities, input validation bugs in robotic vehicles, and deep stateful bugs.</p>
<p>定向灰盒模糊测试技术将目标位置的可达性问题转化为一个优化问题，以最小化生成的输入种子到目标位置的距离为标准来进行语料库的筛选。目前，定向灰盒模糊测试技术已经超越了依赖于手动标记的目标位置和基于距离的度量来确定输入种子优先级的主要模式。为了在不同的场景下提高软件测试，已经实现了大量的变体。</p>
<h4 id="background">Background</h4>
<p>This section provides the background knowledge on CGF and DGF.</p>
<h5 id="terminology">Terminology</h5>
<p>To avoid the confusion on the presentation of different literature, we unify the terminology in fuzzing.</p>
<ul>
<li>Fuzzing. In this paper, fuzzing refers to traditional blackbox fuzzing and greybox fuzzing. We exclude whitebox fuzzing as it depends on constraint solving of symbolic execution to generate inputs, which is quite different from evolutionary fuzzers based on mutation.</li>
<li>Testcase. A testcase is an input to the PUT, which is generated by randomly mutating a seed.</li>
<li>Seed. A seed is a testcase that is favored (trigger a new path or close to the target) and retained for the mutation to generate new testcases in the next fuzzing iteration.</li>
<li>Seed prioritization. Seed prioritization means to evaluate and sort the seeds according to its performance. Prioritized seeds would be given more fuzzing chances.</li>
<li>Power schedule Power schedule means to determine the number of fuzzing tests to be applied on a seed (i.e., energy).</li>
<li>Fuzzing cycle All seeds in the seed queue have been fuzzed at least once.</li>
</ul>
<p>本论文对模糊测试中术语的定义。</p>
<h5 id="coverage-guide-greybox-fuzzing">Coverage-guide Greybox Fuzzing</h5>
<p>Coverage-guide greybox fuzzing is the most prevalent fuzzing scheme that aims to maximize the code coverage to find hidden bugs.</p>
<p>AFL (American fuzzy lop) is the stateof-the-art coverage-based greybox fuzzer, and many stateof-the-art greybox fuzzers are built on top of it. Here we use AFL as a representative to illustrate the principle of CGF.</p>
<p>AFL uses lightweight instrumentation to capture basic block transitions and gain coverage information during runtime.</p>
<p>Then it selects a seed from the seed queue and mutates the seed to generate testcases.</p>
<p>If a testcase exercises a new path, it is added to the queue as a new seed.</p>
<p>AFL favors seeds that triggered new paths and give them preference over the non-favored ones.</p>
<p>Compared to other instrumented fuzzers, AFL has a modest performance overhead.</p>
<p>Edge coverage. AFL obtains the execution trace and calculates the edge coverage by instrumenting the PUT at compile time. It inserts random numbers for each branch jump at compile-time and collects these inserted numbers from the register at run-time to identify the basic block transition. Edge coverage is more delicate and sensitive than basic block coverage as it takes into account the transition between basic blocks. It is also more scalable than path coverage as it avoids path explosion.</p>
<p>Seed prioritization. AFL leverages the edge-coverage information to select seeds. It maintains a seed queue and fuzzes the seed within it one by one. It labels some seeds as “favored” when they execute fast and are small in size. AFL uses a bitmap with edges as keys and top-rate seeds as values to maintain the best performance seeds for each edge. It selects favored seeds from the top_rated queue, and gives these seeds preference over the non-favored ones by giving the favored one more fuzzing chances.</p>
<p>Mutation strategies. AFL has two categories of mutation strategies: deterministic strategies and non-deterministic strategies.</p>
<p>The deterministic strategies are applied first, which leverage mutators based on bit-flip, arithmetic, token, dictionary, and interest values to sequentially mutate the seeds with different granularity.</p>
<p>After doing deterministic strategies, AFL introduces non-deterministic strategies, including the havoc stage and splice stage. In the havoc stage, AFL mutates the seed by randomly choosing a sequence of mutation operators from the deterministic strategies and apply them to random locations in the seed file. As a result, the generated testcase is significantly different from the original seed. Then, AFL uses the splice strategy to randomly choose another seed from the seed queue and recombine it with the current seed to generate a new seed. Then, the havoc strategies are re-implemented to the new seed.</p>
<p>Power schedule. In the deterministic stage, mutation strategies are involved sequentially, but in the non-deterministic stage, AFL can assign energy to the seed to decide the fuzzing chances of each seed. The energy is assigned according to the performance score of each seed, which is based on coverage (prioritize inputs that cover more paths), execution time (prioritize inputs that execute faster), and discovery time (prioritize inputs discovered later) Particularly, if the test case exercises a new path, AFL will double the assigned energy.</p>
<p>以AFL为例介绍了覆盖率导向灰盒模糊测试技术。</p>
<p>AFL使用上下文不敏感的边缘覆盖替代一般的基本块覆盖。边缘覆盖比基本块覆盖更精细和敏感，因为它考虑了基本块之间的过渡，边缘覆盖比路径覆盖更具可伸缩性，因为它避免了路径爆炸。AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器收集这些随机数获知跳转信息，统计边缘覆盖。</p>
<p>AFL偏爱触发新路径的输入种子，AFL通过一个位图记录每个种子的优先级，对于优先级高的种子，AFL给予更多的模糊机会，也就是后面说的能量。</p>
<p>AFL有两类变异策略：确定性策略和非确定性策略。AFL首先采用确定性策略，利用基于位翻转、算术、令牌、字典和兴趣值的变异器依次变异不同粒度的种子。在进行确定性策略之后，AFL就会进行非确定性策略，包括havoc阶段和拼接阶段。在havoc阶段，AFL通过从确定性策略中随机选择一系列变异算子对种子进行变异，并将其应用于种子文件中的随机位置。因此，生成的testcase与原始种子有很大的不同。然后，AFL使用剪接策略从种子队列中随机选择另一个种子，并将其与当前种子重新组合以生成新的种子。最后，对新种子重新实施破坏策略。</p>
<p>AFL通过能量调度来分配一轮模糊测试的时间。在确定性阶段，变异策略依次参与，而在非确定性阶段，AFL可以给种子分配能量来决定每个种子的模糊机会。能量是根据每个种子的性能得分来分配的，这是基于覆盖率（优先考虑覆盖更多路径的输入）、执行情况时间（对执行速度更快的输入进行优先级排序）和发现时间（对稍后发现的输入进行优先级排序）。特别的，如果测试用例执行一条新路径，AFL将加倍分配的能量。</p>
<h5 id="directed-greybox-fuzzing">Directed Greybox Fuzzing</h5>
<p><img src="/png/2021-01-02-21-17-13.png"></p>
<p>In 2017, B¨ohme et al. introduced the concept of Directed Greybox Fuzzing (DGF) and implemented a tool called AFLGo based on the modern greybox fuzzing framework.</p>
<p>Unlike blindly increasing the path coverage in coverage-based greybox fuzzing, DGF aims to reach a set of pre-identified locations in the code (potentially the buggy parts) and spends most of its time budget on reaching target locations without wasting resources stressing unrelated parts.</p>
<p>Here we use AFLGo as the representative to illustrate how DGF works.</p>
<p>AFLGo follows the general principles and architecture as coverage-guided fuzzing.</p>
<p>During the compiletime, in addition to instrument to obtain the execution path and path coverage information, AFLGo also calculate the distances between the input and the pre-defined targets. The distance is calculated based on the average of basic blocks on the input seed’s execution trace weight to the target basic blocks, where the weight is determined by the number of edges in the call graph and control-flow graphs of the program.</p>
<p>Then, at runtime, AFLGo prioritize seeds based on distance instead of new path coverage and give preference to seeds closer to the targets at basic block level distance.</p>
<p>B¨ohme et al. view the greybox fuzzing process as a Markov chain that can be efficiently navigated using a “power schedule”. They leverage a simulated annealing strategy to gradually assign more energy to a seed that is closer to the targets than to a seed that is further away. They cast reachability as an optimization problem to minimize the distance of the generated seeds to the targets.</p>
<p>The exploration-exploitation problem. For DGF, the whole fuzzing process is divided as the exploration phase and the exploitation phase. The exploration phase is designed to uncover as many paths as possible. Like many coverageguided fuzzers, DGF in this phase favors the seeds that trigger new paths and prioritizes them. This is because new paths increase the potential to lead to the targets. It is particularly necessary when the initial seeds are quite far from the targets.</p>
<p>Then, based on the known paths, the exploitation phase is invoked to drive the engine to the target code areas. In this phase, B¨ohme et al. prioritize seeds that are closer to the targets and assign more energy to them. The intuition is that if the path that the current seed executes is closer to any of the expected paths that can reach the target, more mutations on that seed should be more likely to generate expected seeds that fulfill the target. The exploration-exploitation tradeoff lies in how to coordinates these two phases. B¨ohme et al use a fixed splitting of the exploration and exploitation phases.</p>
<p>For example, for 24-hour testing, AFLGo uses 20 hours for the exploration and then 4 hours for the exploitation.</p>
<p>以AFLGo为例介绍了定向灰盒模糊测试技术。</p>
<p>与AFL不同，除了获取执行路径和路径覆盖信息外，AFLGo还计算输入与预定义目标之间的距离。该距离基于输入种子的执行跟踪权值上的基本块到目标基本块的平均值来计算，其中权值由程序的调用图和控制流图中的边数来确定。</p>
<p>Bo¨hme等人将灰盒模糊化过程视为一个马尔可夫链，可以使用“功率调度”进行有效导航。他们利用模拟退火策略，逐渐将更多的能量分配给距离目标较近的种子，而不是距离目标较远的种子。他们将可达性问题转化为一个优化问题，以最小化生成的种子到目标的距离。</p>
<p>AFLGo将整个DGF分为两个阶段，探索阶段和开发阶段。</p>
<p>勘探阶段的目的是尽可能多地揭示路径，像许多覆盖率导向模糊程序一样，这个阶段的DGF偏爱触发新路径并对其进行优先级排序的种子，因为新的路径增加了通向目标的可能性。当最初的种子离目标相当远时，这是合理的。</p>
<p>开发阶段的目的是最小化生成的种子到目标的距离。在这一阶段，Bo¨hme等人对更接近目标的种子进行优先排序，并为它们分配更多的能量。直觉是，如果当前种子执行的路径更接近可以到达目标的任何预期路径，那么该种子上的更多突变应该更有可能生成实现目标的预期种子。</p>
<p>勘探开发的权衡在于如何协调这两个阶段。Bo¨hme等人使用固定的勘探和开发阶段划分。例如，对于24小时测试，AFLGo使用20小时进行勘探，然后使用4小时进行开发。</p>
<h5 id="difference-between-cgf-and-dgf">Difference between CGF and DGF</h5>
<ol type="1">
<li>Seed prioritization. A major difference between CGF and DGF lies in the seed prioritization. Since CGF aims to maximize the path coverage, CGF gives preference to seeds that trigger new paths. Differently, DGF aims to reach specific locations in the code. Thus, it prioritizes seeds that are “closer” to the targets. The evaluation metrics of the seeds varies a lot, including distance, coverage, path, and probability.</li>
<li>Target involvement. CGF expands code coverage in an undirected manner, which wastes testing resources on code regions do not contain bugs. While for DGF, a set of targets are marked in advance, manually or automatically, to guide the fuzzing process and save the power. The target selection can affect the performance of DGF. For example, selecting critical sites, such as memory allocation function malloc() or string manipulation function strcpy(), as targets are more likely to trigger memory corruption bugs. Besides, we can leverage the relationship among targets to accelerate detecting complex behavioral bugs, such as use-after-free. Thus, the involvement of targets gives more chance to optimize DGF by applying customized techniques that are specific to DGF.</li>
<li>Exploration-exploitation. Researchers model the greybox fuzzing process as a “multi-armed bandit problem” where the seeds are considered as arms of a multiarmed bandit. For coverage-based greybox fuzzing, the whole process is essentially a tradeoff of the exploration-exploitation problem, where exploration stands for trying as many seeds as possible while exploitation means mutating a certain seed as much as possible. For DGF, the exploration-exploitation problem lies in coordinating the exploration phase and the exploitation phase. In the exploration phase, DGF try to discover as many seeds as possible and learn information from them to increase the potential to reach the targets. At the same time, the exploitation phase gives more chances of mutation to seeds that are more likely to generate inputs to reach the target.</li>
</ol>
<p>CGF和DGF技术的不同点。</p>
<ol type="1">
<li>种子优先级。CGF的目标是最大化路径覆盖，所以会偏爱触发新路径的种子。而DGF的目标是到达代码中的特定位置，所以它偏爱更接近目标的种子。也就是两者对于种子优先级的评价指标不同，包括距离、覆盖率、路径和概率。</li>
<li>探索目标。CGF以一种无方向的方式扩展代码覆盖范围，在不包含bug的代码区域浪费能量。DGF则预先对一组目标位置进行人工或自动标记，以指导整个模糊测试过程，从而节省能量。目标的选择会影响DGF的性能。例如，选择关键目标（如内存分配函数malloc或字符串操作函数strcpy）作为目标更可能触发内存溢出漏洞。此外，我们还可以利用目标之间的关系来加速检测复杂的逻辑漏洞，例如UAF。</li>
<li>勘探开发。对于基于覆盖率的灰盒模糊测试，整个过程本质上是一个探索-开发问题的折衷，其中探索意味着尝试尽可能多的种子，而开发意味着尽可能多地变异某个种子。对于DGF来说，勘探开发问题在于勘探阶段与开发阶段的协调。在探索阶段，DGF试图发现尽可能多的种子，并从中获取更多的新路径，以增加到达目标的可能性。同时，开发阶段给了一些种子更多的变异机会，这些种子更有可能产生到达目标的输入。</li>
</ol>
<h5 id="application-of-dgf">Application of DGF</h5>
<p>DGF is a promising direction as it is especially suitable and effective for specific testing scenarios. We summarize the following common practical application of DGF.</p>
<ul>
<li>Patch testing. DGF can be used to test whether a patch is complete and compatible. A patch is incomplete when a bug can be triggered by multiple inputs, for example, CVE-2017-15939 is caused by an incomplete fix for CVE-2017-15023. Meanwhile, a patch can introduce new bugs. For example, CVE-2016-5728 is introduced by a careless code update. Thus, directed fuzzing towards problematic changes or patches has a higher chance of exposing bugs.</li>
<li>Bug reproduction. DGF is useful when reproducing a known bug without the buggy input. For example, due to concerns such as privacy, some applications (e.g., video player) are not allowed to send the input file. With DGF, the in-house development team can use DGF to reproduce the crash with the method calls in stack-trace and some environmental parameters. DGF is also helpful when generating Proof-of-Concept (PoC) inputs of disclosed vulnerabilities given bug report information. In fact, DGF is in demand because 45.1% of the usual bug reports cannot be reproduced due to missing information and users privacy violations.</li>
<li>Knowledge boost. DGF can boost program testing by integrating the knowledge from a human analyst or auxiliary techniques. Human-in-the loop is commonly used in software testing, which can help to identify the critical syscalls or security-sensitive program sites (e.g., memory allocation function malloc(), string manipulation function strcpy()) based on the previous experience to guide fuzzing to error-prone parts. Auxiliary techniques, such as symbolic execution and tait analysis can be leveraged to overcome roadblocks in the testing. Preliminary results from static analysis and machine learning based detection approach can be used as the potential vulnerable targets for DGF.</li>
<li>Energy saving. Another interesting application of DGF is when the testing resource is limited, for example, fuzzing the IoT devices. Under this circumstance, to save the time and computational resources spent on non-buggy like code regions, identifying critical code areas to guide the testing is more efficient than testing the whole program in an undirected manner.</li>
<li>Special bug hunting. Finally, DGF can be applied to hunting special bugs based on customized indicators. For example, finding uncontrolled memory consumption bugs under the guidance of memory usage, find useafter-free bugs under the guidance of typestate violation. With DGF, the efficiency of discovering behavioral complex bugs can be greatly improved.</li>
</ul>
<p>DGF常见的应用。</p>
<ul>
<li>补丁测试。DGF可以用来测试补丁是否完整和兼容。修补程序在以下情况下是不完整的：一个错误可以由多个输入触发；一个补丁可能会引入新的bug。因此，针对有问题的更改或补丁的定向模糊有更高的暴露bug的机会。</li>
<li>bug复现。对于复现没有触发bug的输入的已知bug，DGF是非常擅长的。例如，出于隐私等考虑，某些应用程序（如视频播放器）不允许发送输入文件。使用DGF，内部开发团队可以使用DGF通过stack-trace中的方法调用和一些环境参数来再现崩溃。在给定错误报告信息的情况下，DGF也可以生成已披露漏洞的概念验证（PoC）输入。事实上，DGF的需求量很大，因为45.1%的常见错误报告由于信息丢失和用户隐私侵犯而无法复现。</li>
<li>人机合一（意译法）。DGF可以集合来自分析人员的知识或辅助技术来促进程序测试。通过分析人员的知识和经验可以帮助DFG识别关键的系统调用或security-sensitive的程序站点（例如，内存分配函数malloc、字符串操作函数strcpy），基于以前的经验来引导模糊化到容易出错的部分。如符号执行和tait analysis之类的辅助技术可以用来解决测试中的障碍，而静态分析和基于机器学习的检测方法的初步结果可以用作DGF的潜在易受攻击目标。</li>
<li>资源的有效利用。当测试资源有限时，例如，对物联网设备进行模糊测试。为了节省花费在非bug类代码区域上的时间和计算资源，识别关键代码区域来指导测试比无方向地测试整个程序更有效。</li>
<li>特定bug狩猎。DGF可以应用于基于定制指标的特定bug搜索。例如，在内存使用状况的指导下查找内存泄漏bug，在typestate violation（应该是指违反了特定的使用范例，例如free后并未清除指针）的指导下查找UAF漏洞。使用DGF，可以大大提高发现行为复杂bug的效率。</li>
</ul>
<h4 id="assessment-of-the-state-of-the-art-works">Assessment of the-state-of-the-art Works</h4>
<p>To conduct a thorough assessment, we extract 15 metrics based on the features of DGF. We further divide the metrics into three categories, including basic information, implementation details, and optimization methods. In the following, we concentrate on properties that related to the critical techniques of DGF, including directed type, input optimization, seed prioritization, power assignment, mutation scheduling, and data-flow analysis. Detailed assessment is listed in Table I.</p>
<p><img src="/png/2021-01-02-22-46-04.png"></p>
<p>为了进行全面的评估，论文根据DGF的特征提取了15个度量。同时进一步将度量分为三类，包括基本信息、实现细节和优化方法。在下文中，论文集中讨论与DGF关键技术相关的特性，包括定向类型、输入优化、种子优先级、能量分配、变异调度和数据流分析。上图（表1）为具体评价。</p>
<h5 id="directed-type">Directed Type</h5>
<p>Although this paper focuses on directed greybox fuzzing (noted as G in Table I), some of the works we investigated adopt symbolic execution to enhance the directedness, forming directed hybrid fuzzing (noted as H), we also include them in this table.</p>
<p>For the directed type, DGF was initially directed by target sites that are manually labeled in the PUT, such as AFLGo and Hawkeye.</p>
<p>Then, researchers noticed that the relationship among the targets is also helpful. For example, in order to trigger use-after-free vulnerabilities, a sequence of operations (e.g., allocate memory, use memory, and free memory) must be executed in a specific order. UAFuzz and UAFL leverages target sequences instead of target sites to find use-after-free vulnerabilities. LOLLY also uses target statement sequences to guide greybox fuzzing to trigger bugs that resulted from the sequential execution of multiple statements. Berry uses symbolic execution to enhance the directedness of LOLLY when reaching deep targets along complex paths.</p>
<p>Apart from the target sequence, researchers have proposed various mechanisms to direct the fuzzing process. Memlock is directed by memory usage to find uncontrolled memory consumption bugs. V-Fuzz is directed by vulnerable probability, which is predicted by a deep learning model to guide the fuzzing process to potentially vulnerable code area. SemFuzz and DrillerGo leverage semantic information retrieved from CVE description and git logs to direct fuzzing and generate PoC exploits. 1DVUL is directed by patch-related branches that directly change the original data flow or control flow to discover 1-day vulnerabilities. SAVIOR and ParmeSan are directed by information from sanitizers. IJON leverages annotations from a human analyst to guide the fuzzer to overcome significant roadblocks. RVFUZZER is directed by control instability to find input validation bugs in robotic vehicles. PFUZZER is directed explicitly at input parser to cover the space of possible inputs well.</p>
<p>DGF has evolved from reaching target locations to hunting complex deep behavioral bugs.</p>
<p>该论文主要研究有向灰盒模糊测试（表1中记为G），不过在某些工作中采用了符号执行来增强有向性，形成了有向混合模糊测试（表1中记为H）。</p>
<p>对于定向类型，DGF最初由PUT中手动标记的目标位置定向，如AFLGo和Hawkeye。</p>
<p>研究人员后来发现目标之间的关系也是有帮助的，也就是改变单独的目标为目标序列。例如，为了出发UAF漏洞，必须按特定顺序执行一系列操作：分配内存、使用内存和释放内存。UAFuzz和UAFL利用目标序列而不是目标位置发现UAF漏洞。LOLLY还使用目标语句序列来引导灰盒模糊测试触发由多个语句的顺序执行导致的bug。Berry使用符号执行来增强LOLLY沿着复杂路径到达深层目标时的方向性。</p>
<p>除了目标序列之外，研究人员还提出了各种机制来指导模糊测试程序。Memlock通过内存使用来查找内存泄漏漏洞。V-Fuzz以易受攻击概率为指导，通过深度学习模型预测易受攻击概率，将模糊测试程序引导到潜在易受攻击的代码区域。SemFuzz和DrillerGo利用从CVE描述和git日志中检索到的语义信息来指导模糊测试并生成PoC报告。1DVUL通过那些直接改变原始数据流或控制流的补丁指导以发现1-day漏洞。SAVIOR和Parmasan是由来自sanitizers（Sanitizers是谷歌发起的开源工具集）的信息指导的。IJON利用来自分析人员的注释来指导模糊测试程序克服重要的障碍。RVFUZZER受control instability的指导，在机器人车辆中发现输入验证漏洞。PFUZZER明确地指向输入解析器，从而更好地覆盖代码区域。</p>
<p>DGF已经从到达目标位置发展到猎取复杂的深层的行为漏洞。</p>
<h5 id="input-optimization">Input Optimization</h5>
<p>Once the targets are marked, DGF needs to generate a seed input to invoke the fuzzing process. A good seed input can drive the fuzzing process closer to the target location and improve the performance of the later mutation process.</p>
<p>According to Zong et al., on average, over 91.7% of the inputs of AFLGo cannot reach the buggy code. Thus, optimizing the input generation has much room to improve the directedness of DGF.</p>
<p>SeededFuzz focuses on improving the generation and selection of initial seeds to achieve the goal of directed fuzzing. It utilizes dynamic taint analysis to identify the bytes of seeds which can influence values at security-sensitive program sites and generates new inputs by mutating the relative bytes and feeds them to target programs to trigger errors.</p>
<p>FuzzGuard uses a deep-learning-based approach to filter out unreachable inputs before exercising them. It views program inputs as a kind of pattern and uses a large number of inputs labeled with the reachability to the target code learned from previous executions to train a model. Then, FuzzGuard utilizes the model to predict the reachability of the newly generated inputs without running them, which saves the time spent on real execution.</p>
<p>A fuzzer can perform much better if it generates the input concerning the input grammar.</p>
<p>TOFU takes advantage of the known structure of the programs inputs in the form of a protobuf specification to generate valid inputs. TOFU augments the input space to include command-line flags by dividing the fuzzing process into syntactic-fuzzing and semantic-fuzzing. However, it usually takes one or two days to implement input-language grammar even if the user is familiar with the input language.</p>
<p>SemFuzz leverages information (syscalls and parameters) retrieved from CVE description and git log to build designed seed inputs to increases the probability of hitting the vulnerable functions.</p>
<p>TIFF and ProFuzzer identify input types to assist mutation towards maximizing the likelihood of triggering memory corruption bugs.</p>
<p>PFUZZER is a syntax-driven approach that specifically targets input parsers to maximize the input space coverage without generating plausible inputs.</p>
<p>优化输入生成对提高DGF的方向性有很大的提升空间。</p>
<p>seedfuzz致力于改进初始种子的生成和选择，以达到定向模糊的目的。它利用动态污点分析来识别种子当中那些会影响security-sensitive程序位置的值的字节，通过改变这些字节来生成新的输入提供给目标程序以触发错误。</p>
<p>FuzzGuard使用了一种基于深度学习的方法，在练习之前过滤掉无法达到的输入。它将程序的输入看作一种模式，并使用大量的在之前的执行中能够到达目标代码的输入来训练模型。然后，FuzzGuard利用该模型预测新生成的输入的可达性，而无需运行它们，从而节省了实际执行所需的时间。</p>
<p>TOFU利用protobuf规范形式的程序输入的已知结构来生成有效的输入。TOFU将模糊测试过程分为语法模糊化和语义模糊化以包含命令行标志，扩展了输入空间。然而，即使用户熟悉输入语言，实现输入语言语法通常也需要一到两天的时间。</p>
<p>SemFuzz利用从CVE描述和git日志中检索到的信息（系统调用和参数）来构建设计好的种子输入，以增加命中易受攻击函数的概率。</p>
<p>TIFF和ProFuzzer识别输入类型，以帮助变异最大化触发内存溢出漏洞的可能性。</p>
<p>PFUZZER是一种语法驱动的方法，专门针对输入解析器，在生成不合理输入的情况下最大化输入空间覆盖率。</p>
<h5 id="seed-prioritization">Seed Prioritization</h5>
<p>The crux of DGF is selecting and prioritizing the seeds that perform better in directedness under certain metrics. We summarize three prevalent metrics widely adopted by modern works, including distance, coverage, and probability.</p>
<ol type="1">
<li>Distance: As we can see from Table I, 32% (9/28) of the directed fuzzers prioritize seeds based on distance and give preference to the seeds that are closer to the target. As a groundbreaking work, AFLGo instruments the source code at compile-time and calculates the distances to the target basic blocks by the number of edges in the call graph and control-flow graphs of the PUT. Then at run-time, it aggregates the distance values of each exercised basic block to compute an average value to evaluate the seed. Many followups inherit this distance-based scheme, such as ParmeSan, and 1DVUL. TOFU’s distance metric is defined as the number of correct branching decisions needed to reach the target. RDFuzz combines distance with frequency to prioritize seeds. The code areas are separated into highfrequency and low-frequency areas by counting the execution frequency. The inputs are classified into high/low distance and high/low frequency four types. In the exploration phase, the low-frequency seeds are prioritized to improve the coverage, and for the exploitation phase, the low distance seeds are preferred to achieve the target code areas. UAFuzz is a tailored directed greybox fuzzer for complex behavioral use-after-free vulnerabilities. Different from the distance based on the control-flow graph, it uses a distance metric of call chains leading to the target functions that are more likely to include both allocation and free functions. W¨ustholz et al uses an online static lookahead analysis to determine a path prefix for which all suffix paths cannot reach a target location. By stressing the path prefix that might reach the target locations, the power schedule of the fuzzer can allocate its resources more strategically. One drawback of the distance-based method is that it only focuses on the shortest distance. When there is more than one path reaching the same targets, the longer options might be ignored, leading to a deviation. We will illustrate it with an example in Section IV-D.</li>
<li>Similarity &amp; Coverage: In addition to distance, similarity is another useful metric, which indicates the coverage of certain target forms, such as functions, locations, and bug traces. This metric is particularly suitable when there are many targets. Hawkeye leverages a static analysis of the PUT and combines the basic block trace distance with covered function similarity for the seed prioritization and power scheduling. LOLLY uses a user-specified program statement sequence as the target and takes the seed’s ability of covering the target sequences (i.e., sequence coverage) as a metric to evaluate the seed. UAFL uses the operation sequence coverage as the feedback to guide the testcase generation to progressively cover the operation sequences that are likely to trigger use-after-free vulnerabilities. UAFuzz also uses a sequenceness-aware target similarity metric to measure the similarity between the execution of a seed and the target UAF bug trace. The sequenceness-aware target similarity metric concretely assesses how many targets a seed execution trace covers at runtime and takes ordering of the targets into account. Berry takes into account the coverage of nodes in the target sequences and their execution context. It enhances the target sequences with necessary nodes, namely the basic blocks required to reach the nodes in the target sequences for all paths. In addition to the branch coverage, Berry also considers the similarity between the target execution trace and the enhanced target sequence to prioritize the seeds. SAVIOR prioritizes seeds that have higher potentials to trigger vulnerabilities based on the coverage of labels predicted by UBSan. TortoiseFuzz differentiates edges that are more likely to be destined vulnerable based on the fact that memory corruption vulnerabilities are closely related to sensitive memory operations. It prioritizes inputs by a combination of coverige and security impact, which is represented by the memory operations on three different types of granularity at function, loop, and basic block.</li>
<li>Probability: Probability is another useful metric that prioritizes the seed by how likely to reach the targets. It usually combines the seed prioritization metric with the target identification metric to direct fuzzing towards potentially vulnerable locations. V-Fuzz and SUZZER predicts the vulnerable probability of functions based on a deep learningbased model and gives each basic block in the vulnerable function a static score. Then for each input, it calculates the sum of the static score of all the basic blocks on its execution path and prioritizes the inputs with higher scores. SAVIOR leverage UBSan to label code areas with buggy potentials. TAFL strengthens fuzzing toward regions that have a higher probability of containing vulnerabilities, which is based on static semantic metrics including sensitive, complex, deep and rare-to-reach regions.</li>
</ol>
<p>现代文献中广泛采用的三个种子优先级的度量标准：距离、覆盖率和概率。</p>
<h6 id="distance">Distance</h6>
<p>从表1可以看出，32%（9/28）的定向模糊器根据距离对种子进行排序，并优先选择距离目标较近的种子。</p>
<p>作为一项开创性的工作，AFLGo在编译时对源代码进行检测，并通过PUT的调用图和控制流图中的边数计算到目标基本块的距离。然后在运行时聚合每个基本块的距离值，以计算平均值来评估种子。许多后续版本继承了这种基于距离的方案，如Parmasan和1DVUL。</p>
<p>TOFU的距离度量定义为达到目标所需的正确分支决策数。RDFuzz将距离和频率结合起来，对种子进行优先级排序。通过计算代码的执行频率，将代码区分为高频区和低频区。输入分为高/低距离和高/低频四种类型。在探测阶段，优先选择低频种子来提高覆盖率；在开发阶段，优先选择低距离种子来实现目标编码区域。UAFuzz是一个定制的定向灰盒模糊测试程序，用于复杂的UAF漏洞。与基于控制流图的距离不同，它使用了通向目标函数的调用链的距离度量，目标函数更可能同时包含分配函数和释放函数。</p>
<p>W¨ustholz et al使用online static lookahead analysis来找到并避免那些所有后缀路径都无法到达目标位置的路径前缀。通过强调可能到达目标位置的路径前缀，模糊测试程序的能量调度可以更有策略地分配其资源。</p>
<p>基于距离的方法的一个缺点是它只关注最短距离。当有多条路径到达同一目标时，可能会忽略较长的选项，从而导致偏差。</p>
<h6 id="similarity-coverage">Similarity &amp; Coverage</h6>
<p>除了距离，相似性是另一个有用的度量，它表示某些目标形式的覆盖范围，例如函数、位置和bug traces。当有许多目标时，这个指标特别适用。</p>
<p>Hawkeye利用对PUT的静态分析，并将基本块跟踪距离与覆盖函数相似性结合起来，用于种子优先级排序和能量调度。</p>
<p>LOLLY使用用户指定的程序语句序列作为目标，并将种子覆盖目标序列的能力（即序列覆盖率）作为评估种子的度量。</p>
<p>UAFL使用操作序列覆盖率作为反馈，引导测试用例生成逐步覆盖触发UAF漏洞可能使用的操作序列。</p>
<p>UAFuzz还使用序列感知目标相似性度量来度量种子执行和目标UAF bug traces之间的相似性。序列感知目标相似性度量具体评估了种子在运行时执行trace所覆盖的目标的数量和顺序。</p>
<p>Berry考虑了目标序列中节点的覆盖率及其执行上下文。它用必要的节点来增强目标序列，即到达所有路径的目标序列中的节点所需的基本块。除了分支覆盖之外，Berry还考虑了目标执行trace和增强目标序列之间的相似性，从而对种子进行优先级排序。</p>
<p>SAVIOR根据UBSan预测的标签覆盖率，优先考虑具有更高触发漏洞潜力的种子。</p>
<p>TortoiseFuzz基于内存损坏漏洞与敏感内存操作密切相关的事实，区分了更可能注定易受攻击的边缘。它通过覆盖率和安全影响因子的组合对输入进行优先级排序，这由函数、循环和基本块的三种不同粒度类型的内存操作表示。</p>
<h6 id="probability">Probability</h6>
<p>概率是另一个有用的指标，它通过达到目标的可能性来确定种子的优先级。它通常将种子优先级度量与目标识别度量相结合，以将模糊化引向潜在的易受攻击的位置。</p>
<p>V-Fuzz和SUZZER基于一个通过深度学习的模型得到函数的脆弱概率，并给函数中的每个基本块一个静态分数。然后，对于每个输入，它计算其执行路径上所有基本块的静态得分之和，并对得分较高的输入进行优先级排序。</p>
<p>SAVIOR利用UBSan为代码区域添加可能存在bug的标签。</p>
<p>TAFL加强了对包含漏洞的概率较高的区域的模糊化，该模糊化基于静态语义度量，包括敏感、复杂、深入和罕见的区域。</p>
<h5 id="power-assignment">Power Assignment</h5>
<p>After the seeds are selected and prioritized, the preferenced seeds are given more power, namely more chances of fuzzing tests. Although power assignment is crucial for DGF, very few works, try to optimize this step.</p>
<p>AFLGo uses a simulated annealing-based power schedule to gradually assign more energy to seeds that are closer to the target locations while reducing energy for further away seeds. Unlike the traditional random walk scheduling that always accepts better solutions which may be trapped in a local optimum, simulated annealing accepts the solution which is not as good as the current one with a certain probability, so it is possible to jump out of the local optimum and reach the global optimal solution. Hawkeye also adopted simulated annealing but added prioritization. Thus, seeds closer to the target are mutated first, which further improves the directedness. LOLLY adopts an optimized simulated annealing-based power schedule to achieve maximum sequence coverage. Controlled by a temperature threshold, the cooling schedule in the exploration stage randomly mutates the provided seeds to generate many new inputs, while in the exploitation stage, it generates more new inputs from seeds that have higher sequence coverage.</p>
<p>AFLGo使用一种基于模拟退火的能量调度，逐渐将更多的能量分配给距离目标位置较近的种子，同时减少距离较远的种子的能量。传统的随机游走调度总是接受更好的解从而可能陷入局部最优，而模拟退火则以一定的概率接受不如当前最优解的解，因此有可能跳出局部最优解而达到全局最优解。Hawkeye也采用了模拟退火，但增加了优先级。因此，更接近目标的种子首先发生变异，这进一步提高了方向性。LOLLY采用了一种优化的基于模拟退火的能量调度来实现最大的序列覆盖。在温度阈值的控制下，探测阶段的会随机地对所提供的种子进行变异以产生许多新的输入；而在开发阶段，它会从具有更高序列覆盖率的种子中产生更多的新输入。</p>
<h5 id="mutator-scheduling">Mutator Scheduling</h5>
<p>Some fuzzers (8 out of 28) optimize mutation strategies to assist directed fuzzing, which is mainly realized by classifying the mutators into different granularities.</p>
<p>Hawkeye leverages an adaptive mutation strategy, which categorizes the mutators as coarse-grained and fine-grained. Coarse-grained mutators are used to change bulks of bytes during the mutations, while fine-grained only involve a few byte-level modifications, insertions, or deletions. It gives less chance of coarse-grained mutations when a seed can reach the target function. Once the seed reaches targets, the times of doing fine-grained mutations increase, and coarse-grained mutations decrease. In practice, the scheduling of mutators is controlled by empirical values.</p>
<p>Similarly, V-Fuzz classify the mutation strategies into slight mutation and heavy mutation and dynamically adjust the mutation strategy via a threshold according to the actual fuzzing states.</p>
<p>SemFuzz performs a resemble classification, except it focuses on the syscall. SemFuzz utilizes coarse mutation on the inputs to find a syscall sequence that can move the execution towards the “vulnerable functions”. After that, it switches to a fine-grained mutation on the syscall sequence to monitor the “critical variables”. TAFL also adopts granularity-aware scheduling of mutators based on an empirical observation that (1) coarse-grained mutators outperforms fine-grained mutators on path growth; (2) combining multiple mutators performs better than using a single kind of mutator. ProFuzzer entails different mutation policies according to the input field types recognized by input type probing.</p>
<p>一些模糊程序（8/28）优化变异策略来辅助定向模糊测试，这主要是通过将变异分类成不同的粒度（类型）来实现的。</p>
<p>Hawkeye利用了一种自适应变异策略，将变异分为粗粒度和细粒度。粗粒度的变异在突变期间会更改大量字节，而细粒度的变异只涉及少量字节级的修改、插入或删除。当一个种子接近目标函数时，粗粒度变异的机会就变少。一旦种子达到目标函数，进行细粒度变异的次数增加，而粗粒度变异的次数减少。</p>
<p>同样，V-Fuzz将变异策略分为轻微变异和严重变异，并根据实际模糊测试的状态通过阈值动态调整变异策略。</p>
<p>SemFuzz执行类似的分类，只是它关注于系统调用。SemFuzz利用对输入的粗变异来找到一个系统调用序列，该序列可以将执行移向易受攻击的函数。之后，它将切换到syscall序列上的细粒度变异，以监视关键变量。</p>
<p>TAFL还采用了基于经验观察的粒度感知的变异调度，即：粗粒度变异在路径增长方面优于细粒度变异；组合多个变异的性能优于使用单一类型的变异。</p>
<p>ProFuzzer根据输入类型探测识别的输入字段类型，如何进行不同的变异策略。</p>
<h5 id="data-flow-analysis">Data-flow Analysis</h5>
<p>Data-flow analysis, such as taint analysis, can reflect the effect of mutation in the generated inputs, thus, it is helpful to optimize mutation strategy and input generation.</p>
<p>RDFuzz leverages a disturb-and-check method to identify and protect the distance sensitive content from the input, which is vital to maintain the distance. Preventing such content during mutation can help to approach the target code location more efficiently. UAFL adopts an information flow analysis to identify the relationship between the input and the program variables in the conditional statement, and assigns higher mutation possibility for these input bytes with high information flow strength, as they are more likely to change the values of target statement. SemFuzz tracks the kernel function parameters that the critical variables depend on via backward data-flow analysis. SeededFuzz utilizes dynamic taint analysis to identify the bytes of seeds which can influence values at security-sensitive program sites. PFUZZER uses dynamic tainting of inputs to relate each value processed to the input characters it is derived from. TIFF infers input type by means of in-memory data-structure identification and dynamic taint analysis, which increases the probability of triggering memory corruption vulnerabilities by type-based mutation. Nevertheless, data-flow analysis usually enlarges the run-time overhead.</p>
<p>数据流分析（如污点分析）可以反映变异对生成输入的影响，有助于优化变异策略和输入生成。</p>
<p>RDFuzz利用一种干扰-检查方法来识别和保护对输入的距离敏感的内容，这对保持距离至关重要（该句不太理解，可能翻译错误）。在变异过程中防止这些内容有助于更有效地接近目标代码位置。</p>
<p>UAFL采用信息流分析来识别条件语句中的输入和程序变量之间的关系，并为那些信息流更多的输入字节赋予更高的变异可能性，因为它们更可能改变目标语句的值。</p>
<p>SemFuzz通过反向数据流分析跟踪关键变量所依赖的核函数参数。</p>
<p>SeedFuzz利用动态污点分析来识别种子中可能影响security-sensitive程序位置的值的字节。</p>
<p>PFUZZER使用输入的动态污染，将处理的每个值与其派生的输入字符相关联。</p>
<p>TIFF通过内存中的数据结构识别和动态污点分析来推断输入类型，这增加了基于类型的变异触发内存损坏漏洞的概率。</p>
<p>当然，数据流分析通常会增加运行时开销。</p>
<h4 id="challenges-and-solutions">Challenges and Solutions</h4>
<p>DFG中现在的挑战及可能的解决方案。</p>
<h5 id="binary-code-support">Binary Code Support</h5>
<p>Most of the known DGF works are implemented on top of AFL and inherit its compile-time instrumentation scheme to feedback the execution status or calculate the distance-based metric. A significant drawback of such a scheme is the dependence of the PUT source code. Thus, such scheme is unsuitable for testing scenes that the source code is unavailable, such as the commercial off-the-shelf (COTS) software, or the security-critical programs that rely partly on third-party libraries.</p>
<p>The binary-level DGF is less prevalent owing to the following reasons. First, heavy runtime overhead. A straightforward solution for the binary code testing is leveraging a full-system emulator. For example, UAFuzz handles binary codes and extract execution paths via QEMU. However, emulator-based tools are usually less efficient. For example, the execution speed of vanilla AFL is 2X - 5X faster than its QEMU mode. Second, difficulty in collecting target information. For an open sourced PUT, we can obtain targets information from various channels, such as the CVE vulnerability descriptions, changes made in the git commit logs, and human experience on critical sits in the source code. However, for a PUT in the binary code, we can only extract targets information from bug traces. Third, difficulty in labeling the targets. For the source code instrumentation approach, the targets can be labeled based on the source code (e.g., cxxfilt.c, line 100). However, the thing is much more difficult for the binary-level approach. Since the binary code is hard to read, we have to disassemble it, such as IDA Pro, and label the targets with the virtual addresses. However, this is inconvenient and time-consuming.</p>
<p>A viable solution to alleviate the performance limitation is hardware assistance. Intel PT is a lightweight hardware feature in recent Intel processors. It captures tracing data about program execution, which replaces the need for dynamic instrumentation. Intel PT can trace program execution on the fly with negligible overhead. Using the packet trace captured by Intel PT along with the corresponding binary of the PUT, a security analyst could fully reconstruct the PUT’s execution path. Averagely, the PT-based approach is 4.3x faster than QEMU-AFL. Previous hardware features such as Intel Last Branch Record also perform program tracing, but its output is stored in special registers instead of the main memory, which limits the trace size. There have been attempts of CGF with PT, such as kAFL, PTfuzz, Ptrix, and Honggfuzz. However, PT has never been used to DGF yet. For the problem of target identification and labeling at binary code level, we can leverage the machine-learningbased approach, or heuristic binary diffing approach to automatically identify the vulnerable code.</p>
<p>大多数已知的DGF都是在AFL的基础上实现的，并继承其编译时插桩方案来反馈执行状态或计算基于距离的度量。这种方案的一个显著缺点是对PUT源代码的依赖性。因此，这种方案不适合没有测试源代码的场景，例如商用闭源COTS软件或部分依赖第三方库的关键程序。</p>
<p>二进制级别的DGF存在以下问题。 1. 运行时开销很大。最简单的二进制代码模糊测试就是利用一个完整的系统仿真器。例如，UAFuzz处理二进制代码，并通过QEMU提取执行路径。然而，基于仿真器的工具通常效率较低。例如，vanilla AFL的执行速度比其QEMU模式快2倍到5倍。 2. 目标信息收集困难。开源PUT可以从各种渠道获取目标信息，例如CVE漏洞描述、git提交日志中所做的更改以及源代码中关键位置的注释。但是，对于二进制代码中的PUT，只能从bug trace中提取目标信息。 3. 标靶困难。对于源代码插桩方法，可以基于源代码标记目标（例如，cxxfilt.c，第100行）。然而，由于二进制代码很难读取，必须对其进行反汇编，如使用idapro，并用虚拟地址标记目标。</p>
<p>一个可行解决方案是通过硬件辅助减轻性能限制。Intel PT是最新Intel处理器中的一种轻量级硬件功能。它捕获有关程序执行的trace数据，从而取代了对动态插桩的需要。Intel PT可以动态跟踪程序执行，开销可以忽略不计。</p>
<p>安全分析人员通过Intel PT捕获的数据包trace以及PUT的二进制文件可以重建PUT的执行路径。平均而言，基于PT的方法比QEMU-AFL快4.3倍。以前的硬件功能（如Intel Last Branch Record）也可以执行程序跟踪，但其输出存储在特殊寄存器中，而不是主内存中，这限制了跟踪大小。CGF与PT的结合也有尝试，比如kAFL、PTfuzz、Ptrix和Honggfuzz。然而，PT从未被用于DGF。</p>
<p>对于二进制代码级别的目标识别和标记问题，可以利用基于机器学习的方法或启发式二进制差分方法来自动识别易受攻击的代码。</p>
<h5 id="automatic-target-identification">Automatic target identification</h5>
<p>Most of the known directed fuzzers require the analyst to mark the targets manually (e.g., AFLGo, Hawkeye). They rely on the prior knowledge of the target sites, such as the line number in the source code or the virtual memory address at the binary level, to label the target and steer the execution to the desired locations.</p>
<p>However, to obtain such prior knowledge is challenging, especially for the binary code. Among the works we investigated, about 43% (12/28) of them try to optimize the way how the targets are identified. Researchers use auxiliary metadata, such as changes made in the PUT code based on git commit logs, information extracted from bug traces, or information from CVE vulnerability descriptions to identify targets. Nevertheless, they still rely on manual efforts to process the information and mark the target on the PUT. It is unsuitable when fuzzing a PUT for the first time or when well-structured information is unavailable.</p>
<p>To achieve automatic target identification, we can use static analysis tools to find potential dangerous areas in the PUT. However, these tools are often specific to the bug types and programming languages used. Another direction is leveraging the compiler sanitizer passes, such as UBSan, to annotate potential bugs in the PUT. For binary code, 1DVUL identifies patch-related target branches by extracting different functions as well as their different basic blocks through binary-level comparison based on Bindiff. A deep learning-based method is also effective in predicting the vulnerability and using the prediction information to guide fuzzing. Finally, attack surface identification component is also useful to identify vulnerable targets for DGF automatically.</p>
<p>大多数已知的定向模糊程序都要求分析人员手动标记目标（如AFLGo、Hawkeye），这依赖对于目标位置的先验知识，例如源代码中的行号或二进制级别的虚拟内存地址，来标记目标并将执行引导到所需的位置。</p>
<p>为了实现目标的自动识别，可以使用静态分析工具在PUT中找到潜在的危险区域。然而，这些工具通常特定于所使用的bug类型和编程语言。另一个方向是利用compiler sanitizer passes，比如UBSan，来注释PUT中的潜在bug。对于二进制代码，1DVUL通过基于Bindiff的二进制级比较，提取不同的函数及其不同的基本块，识别与补丁相关的目标分支。基于深度学习的方法在预测脆弱性和使用预测信息指导模糊化方面也是有效的。最后，攻击面识别组件也可用于自动识别DGF的易受攻击目标。</p>
<h5 id="differentiated-weight-metric">Differentiated weight metric</h5>
<p><img src="/png/2021-01-03-13-09-41.png"></p>
<p>In most of the state-of-the-art directed greybox fuzzers, the prioritization of seeds is based on equal-weight metrics. Take the widely used distance-based metric as an example, the ability to reach the target is measured by the distance between the seed and the target. Specifically, the distance is represented by a number of edges, namely the transitions among basic blocks. However, such measurement ignores the fact that different branch jumps have different probabilities to take. Thus, such inaccuracy limits the performance of directed fuzzing.</p>
<p>We use the following example to illustrate the difference. Figure 1 shows a control-flow graph fragment, in which the input x is an integer ranges from 0 to 9. It is easy to know that the probability of jumping from node A to node C is 0.1, and from node A to node B is 0.9. We can also compute the probabilities of other jumps by the branch conditions. For the distance calculation based on the number of branch jumps, the distance of A → C is shorter than that of A → G. This is because A → C has only one jump but A → G has three jumps. However, when we take the branch jump probability into account, the probability of A → C is 0.1. However, the probability of A → G is 0.9 × 0.7 × 0.5 ≈ 0.3, which is more likely to be taken than A → C and should be considered as has a “shorter” distance. Thus, it is more reasonable to consider the weight difference as well when calculating the distance to guide the seed prioritization. The other seed prioritization metrics, such as similarity and probability, should follow the same rationale.</p>
<p>One possible solution is taking the branch jump probability into account. When evaluating the reachability of the target based on probability, each seed is prioritized based on how likely the seed can generate an input to reach the target, namely the probability of converting the current execution path of this seed to a target path that goes through the target. Since an execution path can be viewed as a Markov Chain of successive branches, the probability of a path can be calculated by gathering the probabilities of all the branches within the path.</p>
<p>We can estimate the branch probability by statistically calculating the ratio based on the Monte Carlo method. The density of the stationary distribution formally describes the likelihood that the fuzzer exercises a certain path after a certain number of iterations. A Monte Carlo based method requires two conditions: 1) the sampling should be random; 2) the sample scale should be large. Fortunately, the fuzzing process by nature fulfills these requirements. The execution paths motivated by randomly mutated testcases can be viewed as random samples, which met the first requirement. The high throughput of the testcases generated by fuzzers makes the estimation statistically meaningful, satisfying the second requirement. Thus, regarding fuzzing as a sampling process, we can statistically estimate the branch jump probability in a lightweight fashion.</p>
<p>One possible drawback of such a probability-based approach is the potential run-time overhead. Both the statistical jump counting and the probability calculation introduce extra computation. A simple way to alleviate performance deduction is interval sampling.</p>
<p>Another possible solution is to accelerate the computation, which involves how the metadata is stored and accessed. Conventionally, graph-based data is stored in an adjacency table. However, since the probabilitybased approach updates the jump statistics very often and the reachability judgment also requires a quick edge tracing, thus, the adjacency table is unsuitable owing to its low efficiency when accessing data. Another option is the adjacency matrix, which supports quick data access. However, since a jump usually has two branches, the matrix would be vast but the data distribution is relatively sparse, which increases space consumption dramatically.</p>
<p>Thus, a pre-condition to leverage a probability-based approach is designing a customized data structure that balances the time complexity and space complexity.</p>
<p>在大多数最先进的定向灰盒模糊器中，种子的优先级是基于等权度量的。以广泛应用的距离度量为例，通过种子与目标之间的距离来度量到达目标的能力。特别是距离由多条边表示，即基本块之间的过渡。然而，这样的测量忽略了一个事实，即不同的分支跳跃有不同的概率。因此，这种不精确性限制了定向模糊的性能。</p>
<p>图1显示了一个控制流图片段，其中输入x是一个从0到9的整数。很容易知道从节点A跳到节点C的概率是0.1，从节点A跳到节点B的概率是0.9。如果据根据分支跳数计算距离，则A→C的距离比A→G短，这是因为A→C只有一个跳，而A→G有三个跳。但是如果考虑分支跳跃概率，则A→C的概率为0.1，而A→G的概率为0.9×0.7×0.5≈0.3，这比A→C更“短”。因此，在计算距离以指导种子排序时，考虑权重差异也更为合理。其他种子优先级度量，如相似性和概率，应该遵循相同的原理。</p>
<p>一种可能的解决方案是考虑分支跳转概率。当基于概率评估目标的可达性时，每个种子基于该种子生成到达目标的输入的可能性，即将该种子的当前执行路径转换为穿过该目标的目标路径的概率来优先排序。由于执行路径可以看作是连续分支的马尔可夫链，因此可以通过收集路径中所有分支的概率来计算路径的概率。</p>
<p>基于Monte Carlo方法，可以通过统计计算分支概率来估计分支概率。平稳分布的密度形式上描述了模糊程序经过一定次数的迭代后执行某条路径的可能性。基于Monte Carlo方法需要两个条件：1）抽样应该是随机的；2）抽样规模应该很大。幸运的是，模糊过程本质上满足了这些要求。由随机变异的测试用例驱动的执行路径可以看作是满足第一个需求的随机样本。模糊程序生成的测试用例的高吞吐量使得估计具有统计意义，满足第二个需求。因此，将模糊化作为一个抽样过程，可以以一种轻量级的方式统计估计分支跳跃概率。</p>
<p>这种基于概率的方法的一个可能缺点是潜在的运行时开销。统计跳跃计数和概率计算都引入了额外的计算。减少性能降低的一个简单方法是间隔采样。</p>
<p>另一个可能的解决方案是加速计算，这涉及到元数据的存储和访问方式。传统上，基于图形的数据存储在邻接表中。然而，由于基于概率的方法经常更新跳跃统计信息，并且可达性判断也需要快速的边缘跟踪，因此邻接表在访问数据时效率较低，不适合使用。另一种选择是邻接矩阵，它支持快速数据访问。然而，由于一个跳转通常有两个分支，矩阵将是巨大的，但数据分布相对稀疏，这大大增加了空间消耗。</p>
<p>因此，利用基于概率的方法的先决条件是设计一个平衡时间复杂性和空间复杂性的定制数据结构。</p>
<h5 id="global-optimum-deviation">Global Optimum Deviation</h5>
<p><img src="/png/2021-01-03-16-09-55.png"></p>
<p>When there are multi-targets in a DGF testing, How to coordinates these targets is another challenge.</p>
<p>One strategy is seeking the global shortest distance based on Dijkstras algorithm, as AFLGo does. However, such global optimum might miss the local optimum seed that is closest to a certain target, leading to a deviation.</p>
<p>We use the following example to illustrate the situation. Figure 2 shows a control-flow graph fragment, where node K and O are the target nodes. Here we test three seeds, one exercises path A→B→D→G→K, one exercises path A→C→E→I→M→N→O, and the other exercises path A→C→E→H→L. Based on the distance formula defined by B¨ohme et al., we have calculated the harmonic distances between each node in the three paths to the two targets and label them by the side of each node.</p>
<p>The global distances of the three seeds are dABDGK, dACEIMNO, and dACEHL. Since dACEHL is the smallest among the three, we should prioritize the seed of path A→C→E→H→L. However, this is unreasonable because path A→B→D→G→K goes through target node K and path A→C→E→I→M→N→O goes through target O, but path A→C→E→H→L does not reach any targets. Intuitionally, path A→C→E→H→L is far away from the targets and should not be prioritized. Therefore, when there are multiple targets, finding the global shortest distance has deviation and affects the directedness of fuzzing.</p>
<p>The reason behind such deviation is that the distancebased seed measurement only focuses on the shortest path. When there are multiple paths reaching the same target, the longer ones might be ignored, causing deviation in the result.</p>
<p>In Figure 2, if we consider path A→C→K and path A→C→E→H→O. As expected, dACK &lt; dACEIMNO &lt; dACEIMNL. This is because path A→C→K and path A→C→E→H→O are the shortest paths to targets K and O, respectively. The shortest path is always prioritized. To avoid the bias in the evaluation of seeds, we should take into account all the potential paths to the targets. To achieve this goal, Hawkeye uses adjacent-function distance augmentation based on a lightweight static analysis, which considers the patterns of the (immediate) call relation based on the generated call graph.</p>
<p>Another strategy of coordinating multi-targets is separating the targets. For each seed, only selecting the minimum distance among all the targets as the distance of the seed, and prioritize the seed based on this min-distance. In this way, we can avoid the local optimum deviation, but this might slow down the speed of reaching a specific target.</p>
<p>当DGF测试中存在多个目标时，如何协调这些目标是另一个挑战。</p>
<p>一种策略是基于Dijkstras算法来寻找全局最短距离，AFLGo就是这样做的。然而，这样的全局最优可能会错过最接近某个目标的局部最优种子，从而导致偏差。</p>
<p>图2显示了一个控制流图片段，其中节点K和O是目标节点。这里测试了三个种子，路径分别为：A→B→D→G→K，A→C→E→I→M→N→O，A→C→E→H→L。论文作者基于B¨ohme et al.定义的距离公式计算了两个目标的三条路径中每个节点之间的harmonic距离，并在每个节点的侧面标记它们。</p>
<p>路径A→C→E→H→L的种子应该是三个之中距离最小的，但这是不合理的，因为路径A→B→D→G→K穿过目标节点K，路径A→C→E→I→M→N→O穿过目标节点O，但路径A→C→E→H→L没有到达任何目标。直觉上，路径A→C→E→H→L远离目标，不应优先考虑。因此，当存在多个目标时，寻找全局最短距离存在偏差，影响模糊化的方向性。</p>
<p>这种偏差背后的原因是基于距离的种子测量只关注最短路径。当有多条路径到达同一目标时，可能会忽略较长的路径，从而导致结果出现偏差。</p>
<p>图2中，如果考虑路径A→C→K和路径A→C→E→H→O，会发现dACK &lt; dACEIMNO &lt; dACEIMNL。这是因为路径A→C→K和路径A→C→E→H→O分别是到目标K和O的最短路径。最短路径总是优先考虑的。为了避免在评估种子时产生偏差，应该考虑到所有可能到达目标的路径。为了实现这一目标，Hawkeye使用了基于轻量级静态分析的相邻函数距离扩充，该分析基于生成的调用图考虑（立即）调用关系的模式。</p>
<p>多目标协调的另一种策略是目标分离。对于每个种子，仅选择所有目标之间的最小距离作为种子的距离，并基于该最小距离对种子进行优先级排序。这样可以避免局部最优偏差，但可能会减慢达到特定目标的速度。</p>
<h5 id="missing-indirect-calls">Missing Indirect Calls</h5>
<p>No matter what metric is adopted, DGF relies on controlflow analysis to prioritize the seed. Take the distance-based metric as an example, the distance is generally measured based on the control-flow graph and call graph.</p>
<p>However, most researchers construct the control-flow graph and call graph statically via LLVM’s builtin APIs, and such graphs are incomplete due to missing indirect calls. In real-world programs, indirect function calls are prevalent. For example, in libpng, 44.11% of the function calls are indirect function calls. For the static analysis approaches, indirect function calls sites, such as passing a function pointer as a parameter in C or using function objects and pointers, cannot be observed directly from the source code or binary instructions. For the binary code, the target address of indirect calls depends on the values in the registers, which cannot be obtained either. Besides, to construct an inter-procedural control-flow graph, we need to combine each function’s control-flow graph generated based on LLVM’s IR with the call graph of the whole program. Therefore, the distance measurement based on the call graph and control-flow graph is inaccurate without the indirect calls, which affects DGF’s ability to reach the targets.</p>
<p>For static approaches, one straightforward solution to this challenge is performing Andersen’s points-to analysis for function pointers. However, such inclusion-based context-insensitive pointer analysis causes an indirect call to have many outgoing edges, possibly yielding execution paths that are not possible for a given input.</p>
<p>TOFU uses function type-signatures to approximate the callable set at each indirect-call site. However, it does not consider casts, which could allow a differently typed function to be called, introducing imprecision.</p>
<p>For the dynamic situation, ParmeSan identifies the missing edges of indirect calls during real executions and compensates the call graph gradually. Finally, the graphs tend to be complete after enough number of fuzzing executions. However, such a solution inevitably enlarges the run-time overhead and cannot guarantee completeness.</p>
<p>无论采用何种度量，DGF都依赖于控制流分析来确定种子的优先级。以基于距离的度量为例，通常基于控制流图和调用图来度量距离。</p>
<p>然而，由于LLVM的调用流和通过LLVM的间接调用图的构造是不完整的。在实际程序中，间接函数调用非常普遍。例如，在libpng中，44.11%的函数调用是间接函数调用。对于静态分析方法，不能直接从源代码或二进制指令中观察到间接函数调用站点，例如在C中作为参数传递函数指针或使用函数对象和指针。对于二进制代码，间接调用的目标地址取决于寄存器中的值，这些值也无法获得。此外，为了构造一个过程间控制流图需要将基于LLVM的IR生成的每个函数的控制流图与整个程序的调用图结合起来。因此，基于呼叫图和控制流图的距离测量在没有间接呼叫的情况下是不准确的，影响了DGF到达目标的能力。</p>
<p>对于静态方法，解决这个问题的一个简单方法是对函数指针执行Andersen的points to analysis。但是，这种基于包含的上下文不敏感指针分析会导致间接调用具有许多传出边缘，可能会产生给定输入不可能的执行路径。</p>
<p>TOFU使用函数类型签名来近似每个间接调用站点的可调用集。但是，它不考虑类型转换，这可能会允许调用不同类型的函数，从而引入不精确性。</p>
<p>对于动态情况，ParmeSan在实际执行过程中识别间接调用的缺失边，并逐渐补全调用图。最后，在执行足够数量的模糊测试之后，图趋于完整。然而，这样的解决方案不可避免地增加了运行时开销，并且不能保证完整性。</p>
<h5 id="exploration-exploitation-coordination">Exploration-exploitation coordination</h5>
<p>The last challenge for DGF lies in coordinating the exploration-exploitation tradeoff. On the one hand, more exploration can obtain and provide adequate information for the exploitation; on the other hand, an overfull exploration would occupy many resources and delay the exploitation. It is difficult to determine the boundary between the exploration phase and the exploitation phase. In a word, we do not know when to stop exploration and begin the exploitation can perform the best.</p>
<p>AFLGo adopts a fixed splitting of the exploration phase and the exploitation phase. The time budgets are pre-set in the test configuration before testing. Such a scheme is preliminary because the separation point is empirical and inflexible. Since each PUT has a different character, such fixed splitting is less adaptive. Once the exploration phase turns to the exploitation phase, there is no going back even if the direction performance is poor due to not enough paths.</p>
<p><img src="/png/2021-01-03-16-40-06.png"></p>
<p>To illustrate how the splitting of the exploration phase and the exploitation phase affects the performance of DGF, we conduct a simple experiment with AFLGo on libxml. We use the “-z” parameter of AFLGo to set different time budget for the exploration phase and compare the performance. As Figure 3 shows, the horizontal coordinate shows the time duration of the test, and the vertical coordinate means the minimum distance of all the generated inputs to the target code areas (min-distance). A small min-distance indicates a better-directed performance. The experiments last for 24 hours, and AFLGo-1 means 1 hour of exploration with 23 hours of exploitation, and the rest are similar. From the results, we can conclude that the splitting of the exploration phase and the exploitation phase affects the performance of DGF, and the best performance (AFLGo-16) requires adequate time for both of the two phases. However, it is difficult to get an optimum splitting.</p>
<p>Among the directed fuzzers we investigated, only one work tries to improve the coordination of exploration-exploitation. RDFuzz uses an intertwined schedule to conduct exploration and exploitation alternately. It counts the branch-level statistics during the execution to separate the code areas into high-frequency and low-frequency areas. Based on the two evaluation criterias of frequency and distance, the inputs are classified into high/low distance and high/low-frequency types. Low-frequency inputs are helpful to improve the coverage, which is required in the exploration; Low distance inputs are helpful to achieve the target code areas, which are favored in the exploitation. Finally, it uses an intertwined testing schedule to conduct the exploration and exploitation alternately.</p>
<p>Another possible solution to this challenge is leveraging a dynamic strategy to coordinate the splitting of the exploration phase and the exploitation phase, which can adaptively switch between the exploration phase and the exploitation phase. To realize this scheme, we suggest to cast the splitting of fuzzing phases to the dividing of seeds, namely dividing the seeds into two groups: coverage seeds for exploration and directed seeds for exploitation. The number of seeds in each group indicates the energy spent on the corresponding phase. The coordination of the two phases is implemented by controlling the number of seeds in each group. We use a variable called dp to represent the percentage of directed seeds among all the seeds, which also indicates the percentage of energy that spends on the exploitation phase. We give labels to the coverage seeds during seed evaluation, and we give labels to directed seeds after every fuzzing cycle, adjusted by dp.</p>
<p><img src="/png/2021-01-03-16-40-26.png"></p>
<p>We use Algorithm 2 to illustrate this design. A DGF with adaptive splitting should start from the exploration phase (dp = 0) that focuses on discovering new paths. Then, with the increasing of known paths, we gradually increase dp to invoke the exploitation phase, in which high-valued directed seeds are selected and prioritized to enhance the reachability based on dp. When the fuzzer can not find any new paths for a long duration, the exploration phase has come to a bottleneck, and we should quickly move to the exploitation phase by dramatically increasing dp. Similarly, we also need to move from the exploitation phase back to the exploration phase occasionally. For example, we are already at the exploitation phase and dp is very large (e.g., dp &gt; 0.9) but we cannot get any closer to the target for many fuzzing cycles, we should decrease dp dramatically to move back to the exploration phase. This is because the directed seeds in hand perform poorly, and we should enlarge path coverage to discover more potential directed seeds. With this scheme, both of the two phases can coexist to achieve the best performance and adaptiveness. It worth noting that the thresholds in the algorithm are used to illustrate the principle. Reasonable values should be generated based on a heuristic algorithm.</p>
<p>DGF面临的最后一个挑战是如何协调勘探与开发之间的权衡。一方面，多勘探可以为开发提供充分的信息，另一方面，勘探过度会占用大量资源，延缓开发。很难确定勘探阶段和开发阶段之间的界限。</p>
<p>AFLGo采用勘探阶段和开发阶段的固定分割。测试前，时间预算在测试配置中预先设置。这样的方案是初步的，因为分离点是经验性的和不灵活的。由于每个PUT具有不同的字符，因此这种固定拆分的适应性较差。一旦勘探阶段转入开发阶段，即使由于路径不足导致方向性能较差，也不会有回头路。</p>
<p><img src="/png/2021-01-03-16-40-06.png"></p>
<p>为了说明探索阶段和开发阶段的分配如何影响DGF的性能，论文作者在libxml上用AFLGo进行了一个简单的实验。使用AFLGo的“-z”参数为勘探阶段设置不同的时间预算，并比较其性能。如图3所示，水平坐标表示测试的持续时间，垂直坐标表示所有生成的输入到目标代码区域的最小距离。较小的最小距离表示定向性能更好。实验持续24小时，AFLGo-1意味着1小时的探索加上23小时的开发，其余的依此类推。从结果可以看出，勘探阶段和开发阶段的分配会影响DGF的性能，而最佳性能（AFLGo-16）需要两个阶段都有足够的时间。然而，很难得到一个最佳的分配。</p>
<p>在研究的有向模糊程序中，只有一项工作试图提高勘探开发的协调性。RDFuzz统计执行期间的分支级统计信息，以将代码区域分为高频区域和低频区域。根据频率和距离两个评价准则，将输入信号分为高、低距离和高、低频两类。低频输入有助于提高勘探所需的覆盖率；低距离输入有助于实现勘探所需的目标码区。最后，采用一个相互交织的测试时间表，交替进行勘探和开发。</p>
<p>解决这一难题的另一个可能方法是利用动态策略来协调勘探阶段和开发阶段的划分，该策略可以在勘探阶段和开发阶段之间自适应切换。为了实现这一方案，论文作者建议将模糊阶段的分配转化为种子的分配，即将种子分为两组：覆盖种子用于探索和定向种子用于开发。每组种子的数目表示在相应阶段所消耗的能量。这两个阶段的协调是通过控制每组种子的数量来实现的。使用一个称为dp的变量来表示所有种子中定向种子的百分比，这也表示花费在开发阶段上的能量的百分比。在种子评价过程中，对覆盖种子进行标记，在每个模糊周期后，对有向种子进行标记，并通过dp进行调整。</p>
<p><img src="/png/2021-01-03-16-40-26.png"></p>
<p>使用算法2来说明这个设计。具有自适应分裂的DGF应该从探索阶段（dp=0）开始，该阶段侧重于发现新路径。然后，随着已知路径的增加，逐渐增加dp来调用开发阶段，在开发阶段，基于dp选择高值的有向种子并对其进行优先级排序以增强可达性。当模糊测试程序在很长一段时间内找不到新的路径时，勘探阶段已经到了瓶颈，应该通过大幅度提高dp来迅速进入开发阶段。同样，也需要偶尔从开采阶段回到勘探阶段。例如，当模糊测试程序已经处于开采阶段，dp非常大（例如，dp&gt;0.9），但仍然无法在许多模糊循环中更接近目标，就应该大幅降低dp以返回勘探阶段。这是因为现有的定向种子性能较差，应该扩大路径覆盖范围以发现更多潜在的定向种子。在该方案中，两个阶段可以共存，以获得最佳的性能和自适应性。值得注意的是，算法中的阈值是用来说明原理的。应该基于启发式算法产生合理的阈值。</p>
<h4 id="discussion">Discussion</h4>
<p>DGF是目前的研究热点。</p>
<p>With the rapid development of DGF, apart from target sites, various of indicators have been proposed to direct DGF, including target sequence, semantic information, typestate , sanitizer checks, memory usage, and vulnerable probability.</p>
<p>DGF has evolved from reaching target locations to hunting complex deep behavioral bugs, such as used-after-free bugs, memory consumption bugs, memory violation bugs, and deep stateful bugs.</p>
<h5 id="multi-targets-relationship-exploitation">Multi-targets Relationship Exploitation</h5>
<p>Although 86% (24/28) of the directed fuzzers we investigated support multi-targets, only 4 pay attention to the relationship among targets. When there are multiple targets, we can optimize DGF via the relationship among the targets. If they are unrelated, we can assign weights to them to differentiate the importance or probability. Otherwise, the hidden relationship can be extracted and exploited to improve directedness.</p>
<p>For example, UAFL takes into account the operation sequence ordering when leverageing target sequence to find use-after-free vulnerabilities. This is because, to trigger such behavioral complex vulnerabilities, one needs not only to cover individual edges but also to traverse some long sequence of edges in a particular order. Such a method can be extended to detect semantic bugs, such as double-free and API misuse. Berry enhances the target sequences with execution context (i.e., necessary nodes required to reach the nodes in the target sequences) for all paths.</p>
<p>Here we propose the following relationships that can be further included. The spatial relationship. The relative position of targets on the execution tree. Suppose we have two targets, we can consider the relationship including whether they are on the same execution path, how many execution paths are shared by them, and which one is the ancestor or the successor of the other. The stateful relationship. For targets that involve the program state, we could consider their position in the state space. For example, whether two targets share the same states, and whether two states can convert to each other on the state transition map. The interleaving relationship. For multi-threaded programs, the thread scheduling affects the execution ordering of events in different threads. Targets that can be reached under the same thread interleaving should be a close relationship in the interleaving space.</p>
<p>Based on the above discussion, we recommend taking into account the relationship among targets when selecting and prioritizing targets. The targets with higher reachability should have higher priority. Targets with a closer relationship should be covered with fewer test runs.</p>
<p>虽然86%（24/28）的有向模糊测试程序支持多目标，但只有4个关注目标之间的关系。当存在多个目标时，可以通过目标之间的关系来优化DGF。如果它们是不相关的，可以给它们分配权重来区分重要性或概率。否则，可以提取隐藏关系并加以利用，以提高方向性。</p>
<p>UAFL在利用目标序列寻找UAF漏洞时，考虑了操作序列的顺序。这是因为，要触发这种行为复杂的漏洞，不仅需要覆盖单个边缘，还需要以特定顺序遍历一些长的边缘序列。这种方法可以扩展到检测语义错误，比如double-free和API误用。Berry使用所有路径的执行上下文（即到达目标序列中的节点所需的必要节点）增强目标序列。</p>
<p>在这里进一步提出以下关系。</p>
<ol type="1">
<li>空间关系。目标在执行树上的相对位置。假设有两个目标，可以考虑它们之间的关系，包括它们是否在同一个执行路径上，它们共享多少个执行路径，以及哪一个是另一个的前继节点还是后继节点。</li>
<li>有状态的关系。对于涉及程序状态的目标，可以考虑它们在状态空间中的位置。例如，两个目标是否共享相同的状态，以及两个状态是否可以在状态转换映射上相互转换。</li>
<li>交错关系。对于多线程程序，线程调度会影响不同线程中事件的执行顺序。在同一线程交织下可以达到的目标在交织空间中应该是一个密切的关系。</li>
</ol>
<p>基于上述讨论，建议在选择目标和确定目标优先级时考虑目标之间的关系。具有较高可达性的目标应该有更高的优先级。关系更密切的目标应该用更少的测试运行来覆盖。</p>
<h5 id="technology-integration">Technology Integration</h5>
<p><img src="/png/2021-01-03-17-05-33.png"></p>
<p>Owing to that, DGF depends on the random mutation to generate test inputs, it can hardly reach deep targets and is less effective at triggering deep bugs along complex paths. In order to enhance the directedness of reaching corner cases and flaky bugs, various program analysis techniques, such as static analysis, control-flow analysis, data-flow analysis, machine learning, semantic analysis, and symbolic execution, have been adopted (statistics are shown in Table 4). Among the tools we investigate, 75% of them rely on control-flow analysis to evaluate seeds and determine the reachability to the targets; 46% of them leverage static analysis to automatically identify targets and extract information from PUT; 32% use data-flow analysis (mainly taint analysis) to identify the relationship between the input and the critical program variables and optimize mutation strategy scheduling; 11% use machine learning to predict vulnerable code and filter out unreachable inputs; 18% adopt semantic analysis to identify vulnerable targets automatically and learn input fields semantics to optimize mutation; finally, 18% integrate symbolic (concolic) execution to solve complex path constraints. In a personal view, directed hybrid fuzzing is a promising direction that can leverage the precision of symbolic execution and the scalability of DGF to mitigate individual weaknesses. Directed fuzzing can prioritize and schedule input mutation to get closer to the targets rapidly, and directed symbolic execution can help to reach more in-depth code guarded by sophisticated checks on the execution traces from program entry to the targets. Nevertheless, we should be aware that anti-fuzzing techniques can insert fake paths, add delays in error-handling code, and obfuscate codes to slow down dynamic analyses such as symbolic execution and taint analysis.</p>
<p>正因为如此，DGF依赖于随机变异来产生测试输入，它很难到达深层目标，并且在复杂路径上触发深层缺陷的效果较差。为了增强到达角落案例和片状缺陷的方向性，采用了各种程序分析技术，如静态分析、控制流分析、数据流分析、机器学习、语义分析和符号执行（统计数据如表4所示）。</p>
<p>在我们调查的工具中，75%的工具依赖于控制流分析来评估种子并确定对目标的可达性；46%的工具利用静态分析来自动识别目标[30]，并从PUT中提取信息[12，42]；32%的工具使用数据流分析（主要是污点分析）来识别目标之间的关系输入和关键程序变量[27，44，47]，优化变异策略调度[28，46]；11%使用机器学习预测易受攻击的代码[32]，过滤掉无法到达的输入[54]；18%采用语义分析自动识别易受攻击目标[25，26，50]，学习输入字段语义优化变异；最后，18%集成符号（concolic）执行来解决复杂的路径约束[24，26，30，44]。在个人看来，定向混合模糊是一个很有前途的方向，它可以利用符号执行的精确性和DGF的可伸缩性来缓解个人的弱点。有向模糊化可以对输入变异进行排序和调度，使其快速接近目标，而有向符号执行可以通过对从程序进入到目标的执行轨迹进行复杂的检查，帮助获得更深入的代码。然而，我们应该意识到，反模糊技术[65，66]可以插入假路径，在错误处理代码中增加延迟，并模糊代码以减慢动态分析，如符号执行和污染分析[51]。</p>
<h5 id="implementation-limitation">Implementation Limitation</h5>
<p><img src="/png/2021-01-03-17-14-22.png"></p>
<p>According to Table I, about 57% (16/28) of the tools are implemented on top of AFL. Thus, the performance is, to some extent, limited by the implementation of AFL. We illustrate such limitation from two aspects.</p>
<p>Since the edge coverage of AFL is based on the basic block transitions, thus, it is only sensitive at the basic block level and cannot distinguish the path difference at the instruction level. Figure 5 shows an example of a jump between two nearby basic blocks. Since a traditional control-flow graph is only path-sensitive at the basic block level, we cannot differentiate whether the jump at address 0x400657 is taken (path 2) or not (path 1) because there will be the same edge in the controlflow graph, namely 0x400657 → 0x400671. Thus, general basic block level control-flow graph is not sensitive enough to precisely reflect the code coverage at the instruction level. Another problem lies in the path collision. AFL inserts random numbers for each branch jump at compile-time and collects these inserted numbers from the register at run-time to identify the basic block transition (i.e., the edge in the controlflow graph). Then it maps such transitions to a 64KB bitmap by cur location ∧ (prev location &gt;&gt; 1)]. This scheme incurs path collision because different edges might have the chance to share the same location. Both of the two limitations of AFL can import imprecision to the control-flow graph, which eventually affect the seed prioritization based on the control-flow graph analysis, no matter it is based on distance or other metrics. Although such limitation can be alleviated by constructing finer-grained controlflow graph or designing a customized hash scheme, however, additional work inevitably increases the runtime overhead. Thus, the implementation is essentially a tradeoff between the effectiveness and the efficiency.</p>
<p>根据表一，大约57%（16/28）的工具是在AFL之上实现的。因此，性能在一定程度上受到AFL实现的限制。从两个方面来说明这种局限性。</p>
<p>第一个问题在于，AFL的边缘覆盖是基于基本块转换的，因此它只在基本块级敏感，不能在指令级区分路径差异。图5显示了两个相邻基本块之间的跳转示例。由于仅对路径敏感，因此无法区分地址0x400657处的跳转是采用（路径2）还是不采用（路径1），因为在控制流图中会有相同的边，即0x400657→0x400671。</p>
<p>另一个问题在于，AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器中收集这些插入数，以标识基本块转换（即控制流图中的边）。然后通过一个算法将插入数转换映射到64KB位图。由于不同的边可能有机会共享同一位置，因此该方案会导致路径冲突。</p>
<p>AFL的这两个局限性都会导致控制流图的不精确性，最终影响基于控制流图分析的种子优先级，无论是基于距离还是其他度量。尽管这种限制可以通过构造更细粒度的控制流图或设计定制的哈希方案来缓解，但是，额外的工作不可避免地会增加运行时开销。</p>
<h5 id="efficiency-improvement">Efficiency Improvement</h5>
<p>As we have discussed in last subsection, in order to realize directedness in fuzzing, most researchers use additional instrumentation and data analysis. However, such additional analysis inevitably incurs performance deduction. For the evaluation, researchers usually focus on the ability to reach targets, using metric such as Time-to-Exposure (the length of the fuzzing campaign until the first testcase that exposes a given error) to measure the performance of directed greybox fuzzers, while ignoring the run-time overhead. However, for a given fuzzing time budget, higher efficiency means more fuzzing executions and, consequently, more chance to reach the target. Thus, optimize fuzzing efficiency is another direction to improve the directedness.</p>
<p>One solution is moving the execution-independent computation from run-time to compile-time. For example, AFLGo measures the distance between each basic block and a target location by parsing the call graph and intra-procedure control-flow graph of the PUT. Since both parsing graphs and calculating distances are very time consuming, AFLGo moves most of the program analysis to the instrumentation phase at compile-time in exchange for efficiency at run-time.</p>
<p>Another optimization is at the implementation level. Since most of the data we use during the analysis is graph-based, how such metadata is stored and accessed is vital to the efficiency. We can design an optimized data structure to store such data, which should facilitate the frequent and quick access to the data when searching based on the topological structure of the graph. For example, using the graph database model. Finally, we can leverage parallel computing to improve efficiency further. Prior works [69, 70] have successfully applied parallelism to CGF but not yet to DGF. For DGF, we can use a central node to maintain a seed queue that holds and prioritizes all the seeds for DGF. Then, distributing the seeds to parallel fuzzing instances on computational nodes to test the PUT and collect feedback information.</p>
<p>为了实现模糊化的方向性，大多数研究人员使用额外的工具和数据分析。然而，这种额外的分析不可避免地会导致性能降低。对于性能的评估，研究人员通常侧重于达到目标的能力，使用诸如暴露时间（暴露给定错误的第一个测试用例之前的模糊测试实践长度）等来衡量定向灰盒模糊程序的性能，而忽略了运行时开销。然而，对于给定的模糊时间预算，更高的效率意味着更多的模糊执行，因此，更多的机会达到目标。因此，优化模糊化效率是提高方向性的另一个方向。</p>
<p>一种解决方案是将与执行无关的计算从运行时转移到编译时。例如，AFLGo通过解析PUT的调用图和过程内控制流图来度量每个基本块与目标位置之间的距离。由于解析图和计算距离都非常耗时，AFLGo在编译时将大部分程序分析转移到插桩阶段，以换取运行时的效率。</p>
<p>另一个优化是在实现级别。由于在分析过程中使用的大多数数据都是基于图形的，因此如何存储和访问此类元数据对效率至关重要。可以设计一个优化的数据结构来存储这些数据，这样在基于图的拓扑结构进行搜索时就可以方便地频繁、快速地访问这些数据。例如，使用图形数据库模型。最后，可以利用并行计算来进一步提高效率。以前的工作已经成功地将并行性应用于CGF，但尚未应用于DGF。对于DGF，可以使用一个中心节点来维护一个种子队列，该队列保存DGF的所有种子并对其进行优先级排序。然后，将种子分发到计算节点上的并行模糊实例中，测试PUT并收集反馈信息。</p>
<h5 id="future-research-suggestions">Future research suggestions</h5>
<p>Based on the assessment and analysis of known works, we point out the following directions for future research.</p>
<ul>
<li><p>Among the tools we evaluated, only one (SemFuzz) of them supports kernel code testing. Thus, introducing DGF to kernel code and guiding fuzzing towards critical sites such as syscalls and error handling codes should be a productive direction.</p></li>
<li><p>Although DGF has been trying to discover new bug types, such as use-after-free and memory consumption bugs, many commonly seen bugs have not been included yet. Thus, another research direction is applying DGF to specific bug types, such as information leakage bugs, concurrency bugs, semantic bugs (TOCTTOU, double fetch).</p></li>
<li><p>As for the seed prioritization metric, most of the works leverage distance and coverage (similarity) based methods, which facilitate quantitive seed evaluation without introducing much overhead. However, a smaller distance or broader coverage does not necessarily mean closer to the target owing to the differentiated weight reason (discussed in Section IV-C) and global deviation reason (discussed in Section IV-D). We argue that probabilitybased metrics should be more reasonable.</p></li>
<li><p>Finally, staged fuzzing is a feasible approach that can be further exploited for DGF. By dividing the path to the target into sequential stages, staged directed fuzzing can get to the target step by step by reaching the sub-target in each stage. Moreover, we can leverage different fuzzing strategies to satisfy the requirements in different stages. For example, TOFU uses syntacticfuzzing for command-line flags and semantic-fuzzing for primary input files. Thus, staged fuzzing can reduce the dimensionality of the input space for each individual stage of fuzzing and improve fuzzing efficiency.</p></li>
<li><p>在论文作者评估的工具中，只有SemFuzz支持内核代码测试。因此，在内核代码中引入DGF，并引导对关键站点（如syscalls和错误处理代码）的模糊化应该是一个有效的方向。</p></li>
<li><p>虽然DGF一直在尝试发现新的bug类型，比如UAF漏洞和内存泄漏漏洞，但许多常见的bug还没有被包括在内。因此，另一个研究方向是将DGF应用于特定的bug类型，如信息泄漏bug、并发bug、语义bug（TOCTTOU、double fetch）。</p></li>
<li><p>对于种子优先级度量，大多数工作都利用了基于距离和覆盖率（相似性）的方法，这有助于在不引入太多开销的情况下对种子进行量化评估。然而，较小的距离或较宽的覆盖范围并不一定意味着更接近目标，因为存在不同的权重原因和全局偏差原因。作者认为基于概率的度量应该更合理。</p></li>
<li><p>最后，分阶段模糊测试是一种可行的方法，可以进一步用于DGF。通过将到达目标的路径划分为连续的多个阶段，分阶段定向模糊算法可以在每个阶段到达子目标，逐步到达目标。此外，可以利用不同的模糊策略来满足不同阶段的需求。例如，TOFU对命令行标志使用语法模糊，对主要输入文件使用语义模糊。因此，分阶段模糊化可以降低模糊化各个阶段输入空间的维数，提高模糊化效率。</p></li>
</ul>
<h4 id="conclusions">Conclusions</h4>
<p>Directed greybox fuzzing is a practical and scalable approach to software testing under specific scenarios, such as patch testing and bug reproduction.</p>
<p>The modern DGF has evolved from reaching target locations to hunting complex deep behavioral bugs.</p>
<p>However, DGF still faces challenges, including binary code support, automatic target identification, differentiated weight metric, global optimum deviation, missing indirect calls, and exploration-exploitation coordination.</p>
<p>According to the assessment, we suggest paying more attention to apply differentiated weight in seed prioritization, to overcome the global optimum deviation, to exploit the relationship among targets, and to coordinate the splitting of the exploration phase and the exploitation phase. We also point out research directions for future work.</p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/fuzz/" rel="tag"><i class="fa fa-tag"></i> fuzz</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/2cb5ce06/" rel="next" title="IS-crypto-非对称加密-RSA的攻击方式">
                <i class="fa fa-chevron-left"></i> IS-crypto-非对称加密-RSA的攻击方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/apple-touch-icon.png" alt="w4rd3n">
            
              <p class="site-author-name" itemprop="name">w4rd3n</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">167</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">39</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/hitworld" title="GitHub &rarr; https://github.com/hitworld" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#surveyreview"><span class="nav-number">1.</span> <span class="nav-text">Survey/Review</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fuzzing-challenges-and-reflections"><span class="nav-number">1.1.</span> <span class="nav-text">Fuzzing: Challenges and Reflections</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#blackbox-fuzzing"><span class="nav-number">1.1.1.</span> <span class="nav-text">Blackbox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#greybox-fuzzing"><span class="nav-number">1.1.2.</span> <span class="nav-text">Greybox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#whitebox-fuzzing"><span class="nav-number">1.1.3.</span> <span class="nav-text">Whitebox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#other-fuzzing-tools"><span class="nav-number">1.1.4.</span> <span class="nav-text">Other fuzzing tools</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#challenges"><span class="nav-number">1.1.5.</span> <span class="nav-text">Challenges</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#automation"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">Automation</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems"><span class="nav-number">1.1.5.1.1.</span> <span class="nav-text">[C.1] More Software. How can we fuzz efficiently more types of software systems?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities"><span class="nav-number">1.1.5.1.2.</span> <span class="nav-text">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection"><span class="nav-number">1.1.5.1.3.</span> <span class="nav-text">[C.3] More Difficult Bugs. How can we find “deep bugs” for which efficient oracles exist, but which nevertheless evade detection?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns"><span class="nav-number">1.1.5.1.4.</span> <span class="nav-text">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#the-human-component"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">The Human Component</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor"><span class="nav-number">1.1.5.2.1.</span> <span class="nav-text">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools"><span class="nav-number">1.1.5.2.2.</span> <span class="nav-text">[C.6] Usability. How can we improve the usability of fuzzing tools?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fuzzing-theory"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">Fuzzing Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful"><span class="nav-number">1.1.5.3.1.</span> <span class="nav-text">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing"><span class="nav-number">1.1.5.3.2.</span> <span class="nav-text">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#evaluation-and-benchmarks"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">Evaluation and Benchmarks</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#survey"><span class="nav-number">1.1.6.</span> <span class="nav-text">Survey</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing"><span class="nav-number">1.2.</span> <span class="nav-text">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#introduction"><span class="nav-number">1.2.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#background"><span class="nav-number">1.2.2.</span> <span class="nav-text">Background</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#terminology"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Terminology</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#coverage-guide-greybox-fuzzing"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">Coverage-guide Greybox Fuzzing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#directed-greybox-fuzzing"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">Directed Greybox Fuzzing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#difference-between-cgf-and-dgf"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">Difference between CGF and DGF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#application-of-dgf"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">Application of DGF</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#assessment-of-the-state-of-the-art-works"><span class="nav-number">1.2.3.</span> <span class="nav-text">Assessment of the-state-of-the-art Works</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#directed-type"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Directed Type</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#input-optimization"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">Input Optimization</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#seed-prioritization"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">Seed Prioritization</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#distance"><span class="nav-number">1.2.3.3.1.</span> <span class="nav-text">Distance</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#similarity-coverage"><span class="nav-number">1.2.3.3.2.</span> <span class="nav-text">Similarity &amp; Coverage</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#probability"><span class="nav-number">1.2.3.3.3.</span> <span class="nav-text">Probability</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#power-assignment"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">Power Assignment</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mutator-scheduling"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">Mutator Scheduling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#data-flow-analysis"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">Data-flow Analysis</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#challenges-and-solutions"><span class="nav-number">1.2.4.</span> <span class="nav-text">Challenges and Solutions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#binary-code-support"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">Binary Code Support</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#automatic-target-identification"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">Automatic target identification</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#differentiated-weight-metric"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">Differentiated weight metric</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#global-optimum-deviation"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">Global Optimum Deviation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#missing-indirect-calls"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">Missing Indirect Calls</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exploration-exploitation-coordination"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">Exploration-exploitation coordination</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#discussion"><span class="nav-number">1.2.5.</span> <span class="nav-text">Discussion</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#multi-targets-relationship-exploitation"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">Multi-targets Relationship Exploitation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#technology-integration"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">Technology Integration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#implementation-limitation"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">Implementation Limitation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#efficiency-improvement"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">Efficiency Improvement</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#future-research-suggestions"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">Future research suggestions</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#conclusions"><span class="nav-number">1.2.6.</span> <span class="nav-text">Conclusions</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-gg-circle"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">w4rd3n</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">881k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">13:21</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz",
                'X-LC-Key': "UvlYMzpJKw0Jrw61V5BA5ifU",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  
  

  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>;
  <script>
  //$("body").backstretch("/images/background.jpg");
  </script>
  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
