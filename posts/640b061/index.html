<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.5.0">


  <link rel="mask-icon" href="/images/safari_pinned_tab.svg?v=6.5.0" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml">







<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Survey/Review 本文主要是对fuzz相关论文的笔记。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing是一种自动化漏洞发现技术---通过持续不断地生成输入并报告程序的crash。 现在有三种主要的fuzzing技术和工具：黑盒，灰盒和白盒fuzzing。 Blackbox fuzzing 黑盒fuzzing不需要任何关于">
<meta name="keywords" content="fuzz">
<meta property="og:type" content="article">
<meta property="og:title" content="IS-pwn-fuzz-theory-present-situation">
<meta property="og:url" content="https://hitworld.github.io/posts/640b061/index.html">
<meta property="og:site_name" content="w4rd3n">
<meta property="og:description" content="Survey/Review 本文主要是对fuzz相关论文的笔记。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing是一种自动化漏洞发现技术---通过持续不断地生成输入并报告程序的crash。 现在有三种主要的fuzzing技术和工具：黑盒，灰盒和白盒fuzzing。 Blackbox fuzzing 黑盒fuzzing不需要任何关于">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-22-46-04.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-13-09-41.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-09-55.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-40-06.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-40-26.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-17-05-33.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-17-14-22.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-17-09-36-29.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-17-10-19-48.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-22-13-45-05.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-24-10-39-35.png">
<meta property="og:updated_time" content="2021-02-09T09:54:58.512Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IS-pwn-fuzz-theory-present-situation">
<meta name="twitter:description" content="Survey/Review 本文主要是对fuzz相关论文的笔记。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing是一种自动化漏洞发现技术---通过持续不断地生成输入并报告程序的crash。 现在有三种主要的fuzzing技术和工具：黑盒，灰盒和白盒fuzzing。 Blackbox fuzzing 黑盒fuzzing不需要任何关于">
<meta name="twitter:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">






  <link rel="canonical" href="https://hitworld.github.io/posts/640b061/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>IS-pwn-fuzz-theory-present-situation | w4rd3n</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">w4rd3n</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">混吃等死</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>友链</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hitworld.github.io/posts/640b061/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="w4rd3n">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/apple-touch-icon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="w4rd3n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">IS-pwn-fuzz-theory-present-situation
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-01-01 23:41:38" itemprop="dateCreated datePublished" datetime="2021-01-01T23:41:38+08:00">2021-01-01</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/" itemprop="url" rel="index"><span itemprop="name">IS</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/posts/640b061/" class="leancloud_visitors" data-flag-title="IS-pwn-fuzz-theory-present-situation">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度：</span>
               
                 <span class="leancloud-visitors-count"></span>
                 <span>℃</span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">38k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">35 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="surveyreview">Survey/Review</h2>
<p>本文主要是对fuzz相关论文的笔记。</p>
<h3 id="fuzzing-challenges-and-reflections">Fuzzing: Challenges and Reflections</h3>
<p><a href="https://www.comp.nus.edu.sg/~abhik/pdf/IEEE-SW-Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>Fuzzing是一种自动化漏洞发现技术---通过持续不断地生成输入并报告程序的crash。</p>
<p>现在有三种主要的fuzzing技术和工具：黑盒，灰盒和白盒fuzzing。</p>
<h4 id="blackbox-fuzzing">Blackbox fuzzing</h4>
<p>黑盒fuzzing不需要任何关于程序的先验知识。</p>
<p>黑盒fuzzing主要有两种的variants：突变和生成。</p>
<p>前者通过初始语料库(seed inputs)开始变异，通过对随机位置的随机突变来生成新的输入。</p>
<p>后者是从头开始生成的，通过提供的输入格式来生成满足所提供语法的新的输入。</p>
<p>黑盒fuzzing工具：Peach (http://community.peachfuzzer.com)。</p>
<h4 id="greybox-fuzzing">Greybox fuzzing</h4>
<p>灰盒fuzzing通过在编译时对一些位置（例如代码块跳转点）进行插桩来获取轻量级的运行时反馈从而引导fuzzer。</p>
<p>通常，程序会在代码块交界处被插桩，并且一些初始的语料库会被提供，初始的种子输入会被用于突变产生新的输入，那些覆盖了新的代码块或者其他增加了代码覆盖的输入将被加入语料库。</p>
<p>所以随着这种覆盖反馈fuzzer的运行，输入会逐渐深入程序的深处。</p>
<p>sanitizers还会注入断言到程序中来判断漏洞的种类。</p>
<p>灰盒fuzzing工具：AFL (https://lcamtuf.coredump.cx/afl/), LibFuzzer (https://llvm.org/docs/LibFuzzer.html), and Honggfuzz (https://github.com/google/honggfuzz)。</p>
<h4 id="whitebox-fuzzing">Whitebox fuzzing</h4>
<p>基于符号执行的白盒fuzzing使用程序分析和约束求解器来系统地枚举感兴趣的程序路径，其中用作后端的约束求解器是Satisfiability Modulo Theory (SMT)求解器。</p>
<p>白盒fuzzing通过分析与i经过同一路径的输入集合来计算i经过的路径的条件，路径条件用SMT表示，例如：i[0] = 42 ∧ i[0] − i[1] &gt; 7。</p>
<p>白盒fuzzer对于给定的种子输入s，计算并改变路径条件而不是改变程序输入，然后将改变后的路径条件发送到一个约束解算器来产生新的输入。</p>
<p>白盒fuzzing会跟踪到目前为止获取的所有输入的路径状况，所以始终能够生成一个经过新路径的输入。</p>
<p>白盒fuzzing工具：KLEE (https://klee.github.io/) and SAGE。</p>
<h4 id="other-fuzzing-tools">Other fuzzing tools</h4>
<p>DeepState (https://github.com/trailofbits/deepstate)：一个单元测试框架.</p>
<p>The Mayhem system. --- Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, David Brumley. 2012. Unleashing Mayhem on Binary Code. IEEE Symposium on Security and Privacy (S&amp;P’12).</p>
<h4 id="challenges">Challenges</h4>
<p>fuzzing技术现在面临的问题与挑战。</p>
<h5 id="automation">Automation</h5>
<p>自动化方面的挑战。</p>
<h6 id="c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems">[C.1] More Software. How can we fuzz efficiently more types of software systems?</h6>
<p>如何扩展能够fuzzing的领域和范围？</p>
<p>现在的fuzzer基本上都是生成不规则的输入，而对于文件解析器和面对对象程序来说，需要的是高度结构化的输入。</p>
<p>还有网络程序，机器学习系统的fuzzing方式应该是怎么样的？</p>
<p>对于那些有状态的软件，它们对于相同的输入会产生不同的输出，应该如何进行fuzz？还有多语言构建的软件和GUI软件。</p>
<p>给定一个程序，它的输入域是由语法/协议定义的，那么符号执行工具如何对这种结构化的输入域制定约束?</p>
<h6 id="c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</h6>
<p>如何扩展fuzzing发现的漏洞类型？</p>
<p>现在已经可以利用断言检测程序运行状态发现内存和并发漏洞。</p>
<p>侧信道漏洞发现已经成为热门，未来应该着眼于其他的关键性安全漏洞，包括其他编程语言中的。</p>
<h6 id="c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection">[C.3] More Difficult Bugs. How can we find “deep bugs” for which efficient oracles exist, but which nevertheless evade detection?</h6>
<p>fuzzing如何发现更深层次的漏洞？</p>
<ol type="1">
<li>结构感知和基于语法的fuzzing，以及静态分析和符号执行与灰盒fuzzing的结合是很有前途的方向。</li>
<li>针对软件补丁的技术对于发现软件补丁引入的错误是至关重要的。</li>
<li>应该研究促进bug发现的策略。例如AFLFast，它可以在灰盒fuzzing中更快地检测崩溃，并通过研究gpu的效用和其他有效的并行化方法以最大限度地增加单位时间内的执行次数。</li>
</ol>
<h6 id="c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</h6>
<p>需要实证研究来了解源代码中安全漏洞的性质和分布。</p>
<h5 id="the-human-component">The Human Component</h5>
<p>fuzzing中的人。</p>
<h6 id="c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</h6>
<p>人在模糊测试中能起到的作用，也就是什么才是最合理的半自动化fuzzing方案？</p>
<p>Ned Williamson给出了下面这种方法。</p>
<ol type="1">
<li>首先审核代码，以识别可能存在安全漏洞的代码区域。</li>
<li>为设备准备fuzzing，运行fuzzing一段时间，并确定fuzzing的遇到的障碍和问题。</li>
<li>手动修补遇到的障碍和问题。</li>
<li>如果fuzzer花费很多时间来测试代码中不重要的部分，对fuzzer进行调整。</li>
<li>一旦发现了一个潜在的漏洞，就要回溯并之前修补的部分，并相应地调整输入再次触发漏洞。</li>
</ol>
<h6 id="c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools">[C.6] Usability. How can we improve the usability of fuzzing tools?</h6>
<p>如何提高模糊工具的可用性？也就是说如何让一个技术人员快速掌握并使用。</p>
<h5 id="fuzzing-theory">Fuzzing Theory</h5>
<p>需要一个可靠的Fuzzing Theory。</p>
<h6 id="c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</h6>
<p>除了白盒模糊测试，灰盒模糊测试和黑盒模糊测试都不能保证没有未发现的漏洞。白盒模糊测试受限于时间和可扩展性也无法完全保证，灰盒模糊测试存在适应性偏差，黑盒模糊测试存在剩余风险。</p>
<h6 id="c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</h6>
<p>给定程序和时间预算，什么是能在时间预算内找到最多漏洞的模糊技术或技术组合程序的大小和复杂性如何影响可伸缩性和性能？计算资源对程序效率的影响程度？</p>
<h5 id="evaluation-and-benchmarks">Evaluation and Benchmarks</h5>
<p>[C.9] How can we evaluate specialized fuzzers?</p>
<p>[C.10] How can we prevent overfitting to a specific benchmark?</p>
<p>[C.11] Are synthetic bugs representative?</p>
<p>[C.12] Are real bugs, which have previously been discovered with other fuzzers, representative?</p>
<p>[C.13] Is coverage a good measure of fuzzer effectiveness?</p>
<p>[C.14] What is a fair choice of time budget?</p>
<p>[C.15] How do we evaluate techniques instead of implementations?</p>
<h3 id="sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv20_SoK.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>大多数greybox fuzzing工具是由代码覆盖率引导的，因为代码覆盖率和bug覆盖率是正相关的，但其实大部分代码是不存在bug的。</p>
<p>与盲目扩展路径覆盖范围的基于代码覆盖率的fuzzing不同，定向greybox fuzzing将其大部分时间预算花在到达特定的目标站点上，例如，容易出bug的区域。</p>
<p>因此，定向灰盒模糊测试特别适用于补丁测试、1 day bug复现以及与其他工具集成等场景。</p>
<h4 id="introduction">Introduction</h4>
<p>传统的定向fuzzing是基于符号执行，但是这种方法会受到符号执行一些问题而限制，例如：复杂的约束求解和路径爆炸等问题。</p>
<p>通过在测试程序(PUT)中指定一组目标站点，并利用编译时插桩获取运行时信息来计算输入种子和目标之间的距离，通过给更接近目标的种子更多的变异机会来将fuzzer导向目标站点。</p>
<p>定向greybox fuzzing将目标站点的可达性问题转化为一个优化问题，以最小化生成的输入种子到目标站点的距离为标准来进行语料库的筛选。</p>
<p>定向greybox fuzzing并未止步于依赖于手动标记的目标站点和基于距离的度量来确定输入种子优先级的主要模式。为了在不同的场景下提高软件测试，已经实现了大量的变体。</p>
<h4 id="background">Background</h4>
<p>CGF(覆盖率导向greybox fuzzing)和DGF(定向greybox fuzzing)的背景知识。</p>
<h5 id="terminology">Terminology</h5>
<p>该文献中使用的术语及其解释。</p>
<ul>
<li>Fuzzing. In this paper, fuzzing refers to traditional blackbox fuzzing and greybox fuzzing. We exclude whitebox fuzzing as it depends on constraint solving of symbolic execution to generate inputs, which is quite different from evolutionary fuzzers based on mutation.</li>
<li>Testcase. A testcase is an input to the PUT, which is generated by randomly mutating a seed.</li>
<li>Seed. A seed is a testcase that is favored (trigger a new path or close to the target) and retained for the mutation to generate new testcases in the next fuzzing iteration.</li>
<li>Seed prioritization. Seed prioritization means to evaluate and sort the seeds according to its performance. Prioritized seeds would be given more fuzzing chances.</li>
<li>Power schedule Power schedule means to determine the number of fuzzing tests to be applied on a seed (i.e., energy).</li>
<li>Fuzzing cycle All seeds in the seed queue have been fuzzed at least once.</li>
</ul>
<h5 id="coverage-guide-greybox-fuzzing">Coverage-guide Greybox Fuzzing</h5>
<p>下面用ALF来介绍典型的CGF技术。</p>
<p>AFL使用上下文不敏感的边缘覆盖替代一般的基本块覆盖。AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器收集这些随机数获知跳转信息，统计边缘覆盖。</p>
<p>边缘覆盖比基本块覆盖更精细和敏感，因为它考虑了基本块之间的过渡。边缘覆盖也比路径覆盖更具可伸缩性，因为它避免了路径爆炸。</p>
<p>AFL偏爱触发新路径的输入种子，AFL通过一个位图记录每个种子的优先级，对于优先级高的种子，AFL给予更多的模糊机会，也就是后面说的能量。</p>
<p>AFL有两类变异策略：确定性策略和非确定性策略。</p>
<p>AFL首先采用确定性策略，利用基于位翻转、算术、令牌、字典和特殊值的变异器依次变异不同粒度的种子。</p>
<p>在进行确定性策略之后，AFL就会进行非确定性策略，包括havoc阶段和拼接阶段。</p>
<p>在havoc阶段，AFL通过从确定性策略中随机选择一系列变异算子对种子进行变异，并将其应用于种子文件中的随机位置。因此，生成的testcase与原始种子有很大的不同。</p>
<p>然后，AFL使用剪接策略从种子队列中随机选择另一个种子，并将其与当前种子重新组合以生成新的种子。最后，对新种子重新实施破坏策略。</p>
<p>AFL通过能量调度来分配一轮模糊测试的时间。</p>
<p>在确定性阶段，变异策略依次参与，而在非确定性阶段，AFL可以给种子分配能量来决定每个种子的模糊机会。</p>
<p>能量是根据每个种子的性能得分来分配的，而性能得分基于覆盖率（优先考虑覆盖更多路径的输入）、执行情况时间（对执行速度更快的输入进行优先级排序）和发现时间（对稍后发现的输入进行优先级排序）来计算出来的。</p>
<p>特别的，如果测试用例执行一条新路径，AFL将加倍分配的能量。</p>
<h5 id="directed-greybox-fuzzing">Directed Greybox Fuzzing</h5>
<p><img src="/png/2021-01-02-21-17-13.png"></p>
<p>下面以用AFLGo为代表来说明DGF的工作原理。</p>
<p>AFLGo遵循CGF的一般原理和体系结构。不同的是，除了获取执行路径和边缘覆盖信息外，AFLGo还计算输入与目标站点之间的距离。该距离基于输入种子的执行跟踪权值上的基本块到目标基本块的平均值来计算，其中权值由程序的调用图和控制流图中的边数来确定。</p>
<p>B¨ohme et al.将灰盒模糊化过程视为一个马尔可夫链，所以可以使用功率调度进行有效的引导。利用模拟退火策略，逐渐将更多的能量分配给距离目标较近的种子，从而将可达性问题转化为优化问题，以最小化生成的种子到目标站点的距离为目的。</p>
<p>AFLGo将整个DGF分为两个阶段，探索阶段和开发阶段。</p>
<p>勘探阶段的目的是尽可能多地揭示路径，像许多覆盖率导向模糊程序一样，这个阶段的DGF偏爱触发新路径并对其进行优先级排序的种子，因为新的路径增加了通向目标的可能性。</p>
<p>开发阶段的目的是最小化生成的种子到目标的距离。在这一阶段，B¨ohme et al.对更接近目标的种子进行优先排序，并为它们分配更多的能量。</p>
<p>勘探开发的权衡在于如何协调这两个阶段。B¨ohme et al.使用固定的勘探和开发阶段划分。例如，对于24小时测试，AFLGo使用20小时进行勘探，然后使用4小时进行开发。</p>
<h5 id="difference-between-cgf-and-dgf">Difference between CGF and DGF</h5>
<p>CGF和DGF技术的不同点。</p>
<ol type="1">
<li>种子优先级。CGF的目标是最大化路径覆盖，所以会偏爱触发新路径的种子。而DGF的目标是到达代码中的特定位置，所以它偏爱更接近目标的种子。</li>
<li>探索目标。CGF以一种无方向的方式扩展代码覆盖范围，在不包含bug的代码区域浪费能量。DGF则预先对一组目标站点进行人工或自动标记，以指导整个模糊测试过程，从而节省能量。目标的选择会影响DGF的性能。</li>
<li>勘探开发。对于基于覆盖率的灰盒模糊测试，整个过程本质上是一个探索-开发问题的折衷，其中探索意味着尝试尽可能多的种子，而开发意味着尽可能多地变异某个种子。对于DGF来说，勘探开发问题在于勘探阶段与开发阶段的协调。在探索阶段，DGF试图发现尽可能多的种子，并从中获取更多的新路径，以增加到达目标的可能性。同时，开发阶段给了一些种子更多的变异机会，这些种子更有可能产生到达目标的输入。</li>
</ol>
<h5 id="application-of-dgf">Application of DGF</h5>
<p>DGF常见的应用方向。</p>
<ul>
<li>补丁测试。DGF可以用来测试补丁是否完整和兼容，修补程序在以下情况下是不完整的：错误可能由多个输入触发；补丁可能会引入新的bug。因此，针对有问题的更改或补丁的DGF有更高的发现bug的机会。</li>
<li>bug复现。DGF可以用于复现没有crash输入的已知bug。例如，出于隐私等考虑，某些应用程序（如视频播放器）不允许发送输入文件，这种情况下内部开发团队可以使用DGF通过stack trace中的方法调用和一些环境参数来再现崩溃。在给定错误报告信息的情况下，DGF也可以生成已披露漏洞的PoC。</li>
<li>人机合一（意译法）。DGF可以配合分析人员的知识或辅助技术来促进fuzz。通过分析人员的知识和经验可以帮助DGF识别关键的系统调用或security-sensitive的程序站点（例如，内存分配函数malloc、字符串操作函数strcpy），基于以前的经验来引导模糊化到容易出错的部分。如符号执行和taint analysis之类的辅助技术可以用来解决测试中的障碍，而静态分析和基于机器学习的检测方法的初步结果可以用作DGF的潜在易受攻击目标。</li>
<li>测试资源有限。当测试资源有限时，例如对物联网设备进行fuzz，识别关键代码区域来指导fuzz比无方向地fuzz整个程序更有效。</li>
<li>特定类型bug检测。DGF可以应用于基于定制指标的特定bug检测。例如，在内存使用状况的指导下查找内存泄漏bug，在typestate violation（应该是指违反了特定的使用范例，例如free后并未清除指针）的指导下查找UAF漏洞。</li>
</ul>
<h4 id="assessment-of-the-state-of-the-art-works">Assessment of the-state-of-the-art Works</h4>
<p><img src="/png/2021-01-02-22-46-04.png"></p>
<p>为了进行全面的评估，论文根据DGF的特征提取了15个度量。同时进一步将度量分为三类，包括基本信息、实现细节和优化方法。</p>
<p>在下文中，论文集中讨论与DGF关键技术相关的特性，包括定向类型、输入优化、种子优先级、能量分配、变异调度和数据流分析。</p>
<p>该论文主要研究DGF（表1中记为G），不过在某些工作中采用了符号执行来增强有向性，形成了有向混合模糊测试（表1中记为H）。</p>
<h5 id="directed-type">Directed Type</h5>
<p>对于定向目标的类型，DGF最初通过在PUT中手动标记的目标站点来进行定向，如AFLGo和Hawkeye。</p>
<p>后来发现目标之间的关系对于bug的触发也是有影响的，所以改变单独的目标站点为目标序列。</p>
<p>为了触发UAF漏洞，必须按特定顺序执行一系列操作：分配内存、使用内存和释放内存。所以UAFuzz和UAFL利用目标序列而不是目标站点来发现UAF漏洞。LOLLY还使用目标语句序列来引导DGF触发由多个语句的顺序执行导致的bug。Berry使用符号执行来增强LOLLY沿着复杂路径到达深层目标时的方向性。</p>
<p>除了目标序列之外，研究人员还提出了各种机制来指导DGF。</p>
<p>Memlock通过监控内存使用情况来发现内存泄漏漏洞。V-Fuzz以易受攻击概率为指导，通过深度学习模型预测易受攻击概率，将DGF引导到潜在易受攻击的代码区域。SemFuzz和DrillerGo利用从CVE描述和git日志中检索到的语义信息来指导DGF并生成PoC报告。1DVUL通过那些直接改变原始数据流或控制流的补丁指导以发现1-day漏洞。SAVIOR和Parmasan是由来自sanitizers（Sanitizers是谷歌发起的开源工具集）的信息指导的。IJON利用来自分析人员的注释来指导DGF克服重要的障碍。RVFUZZER受control instability的指导，在机器人车辆中发现输入验证漏洞。PFUZZER明确地指向输入解析器，从而更好地覆盖代码区域。</p>
<p>DGF已经从到达目标站点发展到发现复杂的深层的行为漏洞。</p>
<h5 id="input-optimization">Input Optimization</h5>
<p>优化输入的生成策略对于提高DGF的性能有很大的帮助。</p>
<p>seedfuzz致力于改进初始种子的生成和选择，以达到定向模糊的目的。它利用动态污点分析来识别种子当中那些会影响security-sensitive程序位置的值的字节，通过改变这些字节来生成新的输入提供给目标程序以触发错误。</p>
<p>FuzzGuard使用了一种基于深度学习的方法，在fuzz之前过滤掉无法达到目标站点的输入。它将程序的输入看作一种模式，并使用大量的在之前的执行中能够到达目标代码的输入来训练模型，然后利用该模型预测新生成的输入的可达性，从而节省了实际执行所需的时间。</p>
<p>TOFU利用protobuf规范形式的程序输入的已知结构来生成有效的输入。通过将模糊处理分为语法模糊处理和语义模糊处理，TOFU扩大了输入空间，以包含命令行标志。然而，即使用户熟悉输入语言，实现输入语言语法通常也需要一到两天的时间。</p>
<p>SemFuzz利用从CVE描述和git日志中检索到的信息（系统调用和参数）来构建设计好的种子输入，以增加命中易受攻击函数的概率。</p>
<p>TIFF和ProFuzzer通过识别输入类型辅助变异，从而最大化触发内存溢出漏洞的可能性。</p>
<p>PFUZZER是一种语法驱动的方法，专门针对输入解析器，在生成不合理输入的情况下最大化输入空间覆盖率。</p>
<h5 id="seed-prioritization">Seed Prioritization</h5>
<p>DGF文献中广泛采用的三个种子优先级的度量标准：距离、覆盖率和概率。</p>
<h6 id="distance">Distance</h6>
<p>作为一项开创性的工作，AFLGo在编译时对源代码进行检测，并通过PUT的调用图和控制流图中的边数计算到目标基本块的距离。然后在运行时聚合每个基本块的距离值，以计算平均值来评估种子。许多后续版本继承了这种基于距离的方案，如Parmasan和1DVUL。</p>
<p>TOFU的距离度量定义为达到目标所需的正确分支决策数。</p>
<p>RDFuzz将距离和频率结合起来，对种子进行优先级排序。通过代码的执行频率将代码区分为高频区和低频区。输入分为高/低距离和高/低频四种类型。在探测阶段，优先选择低频种子来提高覆盖率；在开发阶段，优先选择低距离种子来靠近目标区域。</p>
<p>UAFuzz是一个定制的DGF程序，用于复杂的UAF漏洞。与基于控制流图的距离不同，它使用了通向目标函数的调用链的距离度量，目标函数一般包含分配函数和释放函数。</p>
<p>W¨ustholz et al使用online static lookahead analysis来找到并避免那些所有后缀路径都无法到达目标站点的路径前缀。通过强调可能到达目标站点的路径前缀，DGF的能量调度可以更合理地分配其资源。</p>
<p>基于距离的方法的一个缺点是它只关注最短距离。当有多条路径到达同一目标时，可能会忽略较长的选项，从而导致偏差。</p>
<h6 id="similarity-coverage">Similarity &amp; Coverage</h6>
<p>相似性表示某些目标形式的覆盖范围，例如函数、位置和bug traces。当有许多目标时，这个指标特别适用。</p>
<p>Hawkeye利用对PUT的静态分析，将基本块跟踪距离与覆盖函数相似性结合起来，用于种子优先级排序和能量调度。LOLLY使用指定的程序语句序列作为目标，并将种子覆盖目标序列的能力（即序列覆盖率）作为评估种子的度量。UAFL使用操作序列覆盖率作为反馈，引导测试用例生成逐步覆盖触发UAF漏洞可能使用的操作序列。</p>
<p>UAFuzz还使用序列感知目标相似性度量来度量种子执行和目标UAF bug traces之间的相似性。序列感知目标相似性度量具体评估了种子在运行时执行trace所覆盖的目标的数量和顺序。</p>
<p>Berry考虑了目标序列中节点的覆盖率及其执行上下文。它用必要的节点来增强目标序列，即到达所有路径的目标序列中的节点所需的基本块。除了分支覆盖之外，Berry还考虑了目标执行trace和增强目标序列之间的相似性，从而对种子进行优先级排序。</p>
<p>SAVIOR根据UBSan预测的标签覆盖率，优先考虑具有更高触发漏洞潜力的种子。TortoiseFuzz基于内存损坏漏洞与敏感内存操作密切相关的事实，区分了更可能注定易受攻击的边缘。它通过覆盖率和安全影响因子的组合对输入进行优先级排序，这由函数、循环和基本块的三种不同粒度类型的内存操作表示。</p>
<h6 id="probability">Probability</h6>
<p>概率是另一个有用的指标，它通过达到目标的可能性来确定种子的优先级。通常将种子优先级度量与目标识别度量相结合，以将模糊化引向潜在的易受攻击的位置。</p>
<p>V-Fuzz和SUZZER基于一个通过深度学习的模型得到函数的脆弱概率，并给函数中的每个基本块一个静态分数。然后对于每个输入计算其执行路径上所有基本块的静态得分之和，并对得分较高的输入进行优先级排序。</p>
<p>SAVIOR利用UBSan为代码区域添加可能存在bug的标签。TAFL加强了对包含漏洞的概率较高的区域的模糊化，该模糊化基于静态语义度量，包括敏感、复杂、深入和罕见的区域。</p>
<h5 id="power-assignment">Power Assignment</h5>
<p>AFLGo使用一种基于模拟退火的能量调度，逐渐将更多的能量分配给距离目标站点较近的种子，同时减少距离较远的种子的能量。</p>
<p>传统的随机游走调度总是接受更好的解从而可能陷入局部最优，而模拟退火则以一定的概率接受不如当前最优解的解，因此有可能跳出局部最优解而达到全局最优解。</p>
<p>Hawkeye也采用了模拟退火，但增加了优先级。因此，更接近目标的种子首先发生变异，这进一步提高了方向性。LOLLY采用了一种优化的基于模拟退火的能量调度来实现最大的序列覆盖。在温度阈值的控制下，探测阶段的会随机地对所提供的种子进行变异以产生许多新的输入；而在开发阶段，它会从具有更高序列覆盖率的种子中产生更多的新输入。</p>
<h5 id="mutator-scheduling">Mutator Scheduling</h5>
<p>一些模糊程序通过优化变异策略来辅助DGF，这主要是通过将变异分类成不同的粒度（类型）来实现的。</p>
<p>Hawkeye利用了一种自适应变异策略，将变异分为粗粒度和细粒度。粗粒度的变异在突变期间会更改大量字节，而细粒度的变异只涉及少量字节级的修改、插入或删除。当一个种子接近目标函数时，粗粒度变异的机会就变少。一旦种子达到目标函数，进行细粒度变异的次数增加，而粗粒度变异的次数减少。同样，V-Fuzz将变异策略分为轻微变异和严重变异，并根据实际模糊测试的状态通过阈值动态调整变异策略。</p>
<p>SemFuzz执行类似的分类，只是它关注于系统调用。SemFuzz利用对输入的粗变异来找到一个系统调用序列，该序列可以将执行移向易受攻击的函数。之后，它将切换到syscall序列上的细粒度变异，以监视关键变量。</p>
<p>TAFL还采用了基于经验观察的粒度感知的变异调度，即：粗粒度变异在路径增长方面优于细粒度变异；组合多个变异的性能优于使用单一类型的变异。</p>
<p>ProFuzzer根据输入类型探测识别的输入字段类型，如何进行不同的变异策略。</p>
<h5 id="data-flow-analysis">Data-flow Analysis</h5>
<p>数据流分析（如污点分析）可以反映变异对生成输入的影响，有助于优化变异策略和输入生成。</p>
<p>RDFuzz利用一种干扰-检查方法来识别和保护对输入的距离敏感的内容，这对保持距离至关重要（该句不太理解，可能翻译错误）。在变异过程中防止这些内容有助于更有效地接近目标代码位置。</p>
<p>UAFL采用信息流分析来识别条件语句中的输入和程序变量之间的关系，并为那些信息流更多的输入字节赋予更高的变异可能性，因为它们更可能改变目标语句的值。</p>
<p>SemFuzz通过反向数据流分析跟踪关键变量所依赖的核函数参数。SeedFuzz利用动态污点分析来识别种子中可能影响security-sensitive程序位置的值的字节。PFUZZER使用输入的动态污染，将处理的每个值与其派生的输入字符相关联。TIFF通过内存中的数据结构识别和动态污点分析来推断输入类型，这增加了基于类型的变异触发内存损坏漏洞的概率。</p>
<p>当然，数据流分析通常会增加运行时开销。</p>
<h4 id="challenges-and-solutions">Challenges and Solutions</h4>
<p>DGF面临的挑战及可能的解决方案。</p>
<h5 id="binary-code-support">Binary Code Support</h5>
<p>大多数已知的DGF都是在AFL的基础上实现的，并继承其编译时插桩方案来反馈执行状态或计算基于距离的度量。这种方案不适合没有测试源代码的场景，例如商用闭源COTS软件或部分依赖第三方库的关键程序。</p>
<p>二进制级别的DGF存在以下问题。</p>
<ol type="1">
<li>运行时开销很大。最简单的方法就是利用一个完整的系统仿真器。例如，UAFuzz处理二进制代码，并通过QEMU提取执行路径。然而，基于仿真器的工具通常效率较低。</li>
<li>目标信息收集困难。对于二进制代码中的PUT，只能从bug trace中提取目标信息。</li>
<li>标靶困难。由于二进制代码很难读取，必须对其进行反汇编，如使用idapro，并用虚拟地址标记目标。</li>
</ol>
<p>一个可行解决方案是通过硬件辅助减轻性能限制。Intel PT是最新Intel处理器中的一种轻量级硬件功能，可以捕获有关程序执行的trace数据，同时Intel PT可以动态跟踪程序执行，开销可以忽略不计。安全分析人员通过Intel PT捕获的数据包trace以及PUT的二进制文件可以重建PUT的执行路径。平均而言，基于PT的方法比QEMU-AFL快4.3倍。</p>
<p>以前的硬件功能（如Intel Last Branch Record）也可以执行程序跟踪，但其输出存储在特殊寄存器中，而不是主内存中，这限制了跟踪大小。CGF与PT的结合也有尝试，比如kAFL、PTfuzz、Ptrix和Honggfuzz。然而，PT从未被用于DGF。</p>
<p>对于二进制代码级别的目标识别和标记问题，可以利用基于机器学习的方法或启发式二进制差分方法来自动识别易受攻击的代码。</p>
<h5 id="automatic-target-identification">Automatic target identification</h5>
<p>大多数已知的DGF都要求分析人员手动标记目标（如AFLGo、Hawkeye），这依赖对于目标站点的先验知识。</p>
<p>为了实现目标的自动识别，可以使用静态分析工具在PUT中找到潜在的危险区域。然而，这些工具通常特定于所使用的bug类型和编程语言。</p>
<p>另一个方向是利用compiler sanitizer passes，比如UBSan，来注释PUT中的潜在bug。</p>
<p>对于二进制代码，1DVUL通过基于Bindiff的二进制级比较，提取不同的函数及其不同的基本块，识别与补丁相关的目标分支。基于深度学习的方法在预测脆弱性和使用预测信息指导模糊化方面也是有效的。最后，攻击面识别组件也可用于自动识别DGF的易受攻击目标。</p>
<h5 id="differentiated-weight-metric">Differentiated weight metric</h5>
<p><img src="/png/2021-01-03-13-09-41.png"></p>
<p>在大多数最先进的DGF中，种子的优先级是基于等权度量的。以广泛应用的距离度量为例，通过种子与目标之间的距离来度量到达目标的能力。特别是距离由多条边表示，即基本块之间的过渡。然而，这样的测量忽略了一个事实，即不同的分支跳跃有不同的概率。</p>
<p>图1显示了一个控制流图片段，其中输入x是一个从0到9的整数。很容易知道从节点A跳到节点C的概率是0.1，从节点A跳到节点B的概率是0.9。如果据根据分支跳数计算距离，则A→C的距离比A→G短，这是因为A→C只有一个跳，而A→G有三个跳。但是如果考虑分支跳跃概率，则A→C的概率为0.1，而A→G的概率为0.9×0.7×0.5≈0.3，这比A→C更短。因此，在计算距离时考虑权重差异更为合理。其他种子优先级度量，如相似性和概率，应该遵循相同的原理。</p>
<p>一种可能的解决方案是考虑分支跳转概率。当基于概率评估目标的可达性时，每个种子基于该种子生成到达目标的输入的可能性，即将该种子的当前执行路径转换为穿过该目标的目标路径的概率来优先排序。由于执行路径可以看作是连续分支的马尔可夫链，因此可以通过收集路径中所有分支的概率来计算路径的概率。</p>
<p>基于统计模拟方法，可以通过统计计算分支概率来估计分支概率。平稳分布的密度形式上描述了DGF经过一定次数的迭代后执行某条路径的可能性。基于统计模拟方法方法需要两个条件：1）抽样应该是随机的；2）抽样规模应该很大。</p>
<p>模糊过程本质上满足了这些要求。由随机变异的测试用例驱动的执行路径可以看作是满足第一个需求的随机样本。模糊程序生成的测试用例的高吞吐量使得估计具有统计意义，满足第二个需求。因此，将模糊化作为一个抽样过程，可以以一种轻量级的方式统计估计分支跳跃概率。</p>
<p>这种基于概率的方法的一个可能缺点是潜在的运行时开销。统计跳跃计数和概率计算都引入了额外的计算。减少性能降低的一个简单方法是间隔采样。</p>
<p>另一个可能的解决方案是加速计算，这涉及到元数据的存储和访问方式。</p>
<p>传统上，基于图的数据存储在邻接表中。然而，由于基于概率的方法经常更新跳跃统计信息，并且可达性判断也需要快速的边缘跟踪，因此邻接表在访问数据时效率较低，不适合使用。另一种选择是邻接矩阵，它支持快速数据访问。然而，由于一个跳转通常有两个分支，矩阵将是巨大的，但数据分布相对稀疏，这大大增加了空间消耗。</p>
<p>因此，利用基于概率的方法的先决条件是设计一个平衡时间复杂性和空间复杂性的定制数据结构。</p>
<h5 id="global-optimum-deviation">Global Optimum Deviation</h5>
<p><img src="/png/2021-01-03-16-09-55.png"></p>
<p>当DGF测试中存在多个目标时，如何协调这些目标是另一个挑战。</p>
<p>一种策略是基于Dijkstras算法来寻找全局最短距离，AFLGo就是这样做的。然而，这样的全局最优可能会错过最接近某个目标的局部最优种子，从而导致偏差。</p>
<p>图2显示了一个控制流图片段，其中节点K和O是目标节点。这里测试了三个种子，路径分别为：A→B→D→G→K，A→C→E→I→M→N→O，A→C→E→H→L。论文作者基于B¨ohme et al.定义的距离公式计算了两个目标的三条路径中每个节点之间的harmonic distances，并在每个节点的侧面标记它们。</p>
<p>路径A→C→E→H→L的种子应该是三个之中距离最小的，但这是不合理的，因为路径A→B→D→G→K穿过目标节点K，路径A→C→E→I→M→N→O穿过目标节点O，但路径A→C→E→H→L没有到达任何目标。直觉上，路径A→C→E→H→L远离目标，不应优先考虑。因此，当存在多个目标时，寻找全局最短距离存在偏差，影响模糊化的方向性。</p>
<p>这种偏差背后的原因是基于距离的种子测量只关注最短路径。当有多条路径到达同一目标时，可能会忽略较长的路径，从而导致结果出现偏差。</p>
<p>图2中，如果考虑路径A→C→K和路径A→C→E→H→O，会发现d(ACK) &lt; d(ACEIMNO) &lt; d(ACEIMNL)。这是因为路径A→C→K和路径A→C→E→H→O分别是到目标K和O的最短路径。最短路径总是优先考虑的。为了避免在评估种子时产生偏差，应该考虑到所有可能到达目标的路径。</p>
<p>为了实现这一目标，Hawkeye使用了基于轻量级静态分析的相邻函数距离扩充，该分析基于生成的调用图考虑（立即）调用关系的模式。</p>
<p>多目标协调的另一种策略是目标分离。对于每个种子，仅选择所有目标之间的最小距离作为种子的距离，并基于该最小距离对种子进行优先级排序。这样可以避免局部最优偏差，但可能会减慢达到特定目标的速度。</p>
<h5 id="missing-indirect-calls">Missing Indirect Calls</h5>
<p>无论采用何种度量，DGF都依赖于控制流分析来确定种子的优先级。以基于距离的度量为例，通常基于控制流图和调用图来度量距离。</p>
<p>然而，由于LLVM的调用流和通过LLVM的间接调用图的构造是不完整的。在实际程序中，间接函数调用非常普遍。例如，在libpng中，44.11%的函数调用是间接函数调用。对于静态分析方法，不能直接从源代码或二进制指令中观察到间接函数调用站点，例如在C中作为参数传递函数指针或使用函数对象和指针。对于二进制代码，间接调用的目标地址取决于寄存器中的值，这些值也无法获得。</p>
<p>此外，为了构造一个过程间控制流图需要将基于LLVM的IR生成的每个函数的控制流图与整个程序的调用图结合起来。因此，基于调用图和控制流图的距离测量在没有间接调用的情况下是不准确的，影响了DGF到达目标的能力。</p>
<p>对于静态方法，解决这个问题的一个简单方法是对函数指针执行Andersen的points to analysis。但是，这种基于包含的上下文不敏感指针分析会导致间接调用具有许多传出边缘，可能会产生给定输入不可能的执行路径。</p>
<p>TOFU使用函数类型签名来近似每个间接调用站点的可调用集。但是，它不考虑类型转换，这可能会允许调用不同类型的函数，从而引入不精确性。</p>
<p>对于动态情况，ParmeSan在实际执行过程中识别间接调用的缺失边，并逐渐补全调用图。最后，在执行足够数量的模糊测试之后，图趋于完整。然而，这样的解决方案不可避免地增加了运行时开销，并且不能保证完整性。</p>
<h5 id="exploration-exploitation-coordination">Exploration-exploitation coordination</h5>
<p>DGF面临的最后一个挑战是如何协调勘探与开发之间的权衡。</p>
<p>一方面，多勘探可以为开发提供充分的信息，另一方面，勘探过度会占用大量资源，延缓开发。很难确定勘探阶段和开发阶段之间的界限。</p>
<p>AFLGo采用勘探阶段和开发阶段的固定分割。测试前，时间预算在测试配置中预先设置。这样的方案是初步的，因为分离点是经验性的和不灵活的。由于每个PUT具有不同的字符，因此这种固定拆分的适应性较差。一旦勘探阶段转入开发阶段，即使由于路径不足导致方向性能较差，也不会有回头路。</p>
<p><img src="/png/2021-01-03-16-40-06.png"></p>
<p>论文作者对libxml使用AFLGo进行了一个简单的实验。使用AFLGo的-z参数为勘探阶段设置不同的时间预算，并比较其性能。如图3所示，水平坐标表示测试的持续时间，垂直坐标表示所有生成的输入到目标代码区域的最小距离。实验持续24小时，AFLGo-1意味着1小时的探索加上23小时的开发，其余的依此类推。从结果可以看出，勘探阶段和开发阶段的分配会影响DGF的性能，而最佳性能（AFLGo-16）需要两个阶段都有足够的时间。然而，很难得到一个最佳的分配。</p>
<p>RDFuzz统计执行期间的分支级统计信息，以将代码区域分为高频区域和低频区域。根据频率和距离两个评价准则，将输入信号分为高、低距离和高、低频两类。低频输入有助于提高勘探所需的覆盖率；低距离输入有助于实现勘探所需的目标码区。最后，采用一个相互交织的测试时间表，交替进行勘探和开发。</p>
<p>解决这一难题的另一个可能方法是利用动态策略来协调勘探阶段和开发阶段的划分，该策略可以在勘探阶段和开发阶段之间自适应切换。</p>
<p>为了实现这一方案，论文作者建议将模糊阶段的分配转化为种子的分配，即将种子分为两组：覆盖种子用于探索和定向种子用于开发。每组种子的数目表示在相应阶段所消耗的能量。这两个阶段的协调是通过控制每组种子的数量来实现的。使用一个称为dp的变量来表示所有种子中定向种子的百分比，这也表示花费在开发阶段上的能量的百分比。在种子评价过程中，对覆盖种子进行标记，在每个模糊周期后，对有向种子进行标记，并通过dp进行调整。</p>
<p><img src="/png/2021-01-03-16-40-26.png"></p>
<p>使用算法2来说明这个设计。具有自适应分裂的DGF应该从探索阶段（dp=0）开始，该阶段侧重于发现新路径。然后，随着已知路径的增加，逐渐增加dp来调用开发阶段，在开发阶段，基于dp选择高值的有向种子并对其进行优先级排序以增强可达性。</p>
<p>当模糊测试程序在很长一段时间内找不到新的路径时，勘探阶段已经到了瓶颈，应该通过大幅度提高dp来迅速进入开发阶段。同样，也需要偶尔从开采阶段回到勘探阶段。例如，当模糊测试程序已经处于开采阶段，dp非常大（例如，dp&gt;0.9），但仍然无法在许多模糊循环中更接近目标，就应该大幅降低dp以返回勘探阶段。这是因为现有的定向种子性能较差，应该扩大路径覆盖范围以发现更多潜在的定向种子。</p>
<p>在该方案中，两个阶段可以共存，以获得最佳的性能和自适应性。值得注意的是，算法中的阈值是用来说明原理的。应该基于启发式算法产生合理的阈值。</p>
<h4 id="discussion">Discussion</h4>
<p>DGF技术中的研究热点。</p>
<h5 id="multi-targets-relationship-exploitation">Multi-targets Relationship Exploitation</h5>
<p>虽然大多数的有向模糊测试程序支持多目标，但只有少部分关注目标之间的关系。当存在多个目标时，可以通过目标之间的关系来优化DGF。如果它们是不相关的，可以给它们分配权重来区分重要性或概率。否则，可以提取隐藏关系并加以利用，以提高方向性。</p>
<p>UAFL在利用目标序列寻找UAF漏洞时，考虑了操作序列的顺序。这是因为，要触发这种行为复杂的漏洞，不仅需要覆盖单个边缘，还需要以特定顺序遍历一些长的边缘序列。这种方法可以扩展到检测语义错误，比如double-free和API误用。Berry使用所有路径的执行上下文（即到达目标序列中的节点所需的必要节点）增强目标序列。</p>
<p>在这里进一步提出以下关系。</p>
<ol type="1">
<li>执行空间关系。目标在执行树上的相对位置。假设有两个目标，可以考虑它们之间的关系，包括它们是否在同一个执行路径上，它们共享多少个执行路径，以及哪一个是另一个的前继节点还是后继节点。</li>
<li>状态空间关系。对于涉及程序状态的目标，可以考虑它们在状态空间中的位置。例如，两个目标是否共享相同的状态，以及两个状态是否可以在状态转换映射上相互转换。</li>
<li>交错关系。对于多线程程序，线程调度会影响不同线程中事件的执行顺序。在同一线程交织下可以达到的目标在交织空间中应该是一个密切的关系。</li>
</ol>
<p>基于上述讨论，建议在选择目标和确定目标优先级时考虑目标之间的关系。具有较高可达性的目标应该有更高的优先级。关系更密切的目标应该用更少的测试运行来覆盖。</p>
<h5 id="technology-integration">Technology Integration</h5>
<p><img src="/png/2021-01-03-17-05-33.png"></p>
<p>DGF依赖于随机变异来产生测试输入，所以它很难到达深层目标，并且在复杂路径上触发深层缺陷的效果较差。为了增强到达角落案例和片状缺陷的方向性，采用了各种程序分析技术，如静态分析、控制流分析、数据流分析、机器学习、语义分析和符号执行（统计数据如表4所示）。</p>
<p>在论文作者调查的工具中，75%的工具依赖于控制流分析来评估种子并确定对目标的可达性；46%的工具利用静态分析来自动识别目标，并从PUT中提取信息；32%的工具使用数据流分析（主要是污点分析）来识别目标之间的关系输入和关键程序变量，优化变异策略调度；11%使用机器学习预测易受攻击的代码，过滤掉无法到达的输入；18%采用语义分析自动识别易受攻击目标，学习输入字段语义优化变异；最后，18%集成符号（concolic）执行来解决复杂的路径约束。</p>
<h5 id="implementation-limitation">Implementation Limitation</h5>
<p><img src="/png/2021-01-03-17-14-22.png"></p>
<p>大约一半的工具是在AFL之上实现的。因此，性能在一定程度上受到AFL实现的限制。从两个方面来说明这种局限性。</p>
<p>第一个问题在于，AFL的边缘覆盖是基于基本块转换的，因此它只在基本块级敏感，不能在指令级区分路径差异。图5显示了两个相邻基本块之间的跳转示例。由于仅对路径敏感，因此无法区分地址0x400657处的跳转是采用（路径2）还是不采用（路径1），因为在控制流图中会有相同的边，即0x400657→0x400671。</p>
<p>另一个问题在于，AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器中收集这些插入数，以标识基本块转换（即控制流图中的边）。然后通过一个算法将插入数转换映射到64KB位图。由于不同的边可能有机会共享同一位置，因此该方案会导致路径冲突。</p>
<p>AFL的这两个局限性都会导致控制流图的不精确性，最终影响基于控制流图分析的种子优先级，无论是基于距离还是其他度量。</p>
<p>尽管这种限制可以通过构造更细粒度的控制流图或设计定制的哈希方案来缓解，但是，额外的工作不可避免地会增加运行时开销。</p>
<h5 id="efficiency-improvement">Efficiency Improvement</h5>
<p>为了实现模糊化的方向性，大多数研究人员使用额外的工具和数据分析。然而，这种额外的分析不可避免地会导致性能降低，对于给定的模糊时间预算，更高的效率意味着更多的模糊执行，=也就是更多的机会达到目标。因此，优化模糊化效率是提高方向性的另一个方向。</p>
<p>一种解决方案是将与执行无关的计算从运行时转移到编译时。例如，AFLGo通过解析PUT的调用图和过程内控制流图来度量每个基本块与目标站点之间的距离。由于解析图和计算距离都非常耗时，AFLGo在编译时将大部分程序分析转移到插桩阶段，以换取运行时的效率。</p>
<p>另一个优化是在实现级别。由于在分析过程中使用的大多数数据都是基于图的，因此如何存储和访问此类元数据对效率至关重要。可以设计一个优化的数据结构来存储这些数据，这样在基于图的拓扑结构进行搜索时就可以方便地频繁、快速地访问这些数据。例如，使用图数据库模型。</p>
<p>最后，可以利用并行计算来进一步提高效率。以前的工作已经成功地将并行性应用于CGF，但尚未应用于DGF。对于DGF，可以使用一个中心节点来维护一个种子队列，该队列保存DGF的所有种子并对其进行优先级排序。然后，将种子分发到计算节点上的并行模糊实例中，测试PUT并收集反馈信息。</p>
<h5 id="future-research-suggestions">Future research suggestions</h5>
<ul>
<li>在论文作者评估的工具中，只有SemFuzz支持内核代码测试。因此，在内核代码中引入DGF，并引导对关键站点（如syscalls和错误处理代码）的模糊化应该是一个有效的方向。</li>
<li>虽然DGF一直在尝试发现新的bug类型，比如UAF漏洞和内存泄漏漏洞，但许多常见的bug还没有被包括在内。因此，另一个研究方向是将DGF应用于特定的bug类型，如信息泄漏bug、并发bug、语义bug（TOCTTOU、double fetch）。</li>
<li>对于种子优先级度量，大多数工作都利用了基于距离和覆盖率（相似性）的方法，这有助于在不引入太多开销的情况下对种子进行量化评估。然而，较小的距离或较宽的覆盖范围并不一定意味着更接近目标，因为存在不同的权重原因和全局偏差原因。作者认为基于概率的度量应该更合理。</li>
<li>最后，分阶段模糊测试是一种可行的方法，可以进一步用于DGF。通过将到达目标的路径划分为连续的多个阶段，分阶段定向模糊算法可以在每个阶段到达子目标，逐步到达目标。此外，可以利用不同的模糊策略来满足不同阶段的需求。例如，TOFU对命令行标志使用语法模糊，对主要输入文件使用语义模糊。因此，分阶段模糊化可以降低模糊化各个阶段输入空间的维数，提高模糊化效率。</li>
</ul>
<h3 id="fuzzing-hack-art-and-science-cacm-2020">Fuzzing: Hack, Art, and Science (CACM 2020)</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/CACM20_Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>三种检测软件中安全漏洞的方法。</p>
<p>静态程序分析器：能够自动检查代码并标记错误的代码模式，它们可以标记出许多浅显的错误，但是工具也容易发出虚假的警报。</p>
<p>人工代码审计：包括发布之前的peer-reviewing和渗透测试，这个步骤可以检测很多问题，包括安全漏洞，设计缺陷和编码错误等超出了自动化工具的范围的问题。</p>
<p>然后就是模糊测试Fuzzing。</p>
<h4 id="blackbox-fuzzing-1">Blackbox Fuzzing</h4>
<p>Fuzzing最简单的形式是Blackbox random fuzzing，它随机地改变格式良好的应用程序输入，然后用这些修改后的输入测试应用程序。</p>
<p><img src="/png/2021-01-17-09-36-29.png"></p>
<p>程序采用格式良好的（第1行）作为输入。然后，它选择一个随机数的字节，这些字节将在该输入中被模糊化（第2行）。这个数字从1到输入长度除以1000不等。这个任意的1000值是可选的，但是它可以防止模糊化原始文件中的太多字节。</p>
<p>接下来，第4-8行循环重复选择输入中的一个随机位置（第5行）和一个新的随机字节（第6行），然后在该位置（第7行）写入该字节，直到所选的字节数被模糊化。</p>
<p>然后，程序用它执行被测试的应用程序（第9行），如果检测到错误，则报告错误（第10行）。</p>
<p>实际上，应用程序是在运行时检查工具的监视下运行的，如Purify、Valgrind、AppVerifier或AddressSanitizer，以增加发现非崩溃安全漏洞（如缓冲区溢出）的机会。</p>
<p>图2的程序可以重复执行，以生成任意多个新的模糊输入。尽管它很简单，但这种fuzzing策略已经可以有效地发现那些处理二进制格式输入的应用程序中的安全漏洞，特别是如果它们以前从未被fuzzing过。</p>
<p>实际上，对于JPEG图像格式，通常使用原始字节值来编码键输入属性，如图像大小、尺寸和输入文件数据指针；在其他格式良好的输入中fuzzing这些关键字节值（其位置因图像而异）可能会发现由于输入验证不完整而导致的缓冲区溢出错误。</p>
<p>在实践中，Blackbox random fuzzing的有效性关键取决于一组形式良好的种子输入来启动fuzz过程。事实上，格式良好的种子输入将在应用程序中更快地执行更多的代码，并且涵盖输入格式支持的各种选项和编码，以进行全面的fuzzing。</p>
<p>相反，没有格式良好的种子输入的fuzzing很可能会生成纯垃圾，被测试的应用程序将快速检测并丢弃这些垃圾。这就是为什么图2的程序将第2行中的常数1000定义为其模糊密度，如果种子输入中的每个字节都被模糊化，则生成的新输入将完全是乱码和随机的；但是如果平均每1000字节最多有一个字节被模糊化，模糊化只会给原始种子输入添加有限的噪声，并用此进行测试稍微损坏的新输入更有可能在被测应用程序的更多不同部分执行更多的错误处理代码，从而增加发现错误的机会。</p>
<h4 id="grammar-based-fuzzing">Grammar-Based Fuzzing</h4>
<p>Blackbox random fuzzing提供了一个Fuzzing的基准，但其有效性有限：产生新的有效的输入的几率非常小，尤其是对于那些接受结构化输入的程序，随机模糊输入可能会破坏关键结构 的属性，导致应用程序快速检测到错误然后丢弃，而并没有对太多的应用程序代码进行fuzzing。</p>
<p>Grammar-based fuzzing对于接受格式化输入的程序是非常有效的。分析人员提供指定的输入语法来指明被测试的应用程序的输入格式。通常，分析人员还会指定需要模糊哪些输入部分，以及怎么样模糊。然后根据这样的输入语法生成许多新的输入，每个都满足输入语法的约束。基于语法的模糊器有Peach，SPIKE和Sulley等。</p>
<p><img src="/png/2021-01-17-10-19-48.png"></p>
<p>图3显示了一个代码片段，展示了基于语法的模糊器（如SPIKE）生成新输入的过程，输入语法在这里直接表示为可以解释执行的代码。</p>
<p>代码中通过调用s_string按顺序指定那些固定的常量字符串，用s_blocksize_string获取clock变量的字符串长度作为之前Content-Length的参数，s_block_start表示开始定义block，继续使用s_string定义常量字符串，关键点在于使用s_string_variable生成随机化的数据来进行fuzz，后面s_string同理，最后使用s_block_end结束block的定义。</p>
<p>通过执行图3所示的代码，SPIKE可能会生成以下字符串序列。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/api/blog/</span> HTTP/1.2</span><br><span class="line"><span class="attribute">Content-Length:10&#123;body:XXX&#125;</span></span><br></pre></td></tr></table></figure>
<p>Grammar-based fuzzing的优势和优点。</p>
<ol type="1">
<li>可以通过分析人员的专业知识将fuzzing集中于那些可能永远不会被Blackbox random fuzzing覆盖到的代码区域。</li>
<li>可以将不可靠的输入作为Web页面，包括复杂的HTML文档和JavaScript代码，从而发现浏览器中的安全漏洞，以及那些复杂的代码编译器中的bug。</li>
<li>也适用于网络协议的fuzzing，如图3所示。</li>
</ol>
<p>Grammar-based fuzzing is also related to model-based testing. Given an abstract representation of a program—called a model—model-based testing consists in generating tests by analyzing the model in order to check the conformance of the program with respect to the model. Test generation algorithms used in model-based testing often try to generate a minimum number of tests covering, say, every state and transition of a finite-state machine model in order to generate test suites that are as small as possible. Similar algorithms can be used to cover all production rules of a grammar without exhaustively enumerating all possible combinations.</p>
<p>机器学习在Grammar-based fuzzing中的应用仍处于初步阶段，如何自动学习输入样本的语法是一个研究领域。例如，可以学习上下文无关的语法，使用自定义输入的示例概括步骤，或使用程序的动态污点分析以确定在测试中程序是如何处理其输入的。基于神经网络的统计机器学习技术可以也可以用来学习输入文法。</p>
<p>由于语法的编写过程是开放性的，并且可选择性如此之多，例如：如何fuzzing，何时停止，如何进一步编辑语法等实际问题。</p>
<h4 id="whitebox-fuzzing-1">Whitebox Fuzzing</h4>
<p>Blackbox Fuzzing的效果是非常有限的，Grammar-based fuzzing是劳动密集型的。而且什么时候可以认为已经发现了所有的漏洞？前两者是无法做到的。</p>
<p>whitebox fuzzing从一个格式良好的输入开始，对测试程序进行动态符号执行并收集符号执行过程中遇到的条件分支的输入约束。然后，将收集到的约束条件一一systematically否定，并使用约束条件求解器求解，该约束条件求解器的结果将用于生成进入程序不同的执行路径的新输入。</p>
<p>使用systematic搜索技术来重复此过程，该技术尝试遍历程序的所有（实际上是许多）可行的执行路径，同时使用运行时检查器检查许多运行时状态来判断是否触发了bug（如缓冲区溢出）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// x is an input</span></span><br><span class="line"> <span class="keyword">int</span> y = x + <span class="number">3</span>;</span><br><span class="line"> <span class="keyword">if</span> (y == <span class="number">13</span>) <span class="built_in">abort</span> (); <span class="comment">// error</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态符号执行具有初始具体值，变量x为0的程序输入，此时执行的为else的分支，并生成路径约束x + 3 ≠ 13。</p>
<p>否定此约束条件并用约束求解后求解器，求解器产生解决方案x = 10。新输入使程序遵循条件语句的then分支语句并找到错误。而这在blackbox random fuzzing只有1/2^32的几率命中（假设输入变量x的变量大小为32bit）。这直观地解释了为什么白盒模糊通常提供更高的代码覆盖率。</p>
<p>whitebox fuzzing可以生成比其他方法执行更多程序路径的输入，因为它更精确。而且whitebox fuzzing可以自动发现并测试出程序遇到的极端情况，例如由于无法正确分配内存或操作缓冲区而导致的安全漏洞。从理论上讲，whitebox fuzzing提供了完整的程序路径覆盖，也就是说达到了程序验证的效果（针对达到指定大小的任何输入）。</p>
<p>例如，简单程序foo有两个可行的执行路径，可以穷举和探索所有路径以证明该程序不包含任何缓冲区溢出。但是实际上，探索通常是不完整的，因为程序中的执行路径的数量是巨大的，而且符号执行，约束生成和约束求解可能由于复杂的程序语句（指针操作，浮点操作等）导致结果不精确，同时还有外部操作系统和库功能产生的大量约束，这些约束无法在限定的时间内完全解决。</p>
<p>由于这些限制，whitebox fuzzing的有效性仍然依赖于各种各样的合适的种子输入。</p>
<p>whitebox fuzzing最初是在SAGE中实现的，它扩展了dynamic test generation的工作范围，从单元测试到大型程序的安全性测试。被称为execution-generated tests或concolic testing。</p>
<p>SAGE执行x86级别动态符号执行，并实现几个至关重要的优化用于处理来自于数亿条机器指令的执行痕迹，以便对应那些包含数百万行代码的文件解析器，例如Microsoft Excel或PowerPoint。</p>
<p>当探索巨大状态空间的时候，SAGE也会使用基于代码覆盖率的启发式探索。</p>
<ul>
<li>对执行的每个测试都测量其指令覆盖率，对于发现更多新指令（新路径）的符号优先执行，以便探索更多未开发代码区域。</li>
<li>测试和符号执行可以在多个内核或机器上并行运行。whitebox fuzzing也可以从给定的种子输入开始，同时如果输入语法可用还可以使用Grammar-based fuzzing来生成种子输入。</li>
</ul>
<p>whitebox fuzzing已在许多其他工具中采用，包括开源工具KLEE，S2E，和Symbolic PathFinder。</p>
<h4 id="other-approaches">Other Approaches</h4>
<p>Portfolio approaches同时运行多种的fuzzer并收集它们的结果，因此结合了它们的互补优势。</p>
<h3 id="survey-of-directed-fuzzy-technology">Survey of Directed Fuzzy Technology</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/ICSESS19_Survey.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>主流fuzz工具。</p>
<p><img src="/png/2021-01-22-13-45-05.png"></p>
<h4 id="dse">DSE</h4>
<p>符号执行实际上是将可达性问题转化为约束求解问题。</p>
<h5 id="symbolic-execution-algorithm">Symbolic Execution Algorithm</h5>
<p>符号执行最初用于编译过程，程序分析等，主要思想是将符号变量作为输入去执行程序，在执行的过程中收集条件判断时通往不同路径的约束，最后使用约束求解获得到达对应路径的输入。</p>
<h6 id="静态符号执行">静态符号执行</h6>
<p>静态符号执行首先将输入变量符号化，然后通过静态分析将程序转换为中间语言，并且在运行中更改符号化变量来获取通往不同路径的约束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = raw_input();</span><br><span class="line">b = <span class="number">2</span> * a;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">10</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"win"</span> ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">"lose"</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，正常运行是用户输入值任何程序返回结果。在静态符号执行中，a首先被符号化，即a = x，而b = 2 * x。</p>
<p>可知当10 == 2 * x时，它进入win路径，否则进入lose路径。这两条路径合并的状态被称为执行树，10 == 2 * x和10 != 2 * x则是路径约束。</p>
<p>当符号执行结束，即程序正常或异常退出时。约束解算器将求解对应路径的约束，从而获得到达此路径所需的变量的值。</p>
<p>静态符号执行存在很多实际实施过程中的问题，例如：约束无法求解。</p>
<h6 id="动态符号执行">动态符号执行</h6>
<p>结合传统静态符号执行和实际执行的符号执行称为动态符号执行。</p>
<p>动态符号执行维持两种状态：一种是实际状态，另一种是符号状态。实际状态对应随机生成的变量的值，而符号状态则是符号化的变量。</p>
<p>动态符号执行首先根据实际状态运行，运行过程中收集符号化变量在当前分支路径上的约束并进行求解。然后，将约束条件求反就得到另一条分支路径的约束。重复该过程，直到探索完所有路径或达到设置的限制。</p>
<p>还是上面的代码，在一次动态符号执行中，假设随机生成的变量a = 7，实际执行时会进入lose路径。</p>
<p>此时通过不断的收集进入lose路径的约束求返获得进入win路径的约束，并使用约束求解器来验证。这样就避免了约束不能解决或找到的问题。</p>
<ol type="1">
<li>通过动态符号执行提取来自原始的复杂的控制流图CFG的行为信息。</li>
<li>然后向控制流模型添加约束以实现一个基于控制流的有限状态机控制参数，Finite State Machine control parameters (EPBFSM)。</li>
<li>最后，通过解决EPBFSM中的约束产生的新的模糊输入，这种方法不仅可以找到可能发现漏洞的路径，也可以识别可能发现漏洞的可控对象。</li>
</ol>
<h5 id="directed-symbolic-execution">Directed Symbolic Execution</h5>
<p>通常测试出来的大多数路径都不是可以直接到达目标的，所以要通过找到一条到达中间目标的路径来继续进行搜索。</p>
<p>补丁测试工具KATCH使用符号执行器KillE到达被patch的地方。</p>
<p>而KLEE使用符号执行的方法，通过大量的程序分析和约束求解系统地探索到达目标位置的路径的状态空间。</p>
<p>一旦识别到一条可以到达目标位置的路径，就可以对相应的路径约束求解从而生成测试用例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">55</span> <span class="comment">/* Read type and payload length first */</span></span><br><span class="line"><span class="number">56</span> hbtype = *p++;</span><br><span class="line"><span class="number">57</span> n2s(p, payload);</span><br><span class="line"><span class="number">58</span> pl = p;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="number">65</span> <span class="keyword">if</span> (hbtype == TLSl _HB_REQUEST) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="number">77</span> <span class="comment">/* Enter response type, length and copy payload */</span></span><br><span class="line"><span class="number">78</span> *bp++ = TLS <span class="number">1</span>_HB_RE SPONSE;</span><br><span class="line"><span class="number">79</span> s2n(payload, bp);</span><br><span class="line"><span class="number">80</span> <span class="built_in">memcpy</span>(bp,pl,payload);</span><br></pre></td></tr></table></figure>
<p>假设KATCH将上面代码的第80行设置为目标，并且找到一个到达65行可行路径A作为中间目标。</p>
<p>接下来，KATCH通过约束求解器将收集到的A的约束和hbtype == TLSl _HB_REQUEST的约束进行求解，就可以生成运行到80行的输入。</p>
<p>与GF不同，基于符号执行的whitebox fuzzing为实现定向模糊测试提供了简单的处理方法。大多数补丁测试工具都基于DSE。</p>
<p>但是，DSE为了有效性牺牲了效率，因为DSE需要很长时间来执行程序分析和约束求解。</p>
<p>在每次迭代中，DSE使用程序分析来确定那些为了靠近目标而需要否定的分支，根据这些路径构建相应的约束，并使用约束求解器来验证。</p>
<h3 id="a-review-of-machine-learning-applications-in-fuzzing">A Review of Machine Learning Applications in Fuzzing</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv19_Machine.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>论文讲述了ML在Fuzzing中的应用，主要关注三种类型的ML：有监督学习，无监督学习，强化学习。</p>
<p>有监督学习用于训练一个模型来识别给定数据点的标签，要求训练数据集的数据点都有显式标签。</p>
<p>无监督学习用于训练一个模型来发现数据点之间的模式或相似性，不要求数据点有显式标签。</p>
<p>强化学习是用来训练一个模型（代理）基于环境而行动，以取得最大化的预期利益。强化学习会对代理在环境中所做的操作或者结果进行对应的奖励，类似于监督学习，这些奖励为代理提供了一个最佳行动的指示。</p>
<p>一个典型的强化学习场景：Flappy bird游戏。</p>
<ul>
<li>机器有一个明确的小鸟角色——代理。</li>
<li>需要控制小鸟飞的更远——目标。</li>
<li>整个游戏过程中需要躲避各种水管——环境。</li>
<li>躲避水管的方法是让小鸟用力飞一下——行动。</li>
<li>飞的越远，就会获得越多的积分——奖励。</li>
</ul>
<p>这些ML都可以采用一种特殊的ML形式--深度学习。深度学习是指一种分层学习，可用于学习一组数据点的基本特征和结构。</p>
<h4 id="overview-of-fuzzing">OVERVIEW OF FUZZING</h4>
<p>现代模糊程序的三种主要类型：基于变异的fuzzer、基于生成的fuzzer和进化fuzzer。</p>
<p>基于变异的模糊程序盲目地变异提供的初始输入以提供给程序。一般来说，基于变异的模糊程序不知道预期的输入格式。Peach是一种模糊程序，可以执行基于变异和基于生成的fuzzing。</p>
<p>基于生成的模糊程序通过规范获取有关预期输入格式或协议的信息，根据这些规范生成输入。基于生成的fuzzer包括Peach和Sulley，Sulley是一个Python实现的fuzzing框架，可以为文件传输协议、网络协议和文件格式生成输入。</p>
<p>进化模糊程序是一种最新的模糊程序，它在变异的基础上，评估每一个输入的优先级，并使用适应度函数（通常是覆盖率）对输入进行排序，并选择排序最好的输入进行变异。进化模糊程序的例子包括honggfuzz、AFL和libFuzzer。</p>
<p><img src="/png/2021-01-24-10-39-35.png"></p>
<p>上图将一般的fuzzing过程分为几个阶段。</p>
<h5 id="pre-fuzzing-program-knowledge">Pre-Fuzzing: Program Knowledge</h5>
<p>在开始fuzzing之前，fuzzer需要程序知识，也就是如何对程序进行检测或观察？什么构成了一个有趣的程序状态？需要研究哪些输入接口？</p>
<p>基于变异的fuzzer通常需要以输入语料库或一组程序输入的形式提供额外的程序知识，以便有效地生成输入，这些程序输入往往是预期输入的示例。</p>
<p>基于生成的fuzzer以输入规范的形式吸收额外的程序知识，例如预期的文件格式或协议描述。基于生成的fuzzer通常比基于变异的模糊器有更好的代码覆盖率和更深入的程序状态探索。但是更难设置，因为它需要准确的程序输入规范，这通常比生成输入语料库耗费更多时间。而且基于生成的fuzzer仅探索这些规范指定的输入空间。</p>
<p>进化fuzzer和基于变异的fuzzer一样，通过输入语料库获取额外的程序知识。</p>
<p>通常，程序知识由使用者开发和提供。</p>
<h5 id="stage-1-generate-inputs">Stage 1: Generate Inputs</h5>
<p>在fuzzing的第一阶段，fuzzer使用程序知识生成输入，通过已指定的输入接口提供给程序，这个阶段的目标是生成那些可以触发或者说到达新的代码区域的输入。</p>
<p>并不是所有的新输入都会被使用，fuzzing的下一阶段将会选择这些生成输入。</p>
<p>基于变异的fuzzer通过处理先前的优先级高的输入来生成新的输入。在第一次迭代中，fuzzer处理初始输入语料库中提供的输入。之后，fuzzer会根据监视程序的信息评估输入性能，然后调整语料库。</p>
<p>基于生成的fuzzer通过根据输入规范来生成新的输入。对于一个给定的规范，只存在有限的与该规范对应的输入，也就是说输入搜索空间是有限的，所以基于生成的fuzzer可以探索整个输入搜索空间。</p>
<p>进化fuzzer和基于变异的fuzzer类似。要么变异一个输入，要么选择两个或多个输入进行交叉组合以产生新的输入，也可以使用其他随机化技术。进化fuzzer通过评估前一阶段的输入性能来选择输入进行随机化。</p>
<p>理论上，基于变异和进化的fuzzer可以产生无限的输入，无限的输入搜索空间使得很难估计有多少输入空间已经被探索过。</p>
<p>符号执行是一种静态分析技术，它可以帮助生成新的输入，从而增加fuzzer的覆盖范围。在实际中符号执行用于为基于变异和进化的fuzzer生成新的输入提供信息。这些新的输入可以添加到输入语料库中，或者以其他方式输入到程序中。</p>
<p>符号执行通过分析程序来找出程序中数据值的约束或限制，而无需真正执行。符号执行的工作原理是将输入数据抽象为一个符号值变元，然后遍历整个变元的符号值，当程序通过一个符号值进行分支判断时（例如if(x&lt;10)），符号执行引擎将生成两个符号程序状态，每个状态各包括一个不同分支的执行端满足的约束（branch-take状态将包含约束x&lt;10，而branch-not-take状态将包含约束x&gt;=10；除此之外，这两个符号状态将是相同的），并继续以符号执行的方式执行这两个状态。</p>
<p>符号状态包括表示达到该状态所需的一系列分支决策的约束，即路径。用户可以询问有关用于达到该状态的路径的问题。例如，到达这一点的x值是多少？为了回答这样的问题，将符号状态建模为一组约束，这些约束为每个输入变量编码路径上的有效值范围。然后，约束求解器求解这些约束，或者向输入变量返回有效的具体赋值，或者证明不存在此类赋值（即约束不可满足）[47]。这个赋值表示一个输入，它通过做出与原始路径中相同的分支决策，使程序达到所需的程序状态。</p>
<p>fuzzer可以使用符号执行来创建新的输入，通过请求解算器为新发现的符号状态提供解决方案来探索新的或有趣的路径。不幸的是，符号执行的计算成本很高，而且大量可能的程序路径使得以符号方式执行整个程序是不可行的程序。这个高成本意味着必须巧妙地使用符号执行；它通常用于寻找通过随机探索难以找到的路径。为了降低这一成本，模糊程序将符号执行与其标准输入生成技术配对[23]。符号执行引擎可以通过“跟随”一个感兴趣的输入来限制路径，例如，只允许新的符号状态在有限数量的分支中偏离输入。然而，计算成本和路径爆炸仍然是重要的障碍。大量的研究工作正试图解决这些符号执行的研究挑战[31，43，56]。[2]</p>
<p>不幸的是，fuzzer的覆盖率仍然很低，即使将其专用的输入生成技术与符号执行相结合。有效的输入生成仍然是一个研究挑战，新技术的其他巧妙应用可能有助于智能地生成输入，从而提高覆盖率。然而，即使这些输入生成技术创建的输入也比模糊程序有更多的计算时间来执行。在下一个阶段，输入被过滤到一个更小的集合中，然后输入到程序中。</p>
<h5 id="stage-2-select-inputs">Stage 2: Select Inputs</h5>
<p>在模糊化过程的第二阶段，模糊器选择并命令输入发送到程序。回想一下，fuzzer的目标是快速执行新的程序路径。然而，正如Böhme等人断言的那样，大多数输入都使用相同的少数程序路径[7，8]。为了解决这个问题，模糊程序必须有效地使用其输入语料库，并尽可能减少发现新程序路径所花费的计算量。</p>
<p>输入测试调度，或种子选择，可以帮助打击这种倾向的投入，探索有限的程序路径。输入测试调度对输入和输入顺序进行排序和选择，预测哪些新输入最有可能导致新的和不相交的有趣程序状态。对于漏洞评估，测试调度通常选择输入，以最大限度地增加发现的bug数量[63]。输入测试调度是有效探索大的或无限的输入搜索空间的关键，但是为特定的程序和模糊程序寻找合适的调度策略仍然是一个研究挑战。幸运的是，FuzzSim等工具可以使用流程中许多迭代的输入性能信息快速比较输入选择策略[63]。</p>
<p>如前所述，当模糊程序继续迭代过程时，基于变异和进化的模糊程序可能会收集许多非常大的输入。这会人为地减慢模糊过程。为了解决这个问题，模糊程序或者用户需要执行语料库最小化，减少输入的数量，或者输入最小化，减少每个输入的大小。例如，Ormandy在“Making Software Dumberer”[45]中引入的语料库蒸馏就是通过将一组输入减少到保持相同覆盖率的最小输入集来实现的。SEC Consult的fuzzer忽略了通过手动分析确定为不感兴趣的输入搜索空间的特定部分，以限制对每个输入执行的操作数[22]。</p>
<p>无论是智能地调度输入，减少活动输入的数量，还是保持输入较小，这些技术都试图减少模糊程序发现新的有趣程序状态所需的时间。然而，有效地利用模糊器有限的计算时间仍然是一个研究挑战。在下一个阶段中，模糊程序发送选定的输入，监视程序的结果操作，并确定感兴趣的程序状态。</p>
<h5 id="stage-3-monitor-program">Stage 3: Monitor Program</h5>
<p>在模糊化过程的第三阶段，模糊器将程序选择的输入反馈给程序，并监视程序以识别感兴趣的程序状态。“有趣的程序状态”表现出特定的程序行为-</p>
<p>在那种状态下。在大多数情况下，崩溃代表感兴趣的行为（即程序意外失败）。然而，通过程序插装可以观察到的任何行为都可以用来识别有趣的程序状态。例如，Valgrind可以检测（观察）内存损坏，即使损坏不会导致崩溃[60]。另一个例子是，Heelan使用模糊识别潜在的程序内存分配器[28]。对于脆弱性评估，有趣的行为是与可能的缺陷或脆弱性相关的可观察行为。</p>
<p>如前所述，fuzzer需要程序知识，了解如何对程序进行检测以及什么构成了一个有趣的程序状态。人类用户通常会提供这些信息，但是如何定义一个有趣的程序状态仍然是一个研究挑战。在脆弱性评估案例中，哪些可观察到的行为与识别缺陷或脆弱性最相关？</p>
<p>一旦fuzzer识别出一个有趣的程序状态，它就需要将该状态的描述返回给用户进行分析。fuzzer对程序状态的描述差别很大。例如，在崩溃时，一个fuzzer可能只提供导致崩溃的输入，而另一个fuzzer可能提供一个完整的内核转储，即在故障点捕获程序内存。在评估（下一阶段）之后，这些信息可能会指导进一步的模糊化迭代。</p>
<h5 id="stage-4-evaluate-inputs">Stage 4: Evaluate Inputs</h5>
<p>在模糊化过程的第四阶段，模糊器评估输入的执行情况。许多fuzzer使用代码覆盖率来衡量输入的效用：如果输入导致执行新的代码部分（通常是新的基本块），那么该输入的覆盖率就增加了，并得到了很高的评价。libFuzzer工具使用了一个类似的度量，即数据覆盖率，如果在代码中先前进行的比较中出现了新的数据值，那么它也会对输入进行很高的评价。一些fuzzer使用bug发现作为度量；导致崩溃的输入被高度评价。</p>
<p>进化模糊器需要反馈输入的性能如何[21]；也就是说，它们必须能够评估输入并对其进行排序。这些模糊器使用输入秩来生成新的输入，以及选择和发送输入。基于变异和基于生成的模糊器通常不需要输入性能反馈，但是相同的度量可以帮助评估模糊器的整体性能。</p>
<p>实际上，覆盖度量是启发式的，不能提供对输入性能的完整评估。因此，有效和可比较的指标仍然是一个研究挑战。</p>
<p>后模糊：有趣的程序状态。在模糊化过程之后，用户分析fuzzer输出的有趣的程序状态。这个过程通常是高度手工的，并且受益于软件工程相关领域的研究。对于每个输出状态，用户分析该状态以确定该状态中有趣行为的根本原因。通常，用户在程序执行相关输入时手动观察，并希望找出根本原因。然后用户决定根本原因是新的缺陷还是漏洞。</p>
<p>模糊程序通常输出大量有趣的程序状态。用户必须进行分类，以决定哪些有趣的程序状态值得进一步调查。不幸的是，输出程序状态通常具有相同的根本原因。更糟糕的是，具有相同根源的州可能会出现截然不同的情况。例如，内存损坏漏洞可能会导致程序的许多不同部分崩溃，内存映像差异很大，因为无法立即观察到该漏洞的影响。一些自动化工具试图消除fuzzer输出的重复数据[28]或根本原因，但这些工具往往不完善，分类和根本原因分析仍然是研究的挑战。</p>
<p>比较模糊词 不幸的是，尽管所有的研究都致力于使模糊程序更有效，更高效，但很难确定一个模糊程序是否比另一个“更好”。由于许多原因，很难测量模糊器的效用，从无法探索整个输入搜索空间，这会使性能度量产生偏差；到缺乏基本事实，这使得验证成为一个困难的手动过程；再到模糊过程中利用的随机性，这就需要进行统计测试。例如，在漏洞分析中，模糊程序通常是通过唯一漏洞的数量来判断的；然而，当一个新的模糊程序在一组现实世界的程序中发现新的漏洞时，这可能仅仅表明模糊程序的核心算法比其他算法更适合该组程序[49]。结果不一定能很好地推广。</p>
<p>为了帮助判断fuzzer效用，Klees最近提出了一个fuzzer比较框架[30]。Klees呼吁通过指定来控制比较：基线模糊器、目标程序的基准套件、性能指标、与基线相当的配置参数以及足够数量的统计测试试验[30]。具有已知缺陷的小数据集可以用这种方法来比较和验证模糊器。然而，不幸的是，这些比较在计算上是昂贵的，并且，如前所述，结果不一定是泛化的。实际上，在为这个框架开发出彻底的基准之前，用户将不得不依靠他们的直觉来指导关于哪个fuzzer将用于特定程序、如何配置或调整该fuzzer以及该fuzzer是否足够好的决策。有效的模糊比较仍然是一个重大的研究挑战。</p>
<h4 id="applications-of-machine-learning-to-fuzzing">APPLICATIONS OF MACHINE LEARNING TO FUZZING</h4>
<p>在这一节中，我们将探讨将机器学习（ML）应用于模糊化过程的研究。ML已被用于在模糊化过程中生成新的输入，并在较小程度上改进后模糊化。无监督学习在输入生成中得到了最成功的应用，例如AFL[34]等模糊工具将遗传算法（GAs）集成到输入生成过程中。最近也有监督学习和强化学习（RL）在输入生成中的应用[4，5，9，51]。此外，这三种类型的ML都已应用于符号执行[10、40、50、64]，主要是为了减少约束方程的求解时间。监督学习和非监督学习都已应用于后模糊过程，主要用于碰撞分类和根本原因分类[15，33，39]。有趣的是，我们知道在两个领域没有研究：输入最小化和语料库最小化。这些模糊化过程往往不是大的瓶颈，这可能是缺乏研究的原因。</p>
<p>我们首先讨论输入生成的ML研究。然后讨论了ML在后模糊任务中的应用。最后，我们通过讨论没有见过ML应用程序的模糊化任务来结束讨论。对于每一个领域，我们将展示每种类型的ML如何提供独特的改进方法以及应用每种类型的困难。</p>
<p>生成输入 ML在模糊化中最成功的应用发生在生成输入阶段。在本节中，我们将讨论如何将各种类型的ML应用于输入生成。我们将展示以GAs和deep learning（DL）形式出现的无监督学习在输入生成方面有许多成功的应用。我们还讨论了RL和监督学习在各种类型的输入生成中的应用，尽管这项研究倾向于更具探索性。</p>
<p>遗传算法。最常用的ML输入生成技术是GAs[17，18，21，34，37]。GAs是一种受生物进化启发的无监督ML，通常是进化模糊器的核心输入生成算法。当使用遗传算法时，有3个主要步骤：1）生成一个小的输入基总体，2）对输入执行转换，3）测量转换后的输入的性能。根据选定的指标，在最有效的输入上重复此过程。在模糊器的情况下，输入的基本总体由一组种子程序输入组成。遗传算法将变异这些种子输入来探索代码空间，目的是在代码中发现新的路径。由于这种在先前成功输入的基础上建立的能力，GAs已经成功地产生了输入。</p>
<p>如第2节所述和第2节所述，进化模糊器使用适应度函数对输入进行排序，以进行选择和变异。适应度函数的选择会对1）模糊器的性能，2）模糊器识别特定类型错误的能力，以及3）陷入局部极小值的趋势产生巨大影响。因此，在选择适应度函数时必须特别小心。</p>
<p>虽然传统的代码覆盖率是适应度函数最常用的度量，但也使用了更高级的启发式方法，如动态马尔可夫模型（DMM）启发式方法[55]。本文将程序控制图表示为马尔可夫过程，即控制图的每一条边都有转移概率的随机过程。DMM启发式使用马尔可夫模型和转移概率来创建适应度函数。与代码覆盖率不同，这种设置允许更精确地控制fuzzer，将其引导到代码中可能包含bug或缺陷的特定部分。</p>
<p>适应度函数的选择是模糊行为的一个重要决定因素，因此开发新的适应度函数来诱导期望的模糊行为可能是一个很有前途的研究领域。特别是，允许对模糊程序进行更细粒度控制的适应度函数对于特定的模糊化目标可能更为有利。此外，策略性地组合或在多个度量之间交替也可能有助于实现模糊化目标。</p>
<p>深度学习和神经网络。深度学习（DL）和神经网络（NNs）已被应用于输入生成，特别是改进基于生成和基于变异的模糊器。递归神经网络（RNN）[36]是应用于模糊化的最常用的DL方法。特别是，长-短期记忆（LSTM）[36]网络是RNN的一种变体，已被研究用于输入生成。</p>
<p>在一项研究中，Godefroid等人使用LSTMs为基于生成的fuzzers中的PDF文件创建输入语法[24]。LSTM在许多类型的序列生成任务中显示出了良好的前景[27]。然而，Godefroid等人发现模糊化和LSTM输入语法学习的目标经常相互冲突：LSTM倾向于产生格式良好的输入，而fuzzers的目标是产生探索新程序状态的范例输入。为了避免这一矛盾，采用了抽样策略来选取LSTM生成的输入，最终创建了一个在格式良好和格式错误的输入之间具有很强平衡性的输入语法。实验结果表明，使用ML生成输入语法是一种很有前途的提高代码覆盖率的技术。</p>
<p>在另一项研究中，Rajpal等人将DL整合到AFL中，通过选择要变异的输入字节来增加模糊覆盖率[5]。一个神经网络被用来生成一个热图，指出当任何特定字节发生变异时，增加代码覆盖率的预测可能性。比较了用于生成热图的四种不同的序列学习结构：1）标准LSTM，2）双向LSTM[36]，它向前和向后处理输入序列，3）Seq2Seq[14]，它将一个序列转换为另一个序列，以及4）Seq2Seq的一种变体，它使用注意机制来关注最重要的序列输入的重要部分[3]。虽然每个模型在某些情况下都增加了代码覆盖率，但总体而言，标准LSTM模型的性能略优于其他模型。实验上，在ELF、XML和PDF格式上，DL增强AFL优于标准AFL，而在PNG格式上，标准AFL优于DL增强AFL。</p>
<p>另一种生成输入的方法是对程序行为建模，使用模型选择最有希望的输入。NEUZZ方法使用浅层神经网络将程序的行为建模为平滑的连续函数[51]。训练神经网络，根据种子输入预测程序的分支行为。实验发现，训练过程中产生的梯度，特别是较大的梯度，有助于识别哪些输入字节控制分支行为。NEUZZ利用这些信息来指导fuzzer的突变，使它在一些程序上实验性地优于标准fuzzer，包括AFL和Angora。</p>
<p>Chen等人还通过</p>
<p>安哥拉起毛工具[12]。Angora使用离散函数表示从程序起点到特定分支约束的路径。然后在函数表示中的小离散区间上实现梯度下降，以找到满足约束的一组输入，并通过该特定分支移动程序。总的来说，这种方法证明了快速解决分支约束的能力，并且在某些程序上的实验性能优于AFL和符号执行。</p>
<p>Cheng等人[13]实现了一种使用DL生成输入的其他替代方法。这种方法使用RNN通过一个程序来预测新的路径。然后将这些路径输入到Seq2Seq模型中，该模型为执行预测路径的模糊器生成新的种子输入。初步研究表明，实验生成的语料库提高了PDF、PNG和TFF格式的fuzzer代码覆盖率。</p>
<p>DL和NN应用程序的输入生成显示出希望，但仍有障碍，更普遍的使用。首先，DL模型需要大量的训练计算时间，因此训练很可能无法实际地集成到模糊化过程中。另一种选择可能是为个别项目训练个别模型，但这也可能不切实际。其中许多研究试图缓解这些问题。例如，Rajpal等人通过在模糊化开始之前只在一小部分输入上训练神经网络来规避训练成本[5]。另一方面，She等人在整个模糊化过程中使用了简化形式的模型再训练，只使用最有用的数据点进行再训练[51]。这两种方法都减少了训练时间，但对模糊性能的总体影响尚不清楚。减少数据量的另一种方法是开发在程序之间传输先前训练过的模型的方法。这种方法可能会消除或减少模糊化以前未开发的程序所需的模型训练量，但这些方法如何影响性能尚不清楚。</p>
<p>DL应用程序实现模糊化的第二个障碍是跨文件格式的性能一致性。其中许多研究表明，对于某些文件格式（如PDF），DL与以前的基线相比，始终提高了模糊性能，而其他格式则无法与最先进的技术竞争。未来的研究对于理解DL和NNs对于特定文件格式的适用性可能是有益的。</p>
<p>强化学习。两组应用强化学习（RL）[29]，[2]进行输入生成。Becker等人使用SARSA算法[29]通过改变发送到主机的网络数据包来模糊IPv6协议[4]。SARSA算法考虑了agent的当前状态和行为来确定最优行为。Bottinger等人使用深度Q学习网络[42]学习描述PDF格式的基于生成的模糊器输入的语法[9]。深度Q学习网络使用深度神经网络将状态映射到动作。</p>
<p>这些研究为RL在输入生成中的应用提供了重要的启示。首先，他们表明程序表示对于训练一个成功的RL代理是至关重要的。Becker等人使用有限状态机来表示IPv6协议的行为，其中每个状态表示主机对特定数据包的当前响应，状态之间的转换表示数据包的可能突变。Bottinger等人还使用了一种有限状态机，即马尔可夫决策过程来表示问题。马尔可夫决策过程的特点是状态之间的随机转换。在这项研究中，状态表示模糊器的特定种子输入，而转换表示该状态下种子输入的概率重写规则。因此，Becker和Bottinger都演示了使用有限状态机作为问题表示来训练RL代理生成输入的实用性。</p>
<p>第二，他们提供了有效定义一个代理的奖励函数的见解，这通常是RL最具挑战性的方面。Becker等人根据以下标准创建了一个多部分奖励函数：从单个输入调用的程序函数的数量、是否存在错误以及来自程序的响应消息的潜在损坏或延迟[4]。错误的存在是向代理发出的最强信号，表明它已到达代码空间的一个有趣部分。即使在没有错误信号的情况下，程序响应也被用来指导代理。因此，奖励函数的每一部分在指导代理人方面都起着独特的作用，如果忽略这些标准，可能会导致代理人的效率降低。Bottinger等人试验了多种不同的奖励函数，一种使用代码覆盖率，另一种使用执行时间，第三种结合代码覆盖率和执行时间。在这两项研究中，奖励函数都会影响模糊者对输入空间的探索。例如，当Bottinger使用执行时间作为奖励时，代理学习导致程序快速终止的输入。Becker和Bottinger的工作都表明需要仔细定义奖励函数，考虑到软件程序类型、寻找的bug类型、可用的模糊度量以及最终的模糊目标。</p>
<p>标准模糊器还没有实现RL，应用程序仍然是理论上的。在这一领域，关键的第一步是更深入地理解奖励函数。具体地说，目前还不清楚奖励函数应该如何依赖于程序，或者是否存在普遍有效的奖励函数。例如，相同的奖励功能可以用于每个项目，还是每个独特的项目都需要一个独特的奖励功能？文件格式（如PDF和PNG）如何影响奖励函数的定义？</p>
<p>RL面临的另一个挑战是理解代理的可转移性。目前还不清楚是否有必要为每个独特的程序训练一个新的RL代理，这样做可能是不切实际的。因此，研究和创造可转让代理人可能是未来研究的必要步骤。</p>
<p>符号执行的机器学习。在这里，我们简要地讨论了目前正在探索的用于改进符号执行的不同ML技术。如第2节所讨论的，符号执行有助于为模糊程序生成有效的新输入，但计算成本和路径爆炸仍然是一大障碍。ML中的一些研究工作探索了改进约束求解的可行性，这可以支持fuzzer输入生成的符号执行。不幸的是，目前使用ML的努力无法与使用图算法的最新方法相匹敌[31]；它们仅仅是对可行性的探索。</p>
<p>有监督学习用于求解约束方程。在一项研究中，图形神经网络被用来识别表明约束方程是否有有效解的特征[10]。在另一项研究中，吴使用了逻辑回归和蒙特卡罗方法相结合的方法来确定初始值，从而提高了找到约束方程有效解的概率。蒙特卡罗方法用于确定初始有希望的值，而logistic回归则用于说明使用这些选择值的约束方程解的有效性。合并这些新的初始值会减少miniat解算器的运行时间[64]。在另一项研究中，LSTM（即DL）被训练用于求解约束方程[50]。虽然LSTMs无法击败最先进的约束求解器，但它们能够从未经训练的域中求解约束方程，这表明DL模型具有泛化能力。Shiqi等人开发的另一种方法使用NNs表示约束方程[52]。这些约束方程的解通过梯度下降被发现。总的来说，这些研究都提供了求解约束方程的独特方法。虽然不能和目前的技术水平竞争，但它们为使用监督学习来减少求解约束方程所需的计算时间提供了一个强有力的起点。</p>
<p>Mairy等人使用RL改进了局部邻域搜索方法[40]。局部邻域搜索方法通过求解约束方程的各个子集，并将这些子集组合起来形成最终解，从而迭代地找到约束方程的解。为了发现有用的子集，这些局部邻域搜索方法必须智能地探索可能的子集空间。引导RL代理选择更可能导致有效解决方案的子集，以减少找到此类解决方案所需的时间。</p>
<p>一项研究工作使用ML来减少解搜索空间的大小，而不是直接求解约束方程。Li等人将路径约束的典型集合重新表述为优化问题，并试图减少不可行路径的数量，即由于约束冲突而永远无法到达的路径[35]。他们使用ML技术RACOS[67]来解决优化问题，这是一种优化技术，可以很好地扩展到高维问题；然而，只分析了335行的非常小的程序。</p>
<p>使用ML来改进符号执行的初步探索显示了希望；然而，在这里应用ML的实际效用还有待观察。目前的研究通常局限于一些小问题，这些小问题无法与最先进的技术抗衡。此外，这项研究还没有应用到第2节中描述的模糊器和符号执行技术的结合。ML能否帮助改进这些组合技术是一个悬而未决的问题。</p>
<p>后模糊化：有趣的程序状态 如第2节所述，用户对fuzzer输出的有趣的程序状态进行分类，然后进行分析，通常是手动的。用户将程序状态分类为1）评估唯一性[46]，2）分析分类状态以确定可再现性和根本原因，以及3）模糊漏洞评估时，确定根本原因是否可利用。ML主要用于分类崩溃（分类）或分类错误（根本原因分析），尽管Yan等人使用了贝叶斯方法和！可利用工具，提高确定漏洞可利用性的可靠性[65]。</p>
<p>Dang等人使用聚集层次聚类（aggregative hierarchy clustering）将具有类似调用堆栈的崩溃进行分组，这是一种无监督学习技术，可以对具有类似特征的数据点进行聚类[15]。他们在调用堆栈上引入了自己的相似性度量，即位置相关模型，允许他们使用未标记的调用堆栈数据集进行训练。他们在微软的各种产品上测试了他们的模型，并且在很多情况下比以前的碰撞相似性识别方法表现得更好。</p>
<p>已经有几次尝试使用ML对软件中的bug进行分类。Harsh等人使用多种监督技术（包括决策树、支持向量机和朴素贝叶斯）对根本原因分类进行了实验[33]。然而，他们指出，由于缺乏标记数据，应用监督技术可能具有挑战性。为了解决缺少标记数据的问题，Harsh等人还尝试了无监督和半监督技术。不幸的是，这项研究的技术是有限的，因为bug的类别是非常广泛和系统特定的。</p>
<p>在另一项研究中，Long等人使用ML来确定根本原因，并生成修补程序来修复相关的bug[39]。他们的工具Prophet使用了一个参数化的对数线性概率模型，该模型能够识别决定一段代码必须如何修复的重要特征。这项工作的一个重要方面是Prophet模型的可解释性；模型参数可用于确定生成特定面片的各种特征的重要性。这种可解释性非常重要，因为它可以帮助用户理解生成特定修补程序的原因。</p>
<p>有监督的ML技术用于更频繁地识别软件领域之外的根本原因[53]。在一个例子中，决策树和支持向量机被用于工业生产系统的根本原因分析[16]。在另一个例子中，神经网络用于工业储罐系统内的故障定位[54]。支持向量机在加速电路板故障定位方面也显示出良好的前景[66]。虽然这些研究都没有直接应用到软件上，但是可以扩展研究以帮助软件领域的根本原因分析。</p>
<p>挑战。ML很少应用于后模糊任务，原因有二：1）ML结果和算法往往难以解释；2）适当的训练数据集比较稀疏。首先，大多数ML分类技术返回的是预测，而不是解释。这使得用户很难确定预测的标签是否正确以及为什么应用该标签。例如，在根本原因分析中，用户会发现很难理解根本原因应该在代码中显示在哪里，或者验证标签，或者纠正根本原因[33]。此外，ML算法往往建立不透明的规则，很难映射到领域知识。</p>
<p>第二，我们只有极少数可用的标记数据集，目前还不清楚什么是强大的、可概括的基准数据集。在为后模糊任务构建数据集时，有几个没有明确答案的问题必须解决，例如：</p>
<p>•应该包括哪些可能的错误？</p>
<p>•应表示哪些编程语言？•应如何为ML算法编码错误及其根本原因，特别是考虑到根本原因是细微差别的，并且可能因系统而异？</p>
<p>种子选择 在用ML进行种子选择方面的研究很少。</p>
<p>Wang等人进行了一项广泛的研究，使用NNs来选择更可能导致模糊代码中的漏洞的输入[62]。虽然这项研究显示了有希望的结果，但诸如训练模型到新项目的可转移性等挑战仍然存在。与输入生成一样，模型的可传递性仍然是ML应用于种子选择的潜在瓶颈。</p>
<p>先前的种子选择研究指出了未来ML研究的另一种可能性。种子选择必须在使用已知性能水平的当前输入与探索未知但可能更好性能的新输入之间取得平衡[63]。RL算法通常成功地应用于这类需要平衡新输入的探索和当前输入的利用的场景中。因此，RL算法可能非常适合于确定最优种子调度。未来的研究可能包括1）为最佳种子选择创建奖励函数，2）确定离线RL代理在程序之间的可转移性，以及3）在模糊过程中集成在线RL代理。</p>
<p>输入和语料库最小化 据我们所知，目前还没有任何关于输入最小化或语料库最小化的研究。首先，输入最小化和语料库最小化都不是一个很大的瓶颈。</p>
<p>最大的瓶颈存在于输入生成和后模糊化过程中，因此，大多数研究往往集中在这些领域。第二，最小化输入或总语料库大小并不自然地适合于ML技术。虽然输入生成和后模糊化（在较小程度上）通常可以表示为ML问题，但通常使用启发式方法成功地实现最小化</p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/fuzz/" rel="tag"><i class="fa fa-tag"></i> fuzz</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/2cb5ce06/" rel="next" title="IS-crypto-非对称加密-RSA的攻击方式">
                <i class="fa fa-chevron-left"></i> IS-crypto-非对称加密-RSA的攻击方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/ed03f22a/" rel="prev" title="CS-BASIC-compiler-principles-属性文法和语法制导翻译">
                CS-BASIC-compiler-principles-属性文法和语法制导翻译 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/apple-touch-icon.png" alt="w4rd3n">
            
              <p class="site-author-name" itemprop="name">w4rd3n</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">173</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/hitworld" title="GitHub &rarr; https://github.com/hitworld" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#surveyreview"><span class="nav-number">1.</span> <span class="nav-text">Survey/Review</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fuzzing-challenges-and-reflections"><span class="nav-number">1.1.</span> <span class="nav-text">Fuzzing: Challenges and Reflections</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#blackbox-fuzzing"><span class="nav-number">1.1.1.</span> <span class="nav-text">Blackbox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#greybox-fuzzing"><span class="nav-number">1.1.2.</span> <span class="nav-text">Greybox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#whitebox-fuzzing"><span class="nav-number">1.1.3.</span> <span class="nav-text">Whitebox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#other-fuzzing-tools"><span class="nav-number">1.1.4.</span> <span class="nav-text">Other fuzzing tools</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#challenges"><span class="nav-number">1.1.5.</span> <span class="nav-text">Challenges</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#automation"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">Automation</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems"><span class="nav-number">1.1.5.1.1.</span> <span class="nav-text">[C.1] More Software. How can we fuzz efficiently more types of software systems?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities"><span class="nav-number">1.1.5.1.2.</span> <span class="nav-text">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection"><span class="nav-number">1.1.5.1.3.</span> <span class="nav-text">[C.3] More Difficult Bugs. How can we find “deep bugs” for which efficient oracles exist, but which nevertheless evade detection?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns"><span class="nav-number">1.1.5.1.4.</span> <span class="nav-text">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#the-human-component"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">The Human Component</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor"><span class="nav-number">1.1.5.2.1.</span> <span class="nav-text">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools"><span class="nav-number">1.1.5.2.2.</span> <span class="nav-text">[C.6] Usability. How can we improve the usability of fuzzing tools?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fuzzing-theory"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">Fuzzing Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful"><span class="nav-number">1.1.5.3.1.</span> <span class="nav-text">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing"><span class="nav-number">1.1.5.3.2.</span> <span class="nav-text">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#evaluation-and-benchmarks"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">Evaluation and Benchmarks</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing"><span class="nav-number">1.2.</span> <span class="nav-text">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#introduction"><span class="nav-number">1.2.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#background"><span class="nav-number">1.2.2.</span> <span class="nav-text">Background</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#terminology"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Terminology</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#coverage-guide-greybox-fuzzing"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">Coverage-guide Greybox Fuzzing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#directed-greybox-fuzzing"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">Directed Greybox Fuzzing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#difference-between-cgf-and-dgf"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">Difference between CGF and DGF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#application-of-dgf"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">Application of DGF</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#assessment-of-the-state-of-the-art-works"><span class="nav-number">1.2.3.</span> <span class="nav-text">Assessment of the-state-of-the-art Works</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#directed-type"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Directed Type</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#input-optimization"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">Input Optimization</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#seed-prioritization"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">Seed Prioritization</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#distance"><span class="nav-number">1.2.3.3.1.</span> <span class="nav-text">Distance</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#similarity-coverage"><span class="nav-number">1.2.3.3.2.</span> <span class="nav-text">Similarity &amp; Coverage</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#probability"><span class="nav-number">1.2.3.3.3.</span> <span class="nav-text">Probability</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#power-assignment"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">Power Assignment</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mutator-scheduling"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">Mutator Scheduling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#data-flow-analysis"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">Data-flow Analysis</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#challenges-and-solutions"><span class="nav-number">1.2.4.</span> <span class="nav-text">Challenges and Solutions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#binary-code-support"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">Binary Code Support</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#automatic-target-identification"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">Automatic target identification</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#differentiated-weight-metric"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">Differentiated weight metric</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#global-optimum-deviation"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">Global Optimum Deviation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#missing-indirect-calls"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">Missing Indirect Calls</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exploration-exploitation-coordination"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">Exploration-exploitation coordination</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#discussion"><span class="nav-number">1.2.5.</span> <span class="nav-text">Discussion</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#multi-targets-relationship-exploitation"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">Multi-targets Relationship Exploitation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#technology-integration"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">Technology Integration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#implementation-limitation"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">Implementation Limitation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#efficiency-improvement"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">Efficiency Improvement</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#future-research-suggestions"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">Future research suggestions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fuzzing-hack-art-and-science-cacm-2020"><span class="nav-number">1.3.</span> <span class="nav-text">Fuzzing: Hack, Art, and Science (CACM 2020)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#blackbox-fuzzing-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">Blackbox Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#grammar-based-fuzzing"><span class="nav-number">1.3.2.</span> <span class="nav-text">Grammar-Based Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#whitebox-fuzzing-1"><span class="nav-number">1.3.3.</span> <span class="nav-text">Whitebox Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#other-approaches"><span class="nav-number">1.3.4.</span> <span class="nav-text">Other Approaches</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#survey-of-directed-fuzzy-technology"><span class="nav-number">1.4.</span> <span class="nav-text">Survey of Directed Fuzzy Technology</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dse"><span class="nav-number">1.4.1.</span> <span class="nav-text">DSE</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#symbolic-execution-algorithm"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Symbolic Execution Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#静态符号执行"><span class="nav-number">1.4.1.1.1.</span> <span class="nav-text">静态符号执行</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#动态符号执行"><span class="nav-number">1.4.1.1.2.</span> <span class="nav-text">动态符号执行</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#directed-symbolic-execution"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">Directed Symbolic Execution</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-review-of-machine-learning-applications-in-fuzzing"><span class="nav-number">1.5.</span> <span class="nav-text">A Review of Machine Learning Applications in Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#overview-of-fuzzing"><span class="nav-number">1.5.1.</span> <span class="nav-text">OVERVIEW OF FUZZING</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#pre-fuzzing-program-knowledge"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">Pre-Fuzzing: Program Knowledge</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stage-1-generate-inputs"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">Stage 1: Generate Inputs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stage-2-select-inputs"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">Stage 2: Select Inputs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stage-3-monitor-program"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">Stage 3: Monitor Program</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stage-4-evaluate-inputs"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">Stage 4: Evaluate Inputs</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#applications-of-machine-learning-to-fuzzing"><span class="nav-number">1.5.2.</span> <span class="nav-text">APPLICATIONS OF MACHINE LEARNING TO FUZZING</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-gg-circle"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">w4rd3n</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">856k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">12:59</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz",
                'X-LC-Key': "UvlYMzpJKw0Jrw61V5BA5ifU",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  
  

  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>;
  <script>
  //$("body").backstretch("/images/background.jpg");
  </script>
  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
