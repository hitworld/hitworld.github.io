<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.5.0">


  <link rel="mask-icon" href="/images/safari_pinned_tab.svg?v=6.5.0" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml">







<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Fuzzing: Challenges and Reflections 在线pdf. Blackbox fuzzing Blackbox fuzzing不需要任何关于程序的先验知识，主要有两种的测试用例的生成方式：突变和生成。 前者通过初始语料库(seed inputs)开始变异，通过对随机位置的随机突变来生成新的测试用例。后者则通过提供的输入格式来生成新的测试用例。 Blackbox">
<meta name="keywords" content="fuzz">
<meta property="og:type" content="article">
<meta property="og:title" content="IS-pwn-fuzz-theory-present-situation">
<meta property="og:url" content="https://hitworld.github.io/posts/640b061/index.html">
<meta property="og:site_name" content="w4rd3n的笔记">
<meta property="og:description" content="Fuzzing: Challenges and Reflections 在线pdf. Blackbox fuzzing Blackbox fuzzing不需要任何关于程序的先验知识，主要有两种的测试用例的生成方式：突变和生成。 前者通过初始语料库(seed inputs)开始变异，通过对随机位置的随机突变来生成新的测试用例。后者则通过提供的输入格式来生成新的测试用例。 Blackbox">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-22-46-04.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-13-09-41.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-09-55.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-40-26.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-17-14-22.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-17-09-36-29.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-17-10-19-48.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-22-13-45-05.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-24-10-39-35.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-21-17-00-18.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-20-39-01.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-20-40-35.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-21-17-04.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-21-17-18.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-21-19-03.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-26-20-55-03.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-03-03-18-07-52.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-03-03-18-30-10.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-03-03-21-47-15.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-03-03-22-21-41.png">
<meta property="og:updated_time" content="2021-07-03T05:40:30.565Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IS-pwn-fuzz-theory-present-situation">
<meta name="twitter:description" content="Fuzzing: Challenges and Reflections 在线pdf. Blackbox fuzzing Blackbox fuzzing不需要任何关于程序的先验知识，主要有两种的测试用例的生成方式：突变和生成。 前者通过初始语料库(seed inputs)开始变异，通过对随机位置的随机突变来生成新的测试用例。后者则通过提供的输入格式来生成新的测试用例。 Blackbox">
<meta name="twitter:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">






  <link rel="canonical" href="https://hitworld.github.io/posts/640b061/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>IS-pwn-fuzz-theory-present-situation | w4rd3n的笔记</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">w4rd3n的笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">混吃等死</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>友链</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hitworld.github.io/posts/640b061/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="w4rd3n">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/apple-touch-icon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="w4rd3n的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">IS-pwn-fuzz-theory-present-situation
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-01-01 23:41:38" itemprop="dateCreated datePublished" datetime="2021-01-01T23:41:38+08:00">2021-01-01</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/" itemprop="url" rel="index"><span itemprop="name">IS</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/posts/640b061/" class="leancloud_visitors" data-flag-title="IS-pwn-fuzz-theory-present-situation">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度：</span>
               
                 <span class="leancloud-visitors-count"></span>
                 <span>℃</span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">61k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">56 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="fuzzing-challenges-and-reflections">Fuzzing: Challenges and Reflections</h2>
<p><a href="https://www.comp.nus.edu.sg/~abhik/pdf/IEEE-SW-Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<h3 id="blackbox-fuzzing">Blackbox fuzzing</h3>
<p>Blackbox fuzzing不需要任何关于程序的先验知识，主要有两种的测试用例的生成方式：突变和生成。</p>
<p>前者通过初始语料库(seed inputs)开始变异，通过对随机位置的随机突变来生成新的测试用例。后者则通过提供的输入格式来生成新的测试用例。</p>
<p>Blackbox fuzzing工具：Peach(http://community.peachfuzzer.com)。</p>
<h3 id="greybox-fuzzing">Greybox fuzzing</h3>
<p>Greybox fuzzing通过在编译时对一些位置（例如代码块交界处）进行插桩来获取运行时状态从而引导fuzzing的进行。</p>
<p>通常一些初始语料库会被提供，并被用于突变产生新的输入，那些增加了代码覆盖率的输入（优质的输入）将被加入语料库，随着覆盖率反馈fuzzer的运行，输入会逐渐深入程序的深处。还可以通过Sanitizers注入断言到程序中来判断漏洞的种类。</p>
<p>Greybox fuzzing工具：AFL(https://lcamtuf.coredump.cx/afl/)，LibFuzzer(https://llvm.org/docs/LibFuzzer.html)，Honggfuzz(https://github.com/google/honggfuzz)。</p>
<h3 id="whitebox-fuzzing">Whitebox fuzzing</h3>
<p>基于符号执行的Whitebox fuzzing使用程序分析和约束求解器Satisfiability Modulo Theory(SMT)来系统地枚举感兴趣的程序路径。</p>
<p>Whitebox fuzzing对于给定的种子输入s，计算并改变路径条件而不是改变程序输入，然后将改变后的路径条件发送到约束解算器来产生新的输入。因为Whitebox fuzzing会跟踪到目前为止获取的所有输入的路径状况，所以始终能够生成一个经过新路径的输入。</p>
<p>Whitebox fuzzing工具：KLEE(https://klee.github.io/)，SAGE。</p>
<h3 id="other-fuzzing-tools">Other fuzzing tools</h3>
<p>DeepState(https://github.com/trailofbits/deepstate)：一个单元测试框架。</p>
<p>The Mayhem system. --- Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, David Brumley. 2012. Unleashing Mayhem on Binary Code. IEEE Symposium on Security and Privacy (S&amp;P’12).</p>
<h3 id="challenges">Challenges</h3>
<h4 id="automation">Automation</h4>
<h5 id="c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems">[C.1] More Software. How can we fuzz efficiently more types of software systems?</h5>
<ul>
<li>对于文件解析器和面对对象程序来说，需要的是高度结构化的输入，应该如何生成测试用例？</li>
<li>网络应用程序，机器学习系统，多语言构建的软件和GUI软件的fuzz方式应该是怎么样的？</li>
<li>对于那些有状态的软件，它们对于相同的输入会产生不同的输出，应该如何进行fuzz？</li>
<li>给定一个程序，它的输入域是由语法/协议定义的，那么符号执行工具如何对这种结构化的输入域制定约束?</li>
</ul>
<h5 id="c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</h5>
<p>现在已经可以利用Sanitizers类型软件检测复杂的漏洞类型，侧信道漏洞发现已经成为热门。</p>
<h5 id="c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection">[C.3] More Difficult Bugs. How can we find "deep bugs" for which efficient oracles exist, but which nevertheless evade detection?</h5>
<p>结构感知，基于语法的fuzzing，静态分析和符号执行与Greybox fuzzing的结合都是很有前途的方向，针对软件补丁的测试技术对于发现软件补丁引入的错误是很有效的。</p>
<h5 id="c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</h5>
<p>需要实证研究来了解源代码中安全漏洞的性质和分布。</p>
<h4 id="the-human-component">The Human Component</h4>
<h5 id="c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</h5>
<p>Ned Williamson给出了下面这种方法。</p>
<ol type="1">
<li>首先审核代码，以识别可能存在安全漏洞的代码区域。</li>
<li>为设备准备fuzzing，运行fuzzing一段时间，并确定fuzzing过程的遇到的障碍和问题。</li>
<li>手动修补遇到的障碍和问题。</li>
<li>如果fuzzer花费很多时间来测试代码中不重要的部分，对fuzzer进行调整。</li>
<li>一旦发现了一个潜在的漏洞，就要回溯并之前修补的部分，并相应地调整输入再次触发漏洞。</li>
</ol>
<h5 id="c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools">[C.6] Usability. How can we improve the usability of fuzzing tools?</h5>
<p>如何提高模糊工具的可用性？也就是说如何让一个技术人员快速掌握并使用。</p>
<h4 id="fuzzing-theory">Fuzzing Theory</h4>
<h5 id="c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</h5>
<p>除了白盒模糊测试，灰盒模糊测试和黑盒模糊测试都不能保证没有未发现的漏洞。白盒模糊测试受限于时间和可扩展性也无法完全保证，而灰盒模糊测试存在适应性偏差，黑盒模糊测试也存在剩余风险。</p>
<h5 id="c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</h5>
<p>给定程序和时间预算，什么是能在时间预算内找到最多漏洞的模糊技术或技术组合程序的大小和复杂性如何影响可扩展性和性能？计算资源对程序效率的影响程度？</p>
<h4 id="evaluation-and-benchmarks">Evaluation and Benchmarks</h4>
<p>[C.9] How can we evaluate specialized fuzzers?</p>
<p>[C.10] How can we prevent overfitting to a specific benchmark?</p>
<p>[C.11] Are synthetic bugs representative?</p>
<p>[C.12] Are real bugs, which have previously been discovered with other fuzzers, representative?</p>
<p>[C.13] Is coverage a good measure of fuzzer effectiveness?</p>
<p>[C.14] What is a fair choice of time budget?</p>
<p>[C.15] How do we evaluate techniques instead of implementations?</p>
<h2 id="sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv20_SoK.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>大多数greybox fuzzing工具是由代码覆盖率引导的(CGF，覆盖率导向greybox fuzzing)，但其实大部分代码区域是不存在bug的，与基于代码覆盖率的greybox fuzzing不同，定向greybox fuzzing(DGF)将其大部分时间预算花在到达特定的目标区域上，例如，容易出bug的区域。因此，定向灰盒模糊测试特别适用于补丁测试、1 day bug复现以及与其他工具集成等场景。</p>
<h3 id="introduction">Introduction</h3>
<p>传统的定向fuzzing是基于符号执行的，但是符号执行面对大型应用程序时存在复杂的约束求解和路径爆炸等问题。而DGF在测试程序(PUT)中指定一组目标区域，并利用编译时插桩获取运行时信息来计算输入种子和目标之间的距离，通过给更接近目标的种子更多的变异机会来将fuzzer导向目标区域。</p>
<p>DGF将目标区域的可达性问题转化为一个优化问题，以最小化生成的输入种子到目标区域的距离为标准来进行语料库的筛选。</p>
<p>DGF并未止步于依赖于手动标记的目标区域和基于距离的度量来确定输入种子优先级的主要模式。为了在不同的场景下提高软件测试，已经实现了大量的变体。</p>
<h3 id="background">Background</h3>
<h4 id="terminology">Terminology</h4>
<p>该文献中使用的术语及其解释。</p>
<ul>
<li>Fuzzing. In this paper, fuzzing refers to traditional blackbox fuzzing and greybox fuzzing. We exclude whitebox fuzzing as it depends on constraint solving of symbolic execution to generate inputs, which is quite different from evolutionary fuzzers based on mutation.</li>
<li>Testcase. A testcase is an input to the PUT, which is generated by randomly mutating a seed.</li>
<li>Seed. A seed is a testcase that is favored (trigger a new path or close to the target) and retained for the mutation to generate new testcases in the next fuzzing iteration.</li>
<li>Seed prioritization. Seed prioritization means to evaluate and sort the seeds according to its performance. Prioritized seeds would be given more fuzzing chances.</li>
<li>Power schedule Power schedule means to determine the number of fuzzing tests to be applied on a seed (i.e., energy).</li>
<li>Fuzzing cycle All seeds in the seed queue have been fuzzed at least once.</li>
</ul>
<h4 id="coverage-guide-greybox-fuzzing">Coverage-guide Greybox Fuzzing</h4>
<p>以ALF为例来介绍典型的CGF技术。</p>
<p>AFL使用上下文不敏感的边覆盖（基本块间跳转）替代一般的基本块覆盖（基本块执行）。AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器收集这些随机数获知跳转信息，统计边覆盖。边覆盖比基本块覆盖更精细和敏感，因为它考虑了基本块之间的过渡。边覆盖也比路径覆盖更具可扩展性，因为它避免了路径爆炸。</p>
<p>AFL偏爱触发新路径的输入种子，通过一个位图来记录每个种子的优先级，对于优先级高的种子，AFL会给予更多的变异机会，也就是后面说的能量。</p>
<p>AFL有两类变异策略：确定性策略和非确定性策略。</p>
<p>首先是确定性策略，利用基于位翻转、算术、令牌、字典和特殊值的变异器依次变异不同粒度的种子。然后是非确定性策略，包括havoc阶段和拼接阶段。在havoc阶段，AFL通过从确定性策略中随机选择一系列变异算子对种子进行变异，并将其应用于种子文件中的随机位置。再然后，AFL从种子队列中随机选择另一个种子，并将其与当前种子重新组合以生成新的种子。最后，对新种子重新实施破坏策略。</p>
<p>在确定性阶段，各种变异策略依次进行，而在非确定性阶段，AFL可以通过种子获得的能量来决定每个种子的变异次数。</p>
<p>能量是根据每个种子的性能得分来分配的，而性能得分基于覆盖率（优先考虑覆盖更多路径的输入）、执行情况时间（对执行速度更快的输入进行优先级排序）和发现时间（对稍后发现的输入进行优先级排序）计算出来的。</p>
<h4 id="directed-greybox-fuzzing">Directed Greybox Fuzzing</h4>
<p><img src="/png/2021-01-02-21-17-13.png"></p>
<p>以ALFGo为例来说明DGF的工作原理。</p>
<p>AFLGo遵循CGF的一般原理和体系结构。不同的是，除了获取执行路径和边缘覆盖信息外，AFLGo还计算输入与目标区域之间的距离。该距离基于输入种子的覆盖基本块到目标基本块的平均值来计算，其中权值由程序的调用图和控制流图中的边数来确定。</p>
<p>B¨ohme等人将灰盒模糊化过程视为一个马尔可夫链，所以可以使用功率调度进行有效的引导。利用模拟退火策略，逐渐将更多的能量分配给距离目标较近的种子，从而将可达性问题转化为优化问题，以最小化生成的种子到目标区域的距离为目的。</p>
<p>AFLGo将整个DGF分为两个阶段，探索阶段和开发阶段。探索阶段的目的是尽可能多地揭示路径，像许多覆盖率导向模糊程序一样，这个阶段的DGF偏爱触发新路径并对其进行优先级排序的种子，因为新的路径增加了通向目标的可能性。开发阶段的目的是最小化生成的种子到目标的距离。在这一阶段，B¨ohme等人对更接近目标的种子进行优先排序，并为它们分配更多的能量。</p>
<p>勘探开发的权衡在于如何协调这两个阶段。B¨ohme等人使用固定的勘探和开发阶段划分。例如，对于24小时测试，AFLGo使用20小时进行勘探，然后使用4小时进行开发。</p>
<h4 id="difference-between-cgf-and-dgf">Difference between CGF and DGF</h4>
<ol type="1">
<li>种子优先级。CGF的目标是最大化路径覆盖，所以会偏爱触发新路径的种子。而DGF的目标是到达代码中的特定位置，所以它偏爱更接近目标的种子。</li>
<li>探索目标。CGF以一种无方向的方式扩展代码覆盖范围，在不包含bug的代码区域浪费能量。DGF则预先对一组目标区域进行人工或自动标记，以指导整个模糊测试过程，目标的选择会影响DGF的性能。</li>
<li>勘探开发。对于基于覆盖率的灰盒模糊测试，整个过程本质上是一个探索-开发问题的折衷，其中探索意味着尝试尽可能多的种子，而开发意味着尽可能多地变异某个种子。对于DGF来说，勘探开发问题在于勘探阶段与开发阶段的协调。在探索阶段，DGF试图发现尽可能多的种子，并从中获取更多的新路径，以增加到达目标的可能性。同时，开发阶段给了一些种子更多的变异机会，这些种子更有可能产生到达目标的输入。</li>
</ol>
<h4 id="application-of-dgf">Application of DGF</h4>
<ul>
<li>补丁测试。DGF可以用来测试patch是否完整和兼容，patch在以下情况下是不完整的：错误由多个输入触发；patch引入新的bug。因此针对patch的DGF有更高的发现bug的机会。</li>
<li>bug复现。DGF可以用于复现没有crash输入的已知bug。例如，某些应用程序（如视频播放器）不允许发送输入文件，内部开发团队可以使用DGF通过stack trace中的方法调用和一些环境参数来再现crash。在给定错误报告信息的情况下，DGF也可以生成已披露漏洞的PoC。</li>
<li>DGF可以配合分析人员的知识或辅助技术来促进fuzz的效果，例如帮助DGF识别关键的系统调用或重要的程序区域（例如，内存分配函数malloc、字符串操作函数strcpy），基于以前的经验来引导fuzzer到容易出错的部分。如符号执行和污点分析之类的辅助技术可以用来解决测试中的障碍，而静态分析和基于机器学习的检测方法的可以寻找潜在易受攻击目标。</li>
<li>特定类型bug检测。DGF可以应用于基于定制指标的特定bug检测。例如，在内存使用状况的指导下查找内存泄漏bug，在typestate violation（应该是指违反了特定的使用范例，例如free后并未清除指针）的指导下查找UAF漏洞。</li>
</ul>
<h3 id="assessment-of-the-state-of-the-art-works">Assessment of the-state-of-the-art Works</h3>
<p><img src="/png/2021-01-02-22-46-04.png"></p>
<p>该论文主要研究DGF（表1中记为G），不过在某些工作中采用了符号执行来增强有向性，形成了有向混合模糊测试（表1中记为H）。</p>
<h4 id="directed-type">Directed Type</h4>
<p>对于定向目标的类型，DGF最初通过在PUT中手动标记的目标区域来进行定向，如AFLGo和Hawkeye。</p>
<p>目标区域之间的关系对于bug的触发也是有影响的，为了触发UAF漏洞，必须按特定顺序执行一系列操作：分配内存、使用内存和释放内存。所以UAFuzz和UAFL利用目标区域序列而不是目标区域来发现UAF漏洞。LOLLY还使用目标语句序列来引导DGF触发由多个语句的顺序执行导致的bug。Berry使用符号执行来增强LOLLY沿着复杂路径到达深层目标时的方向性。</p>
<p>除了目标区域序列之外，研究人员还提出了各种机制来指导DGF。Memlock通过监控内存使用情况来发现内存泄漏漏洞。V-Fuzz以易受攻击概率为指导，通过深度学习模型预测易受攻击概率，将DGF引导到潜在易受攻击的代码区域。SemFuzz和DrillerGo利用从CVE描述和git日志中检索到的语义信息来指导DGF并生成PoC报告。1DVUL通过那些直接改变原始数据流或控制流的补丁指导以发现1-day漏洞。SAVIOR和Parmasan是由来自Sanitizers（Sanitizers是谷歌发起的开源工具集）的信息指导的。IJON利用来自分析人员的注释来指导DGF克服重要的障碍。RVFUZZER受control instability的指导，在机器人车辆中发现输入验证漏洞。PFUZZER明确地指向输入解析器，从而更好地覆盖代码区域。</p>
<h4 id="input-optimization">Input Optimization</h4>
<p>seedfuzz利用动态污点分析来识别种子当中那些会影响程序重要位置的值的字节，通过改变这些字节来生成新的输入提供给目标程序以触发bug；FuzzGuard使用了一种基于深度学习的方法，将程序的输入看作一种模式，并使用大量的能够到达目标区域的输入来训练模型，然后利用该模型预测新输入的可达性，节省执行所需的时间；SemFuzz利用从CVE描述和git日志中检索到的信息（系统调用和参数）来生成种子输入，以增加命中易受攻击函数的概率；TIFF和ProFuzzer通过识别输入类型来辅助变异，从而最大化触发内存溢出漏洞的可能性；PFUZZER是一种语法驱动的方法，专门针对输入解析器，在生成不合理输入的情况下最大化输入空间覆盖率。</p>
<h4 id="seed-prioritization">Seed Prioritization</h4>
<p>DGF文献中广泛采用的三个种子优先级的度量标准：距离、覆盖率和概率。</p>
<h5 id="distance">Distance</h5>
<p>AFLGo在编译时对源代码进行检测，并通过PUT的调用图和控制流图中的边数计算到目标基本块的距离。然后在运行时聚合每个基本块的距离值，以计算平均值来评估种子。许多后续版本继承了这种基于距离的方案，如Parmasan和1DVUL。TOFU的距离度量定义为达到目标所需的正确分支决策数。RDFuzz通过代码的执行频率将代码区分为高频区和低频区，输入分为高/低距离和高/低频四种类型，在探测阶段，优先选择低频种子来提高覆盖率；在开发阶段，优先选择低距离种子来靠近目标区域。UAFuzz是一个定制的DGF程序，用于复杂的UAF漏洞。与基于控制流图的距离不同，它使用了通向目标函数的调用链的距离度量，目标函数一般包含分配函数和释放函数。W¨ustholz等人使用online static lookahead analysis来找到并避免那些所有后续路径都无法到达目标区域的路径，通过强调可能到达目标区域的路径。</p>
<p>基于距离的方法的一个缺点是它只关注最短距离。当有多条路径到达同一目标时，可能会忽略较长的选项，从而导致偏差。</p>
<h5 id="similarity-coverage">Similarity &amp; Coverage</h5>
<p>Hawkeye利用对PUT的静态分析，将基本块距离(the basic block trace distance)与覆盖函数(covered function similarity)结合起来用于种子优先级排序和能量调度。LOLLY使用指定的程序语句序列作为目标，并将种子覆盖目标序列的能力（即序列覆盖率）作为评估种子的度量。UAFL使用操作序列覆盖率作为反馈，引导测试用例生成逐步覆盖触发UAF漏洞可能使用的操作序列。UAFuzz还使用序列相似性来度量种子执行路径和目标UAF bug traces之间的相似性。Berry考虑了目标序列中节点的覆盖率及其执行上下文，它用必要的节点来增强目标序列，即到达目标序列的所有路径中必需的节点中的基本块。Berry还考虑了输入执行路径和目标序列之间的相似性，从而对种子进行优先级排序。SAVIOR根据UBSan预测的标签覆盖率，优先考虑具有更高触发漏洞潜力的种子。TortoiseFuzz基于内存损坏漏洞与敏感内存操作密切相关的事实，区分了更可能受到易受攻击的边缘，通过覆盖率和安全影响因子的组合对输入进行优先级排序，这由函数、循环和基本块的三种不同粒度类型的内存操作表示。</p>
<h5 id="probability">Probability</h5>
<p>V-Fuzz和SUZZER基于一个通过深度学习的模型得到函数的存在漏洞的概率，并给函数中的每个基本块一个静态分数。然后对于每个输入计算其执行路径上所有基本块的静态得分之和，并对得分较高的输入进行优先级排序。SAVIOR利用UBSan为代码区域添加可能存在bug的标签。TAFL加强了对包含漏洞的概率较高的区域的模糊化，该模糊化基于静态语义度量，包括敏感、复杂、深入和罕见的区域。</p>
<h4 id="power-assignment">Power Assignment</h4>
<p>AFLGo使用一种基于模拟退火的能量调度，逐渐将更多的能量分配给距离目标区域较近的种子，同时减少距离较远的种子的能量。传统的随机游走调度总是接受更好的解从而可能陷入局部最优，而模拟退火则以一定的概率接受不如当前最优解的解，因此有可能跳出局部最优解而达到全局最优解。Hawkeye也采用了模拟退火，但增加了优先级。因此，更接近目标的种子首先发生变异，这进一步提高了方向性。LOLLY采用了一种优化的基于模拟退火的能量调度来实现最大的序列覆盖。在温度阈值的控制下，探测阶段会随机地对所提供的种子进行变异以产生许多新的输入；而在开发阶段，它会从具有更高序列覆盖率的种子中产生更多的新输入。</p>
<h4 id="mutator-scheduling">Mutator Scheduling</h4>
<p>Hawkeye利用了一种自适应变异策略，将变异分为粗粒度和细粒度。粗粒度的变异会更改大量字节，而细粒度的变异只涉及少量字节级的修改、插入或删除。一旦种子接近目标区域，进行细粒度变异的次数增加，而粗粒度变异的次数减少。同样，V-Fuzz将变异策略分为轻微变异和严重变异，并根据实际模糊测试的状态通过阈值动态调整变异策略。SemFuzz执行类似的分类，但它关注于系统调用。SemFuzz利用对输入的粗变异来找到一个系统调用序列，该序列可以将执行移向易受攻击的函数。之后，它将切换到syscall序列上的细粒度变异，以监视关键变量。TAFL还采用了基于经验观察的粒度感知的变异调度，即：粗粒度变异在路径增长方面优于细粒度变异；组合多个变异的性能优于使用单一类型的变异。</p>
<h4 id="data-flow-analysis">Data-flow Analysis</h4>
<p>数据流分析（如污点分析）可以反映输入不同部分对程序的影响，有助于优化变异策略和输入生成。UAFL采用信息流分析来识别条件语句中的输入和程序变量之间的关系，并为那些信息流更多的输入字节赋予更高的变异可能性，因为它们更可能改变目标语句的值。SemFuzz通过反向数据流分析跟踪关键变量所依赖的核函数参数。SeedFuzz利用动态污点分析来识别种子中可能影响程序重要位置的值的字节。PFUZZER使用输入的动态污点分析，将处理的每个值与其派生的输入字符相关联。TIFF通过内存中的数据结构识别和动态污点分析来推断输入类型，这增加了基于类型的变异触发内存损坏漏洞的概率。数据流分析通常会增加运行时开销。</p>
<h3 id="challenges-and-solutions">Challenges and Solutions</h3>
<h4 id="binary-code-support">Binary Code Support</h4>
<p>二进制级别的DGF存在以下问题。</p>
<ol type="1">
<li>运行时开销很大。最简单的方法就是利用一个完整的系统仿真器。例如，UAFuzz处理二进制代码，并通过QEMU提取执行路径。</li>
<li>目标信息收集困难。对于二进制代码中的PUT，只能从bug trace中提取目标信息。</li>
<li>标靶困难。由于二进制代码很难读取，必须对其进行反汇编，如使用idapro，并用虚拟地址标记目标。</li>
</ol>
<p>可以通过硬件辅助减轻性能限制，Intel PT是最新Intel处理器中的一种轻量级硬件功能，可以捕获有关程序执行的trace数据并动态跟踪程序执行，开销忽略不计。通过Intel PT捕获的数据包trace以及PUT的二进制文件可以重建PUT的执行路径。以前的硬件功能（如Intel Last Branch Record）也可以执行程序跟踪，但其输出存储在特殊寄存器中，而不是主内存中，这限制了跟踪大小。CGF与PT的结合也有尝试，比如kAFL、PTfuzz、Ptrix和Honggfuzz。然而Intel PT从未被用于DGF。</p>
<p>对于二进制代码级别的目标识别和标记问题，可以利用基于机器学习的方法或启发式二进制差分方法来自动识别易受攻击的代码。</p>
<h4 id="automatic-target-identification">Automatic target identification</h4>
<p>为了实现目标的自动识别，可以使用静态分析工具在PUT中寻找潜在的危险区域，但这些工具通常特定于所使用的bug类型和编程语言。另一个方向是利用compiler sanitizer passes，比如UBSan，来注释PUT中的潜在bug。对于二进制代码，1DVUL通过基于Bindiff的二进制级比较，提取不同的函数及其不同的基本块，识别与补丁相关的目标分支。基于深度学习的方法在预测脆弱性和使用预测信息指导模糊化方面也是有效的。最后，攻击面识别组件也可用于自动识别DGF的易受攻击目标。</p>
<h4 id="differentiated-weight-metric">Differentiated weight metric</h4>
<p><img src="/png/2021-01-03-13-09-41.png"></p>
<p>上图显示了一个控制流图片段，其中输入x是一个从0到9的整数。很容易知道从节点A跳到节点C的概率是0.1，从节点A跳到节点B的概率是0.9。如果据根据分支跳数计算距离，则A→C的距离比A→G短，这是因为A→C只有一次跳，而A→G有三次跳。但是如果考虑概率，则A→C的概率为0.1，而A→G的概率为0.9×0.7×0.5≈0.3，这比A→C更短。因此，在计算距离时考虑权重差异更为合理。其他种子优先级度量，如相似性和概率，应该遵循相同的原理。</p>
<p>当基于概率评估目标的可达性时，则种子按照穿过其执行路径的概率来进行优先排序。由于执行路径可以看作是连续分支的马尔可夫链，因此可以通过收集路径中所有分支的概率来计算路径的概率。</p>
<p>可以通过统计模拟方法估计分支概率。平稳分布的密度形式上描述了DGF经过一定次数的迭代后执行某条路径的可能性。统计模拟方法需要两个条件：随机抽样；抽样规模较大。模糊过程通常都满足这些要求。基于变异的测试用例的执行路径可以看作是随机样本。模糊程序生成的大量测试用例满足第二个需求。因此将模糊测试作为一个抽样过程，可以以一种轻量级的方式估计分支跳跃概率。基于概率的方法的缺点是带来了运行时开销，例如跳跃计数和概率计算，提升性能的一个简单方法是间隔采样。</p>
<p>另一个可能的解决方案是加速计算，这涉及到元数据的存储和访问方式。通常基于图的数据都存储在邻接表中，但是基于概率的方法会经常更新跳跃统计信息，并且可达性判断也需要快速的边缘跟踪，因此访问数据效率较低的邻接表并不适用。另一种选择是邻接矩阵，它支持快速数据访问。然而，由于一个跳转通常有两个分支，矩阵将是巨大的，但数据分布又相对稀疏，这会导致空间上的浪费。</p>
<p>因此基于概率的方法的一个研究方向是设计一个平衡时间复杂性和空间复杂性的定制数据结构。</p>
<h4 id="global-optimum-deviation">Global Optimum Deviation</h4>
<p><img src="/png/2021-01-03-16-09-55.png"></p>
<p>当DGF测试中存在多个目标时，如何协调这些目标是另一个挑战。一种策略是基于Dijkstras算法来寻找全局最短距离（AFLGo）。然而全局最优可能会错过最接近某个目标的局部最优种子，导致偏差。</p>
<p>上图显示了一个控制流图片段，其中节点K和O是目标节点。这里测试了三个种子，路径分别为：A→B→D→G→K，A→C→E→I→M→N→O，A→C→E→H→L。论文作者基于B¨ohme等人定义的距离公式计算了两个目标的三条路径中每个节点之间的harmonic distances，并在每个节点的侧面标记它们。路径A→C→E→H→L的种子是三个之中全局距离最小的，但路径A→B→D→G→K穿过目标节点K，路径A→C→E→I→M→N→O穿过目标节点O，而路径A→C→E→H→L没有到达任何目标。因此，当存在多个目标时，寻找全局最短距离会导致偏差。如果考虑路径A→C→K和路径A→C→E→H→O，会发现d(ACK) &lt; d(ACEIMNO) &lt; d(ACEIMNL)。这是因为路径A→C→K和路径A→C→E→H→O分别是到目标K和O的最短路径。为了避免在评估种子时产生偏差，应该考虑到所有可能到达目标的路径，Hawkeye使用了基于轻量级静态分析的相邻函数距离扩充，通过调用图分析函数之间的相邻关系。</p>
<p>多目标协调的另一种策略是目标分离。对于每个种子，仅选择所有目标距离中的最小距离作为种子的距离，并基于该最小距离对种子进行优先级排序。这样可以避免局部最优偏差，但可能会减慢达到某个目标的速度。</p>
<h4 id="missing-indirect-calls">Missing Indirect Calls</h4>
<p>无论采用何种度量，DGF都依赖于控制流分析来获取程序知识。然而，LLVM的调用流和间接调用图的构造并不完整。而实际程序中间接函数调用非常普遍。例如，在libpng中，44.11%的函数调用是间接函数调用。静态分析方法并不能直接从源代码或二进制指令中观察到间接函数调用，例如传递函数指针或使用函数对象的指针。如果要构造一个过程间控制流图，则需要将基于LLVM的IR生成的每个函数的控制流图与整个程序的调用图结合起来。</p>
<p>考虑静态分析，一个简单方法是对每个执行的函数指针进行分析，但是这种基于包含的上下文不敏感指针分析会导致出现给定输入不可能的执行路径。TOFU使用函数类型签名来估计每个间接调用点的可调用集，但是TOFU不考虑类型转换，从而引入不精确性。</p>
<p>对于动态情况，ParmeSan在实际执行过程中识别间接调用的目标，从而逐渐补全调用图。然而这不可避免地增加了运行时开销，并且不能保证完整性。</p>
<h4 id="exploration-exploitation-coordination">Exploration-exploitation coordination</h4>
<p>DGF面临的最后一个挑战是如何协调勘探与开发之间的权衡。一方面，多勘探可以为开发提供充分的信息，另一方面，勘探过度会占用大量资源，延缓开发。AFLGo采用勘探阶段和开发阶段的固定分割，由于每个PUT具有不同的字符，因此这种固定拆分的适应性较差。</p>
<p>RDFuzz统计执行期间的信息，将代码区域分为高频区域和低频区域。根据频率和距离两个评价准则，将输入分为高、低距离和高、低频两类。低频输入有助于提高勘探所需的覆盖率；低距离输入有助于实现勘探所需的目标码区。最后，采用一个相互交织的测试时间表，交替进行勘探和开发。</p>
<p>另一个方法是利用动态策略在勘探阶段和开发阶段之间自适应切换。论文作者建议将模糊阶段的分配转化为种子的分配，即将种子分为两组：覆盖种子用于探索，定向种子用于开发。每组种子的数目表示在相应阶段所消耗的能量。这两个阶段的协调是通过控制每组种子的数量来实现的。使用一个称为dp的变量来表示所有种子中定向种子的百分比，即开发阶段上的能量的百分比。在种子评价过程中，对覆盖种子进行标记，在每个模糊周期后，对定向种子进行标记，并通过dp进行调整。</p>
<p><img src="/png/2021-01-03-16-40-26.png"></p>
<p>使用上图中的算法来说明这个设计。具有自适应分裂的DGF应该从探索阶段（dp=0）开始，随着已知路径的增加，逐渐增加dp来调用开发阶段，在开发阶段，基于dp选择高值的定向种子并对其进行优先级排序以增强可达性。当模糊测试程序在很长一段时间内找不到新的路径时，应该通过大幅度提高dp来迅速进入开发阶段。同样，也需要偶尔从开发阶段回到勘探阶段。例如，当模糊测试程序已经处于开发阶段，但长时间更接近目标，就应该大幅降低dp以返回勘探阶段。在该方案中，两个阶段可以共存，以获得最佳的性能和自适应性。值得注意的是，算法中的阈值是用来说明原理的。应该基于启发式算法产生合理的阈值。</p>
<h3 id="discussion">Discussion</h3>
<h4 id="multi-targets-relationship-exploitation">Multi-targets Relationship Exploitation</h4>
<p>当存在多个目标时，可以通过目标之间的关系来优化DGF。如果是不相关的，可以分配权重来区分重要性或概率。否则，可以提取隐藏关系并加以利用。</p>
<p>UAFL在利用目标序列寻找UAF漏洞时，考虑了操作序列的顺序，因为触发这种漏洞需要以特定顺序遍历目标序列。这种方法可以扩展到检测语义错误，比如double-free和API误用。Berry使用所有路径的执行上下文（即到达目标序列中的节点所需的必要节点）增强fuzz的方向性。</p>
<p>现在常见的有以下关系。</p>
<ol type="1">
<li>执行空间关系。考虑目标在执行树上的相对位置，包括它们是否在同一个执行路径上，它们共享多少个执行路径，以及哪一个是另一个的前继节点还是后继节点。</li>
<li>状态空间关系。考虑目标在状态空间中的位置，例如两个目标是否共享相同的状态，以及两个状态是否可以在状态转换映射上相互转换。</li>
<li>交错关系。对于多线程程序，线程调度会影响不同线程中事件的执行顺序。</li>
</ol>
<h4 id="technology-integration">Technology Integration</h4>
<p>依赖随机变异来产生测试输入通常很难到达深层目标，并且在复杂路径上触发深层缺陷的效果较差。为了增强到达这些地方的方向性，可以采用如静态分析、控制流分析、数据流分析、机器学习、语义分析和符号执行等分析方法辅助（。</p>
<p>在论文作者调查的工具中，75%的工具依赖于控制流分析来评估种子并确定对目标的可达性；46%的工具利用静态分析来自动识别目标，并从PUT中提取信息；32%的工具使用数据流分析（主要是污点分析）来识别目标之间的关系输入和关键程序变量，优化变异策略调度；11%使用机器学习预测易受攻击的代码，过滤掉无法到达的输入；18%采用语义分析自动识别易受攻击目标，学习输入字段语义优化变异；18%集成符号（concolic）执行来解决复杂的路径约束。</p>
<h4 id="implementation-limitation">Implementation Limitation</h4>
<p><img src="/png/2021-01-03-17-14-22.png"></p>
<p>AFL的边缘覆盖是基于基本块转换的，因此它只在基本块级敏感，不能在指令级区分路径差异。上图显示了两个相邻基本块之间的跳转示例。由于仅对路径敏感，因此无法区分地址0x400657处的跳转是采用还是不采用，因为在控制流图中会有相同的边，即0x400657→0x400671。</p>
<p>同时AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器中收集这些插入数，以标识基本块转换（即控制流图中的边）。然后通过一个算法将插入数转换映射到64KB位图。由于不同的边可能有机会共享同一位置，因此该方案会导致路径冲突。</p>
<p>AFL的这两个局限性都会导致控制流图的不精确性，最终影响基于控制流图分析的种子优先级。这些问题可以通过构造更细粒度的控制流图或设计定制的hash方案来缓解，但是不可避免地会增加运行时开销。</p>
<h4 id="efficiency-improvement">Efficiency Improvement</h4>
<p>优化模糊化效率的一种解决方案是将与执行无关的计算从运行时转移到编译时。例如，AFLGo通过解析PUT的调用图和过程内控制流图来度量每个基本块与目标区域之间的距离。由于解析图和计算距离都非常耗时，AFLGo在编译时将大部分程序分析转移到插桩阶段，以换取运行时的效率。</p>
<p>另一个优化是在实现级别。由于在分析过程中使用的大多数数据都是基于图的，因此如何存储和访问此类元数据对效率至关重要。可以设计一个优化的数据结构来存储这些数据，这样在基于图的拓扑结构进行搜索时就可以方便地频繁、快速地访问这些数据。例如，使用图数据库模型。</p>
<p>最后，可以利用并行计算来进一步提高效率。以前的工作已经成功地将并行性应用于CGF，但尚未应用于DGF。对于DGF，可以使用一个中心节点来维护一个种子队列，该队列保存DGF的所有种子并对其进行优先级排序。然后，将种子分发到计算节点上的并行模糊程序中，测试PUT并收集反馈信息。</p>
<h4 id="future-research-suggestions">Future research suggestions</h4>
<ul>
<li>在内核代码中引入DGF，并引导对关键区域（如syscalls和错误处理代码）的模糊化应该是一个好的方向。</li>
<li>将DGF应用于特定的bug类型，如信息泄漏bug、并发bug、语义bug(TOCTTOU、double fetch)。</li>
<li>对于种子优先级度量，大多数工作都利用了基于距离和覆盖率（相似性）的方法，这有助于在不引入太多开销的情况下对种子进行量化评估。然而，较小的距离或较宽的覆盖范围并不一定意味着更接近目标，因为存在不同的权重原因和全局偏差原因。作者认为基于概率的度量应该更合理。</li>
<li>分阶段模糊测试可以用于DGF。通过将到达目标的路径划分为连续的多个阶段，分阶段定向模糊算法可以在每个阶段到达子目标，逐步到达目标。此外，可以利用不同的模糊策略来满足不同阶段的需求，从而降低模糊化各个阶段输入空间的维数，提高模糊化效率。</li>
</ul>
<h2 id="fuzzing-hack-art-and-science-cacm-2020">Fuzzing: Hack, Art, and Science (CACM 2020)</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/CACM20_Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>三种发现漏洞的方法：静态程序分析器能够自动检查代码并标记错误的代码模式，可以标记出许多浅显的错误，但是也容易发出虚假的警报。人工代码审计可以检测很多问题，包括安全漏洞，设计缺陷和编码错误等超出了自动化工具的范围的问题。最后就是模糊测试Fuzzing。</p>
<h3 id="blackbox-fuzzing-1">Blackbox Fuzzing</h3>
<p>Fuzzing最简单的形式是Blackbox random fuzzing，它随机地改变格式良好的输入，然后用它们测试PUT。</p>
<p><img src="/png/2021-01-17-09-36-29.png"></p>
<p>PUT通常是在运行时检查工具的监视下运行的，如Purify、Valgrind、AppVerifier或AddressSanitizer，以增加发现非崩溃安全漏洞（如缓冲区溢出）的机会。</p>
<p>在实践中，Blackbox random fuzzing的有效性取决于一组形式良好的种子输入来启动fuzz过程。事实上，格式良好的种子输入将在应用程序中更快地执行更多的代码，并且涵盖输入格式支持的各种选项和编码，以进行全面的fuzzing。对于JPEG图像格式，通常使用原始字节值来编码键输入属性，如图像大小、尺寸和输入文件数据指针；在其他格式良好的输入中fuzzing这些关键字节值（其位置因图像而异）可能会发现由于输入验证不完整而导致的缓冲区溢出错误。</p>
<p>模糊化的变异应该是循序渐进的。</p>
<h3 id="grammar-based-fuzzing">Grammar-Based Fuzzing</h3>
<p>Grammar-based fuzzing对于接受格式化输入的程序是非常有效的，fuzzer根据语法生成新的输入，基于语法的模糊器有Peach，SPIKE和Sulley等。</p>
<p><img src="/png/2021-01-17-10-19-48.png"></p>
<p>上图展示了SPIKE设置语法的过程，输入语法在这里直接表示为可以解释执行的代码。通过调用s_string按顺序指定常量字符串，用s_blocksize_string获取clock变量的字符串长度作为之前Content-Length的参数，s_block_start表示开始定义block，继续使用s_string定义常量字符串，关键点在于使用s_string_variable生成随机化的数据来进行fuzz，后面s_string同理，最后使用s_block_end结束block的定义。由上图代码SPIKE可能会生成以下形式的字符串序列。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/api/blog/</span> HTTP/1.2</span><br><span class="line"><span class="attribute">Content-Length:10&#123;body:XXX&#125;</span></span><br></pre></td></tr></table></figure>
<p>Grammar-based fuzzing的优势和优点。</p>
<ol type="1">
<li>可以通过分析人员的专业知识将fuzzing集中于那些可能永远不会被Blackbox random fuzzing覆盖到的代码区域。</li>
<li>可以将不可靠的输入作为Web页面，包括复杂的HTML文档和JavaScript代码，从而发现浏览器中的安全漏洞，以及那些复杂的代码编译器中的bug。</li>
<li>也适用于网络协议的fuzzing。</li>
</ol>
<p>Grammar-based fuzzing is also related to model-based testing. Given an abstract representation of a program—called a model—model-based testing consists in generating tests by analyzing the model in order to check the conformance of the program with respect to the model. Test generation algorithms used in model-based testing often try to generate a minimum number of tests covering, say, every state and transition of a finite-state machine model in order to generate test suites that are as small as possible. Similar algorithms can be used to cover all production rules of a grammar without exhaustively enumerating all possible combinations.</p>
<p>机器学习在Grammar-based fuzzing中的应用仍处于初步阶段，如何自动学习输入样本的语法仍是一个问题。例如，可以学习上下文无关的语法，使用自定义输入的示例概括步骤，或使用程序的动态污点分析以确定在测试中程序是如何处理其输入的。基于神经网络的统计机器学习技术可以也可以用来学习输入文法。</p>
<h3 id="whitebox-fuzzing-1">Whitebox Fuzzing</h3>
<p>whitebox fuzzing从一个格式良好的输入开始，对测试程序进行动态符号执行并收集符号执行过程中遇到的条件分支的输入约束。然后，将收集到的约束条件逐一否定并求解，从而生成进入另一条路径的输入。使用systematic search技术来重复此过程，该技术尝试遍历程序的所有（实际上是许多）可行的执行路径，同时使用运行时检查器检查许多运行时状态来判断是否触发了bug（如缓冲区溢出）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// x is an input</span></span><br><span class="line"> <span class="keyword">int</span> y = x + <span class="number">3</span>;</span><br><span class="line"> <span class="keyword">if</span> (y == <span class="number">13</span>) <span class="built_in">abort</span> (); <span class="comment">// error</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态符号执行具有初始具体值，变量x为0的程序输入，此时执行的为else的分支，并生成路径约束x + 3 ≠ 13。否定此约束条件并用约束求解后产生新的解决方案x = 10。新输入使程序遵循条件语句的then分支语句并找到错误。whitebox fuzzing可以生成比其他方法执行更多程序路径的输入，因为它更精确。而且whitebox fuzzing可以自动发现并测试出程序遇到的极端情况，例如由于无法正确分配内存或操作缓冲区而导致的安全漏洞。从理论上讲，whitebox fuzzing提供了完整的程序路径覆盖，也就是说达到了程序验证的效果（针对达到指定大小的任何输入）。</p>
<p>但是现实情况并非如此，路径空间的探索通常是不完整的，因为程序中的执行路径的数量是巨大的，而且符号执行，约束生成和约束求解可能由于复杂的程序语句（指针操作，浮点操作等）导致结果不精确，同时还有外部操作系统和库功能产生的大量约束，这些约束无法在限定的时间内完全解决（导致路径爆炸）。所以whitebox fuzzing的有效性仍然依赖于各种各样的合适的种子输入。</p>
<p>whitebox fuzzing最初是在SAGE中实现的，SAGE执行x86级别动态符号执行，并实现几个至关重要的优化用于处理来自于数亿条机器指令的执行痕迹，以便对应那些包含数百万行代码的文件解析器。当探索巨大状态空间的时候，SAGE也会使用基于代码覆盖率的启发式探索。</p>
<ul>
<li>对执行的每个测试都测量其指令覆盖率，对于发现更多新指令（新路径）的符号优先执行，以便探索更多未开发代码区域。</li>
<li>测试和符号执行可以在多个内核或机器上并行运行。whitebox fuzzing也可以从给定的种子输入开始，同时如果输入语法可用还可以使用Grammar-based fuzzing来生成种子输入。</li>
</ul>
<p>whitebox fuzzing也在许多其他工具中采用，如开源工具KLEE，S2E，和Symbolic PathFinder。</p>
<h3 id="other-approaches">Other Approaches</h3>
<p>Portfolio approaches同时运行多种的fuzzer并收集它们的结果，因此结合了它们的互补优势。</p>
<h2 id="survey-of-directed-fuzzy-technology">Survey of Directed Fuzzy Technology</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/ICSESS19_Survey.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p><img src="/png/2021-01-22-13-45-05.png"></p>
<h3 id="dse">DSE</h3>
<p>符号执行实际上是将可达性问题转化为约束求解问题。</p>
<h4 id="symbolic-execution-algorithm">Symbolic Execution Algorithm</h4>
<p>符号执行最初用于编译过程，程序分析等，主要思想是将符号变量作为输入去执行程序，在执行的过程中收集条件判断时通往不同路径的约束，最后使用约束求解获得到达对应路径的输入。</p>
<h5 id="静态符号执行">静态符号执行</h5>
<p>静态符号执行首先将输入变量符号化，然后通过静态分析将程序转换为中间语言，并且在运行中更改符号化变量来获取通往不同路径的约束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = raw_input();</span><br><span class="line">b = <span class="number">2</span> * a;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">10</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"win"</span> ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">"lose"</span>;</span><br></pre></td></tr></table></figure>
<p>上述代码在静态符号执行中，a会首先被符号化，即a = x，而b = 2 * x。可知当10 == 2 * x时，它进入win路径，否则进入lose路径。这两条路径合并的状态被称为执行树，10 == 2 * x和10 != 2 * x则是路径约束。当符号执行结束，即程序正常或异常退出时。约束解算器将求解对应路径的约束，从而获得到达此路径所需的变量的值。</p>
<p>静态符号执行存在很多实际实施过程中的问题，例如：约束无法求解。</p>
<h5 id="动态符号执行">动态符号执行</h5>
<p>结合传统静态符号执行和实际执行的符号执行称为动态符号执行，也称为concolic (concrete + symbolic)测试。动态符号执行维持两种状态：一种是实际状态，另一种是符号状态。实际状态对应随机生成的变量的值，而符号状态则是符号化的变量。动态符号执行首先根据实际状态运行，运行过程中收集符号化变量在当前分支路径上的约束并进行求解。然后，将约束条件求反就得到另一条分支路径的约束。重复该过程，直到探索完所有路径或达到设置的限制。具体的执行状态可以降低符号约束的复杂性。</p>
<p>还是上面的代码，在一次动态符号执行中，假设随机生成的变量a = 7，实际执行时会进入lose路径。此时收集进入lose路径的约束并求返就获得进入win路径的约束，再使用约束求解器来验证。这样就避免了约束不能解决或找到的问题。</p>
<p>通过动态符号执行提取来自原始的复杂的控制流图CFG的行为信息。然后向控制流模型添加约束以实现一个基于控制流的有限状态机控制参数，Finite State Machine control parameters (EPBFSM)。最后，通过解决EPBFSM中的约束产生的新的模糊输入，这种方法不仅可以找到可能发现漏洞的路径，也可以识别可能发现漏洞的可控对象。</p>
<h4 id="directed-symbolic-execution">Directed Symbolic Execution</h4>
<p>通常测试出来的大多数路径都不是可以直接到达目标的，所以要通过找到一条到达中间目标的路径来继续进行搜索。</p>
<p>补丁测试工具KATCH使用符号执行器KillE到达被patch的地方。而KLEE使用符号执行的方法，通过大量的程序分析和约束求解系统地探索到达目标位置的路径的状态空间。一旦识别到一条可以到达目标位置的路径，就可以对相应的路径约束求解从而生成测试用例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">55</span> <span class="comment">/* Read type and payload length first */</span></span><br><span class="line"><span class="number">56</span> hbtype = *p++;</span><br><span class="line"><span class="number">57</span> n2s(p, payload);</span><br><span class="line"><span class="number">58</span> pl = p;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="number">65</span> <span class="keyword">if</span> (hbtype == TLSl _HB_REQUEST) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="number">77</span> <span class="comment">/* Enter response type, length and copy payload */</span></span><br><span class="line"><span class="number">78</span> *bp++ = TLS <span class="number">1</span>_HB_RE SPONSE;</span><br><span class="line"><span class="number">79</span> s2n(payload, bp);</span><br><span class="line"><span class="number">80</span> <span class="built_in">memcpy</span>(bp,pl,payload);</span><br></pre></td></tr></table></figure>
<p>假设KATCH将上面代码的第80行设置为目标，并且找到一个到达65行可行路径A作为中间目标。接下来，KATCH通过约束求解器将收集到的A的约束和hbtype == TLSl _HB_REQUEST的约束进行求解，就可以生成运行到80行的输入。</p>
<p>与GF不同，基于符号执行的whitebox fuzzing为实现定向模糊测试提供了简单的处理方法。大多数补丁测试工具都基于DSE。但是，DSE为了有效性牺牲了效率，因为DSE需要很长时间来执行程序分析和约束求解。在每次迭代中，DSE使用程序分析来确定那些为了靠近目标而需要否定的分支，根据这些路径构建相应的约束，并使用约束求解器来验证。</p>
<h2 id="a-review-of-machine-learning-applications-in-fuzzing">A Review of Machine Learning Applications in Fuzzing</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv19_Machine.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>主要关注三种类型的ML：有监督学习，无监督学习，强化学习。</p>
<p>有监督学习用于训练一个模型来识别给定数据点的标签，要求训练数据集的数据点都有显式标签。无监督学习用于训练一个模型来发现数据点之间的模式或相似性，不要求数据点有显式标签。强化学习是用来训练一个模型（代理）基于环境而行动，以取得最大化的预期利益。强化学习会对代理在环境中所做的操作或者结果进行对应的奖励，类似于监督学习，这些奖励为代理提供了一个最佳行动的指示。这些ML都可以采用一种特殊的ML形式--深度学习。深度学习是指一种分层学习，可用于学习一组数据点的基本特征和结构。</p>
<p>一个典型的强化学习场景：Flappy bird游戏。</p>
<ul>
<li>机器有一个明确的小鸟角色——代理。</li>
<li>需要控制小鸟飞的更远——目标。</li>
<li>整个游戏过程中需要躲避各种水管——环境。</li>
<li>躲避水管的方法是让小鸟用力飞一下——行动。</li>
<li>飞的越远，就会获得越多的积分——奖励。</li>
</ul>
<h3 id="overview-of-fuzzing">OVERVIEW OF FUZZING</h3>
<p>现代模糊程序的三种主要类型：基于变异的fuzzer、基于语法的fuzzer和进化fuzzer。</p>
<p>进化模糊程序是一种最新的模糊程序，它在变异的基础上，评估每一个输入的优先级，并使用适应度函数（通常是覆盖率）对输入进行排序，并选择排序最好的输入进行变异。进化模糊程序的例子包括honggfuzz、AFL和libFuzzer。</p>
<p><img src="/png/2021-01-24-10-39-35.png"></p>
<p>上图将一般的fuzzing过程分为几个阶段。</p>
<h4 id="pre-fuzzing-program-knowledge">Pre-Fuzzing: Program Knowledge</h4>
<p>在开始fuzzing之前，fuzzer需要程序知识，也就是如何对程序进行检测或观察？什么构成了一个有趣的程序状态？需要研究哪些输入接口？</p>
<p>基于变异的fuzzer通常需要以输入语料库或一组程序输入的形式提供额外的程序知识，以便有效地生成输入，这些程序输入往往是预期输入的示例。基于语法的fuzzer以输入语法的形式吸收额外的程序知识，例如预期的文件格式或协议描述。基于语法的fuzzer通常比基于变异的模糊器有更好的代码覆盖率和更深入的程序状态探索。但是更难设置。进化fuzzer和基于变异的fuzzer一样，通过输入语料库获取额外的程序知识。</p>
<h4 id="stage-1-generate-inputs">Stage 1: Generate Inputs</h4>
<p>在fuzzing的第一阶段，fuzzer使用程序知识生成输入，通过已指定的输入接口提供给程序，这个阶段的目标是生成那些可以触发或者说到达新的代码区域的输入。</p>
<p>基于语法的fuzzer通过根据输入规范来生成新的输入。对于一个给定的规范，只存在有限的与该规范对应的输入，也就是说输入搜索空间是有限的，所以基于语法的fuzzer可以探索整个输入搜索空间。</p>
<p>并不是所有的新输入都会被使用。基于变异的fuzzer通过处理先前的优先级高的输入来生成新的输入。在第一次迭代中，fuzzer处理初始输入语料库中提供的输入。之后，fuzzer会根据监视程序的信息评估输入性能，然后调整语料库。进化fuzzer和基于变异的fuzzer类似。要么变异一个输入，要么选择两个或多个输入进行交叉组合以产生新的输入，也可以使用其他随机化技术。进化fuzzer通过评估前一阶段的输入性能来选择输入进行随机化。理论上，基于变异和进化的fuzzer可以产生无限的输入，无限的输入搜索空间使得很难估计有多少输入空间已经被探索过。</p>
<p>符号执行是一种静态分析技术，它可以帮助生成新的输入，从而增加fuzzer的覆盖范围。在实际中符号执行用于为基于变异和进化的fuzzer生成新的输入提供信息。这些新的输入可以添加到输入语料库中，或者以其他方式输入到程序中。为了降低符号执行的成本，fuzzer将符号执行与标准输入生成技术配对。符号执行引擎可以通过跟随一个感兴趣的输入来限制路径，并且只允许新的符号状态在有限数量的分支中偏离该输入。</p>
<h4 id="stage-2-select-inputs">Stage 2: Select Inputs</h4>
<p>在fuzzing的第二阶段，fuzzer选择输入并发送到程序中进行执行。</p>
<p>当基于变异和进化的fuzzer继续迭代运行时，可能会收集许多非常大的输入，这会减慢模糊过程，所以需要执行语料库最小化来减少输入的数量，或者输入最小化来减少每个输入的大小。无论是合理的选择输入来减少活动输入的数量，还是减小输入，这些技术都试图减少fuzzer发现新的程序状态所需的时间。</p>
<h4 id="stage-3-monitor-program">Stage 3: Monitor Program</h4>
<p>在fuzzing的第三阶段，fuzzer将监视程序以识别感兴趣的程序状态。有趣的程序状态指表现出特定的程序行为，在大多数情况下，crash就是一种有趣的程序状态。</p>
<p>而实际上，通过程序插桩可以观察到的任何行为都可以用来识别有趣的程序状态。例如，Valgrind可以检测内存损坏，即使这个损坏不会导致崩溃；对于脆弱性评估，有趣的行为是那些与bug或脆弱性相关的可观察行为。如前所述，fuzzer需要程序知识，从而了解如何对程序进行检测以及什么构成了一个有趣的程序状态。但是如何定义一个有趣的程序状态仍然是一个问题。而在脆弱性评估案例中，如何判断可观察到的行为与识别缺陷或脆弱性是否是最相关的也是一个难点。</p>
<p>一旦fuzzer识别出一个有趣的程序状态，它就需要将该状态的描述返回给用户进行分析。</p>
<h4 id="stage-4-evaluate-inputs">Stage 4: Evaluate Inputs</h4>
<p>在fuzzing的第四阶段，fuzzer评估输入的执行情况。许多fuzzer使用代码覆盖率来衡量输入的效果；libFuzzer工具使用了一个类似的度量，即数据覆盖率，如果该输入和先前的输入执行情况的比较中出现了新的数据值，那么就会对该输入给予较高的评价。一些fuzzer使用bug的发现情况作为度量，导致崩溃的输入被给予较高的评价。</p>
<p>基于进化的fuzzer需要反馈输入的性能指标，也就是必须能够评估输入并对其进行排序。然后fuzzer根据输入的性能指标来有选择地生成新的输入和执行。基于变异和基于语法的fuzzer通常不需要反馈输入的性能指标，但是性能指标可以帮助评估fuzzer的整体性能。找到一个有效和可比较的指标仍然是一个研究挑战。</p>
<h4 id="post-fuzzing-interesting-program-states">Post-Fuzzing: Interesting Program States</h4>
<p>在fuzzing之后，研究人员会简单分析fuzzer反馈的有趣的程序状态，包括形成原因和是否属于漏洞，之后会进行分类，以决定对哪些程序状态进一步分析。不幸的是，这些程序状态通常具有相同的原因，而且具有相同原因的状态可能会出现截然不同的情况。例如，内存损坏漏洞可能会导致程序的许多不同部分崩溃，导致内存映像差异很大。一些自动化工具试图消除fuzzer输出的"重复"状态，但并不完善，对状态进行分类和根本原因的分类仍然是一个研究挑战。</p>
<h3 id="applications-of-machine-learning-to-fuzzing">APPLICATIONS OF MACHINE LEARNING TO FUZZING</h3>
<p>ML已被用于在fuzzing中生成新的输入，并在较小程度上促进post-fuzzing；无监督学习在输入生成中得到了最成功的应用，例如，AFL等模糊工具将遗传算法（GAs）集成到输入生成过程中，最近也有监督学习和强化学习（RL）在输入生成中的应用；此外，这三种类型的ML都已应用于符号执行，主要是为了减少约束方程的求解时间；监督学习和非监督学习都已应用于post-fuzzing，主要用于crash的分类和根本原因分类。</p>
<p>还有两个领域没有进行应用：输入最小化和语料库最小化，可能是因为这些过程不会导致大的性能瓶颈。</p>
<h4 id="generate-inputs">Generate Inputs</h4>
<h5 id="genetic-algorithms">Genetic Algorithms</h5>
<p>GAs是一种受生物进化启发的无监督ML，通常是进化fuzzer的核心输入生成算法，算法通常有3个主要步骤：生成一个小的inputs；对inputs执行变异；测量变异后的inputs的性能。根据选定的指标，在inputs上重复上述过程。进化fuzzer通常使用一个性能函数对执行过的输入进行排序，性能函数的选择会对fuzzer的性能，fuzzer识别特定类型错误的能力，以及fuzzer陷入局部极小值的趋势等方面产生巨大影响。</p>
<p>传统的代码覆盖率是性能函数最常用的度量，但也有更高级的启发式方法，如动态马尔可夫模型DMM启发式方法。也就是将程序控制图表示为马尔可夫过程，即控制图当中的每一条边都有对应的转移概率。DMM启发式方法使用马尔可夫模型和转移概率来创建性能函数。与代码覆盖率不同，这种方法能更精确地控制fuzzer，将其引导到代码中可能包含bug或缺陷的特定部分。</p>
<h5 id="deep-learning-and-neural-networks">Deep Learning and Neural Networks</h5>
<p>深度学习（DL）和神经网络（NNs）也被应用于输入生成，特别是基于语法和基于变异的fuzzer。递归神经网络（RNN）是应用于fuzzing中的最常用的DL方法，特别是Long-Short Term Memory（LSTM，RNN的一种变体）网络。</p>
<p>在一项研究中，Godefroid等人使用LSTM为基于语法的fuzzer中的PDF文件创建输入语法，发现fuzzing和LSTM输入语法学习的目标经常相互冲突：LSTM倾向于产生格式良好的输入，而fuzzer的目标是产生探索新程序状态的范例输入。为了避免这一矛盾，Godefroid等人采用了抽样策略来选取LSTM生成的输入，最终创建了一个具有很强平衡性的输入语法。实验结果表明，使用ML生成输入语法是一种很有前途的提高代码覆盖率的技术。</p>
<p>在另一项研究中，Rajpal等人将DL整合到AFL中，通过变异特定字节来增加覆盖率。具体原理是使用一个NNs来生成一个热图，该图给出了特定字节发生变异时增加代码覆盖率的预测可能性。Rajpal等人比较了四种不同的NNs：标准LSTM；双向LSTM；Seq2Seq；Seq2Seq的一种变体，使用attention机制来关注序列输入的重要部分。每个模型在某些情况下都增加了代码覆盖率，但总体标准LSTM模型的性能略优于其他模型。实验上，在ELF、XML和PDF格式上，DL增强AFL优于标准AFL，而在PNG格式上，标准AFL优于DL增强AFL。</p>
<p>另一种生成输入的方法是对程序行为建模，使用模型选择最有希望的输入。</p>
<p>NEUZZ方法使用浅层神经网络将程序的行为建模为平滑的连续函数，该神经网络被训练用于根据种子输入预测程序的分支行为。实验发现，训练过程中产生的梯度，特别是较大的梯度，有助于识别哪些输入字节控制分支行为。Chen等人通过Angora建模程序行为，Angora使用离散函数表示从程序起点到特定分支约束的路径，然后实现梯度下降从而在函数表示中的小离散区间上找到满足约束的一组输入，并通过该特定分支移动程序。总的来说，这种方法证明了快速解决分支约束的能力，并且在某些程序上的实验性能优于AFL和符号执行。Cheng等人还实现了一种使用DL生成输入的其他替代方法。这种方法使用RNNs来预测程序的新路径，然后将这些路径输入到Seq2Seq模型中，该模型为执行预测路径的fuzzer生成新的种子输入。初步研究表明，实验生成的语料库提高了PDF、PNG和TFF格式的fuzzer代码覆盖率。</p>
<p>DL和NNs的应用仍有障碍。第一个障碍是DL模型需要大量的训练计算时间。其中许多研究试图缓解这些问题。例如，Rajpal等人通过在fuzzing开始之前只在一小部分输入上训练神经网络来规避训练成本。另一方面，She等人在整个fuzzing中使用了简化形式的模型再训练，只使用最有用的数据点进行再训练。这两种方法都减少了训练时间，但对模糊性能的总体影响尚不清楚。减少数据量的另一种方法是开发在程序之间传输先前训练过的模型的方法。这种方法可能会消除或减少fuzzing以前未开发的程序所需的模型训练量，但这些方法如何影响性能尚不清楚。第二个障碍是跨文件格式的性能一致性。其中许多研究表明，对于某些文件格式（如PDF），DL与以前的基线相比，始终提高了模糊性能，而其他格式则无法与最先进的技术竞争。</p>
<h5 id="reinforcement-learning">Reinforcement Learning</h5>
<p>有两个团队应用强化学习进行输入生成。Becker等人使用SARSA算法通过改变发送到主机的网络数据包来对IPv6协议fuzz。SARSA算法考虑了代理的实时状态和行为来确定最优行为。Bottinger等人在基于语法的fuzzer中使用deep Q-learning network来学习语法来描述PDF格式。deep Q-learning network使用深度神经网络将状态映射到动作。</p>
<p>这些研究表明程序表征对于训练一个成功的RL代理是至关重要的。Becker等人使用有限状态机来表示IPv6协议的行为，其中每个状态表示主机对特定数据包的当前响应，状态之间的转换表示数据包的可能突变。Bottinger等人还使用了马尔可夫决策过程来表示问题。马尔可夫决策过程的特点是状态之间的随机转换。在这项研究中，状态表示fuzzer的特定种子输入，而转换表示该状态下种子输入的概率重写规则。因此，Becker和Bottinger都演示了使用有限状态机作为问题表示来训练RL代理生成输入的实用性。</p>
<p>这些研究还提供了有效定义一个代理的奖励函数的经验，这通常是RL最具挑战性的方面。Becker等人根据以下标准创建了一个多部分奖励函数：从单个输入调用的程序函数的数量、是否存在错误以及来自程序的响应消息存在的潜在损坏或延迟。错误的存在是向代理发出的最强信号，表明它已到达代码空间的一个有趣部分。即使在没有错误信号的情况下，程序的响应也被用来指导代理。奖励函数的每一部分都在指导代理人方面都起着各自的作用，如果忽略这些标准，可能会导致代理人的效率降低。Bottinger等人试验了多种不同的奖励函数，一种使用代码覆盖率，另一种使用执行时间，第三种结合代码覆盖率和执行时间。在这两项研究中，奖励函数都会影响fuzzer对输入空间的探索。例如，当Bottinger使用执行时间作为奖励时，代理学习导致程序快速终止的输入。Becker和Bottinger的工作都表明需要仔细定义奖励函数，考虑到软件程序类型、寻找的bug类型、可用的fuzz度量以及最终的fuzz目标。</p>
<p>标准的fuzzer还没有实现RL，这些应用仍然是理论上的。目前还不清楚奖励函数应该如何依赖于程序，或者是否存在普遍有效的奖励函数。例如，相同的奖励函数可以用于每个项目，还是每个独特的项目都需要一个独特的奖励函数？文件格式（如PDF和PNG）如何影响奖励函数的定义？RL面临的另一个挑战是解决代理的可转移性。目前还不清楚是否有必要为每个独特的程序训练一个新的RL代理，这样做可能是不切实际的。因此，研究和创造可转让代理可能是未来研究的必要步骤。</p>
<h5 id="machine-learning-for-symbolic-execution">Machine Learning for Symbolic Execution</h5>
<p>有监督学习被用于求解约束方程。</p>
<p>在一项研究中，图形神经网络被用来识别表明约束方程是否有有效解的特征。在另一项研究中，吴使用了逻辑回归和蒙特卡罗方法相结合的方法来确定初始值，从而提高了找到约束方程有效解的概率。蒙特卡罗方法用于确定初始有希望的值，而逻辑回归则用于说明使用这些选择值的约束方程解的有效性。合并这些新的初始值会减少Minisat solver的运行时间。在另一项研究中，LSTM（即DL）被训练用于求解约束方程。虽然LSTM无法击败最先进的约束求解器，但它们能够从未经训练的域中求解约束方程，这表明DL模型具有泛化能力。Shiqi等人开发的另一种方法使用NNs表示约束方程。这些约束方程的解通过梯度下降被发现。</p>
<p>Mairy等人使用RL改进了局部邻域搜索方法。局部邻域搜索方法通过求解约束方程的各个子集，并将这些子集组合起来形成最终解，从而迭代地找到约束方程的解。为了发现有用的子集，这些局部邻域搜索方法必须智能地探索可能的子集空间。引导RL代理选择更可能导致有效解决方案的子集，以减少找到此类解决方案所需的时间。</p>
<p>还有一项研究工作使用ML来减少解搜索空间的大小，而不是直接求解约束方程。Li等人将路径约束的典型集合重新表述为优化问题，并试图减少不可行路径的数量，即由于约束冲突而永远无法到达的路径。他们使用ML技术RACOS来解决优化问题，这是一种优化技术，可以很好地扩展到高维问题，然而只分析了非常小的程序。</p>
<h4 id="post-fuzzing-interesting-program-states-1">Post-Fuzzing: Interesting Program States</h4>
<p>ML主要用于分类崩溃（分类）或分类错误（根本原因分析），不过也有例外，Yan等人使用贝叶斯方法和!exploitable工具来提高确定漏洞可利用性的可靠性。</p>
<p>Dang等人使用aggregative hierarchy clustering将具有类似调用堆栈的崩溃进行分组，这是一种无监督学习技术，可以对具有类似特征的数据点进行聚类。在调用堆栈上引入了位置相关模型，允许使用未标记的调用堆栈数据集进行训练。他们在微软的各种产品上测试了他们的模型，并且在很多情况下比以前的碰撞相似性识别方法表现得更好。Harsh等人使用多种监督技术（包括决策树、支持向量机和朴素贝叶斯）对根本原因分类进行了实验，但是标记数据不够。为了解决缺少标记数据的问题，Harsh等人还尝试了无监督和半监督技术，但是bug的类别是非常广泛的，且每个系统bug不一样。</p>
<p>在另一项研究中，Long等人使用ML来确定根本原因，并生成修补程序来修复相关的bug。他们的工具Prophet使用了一个参数化的对数线性概率模型，该模型能够识别决定一段代码必须如何修复的重要特征。这项工作的一个重要方面是Prophet模型的可解释性；模型参数可用于确定生成特定patch的各种特征的重要性。这种可解释性非常重要，因为它可以帮助用户理解生成特定修补程序的原因。</p>
<p>有监督的ML技术用于识别软件领域之外的根本原因分析。在一个例子中，决策树和支持向量机被用于工业生产系统的根本原因分析。在另一个例子中，神经网络用于工业储罐系统内的故障定位。支持向量机在加速电路板故障定位方面也显示出良好的前景。虽然这些研究都没有直接应用到软件上，但是可以扩展研究以帮助软件领域的根本原因分析。</p>
<p>ML很少应用于Post-Fuzzing，原因有二。首先，大多数ML分类技术返回的是预测，而不是解释。这使得用户很难确定预测的标签是否正确以及为什么应用该标签。例如，在根本原因分析中，用户会发现很难理解根本原因应该在代码中显示在哪里，或者验证标签，或者纠正根本原因。此外，ML算法往往建立不透明的规则，很难映射到领域知识。其次，只有极少数可用的标记数据集，目前还不清楚什么是强大的、可概括的基准数据集。在为Post-Fuzzing构建数据集时，有几个没有明确答案的问题必须解决：应该包括哪些可能的错误？应该表示为哪些编程语言？应该如何为ML算法编码错误及其根本原因？特别是考虑到根本原因是细微差别的，并且可能因系统而异？</p>
<h4 id="seed-selection">Seed selection</h4>
<p>用ML进行种子选择方面的研究很少。Wang等人进行了一项广泛的研究，使用NNs来选择更可能导致模糊代码中的漏洞的输入。虽然这项研究显示了有希望的结果，但诸如训练模型到新项目的可转移性等挑战仍然存在。与输入生成一样，模型的可传递性仍然是ML应用于种子选择的潜在瓶颈。</p>
<p>先前的种子选择研究指出了未来ML研究的另一种可能性。种子选择必须在使用已知性能水平的当前输入与探索未知但可能更好性能的新输入之间取得平衡。RL算法通常成功地应用于这类需要平衡新输入的探索和当前输入的利用的场景中。因此，RL算法可能非常适合于确定最优种子调度。未来的研究可能包括：为最佳种子选择创建奖励函数；确定离线RL代理在程序之间的可转移性；在fuzzing中集成在线RL代理。</p>
<h2 id="a-systematic-review-of-fuzzing-based-on-machine-learning-techniques">A systematic review of fuzzing based on machine learning techniques</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv19_Machine2.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>机器学习技术在模糊测试中的应用的实质是将漏洞检测作为一个程序或样本分类的问题来对待。研究人员利用现有的机器学习技术帮助fuzzer从现有的大量脆弱性相关数据中提取经验和知识，然后根据训练生成的模型对新样本进行分类和预测。</p>
<p><img src="/png/2021-02-21-17-00-18.png"></p>
<h3 id="applying-machine-learning-techniques-for-different-fuzzing-steps">Applying Machine Learning Techniques for Different Fuzzing Steps</h3>
<h4 id="seed-file-generation">Seed file generation</h4>
<p>利用机器学习技术可以学习传统模糊测试中导致代码覆盖率更高、崩溃次数更多、执行路径更独特的种子文件的共同特征，并通过基于语法或基于变异的方法生成更多具有该特征的种子文件。</p>
<p>Skyfire实现的data-driven种子生成方法使用PCFG（包含语义规则和语法特征的Probabilistic context-sensitive grammar）自动提取语义信息。这些语义信息和语法规则用于种子生成，从而保证生成的种子文件通过语法分析和语义检查。Skyfire可以执行到目标程序的更深路径，从而更有效地发现深层漏洞；Fast fuzzing使用深层神经模型来增强随机突变测试的有效性，从AFL生成的样本中学习特征并生成种子文件，通过生成对抗网络（GAN）的对抗训练增加执行路径；SmartSeed读取输入文件并将其转换为二进制形式的统一类型矩阵，然后使用WGAN和MLP从收集的数据集中自动学习触发唯一崩溃或唯一路径的特征。经过训练的模型可以生成更容易导致崩溃和唯一路径的种子文件；Cheng等人使用RNN和seq2seq找到PDF文件和目标程序执行路径之间的相关性。然后，这种相关性被用来生成新的种子文件，这些文件更有可能在目标程序中探索新的路径；NeuFuzz通过LSTM学习样本中已知的漏洞程序和隐藏的漏洞模式，发现可能包含漏洞的执行路径，然后优先执行能够覆盖包含漏洞路径的种子文件，并根据预测结果为这些种子文件分配更多的变异能量。</p>
<h4 id="testcase-generation">Testcase generation</h4>
<p>Samplefuzz首次尝试使用基于神经网络的统计学习技术从样本输入自动生成输入语法，提出了一种基于seq2seq递归神经网络的PDF对象自动学习生成模型，并对其进行了评价。该模型不仅可以生成大量新的testcase，而且可以提高覆盖率；Fan等人提出了一种为专有网络协议自动生成黑盒模糊testcase的方法，该方法使用seq2seq来处理专有网络协议的通信流量来学习生成的输入模型，并使用该学习模型生成testcase；GANFuzz通过在生成对抗网络中训练生成的模型来学习协议语法，以估计工业网络协议消息的潜在分布函数，基于这个生成模型可以生成一个格式良好的testcase；DeepSmith将随机程序的生成作为一个语言建模问题，使用LSTM模型在代码语料库上学习编程语言的语法、语义、常规结构和模式，并根据编译器模糊化的生成方法生成语法格式的testcase；Sablotny等人构建了堆叠RNN的模型，以生成HTML标记和新的testcase，用于fuzz浏览器的渲染引擎，其主要思想是根据从大量HTML标记中学习字符序列的概率分布来生成HTML标记；IUST DeepFuzz使用基于深度递归神经网络（RNN）的神经语言模型（NLM）学习复杂输入文件的结构，IUST DeepFuzz首先删除输入文件的非文本部分，并用令牌替换它，在训练结束后，用删除部分的变体替换令牌以生成新的testcase；NEUZZ进一步提出了一种梯度引导搜索策略，该策略计算并使用平滑近似梯度（即NNs模型）来识别目标突变位置，这可以最大化目标程序中检测到的bug数量；Paduraru等人对不同文件格式的语料库进行了聚类，将输入文件的语料库作为一系列字符，通过seq2seq学习每个聚类的生成模型，该方法可以在训练好的模型的基础上生成新的testcase，从而可以执行更多的分支；Li等人提出了一种基于WGAN的工业控制协议testcase生成方法，在不知道具体协议规范的情况下，通过实际数据帧的结构和分布生成相似的数据帧；DeepFuzz通过seq2seq模型从原始GCC测试套件学习正确的C程序语法，该模型基于所学语法生成语法正确的C程序，然后使用insert、replace和remove策略生成testcase来fuzz编译器；V-Fuzz构建了一个图形嵌入式网络来训练脆弱性预测模型，根据训练后的模型，引导fuzzer生成倾向于到达潜在漏洞区域的testcase。</p>
<h4 id="testcase-filter">Testcase filter</h4>
<p>Testcase filter的目的是从大量样本中选择更有可能触发新路径或漏洞的样本，利用机器学习技术可以对样本进行分析和分类。</p>
<p>Gong等人基于AFL生成的样本训练了一个深度学习模型，通过训练模型可以预测新一轮AFL生成的样本是否会改变程序状态；Augmented-AFL实现了几种神经网络架构，以学习预测给定输入修改集的预期代码覆盖率的能力。在fuzzing中，学习函数用于预测完整输入文件的热图，对应于每个文件位置突变导致新代码覆盖的概率。然后使用覆盖图确定突变位置的优先级；Siddharth将程序输入映射到执行轨迹，并对执行轨迹分布的熵进行排序。Siddharth假设不确定性越高，执行新代码路径的可能性越大，因此选择熵最大（最不确定）的输入来执行下一个输入。</p>
<h4 id="mutation-operator-selection">Mutation operator selection</h4>
<p>Becker等使用一个有限状态机并分解了不同的消息类型来分析neighbor discovery协议。工作的主要思想是利用基于跟踪、调试和监控三种不同奖励函数的强化学习模型对模糊化网络进行优化，选择最佳的模糊化测试策略；LEFT构建了一个基于强化学习的模型对Android手机中的LTE功能进行fuzz。该模型主要包括三种模糊处理方法：emulation-instrumented black-box fuzzing，threat-model-aware fuzzing，RL-guided fuzzing；受反馈驱动随机测试和强化学习的启发，Böttinger等人提出了第一种使用强化学习的模糊化方法，以最大限度地提高代码覆盖率和减少处理时间。该模型可以在获得高收益的情况下学习突变的运行特征；FuzzerGym使用LLVM Santizers的程序监视器获取状态信息，这些信息被用来优化基于强化学习（RL）的变异算子选择。结合强化学习和模糊化的优点，通过OpenAI-Gym与libFuzzer的集成，实现对多个基准的更深入的覆盖，并直接从输入数据中实现变异选择策略的学习；Karamcheti等人提出了一种基于robers的Thompson抽样优化方法，该方法可以在fuzz单个程序的过程中自适应调整变异算子的分布。通过学习每个变异算子对代码覆盖率的影响，确定应该选择哪个变异算子。最后，在下一次迭代中使用所选择的变异算子对测试输入进行变异；FUZZBOOST使用从运行时跟踪收集的代码覆盖率信息作为奖励，并使用Deep Q-learning算法优化此奖励。通过这样做，模糊代理学习如何选择变异算子对种子程序进行变异，以提高模糊测试的覆盖率。</p>
<h4 id="fitness-function">Fitness function</h4>
<p>Xiao等人提出了一种新的基于遗传规划的适应度函数，不同于目前主流的基于代码覆盖率的方法。它将马尔可夫链和PCFG模型相结合，从程序员开发的普通脚本语料库中学习脚本的共性，并计算测量脚本与普通脚本的偏差。该偏差用于计算基于GP的语言模糊脚本的性能，并认为偏差较大的脚本更容易引发解释器的错误。</p>
<h4 id="exploitability-analysis">Exploitability analysis</h4>
<p>常用的脆弱性分析方法有静态分析和动态分析，采用工具技术如!exploitable，CERT tools。</p>
<p>ExploitMeter使用贝叶斯机器学习算法对从软件中提取的静态特征进行初始判断。将fuzzing中的初始判断和可利用性判断相结合，更新最终的可利用性结果；Exniffer建议使用机器学习来自动确定碰撞可利用性预测的更一般规则。该方法使用支持向量机（SVM）学习从核心转储文件（崩溃期间生成）中提取的特征和从最新处理器硬件调试扩展中获取的信息；Zhan等人基于n-gram分析和特征散列生成紧凑的指纹，用于动态跟踪每个崩溃输入。然后将指纹输入在线分类器，建立识别模型。在线分类器支持的增量学习允许模型即使在大量崩溃时也能很好地扩展，同时对于新的崩溃也很容易更新。</p>
<h3 id="analysis-of-machine-learning-based-fuzzing-model">Analysis of Machine Learning Based Fuzzing Model</h3>
<h4 id="selection-of-machine-learning-algorithm">Selection of machine learning algorithm</h4>
<p><img src="/png/2021-02-23-20-39-01.png"></p>
<p>传统的机器学习技术需要人工提取特征，然而输入样本格式和目标程序都包含复杂的语法和语义结构，并且没有有效的漏洞模型或漏洞特征。</p>
<p>深度学习依赖于它的表征学习，能够自动提取模糊测试中广泛应用的特征。最常用的两种算法是LSTM和seq2seq，LSTM使用最多的原因是它擅长处理顺序数据：程序执行路径与自然语言中的语句非常相似，一段代码是否包含漏洞取决于上下文。另一方面，LSTM具有适于处理长依赖关系的记忆功能，因为与漏洞相关联的代码可能位于路径中相对较长的距离处。seq2seq模型的输入输出序列长度是可变的，可以有效地利用模糊化的输入作为文本数据来学习局部或全局的语法信息。模糊测试中还使用了新的神经网络，如生成对抗网络和图卷积网络。</p>
<p>在模糊测试中，由于强化学习需要在不同的环境中选择不同的行为，因此强化学习被用于变异算子的选择，这与变异算子的选择类似。然而，强化学习本身存在训练时间长、收敛性弱、局部优化等局限性，导致其在模糊测试中的应用较少。</p>
<h4 id="pre-processing-method">Pre-processing method</h4>
<p><img src="/png/2021-02-23-20-40-35.png"></p>
<p>由于PUT的类型不同，输入格式也有很大的不同，这些数据需要转换成可用于机器学习的输入。预处理方法分为三类：程序分析、自然语言处理和其他。</p>
<p>程序分析是指利用静态或动态分析技术提取程序特征或运行时信息，如堆栈、寄存器、汇编指令、跳转、程序控制流图、抽象语法树和程序执行路径等；自然语言处理是指直接以文本形式输入的方法，利用复杂的文本处理技术提取输入数据中隐藏的特征，如n-gram、count statistics、Word2vec、heat map等方法；其他包括将程序分析与自然语言处理技术相结合，或将整个文档或pdf对象转换为向量分析，以及自定义方法（测试用例的二进制序列用32位表示，模糊技术用4位表示，变异位用10位表示，变异值用32位表示，是否是新测试用例用1位表示。最后，每段数据都可以组合成一个79位的二进制序列，第一个78位作为输入，最后一个1位作为标签）。</p>
<h4 id="datasets">Datasets</h4>
<p>机器学习的性能主要受训练数据的影响，目前用于基于机器学习算法的模糊测试的数据集有以下来源：网络爬虫，fuzzing过程中产生，自建，公共数据集。</p>
<h4 id="evaluation-metrics">Evaluation metrics</h4>
<p><img src="/png/2021-02-23-21-17-04.png"></p>
<p><img src="/png/2021-02-23-21-17-18.png"></p>
<p>基于机器学习技术的fuzz的性能评价可以分为两个方面：机器学习模型的性能评价和漏洞检测能力的评价。机器学习模型的评价是基于分类度量的，而基于机器学习的模糊方法的漏洞检测能力评价与传统的模糊方法基本相同，由于基于机器学习的模糊化方法有模型训练、特征提取等步骤，因此效率这一指标也被大量文献所采用。</p>
<h4 id="hyperparameters-setting">Hyperparameters setting</h4>
<p>在机器学习模型的实现中，Hyperparameters的值不是通过训练得到的，而是需要在训练前进行人工设置。一般来说，需要对超参数进行优化，选择一组最优的超参数来提高学习的性能和有效性。</p>
<p><img src="/png/2021-02-23-21-19-03.png"></p>
<p>深度学习算法中的超参数主要用来完成比较，包括层数、每层节点数、epoch数、激活函数和学习率。当每层中的节点数较大时会发生过拟合。随着epoch数的增加，神经网络的权值更新迭代次数增加，损失函数曲线从初始的不拟合状态进入最优拟合状态。激活函数的选择可以提高神经网络的建模表达能力，解决线性模型无法解决的问题。然而，不同激活函数的优缺点是不同的，例如sigmoid输入范围在0和1之间，但存在"sigmoid saturate and kill gradients"而不是"zero-centered"的问题。Tanh解决了sigmoid输出不"zero-centered"的问题，但仍存在其他问题。学习速率控制着模型的学习进度，也影响着模型收敛到局部极小值的速度。较高的学习率容易导致损失值的爆炸和冲击，而较低的学习率会导致过拟合和收敛速度减慢速度。</p>
<h3 id="future-directions">Future Directions</h3>
<p>未来的方向可以从以下三个方面进行：</p>
<ol type="1">
<li>数据集。将机器学习引入fuzz必须建立开放且全面的数据集，作为测试基准。</li>
<li>特征选择。程序的结构和执行信息与漏洞没有直接关系，因此如何从程序或样本中选择实用的特征成为影响fuzz性能的一个重要因素。目前自然语言处理技术比较成熟，可以考虑利用自然语言处理领域的先进技术，提取程序的代码属性、语义和语法特征等有用信息进行fuzz。</li>
<li>学习算法的选择。应根据fuzz不同阶段的特点、对应数据的大小、不同算法的优缺点作为算法选择的依据。其次，graph convolutional networks，fusion neural networks和interpretable deep learning models都可以尝试与fuzz相结合，有必要研究更复杂、更合适的神经网络模型来提高生成样本的质量。</li>
</ol>
<h2 id="the-art-science-and-engineering-of-fuzzing-a-survey">The Art, Science, and Engineering of Fuzzing: A Survey</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/TSE19_Survey.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<ul>
<li>Fuzzing test：模糊测试是使用fuzzing测试被测程序是否存在违反安全策略。</li>
<li>Fuzzer：fuzzer是在被测程序上执行fuzz测试的程序。</li>
<li>Fuzz Campaign: 在特定安全策略下的一轮fuzz，目的是发现违反安全策略的bug。</li>
<li>Bug Oracle：检测程序执行是否违反安全策略的一种机制。</li>
<li>Fuzz Configuration：Fuzz算法的参数值。</li>
</ul>
<h3 id="systemization-taxonomy-and-test-programs">SYSTEMIZATION, TAXONOMY, AND TEST PROGRAMS</h3>
<p>几乎所有的fuzz算法都依赖于PUT之外的一些参数，这些参数的设置称为模糊配置。</p>
<p><img src="/png/2021-02-26-20-55-03.png"></p>
<p>上图是一个用于模糊测试的通用算法模型，算法以一组模糊配置C和一个超时时间作为输入，输出为发现的bug。第一部分是预处理函数，它在模糊活动开始前执行。第二部分是循环中的五个函数：SCHEDULE，INPUTGEN，INPUTEVAL，CONFUPDATE，CONTINUE。有些fuzzer并没有实现所有五个函数。</p>
<ul>
<li>PREPROCESS：以一组fuzz配置C作为参数，并返回一组可能被修改的fuzz配置。预处理可以执行多种操作，例如向PUT进行插桩，或者测量种子的执行速度。</li>
<li>SCHEDULE：以一组fuzz配置C、当前时间和预计时间作为参数，并返回一个fuzz配置conf用于该轮fuzz。</li>
<li>INPUTGEN：以当前fuzz配置conf作为参数，并返回一组具体的测试用例tcs。一些fuzzer使用conf中的种子来生成测试用例，而另一些使用模型或语法。</li>
<li>INPUTEVAL：以当前fuzz配置conf、测试用例tcs和一个嵌入在fuzzer中的Obug（bug oracle）作为参数，使用Obug和测试用例tcs执行PUT并返回每个fuzz运行时获取的信息集，这些信息可用于更新fuzz配置。</li>
<li>CONFUPDATE：以一组fuzz配置C、当前配置conf和每个fuzz运行时获取的信息集作为参数，CONFUPDATE会更新这组fuzz配置。</li>
<li>CONTINUE：以一组fuzz配置C作为参数，并输出一个布尔值指示是否应该继续。</li>
</ul>
<h3 id="preprocess">PREPROCESS</h3>
<p>预处理通常用于检测PUT、剔除潜在的冗余配置、修剪种子以及生成驱动程序应用程序，预处理也可用于为INPUTGEN准备模型。</p>
<ul>
<li>Instrumentation：静态插桩通常通过在编译时对源代码或中间代码修改来进行，除了基于源代码的工具之外，研究人员还开发了二进制级静态插桩（即二进制重写）工具。动态插桩比静态插桩有更高的开销，因为它是在运行时执行的，动态插桩工具：DynInst、DynamoRIO、Pin、Valgrind和QEMU。AFL支持在源代码级别使用修改过的编译器进行静态插桩，或者在QEMU的帮助下在二进制级别进行动态插桩。使用动态插桩时，AFL可以插桩PUT本身中的可执行代码（默认设置），或着PUT和任何外部库中的可执行代码（AFL_INST_LIBS选项）。第二个选项会检测所有遇到的代码，获取包括外部库中代码的覆盖率信息，从而提供更完整的覆盖率图。</li>
<li>Execution Feedback：灰盒fuzzer通常将执行反馈作为参数来生成新的测试用例。路径覆盖有AFL（覆盖率），CollAFL（解决hash冲突）。节点覆盖有LibFuzzer，Syzkaller。</li>
<li>Thread Scheduling：通过显式控制线程的调度方式来触发不同的不确定性的程序行为，例如条件竞争漏洞。</li>
<li>In-Memory Fuzzing：模糊大型程序的一种方法是在程序初始化之后对PUT进行快照，这样就可以通过恢复内存快照直接进行一次新的执行，这种方法也适用于模糊网络应用程序，称为内存模糊化。一些fuzzer在每次迭代后只对函数执行内存模糊化，而不恢复整个PUT的状态，这种技术叫做内存API模糊化。AFL有一个名为persistent mode的选项，它在循环中重复执行内存API模糊化，而不重新启动进程，这相当于忽略了在同一执行中多次调用函数的潜在副作用。</li>
<li>Seed Selection：即减小初始种子池大小，常见的有minset，它找到一组最小的种子，使覆盖度量（如节点覆盖）最大化。fuzzer在实践中使用各种不同的覆盖度量，AFL的minset基于分支覆盖率，而Hongfuzz基于执行的指令、分支和基本块的数量来计算覆盖率。</li>
<li>Seed Trimming：种子修剪，即减小种子的大小，较小的种子可能消耗更少的内存，并带来更高的吞吐量。种子修剪可以发生在预处理时，也可以作为更新的一部分。</li>
<li>Preparing a Driver Application：当fuzz的目标是一个库时，需要研究人员准备一个调用了库中函数的驱动程序。类似地，内核fuzzer可以利用fuzz用户态程序来测试内核，IoTFuzzer通过让驱动程序与相应的智能手机应用程序通信，将IoT设备作为目标。</li>
</ul>
<h3 id="scheduling">SCHEDULING</h3>
<p>调度即为下一次模糊迭代选择一个模糊配置，模糊配置的内容取决于fuzzer的类型，对应的问题称为FCS问题（Fuzz Configuration Scheduling）。</p>
<h4 id="black-box-fcs-algorithms">Black-box FCS Algorithms</h4>
<p>Black-box FCS Algorithms依据的信息为配置的模糊结果、发现的崩溃和错误的数量以及迄今为止花费在该配置上的时间。</p>
<p>Householder和Foote是第一个研究如何在CERT-BFF中利用这些信息的人，Woo等人在多个方面进一步改进了他们的结果。首先，他们将模型细化为Weighted Coupon Collector's Problem with Unknown Weights(WCCP/UW)。其次，他们将multi-armed bandit(MAB)算法应用于模糊化，这是当面临勘探与开发冲突时的常见应对策略。第三，他们将配置的成功概率与已经花费在配置中的时间关联，从而选择更快的配置。第四，他们重新定义了fuzz迭代，从运行固定数量的fuzz进程变为运行固定时间，进一步降低了较慢配置的优先级。</p>
<h4 id="grey-box-fcs-algorithms">Grey-box FCS Algorithms</h4>
<p>Grey-box FCS Algorithms拥有更丰富的信息集，例如覆盖范围。</p>
<p>AFL是这一领域的先驱，它基于evolutionary algorithm(EA)，EA维护一组配置，每个配置都有一些适度值，EA会选择合适的配置，并对其进行突变和重组。同时AFL会维护一个配置队列，从中选择下一个合适的配置。AFL会将更多的运行时间分配给速度最快、分支覆盖率更高的配置。</p>
<p>Bohme等人的AFLFast在三个方面改进了AFL：To start, it modifies configuration fitness setting and selection to prioritize exploration of new and rare paths. Moreover, AFLFast fuzzes a selected configuration a variable number of times as determined by a power schedule. Its FAST power schedule starts with a small “energy” value to ensure initial exploration among configurations and increases exponentially up to a limit to quickly ensure sufficient exploitation. Finally, it also normalizes the energy by the number of generated inputs that exercise the same path, thus promoting explorations of less-frequently fuzzed configurations.</p>
<p>AFLFast中的创新已作为FidgetyAFL的一部分集成到AFL中，AFLFast最大的改进就是会快速检查所有新添加的种子。在相关工作中，AFLGo通过修改其优先级属性针对特定的程序位置。Hawkeye通过在种子调度和输入生成中利用静态分析进一步改进了定向模糊。FairFuzz通过为每对种子和一个稀有分支使用一个mutation mask来指导fuzzing，以探索稀有分支。QTEP使用静态分析来推断二进制文件的哪个部分更有可能存在漏洞，并优先考虑覆盖这些地方的配置。</p>
<h3 id="input-generation">INPUT GENERATION</h3>
<h4 id="model-based-generation-based-fuzzers">Model-based (Generation-based) Fuzzers</h4>
<p>一些fuzzer可以由用户自定义模型，例如Peach、PROTOS和Dharma。Autodafe、Sulley、SPIKE、SPIKEfile和LibFuzzer也公开了创建自定义输入模型的API。Tavor接受以Extended Backus-Naur form（EBNF）编写的输入规范。类似地，PROTOS、SNOOZE、KiF和TFuzz等网络协议fuzzer也由用户配置协议规范。Kernel API fuzzers通常以系统调用模板的形式定义输入模型，通过指定系统调用的参数的数量和类型生成测试用例。Nautilus使用基于语法的输入生成，并使用语法进行种子修剪。</p>
<p>其他基于模型的fuzzer以特定的语言或语法为目标，其模型包含在fuzzer中。例如，cross fuzz和DOMfuzz生成随机文档对象模型（DOM）对象。jsfuzz基于语法模型生成随机但语法正确的JavaScript代码。QuickFuzz利用现有的Haskell库来描述生成测试用例时的文件格式。网络协议模糊器Frankencerts、TLS-Attacker、tlsfuzzer和llfuzzer是根据特定网络协议（如TLS和NFC）的模型设计的。</p>
<p>LangFuzz通过解析输入种子来生成代码片段，其随机的组合这些片段，并将种子与片段突变，以生成测试用例，LangFuzz应用于JavaScript和PHP。而BlendFuzz基于与LangFuzz类似的思想，以XML和正则表达式解析器为目标。</p>
<p>PREPROCESS中的模型推理：TestMiner搜索PUT中可用的数据，如文字，以预测合适的输入；给定一组种子和一个语法，Skyfire使用数据驱动的方法来推断probabilistic context-sensitive grammar，然后使用它来生成语义上有效的输入；IMF通过分析系统API日志学习内核API模型，并生成C代码，该代码使用推断出的模型调用一系列API调用；CodeAlchemist将JavaScript代码分解为代码块并计算组装约束，这些约束描述了何时可以将不同的代码块组装或合并在一起以生成语义上有效的测试用例，使用静态和动态分析计算这些约束；Neural和Learn&amp;Fuzz使用基于神经网络的机器学习技术从一组给定的测试文件中学习模型，然后从推断的模型中生成测试用例，Liu等人提出了一种类似的方法，专门针对文本输入。</p>
<p>CONFUPDATE中的模型推理：PULSAR从捕获的网络数据包中自动推断出网络协议模型，然后用于模糊程序，PULSAR在内部构建一个状态机，并判断哪个消息令牌与一个状态相关，这些信息稍后用于生成覆盖状态机中更多状态的测试用例；Doupe等人提出了一种通过观察I/O行为来推断web服务状态机的方法，然后使用推断出的模型来扫描web漏洞；Ruiter等人的工作类似，但它以TLS为目标，并以LearnLib为实现基础；GLADE从一组I/O样本中合成一个上下文无关语法，并使用推断的语法模糊PUT；gofuzz是一个灰盒fuzzer，它为添加到其种子库中的每个种子建立一个模型，此模型用于从该种子生成新的输入；为了克服符号执行的局限性，Shen等人使用神经网络来解决困难的分支条件。</p>
<p>fuzz的对象通常是文件解析程序。许多文件格式都有相应的编码程序，可以看作是文件格式的隐式模型。MutaGen利用编码器程序中包含的隐式模型来生成新的测试用例，与大多数基于变异的fuzzer不同，MutaGen对编码器程序进行变异。Specifically, to produce a new test case MutaGen computes a dynamic program slice of the encoder program and runs it. The underlying idea is that the program slices will slightly change the behavior of the encoder program so that it produces test cases that are slightly malformed.</p>
<h4 id="model-less-mutation-based-fuzzers">Model-less (Mutation-based) Fuzzers</h4>
<p>大多数无模型fuzzer通过变异种子来生成新的输入，下面是常见变异方法。</p>
<ul>
<li>Bit-Flipping：翻转bit位。</li>
<li>Arithmetic Mutation：AFL和honggfuzz采用了算数变异，它们将选定的字节序列视为整数，并对其执行简单的算术运算后替换。</li>
<li>Block-based Mutation：将随机生成的块插入种子的随机位置；从种子中删除随机选择的块；用随机值替换随机选择的块；随机重组随机块序列的顺序；通过附加随机块来调整种子大小；从种子中取出随机块后插入另一种子的随机块。</li>
<li>Dictionary-based Mutation：一些fuzzer使用一组预定义的特殊值进行替换。例如，AFL、honggfuzz和LibFuzzer在对整数进行变异时使用0、−1和1等值。Radamsa使用Unicode字符串，GPF使用格式化字符（如%x和%s）来改变字符串。</li>
</ul>
<h4 id="white-box-fuzzers">White-box Fuzzers</h4>
<p>白盒fuzzer也可以分为基于模型的fuzzer和无模型的fuzzer，并非所有白盒fuzzer都是动态符号执行器。</p>
<p>一些fuzzer利用白盒程序分析来生存PUT接受的输入，以便与黑盒或灰盒模糊一起使用，与灰盒或黑盒方法相比，动态符号执行速度较慢，一种常见的策略是缩小其使用范围。QSYM试图通过实现一个快速的concolic执行引擎来改进灰盒模糊和白盒模糊之间的集成；DigFuzz通过首先估计使用灰盒模糊的每条路径的执行概率来优化灰盒模糊和白盒模糊之间的切换。</p>
<p>一些fuzzer利用静态或动态程序分析技术来增强fuzz的有效性，例如预处理阶段的程序分析和利用程序分析的结果生成测试用例。TaintScope使用细粒度的污点分析来查找热字节，即流入关键系统调用或API调用的输入字节；Dowser在编译过程中执行静态分析，根据启发式方法查找可能包含bug的循环，它查找包含指针解引用的循环，然后通过污点分析计算输入字节和候选循环之间的关系。Dowser还使用了动态符号执行，但仅使关键字节具有符号性；VUzzer和GRT利用静态和动态分析技术从PUT中提取控制流和数据流特征，并使用它们指导输入生成。</p>
<p>Angora和RedQueen首先运行每个种子，然后使用其运行时信息生成输入，从而降低了分析成本。Angora使用污点分析将每个路径约束与相应的字节相关联，然后执行一个受梯度下降算法启发的搜索，以引导其突变来解决这些约束；RedQueen试图通过检测所有比较运算并查找它们的操作数与给定输入之间的对应关系来检测PUT中如何使用输入，一旦找到匹配项，就可以用来求解约束。</p>
<p>基于变异的fuzzer还有一个问题就是如何绕过校验和验证。TaintScope提出了一种校验和感知模糊技术，该技术通过污点分析识别校验和测试指令，并对PUT进行修补以绕过验证，一旦发现程序崩溃就为输入生成正确的校验和，以生成一个使未修改的PUT崩溃的测试用例；Caballero等人提出了一种称为缝合动态符号执行的技术，可以在存在校验和的情况下生成测试用例；T-Fuzz首先构建一组无需修改程序逻辑即可进行转换的分支，称为NCCs（Non-Critical Checks），当fuzz活动停止发现新路径时，它选择一个NCC，对其进行转换，然后在修改后的PUT上重新启动fuzz活动，当T-Fuzz在一个修改后的PUT上用发现崩溃后，就会用符号执行在原来的PUT上重建崩溃。</p>
<h3 id="input-evaluation">INPUT EVALUATION</h3>
<h4 id="bug-oracles">Bug Oracles</h4>
<p>研究人员提出了各种有效的程序验证来检测那些不安全或不需要的程序行为并中止程序，这种工具称为Sanitizers。</p>
<p>Memory and Type Safety：内存错误可以分为空间上的和时间上的。当指针在它要指向的对象之外解引用时，就会发生空间内存错误，例如缓冲区溢出和下溢。当指针不再有效后被访问时，会发生时间内存错误，例如UAF。Address Sanitizer(ASan)是一种快速内存错误检测器，ASan能够检测到空间和时间内存错误，ASan使用了一个影子内存，它会在指针解引用之前检查地址的有效性，从而检测到许多（但不是所有）不安全的内存访问；MEDS在分配的对象之间创建大量不可访问的内存区域，对ASan进行了改进，这些不可访问区域使被损坏的指针更有可能指向无效内存并导致崩溃；SoftBound/CETS是另一种内存错误检测器，SoftBound/CETS将边界和时间信息与每个指针相关联，从而可以在理论上检测所有的空间和时间内存错误，然而这种完整性带来了更高的平均开销。</p>
<p>Caves，TypeSan和HexType在编译时检测C++中错误的类型转化。另一类内存安全保护是控制流完整性(CFI)，CFI可以用来检测非法修改程序控制流的测试用例。</p>
<p>未定义的行为：Memory Sanitizer(MSAN)在编译期间使用程序来检测由C和C++中未初始化的内存使用引起的未定义行为。与ASan类似，MSan使用一个表示每个可寻址位是否初始化的阴影内存。Memory Sanitizer大约有150%的运行开销；Undefined Behavior Sanitizer(UBSan)在编译时修改程序以检测各种各样的未定义的行为，例如使用未对齐的指针、被零除、解引用空指针和整数溢出；Thread Sanitizer(TSan)是一种编译时修改，用于检测数据争用。当两个线程同时访问一个共享内存位置并且至少有一个访问是写访问时，就会发生数据争用。这样的错误会导致数据损坏，并且由于不确定性而极难重现。</p>
<p>输入验证：KameleonFuzz通过使用真实的web浏览器解析输入，提取DOM树，并将其与表示成功攻击的手动指定模式进行比较，来检测成功的XSS攻击；4SQLi使用类似的技巧来检测SQL注入。因为不可能从web应用程序响应可靠地检测SQL注入，4SQLi使用一个数据库代理来拦截目标web应用程序和数据库之间的通信，以检测输入是否触发了有害行为。</p>
<p>语义差异：语义错误通常是通过一种称为差异测试（differential testing）的技术发现的，这种技术比较相似（但不完全相同）程序的行为。一些fuzzer使用了差异测试来识别类似程序之间的差异，这些差异很可能表明存在bug。Jung等人引入了黑盒差分模糊测试，它使用对单个程序上的多个输入进行差分测试，以获取PUT的输入到其输出之间的映射，这些映射用于识别信息泄漏。</p>
<h4 id="triage">Triage</h4>
<p>Triage是分类和报告那些违规测试用例的过程，分类可以分为三个步骤：重复数据消除、优先级排序和测试用例最小化。</p>
<p>理想情况下，重复数据消除返回一组测试用例，每个测试用例触发一个唯一的bug。三种重复数据消除方法：stack backtrace hashing，coveragebased deduplication，and semantics-aware deduplication。</p>
<p>stack backtrace hashing：通过程序崩溃时的stack backtrace计算一个hash值。有些实现只对函数的名称或地址进行hash运算，而其他实现则同时对名称和偏移量或行数进行hash运算。现在某些实现会产生两个hash：一个主hash和一个次hash。主hash很可能将不同的崩溃分组在一起，因为它只对函数名进行hash，而次hash更精确，可用于细分。stack backtrace hashing的基本假设是：类似的stack backtrace是由类似的bug引起的，反之亦然。但这是缺乏理论证明的。</p>
<p>coveragebased deduplication：AFL记录每次执行PUT时的边缘覆盖率，并测量每条边缘的粗略命中计数。如果crash覆盖了之前没到达的边缘，或crash未覆盖所有早期crash中存在的边缘，则认为该crash是唯一的。</p>
<p>semantics-aware deduplication：RETracer通过分析core dump来检查是哪个指针导致了崩溃，并递归地标识哪个指令将坏值赋给了它，最终找到一个具有最大帧级别的函数并利用该函数分类crash。</p>
<p>优先级排序（Prioritization，又称fuzzer-taming问题）是根据违规测试用例的严重性和唯一性对其进行排序或分组的过程，优先级排序也可以看作分析crash的可利用性。早期的可利用性排名系统有微软的!exploitable，它采用了几种启发式方法和简化的污点分析，按以下标签进行分类：EXPLOITABLE，PROBABLY_EXPLOITABLE，UNKNOWN，NOT_LIKELY_EXPLOITABLE。</p>
<p>测试用例最小化将识别出一个违规测试用例中触发违规所必需的部分，并有选择地生成一个比原始测试用例更小、更简单但仍然会导致违规的测试用例。事实上，许多现有的最小化程序都是受delta debugging的启发。BFF包括一个针对模糊化的最小化算法，该算法试图最小化与原始种子文件不同的比特数；AFL还包括一个测试用例最小化器，它试图通过机会主义地将字节设置为零并缩短测试用例的长度来简化测试用例；Lithium是一个通用的测试用例最小化工具，它通过尝试移除相邻行或字节的块来最小化文件，这些块的大小是按指数递减的；还有各种各样的测试用例缩减器，它们不是专门为fuzz设计的，如delta debugging和C/C++文件的CurDue。</p>
<h3 id="configuration-updating">CONFIGURATION UPDATING</h3>
<p>黑盒fuzzer除了进行bug oracle外，不会执行任何操作，最多将违规测试用例添加到种子集。而灰盒和白盒fuzzer会根据收集到的信息对配置进行更新。C</p>
<h4 id="evolutionary-seed-pool-update">Evolutionary Seed Pool Update</h4>
<p>大多数基于EAs的fuzzer使用节点或分支覆盖率作为适应度函数：如果测试用例发现了新的节点或分支，则将其添加到种子池中。由于可到达路径的数量可以比种子的数量大几个数量级，因此种子池被设计成所有可到达路径的不同子选择，以表示当前对PUT的探索。</p>
<p>基于EAs的fuzzer中的一个常见策略是细化适应度函数，以便它能够检测到更细微和更细粒度的改进指标。例如，AFL通过记录分支被执行的次数来细化其适应度函数定义。STADS提出了一个受生态学启发的统计框架，以估计如果fuzzing继续下去，将会发现多少新的配置。</p>
<p>另一种常见的策略是，在计算复杂的分支条件时，考虑部分条件的满足。例如，LAF-INTEL简单地将多字节比较分解为几个部分，从而检测新种子何时通过中间部分字节的比较；LibFuzzer、honggfuzz、go fuzz和Steelix对所有比较进行数据化，并将任何在比较方面取得进展的测试用例添加到种子库中，类似的想法也被发布为一个用于clang的独立的工具模块；Steelix检查哪些输入偏移会影响比较指令；Angora通过考虑每个分支的调用上下文，改进了AFL的适应度标准；DeepXplore利用神经元覆盖率作为适应度函数，将模糊化应用于神经网络测试。</p>
<blockquote>
<p>VUzzer is an EA-based fuzzer whose fitness function relies on the results of a custom program analysis, which determines weights for each basic block. Specifically, VUzzer first uses a built-in program analysis to classify basic blocks as either normal or error-handling (EH). For a normal block, its weight is inversely proportional to the probability that a random walk on the CFG containing this block visits it according to transition probabilities defined by VUzzer. This favors configurations exercising normal blocks deemed rare by the aforementioned random walk. The weight of EH blocks is negative, which discourages the execution of error handling (EH) blocks. This assumes that traversing an EH block signals a lower chance of exercising a vulnerability since bugs often coincide with unhandled errors.</p>
</blockquote>
<h2 id="fuzzing-a-survey">Fuzzing: a survey</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Cybersecurity18_Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<h3 id="background-1">Background</h3>
<p>静态分析通过对词法、语法、语义特征的分析，以及对数据流的分析、模型检查，可以发现隐藏的bug。优点是检测速度快，缺点是由于缺乏易用的漏洞检测模型，静态分析工具容易产生大量的误报。</p>
<p>动态分析通过对程序运行状态的监控和分析，可以准确地检测程序错误。动态分析的优点是精度高，缺点是动态分析中目标程序的调试、分析和运行需要大量的人工参与。</p>
<p>符号执行将程序的输入符号化，同时为每个执行路径维护一组约束，然后使用约束求解器来求解约束，获得该路径的输入或者判断该路径不可达。从技术上讲，符号执行可以覆盖程序中的任何执行路径。但也存在许多局限性。首先是路径爆炸问题，随着程序规模的增大可能会超出约束求解器的求解能力，选择性符号执行是一种折衷方案。其次是与环境的相互作用，在符号执行中，当目标程序发生与符号执行环境之外的组件（如系统调用、处理信号等）交互时，可能会出现一致性问题。</p>
<p>从概念上讲，Fuzzing从生成大量输入到目标应用程序开始，通过将生成的输入反馈到目标应用程序并监视执行状态来检测异常。</p>
<h3 id="types-of-fuzzers">Types of fuzzers</h3>
<p>根据测试用例的生成方法，fuzzer可以分为基于语法的和基于变异的；根据对源代码的依赖程度和程序分析的程度，模糊器可分为白盒、灰盒和黑盒；根据程序探索策略的不同，模糊程序可分为定向模糊程序和基于覆盖的模糊程序；根据程序执行状态监控与测试用例生成之间是否存在反馈，模糊程序可分为哑模糊程序和智能模糊程序。</p>
<h3 id="coverage-based-fuzzing">Coverage-based fuzzing</h3>
<p>在程序分析中，程序由基本块组成。基本块是具有单个入口和出口的代码段，基本块中的指令将按顺序执行，并且只执行一次。在代码覆盖率度量中，最好的分析单元就是基本块，因为基本块是程序执行的最小相干单元，而且可以通过第一条指令的地址来识别，并可以通过代码插桩来获取执行信息。</p>
<p>有两种基于基本块的基本度量选择，简单地计算执行的基本块和计算基本块之间的转换。在后一种方法中，程序被解释为一个图，顶点表示基本块，边表示基本块之间的过渡。后者记录边，前者记录顶点。实验表明，简单地计算执行的基本块会导致严重的信息丢失。</p>
<p>AFL首次将边缘测量方法引入到基于覆盖的模糊处理中，其通过轻量级程序插桩获得覆盖信息。根据是否提供源代码，AFL提供了两种插桩模式：编译内插桩和外部插桩。在编译内插桩模式下，根据使用的编译器，AFL同时提供gcc模式和llvm模式，在生成二进制代码时，它将插入代码片段。在外部模式下，AFL提供qemu模式，当基本块转换为TCG块时，它将插入代码片段。</p>
<p>fuzzer跟踪执行有两个目的，计算代码覆盖率和检测安全违规。代码覆盖率信息用于进行彻底的程序状态探索，安全违规跟踪用于更好地发现bug。AFL通过代码插桩和位图跟踪代码覆盖率，安全违规追踪则在许多Sanitizer的帮助下进行，比如AddressSanitizer，DataFlowsanitizer，ThreadSanitizer，LeakSanitizer等。</p>
<p><img src="/png/2021-03-03-18-07-52.png"></p>
<p>上图显示了AFL的工作过程。在主模糊循环中，AFL会优先选择最快和最小的种子；然后根据变异策略对种子文件进行变异，生成一组测试用例，包括可变长度和步进的顺序位翻转、小整数的顺序加减和已知有趣整数（如0、1、INT_MAX等）的顺序插入等；执行测试用例并跟踪程序状态。收集覆盖信息以确定有趣的测试用例，即到达新控制流边缘的测试用例。有趣的测试用例被添加到下一轮运行的种子池中。</p>
<h4 id="how-to-get-initial-inputs">How to get initial inputs?</h4>
<p>收集种子输入的常用方法包括使用标准样本、从互联网获取和使用现有的POC样本。过多的种子输入会造成第一次试运行的时间浪费，AFL提供了一个工具以提取实现相同代码覆盖率的最小输入集。</p>
<h4 id="how-to-generate-testcases">How to generate testcases?</h4>
<p>Rawat等人提出了Vuzzer，一种集成静态和动态分析的应用程序感知灰盒模糊器。种子输入的变异涉及两个关键问题：在哪里变异以及变异使用什么值。具体来说，Vuzzer在主模糊循环之前通过静态分析提取影响控制流的立即值、魔数和其他特征字符串。在程序执行过程中，Vuzzer利用动态污点分析技术来收集影响控制流分支的信息，包括特定值和相应的偏移量。Vuzzer通过对收集到的值进行变异和在识别的位置进行变异，可以生成更符合分支判断条件的测试用例，并通过魔数的验证。但是，Vuzzer仍然无法在程序中通过其他类型的验证，例如基于hash的校验和。此外，Vuzzer的插桩、污点分析和主模糊回路是基于Pin（Luk等人）实现的，与AFL相比，测试速度相对较慢；Wang等人提出了数据驱动种子生成解决方案Skyfire。Skyfire通过爬取网络上的数据学习probabilistic context-sensitive grammar（PCSG），并利用所学知识生成结构良好的输入；来自微软研究院的Godefroid等人使用基于神经网络的统计机器学习技术自动生成测试用例；来自微软的Rajpal等人利用神经网络从过去的模糊探索中学习，并预测输入文件中哪个字节会发生变异；Nichols等人使用新一代对抗性网络（GAN）模型帮助用新的种子文件重新初始化系统。实验表明，GAN比LSTM更快、更有效，有助于发现更多的代码路径。</p>
<h4 id="how-to-select-seed-from-the-pool">How to select seed from the pool?</h4>
<p>AFL倾向于更小更快的测试用例来追求更快的测试速度；Böhme等人提出了AFLFast，一种基于覆盖的灰盒模糊器。他们观察到大多数测试用例集中在相同的少数路径上。例如，在PNG处理程序中，通过随机变异生成的大多数测试用例都是无效的，并触发错误处理路径。在模糊化过程中，AFLFast测量执行路径的频率，将路径划分为高频路径和低频路径，对模糊次数较少的种子进行优先排序，并将更多的能量分配给执行低频率路径的种子；Rawat等人整合静态和动态分析，以确定难以深入的路径，并优先考虑深入路径的种子，Vuzzer的种子选择策略可以帮助发现隐藏在深路径中的漏洞。</p>
<p>AFLGo和QTEP采用定向选择策略。AFLGo将一些易受攻击的代码定义为目标位置，并以最佳方式选择更接近目标位置的testcase。AFLGo论文中提到了四类易受攻击的代码，包括补丁、程序崩溃缺乏足够的跟踪信息、静态分析工具验证的结果和敏感信息相关的代码片段。通过适当的定向算法，AFLGo可以在感兴趣的代码上分配更多的测试资源；QTEP利用静态代码分析来检测易出错的源代码，并对包含更多错误代码的种子进行优先级排序。AFLGo和QTEP在很大程度上依赖于静态分析工具的有效性。然而，目前静态分析工具的误报率仍然很高，无法给出准确的验证。</p>
<p>已知漏洞的特征也可用于种子选择策略。SlowFuzz针对的是算法复杂性漏洞，这种漏洞通常伴随着非常高的计算资源消耗而出现。因此，SlowFuzz更喜欢消耗更多资源（如cpu时间和内存）的种子。然而，收集消耗资源的信息会带来很大的开销，降低模糊处理的效率。例如，为了收集cpu时间，SlowFuzz要计算执行的指令数。此外，SlowFuzz对资源消耗信息的准确性要求很高。</p>
<h4 id="how-to-efficiently-test-applications">How to efficiently test applications?</h4>
<p>目标应用程序由主模糊循环中的模糊程序反复启动和完成。AFL使用forkserver方法，该方法为已经加载的程序创建一个相同的克隆，并在每次运行时重用该克隆。此外，AFL还提供持久模式（persistent mode）和并行模式（parallel mode），前者有助于避免众所周知的运行缓慢的execve系统调用和链接过程的开销，后者有助于在多核系统上并行测试；Intel的处理器跟踪PT技术被用于内核模糊化，以节省覆盖率跟踪带来的开销；Xu等人旨在解决多核机器上并行模糊的性能瓶颈。通过设计和实现三个新的操作原语，他们表明这项工作可以大大加快最先进的模糊器，如AFL和LibFuzzer。</p>
<h3 id="techniques-integrated-in-fuzzing">Techniques integrated in fuzzing</h3>
<p><img src="/png/2021-03-03-18-30-10.png"></p>
<p>智能模糊程序通过程序分析技术收集程序控制流和数据流信息，从而利用收集到的信息来改进测试用例的生成。上表总结了模糊化中集成的主要技术，并列出了这些技术的代表性的工作。包括：静态分析、污点分析、代码插桩、机器学习和符号执行。</p>
<h4 id="testcase-generation-1">Testcase generation</h4>
<p>Godefroid等人使用机器学习技术，特别是递归神经网络，来学习输入文件的语法，从而使用学习的语法生成符合格式的测试用例；Wang等人使用了格式方法，它定义了一个probabilistic context-sensitive grammar，并提取格式知识来生成良好的格式种子输入；更先进的模糊程序采用了基于变异的模糊策略，并且应该首先修改可能影响控制流传动的字节，污点分析技术用于跟踪字节对控制流的影响，以定位突变种子的关键字节；通过采用逆向工程和污点分析等技术扫描二进制代码，从条件判断语句中收集特殊值，并将收集到的值作为变异的候选值，从而通过一些关键的验证和检查，如magic bytes和version check；微软的研究人员也尝试利用机器学习技术，如深度神经网络（DNN），根据先前的LSTM的模糊化经验，预测哪些字节发生变异，以及在变异中使用什么值。</p>
<h4 id="program-execution">Program execution</h4>
<p>在执行阶段涉及到的两个关键问题是如何引导模糊化过程以及如何探索新的路径。</p>
<p>模糊化过程通常被引导以覆盖更多的代码并更快地发现错误。在基于覆盖的模糊处理中，检测技术用于记录路径执行情况和计算覆盖信息；对于有向模糊，采用模式识别等静态分析技术对目标代码进行指定和识别，使其更易受到攻击；静态分析技术也可用于收集控制流信息，例如路径深度，可作为指导策略中的另一个参考。通过插桩收集的路径执行信息可以帮助指导模糊化过程；Intel PT是Intel processors提供的一项新功能，具有执行速度快、不依赖源代码等优点，可以准确、高效地跟踪执行过程，在KAFL中，该特性被用于操作系统内核的模糊化，并被证明是非常有效的。</p>
<p>模糊执行的另一个关注点是探索新的路径，模糊程序通常需要经过复杂的条件判断；程序分析技术包括静态分析、污点分析等，可以用来识别执行过程中的阻塞点并进行后续求解；符号执行技术可以通过求解约束集计算满足特定条件要求的值，TaintScope利用符号执行技术来解决总是阻碍模糊化过程的校验和验证问题；Driller利用concolic执行绕过条件判断，发现更深层次的bug。</p>
<h3 id="fuzzing-towards-different-applications">Fuzzing towards different applications</h3>
<h4 id="file-format-fuzzing">File format fuzzing</h4>
<p>目前对模糊化的研究主要集中在文件格式的模糊化上，提出了很多模糊化工具，如Peach、AFL及其扩展。文件格式模糊化的一个重要分支是web浏览器上的模糊化，浏览器处理的文件类型已经从传统的HTML、CSS、JS文件扩展到其他类型的文件，比如pdf、svg和其他由浏览器扩展处理的文件格式。针对web浏览器的著名模糊工具包括Grinder框架、COMRaider、BF3等。</p>
<h4 id="kernel-fuzzing">Kernel fuzzing</h4>
<p>内核的模糊化有许多挑战。首先，内核中的崩溃和挂起会导致整个系统的崩溃，如何捕获崩溃是一个问题；其次，fuzzer通常在ring3中运行，如何与内核交互是另一个问题，当前与内核通信的最佳实践是调用内核API函数。内核模糊器可分为两类：基于知识的模糊器和覆盖引导的模糊器。</p>
<p>基于知识的模糊器在模糊化过程中利用了关于内核API函数的知识，内核API函数调用的模糊化面临两个主要挑战：API调用的参数应是符合规范的随机值；内核API调用的顺序应有效。该方面代表作品包括Trinity和IMF。Trinity是一个类型感知的内核模糊器。在Trinity中，测试用例是基于参数类型生成的，此外还提供了某些值的范围，以帮助生成格式良好的测试用例。IMF试图学习API执行的正确顺序和API调用之间的值依赖性，并将所学的知识用于测试用例的生成。</p>
<p>覆盖引导的内核模糊器的代表性工作包括syzkaller、TriforceAFL和kAFL。Syzkaller在编译过程中为内核提供工具，并在一组QEMU虚拟机上运行内核，在模糊化过程中，覆盖率和安全违规都会被跟踪；TriforceAFL是AFL的一个修改版本，它通过QEMU全系统仿真支持内核模糊化；KAFL利用新的硬件特性Intel PT来跟踪覆盖率，且只跟踪内核代码；实验表明，KAFL比Triforce快40倍左右，大大提高了效率。</p>
<h4 id="fuzzing-of-protocols">Fuzzing of protocols</h4>
<p>通常采用有状态的方法对协议工作过程进行建模，并根据协议规范生成测试用例；SPIKE提供了一组工具，允许用户快速创建网络协议压力测试器；Serge Gorbunov和Arnold Rosenbloom提出了AutoFuzz，它通过构造一个有限状态自动机来学习协议的实现，并进一步利用所学的知识来生成测试用例；Greg Banks等人提出了SNOOZE，它用状态模糊方法识别协议缺陷；Joeri de Ruiter等人提出了一种协议状态fuzzing方法，在状态机中描述TLS的工作状态，并按照逻辑流程进行模糊化处理。</p>
<h2 id="fuzzing-state-of-the-art">Fuzzing: State of the Art</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/TRel18_Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<h3 id="state-of-the-art-in-fuzzing">STATE OF THE ART IN FUZZING</h3>
<h4 id="seeds-generation-and-selection">Seeds Generation and Selection</h4>
<p>Rebert等人测试了六种选择算法：Peach的集覆盖算法；一种随机种子选择算法；最小集覆盖（与minset相同，可通过贪心算法计算）；按种子大小加权的最小集覆盖；按执行时间加权的最小集覆盖；一个hotset算法（fuzz对每个种子文件进行t秒的测试，根据发现的唯一bug的数量对它们进行排序，并返回列表中最前面的几个种子文件）。通过实际实验发现：采用启发式算法的算法性能优于完全随机抽样；在这六种算法中，无权minset算法的性能最好；在实践中，缩减的种子文件集比原始种子文件集的执行效率更高；缩减的种子集可以应用于解析同一文件类型的不同应用程序。</p>
<p>Kargen和Shahmehri声称，通过对生成程序的机器代码执行突变，而不是直接对格式良好的输入执行突变，得到的测试输入更接近被测试程序所期望的格式，可以产生更好的代码覆盖率；为了测试复杂的软件（例如，PDF阅读器），Liang等人利用字体文件的结构信息来选择其中属于异类字体的种子文件；Skyfire接受一个种子输入库和语法，并使用大量现有样本中的知识为处理高度结构化输入的模糊程序生成分布良好的种子输入；有一种算法，在给定一个程序和一个种子输入的情况下，最大限度地增加黑盒变异模糊的bug。其主要思想是利用符号分析对程序种子对的执行轨迹进行分析来获得种子各个位之间的依赖关系，然后使用这种依赖关系来计算该程序种子对的概率最优变异率；考虑到模糊化是概率分析中coupon collector’s problem的一个实例，Arcuri等人提出并证明了随机测试抽样的预期测试用例数的非平凡的最优下界，以覆盖预定义的目标，尽管在实践中如何操作还没有给出。</p>
<h4 id="input-validation-and-coverage">Input Validation and Coverage</h4>
<p>完整性验证：如果输入存在校验和机制，则普通的变异将导致输入无法通过验证；Wang等人开发了一个名为TaintScope的模糊程序，TaintScope首先使用动态污点分析和预定义规则来检测可能污染目标程序中敏感应用程序编程接口（api）的潜在校验和点和热输入字节，然后变异热字节来创建新的测试用例，并更改校验和点，让所有创建的测试用例通过完整性验证，通过符号执行和约束求解确定导致目标程序崩溃的测试用例的校验和值；给定一组样本输入，Hoschele和Zeller使用动态污点跟踪每个输入字符的数据流，并将这些输入片段聚合成词汇和语法实体，得到反映有效输入结构的上下文无关文法；为了减轻基于覆盖率的模糊程序对进行魔数检测的路径的限制，Steelix利用轻量级静态分析和二进制插桩，不仅向模糊程序提供覆盖率信息，还向模糊程序提供比较进度信息，这样的程序状态信息将告诉模糊程序魔数在测试输入中的位置，以及如何执行突变以有效地匹配魔术字节；</p>
<p>格式验证：网络协议、编译器、解释器等对输入格式有严格的要求；Ruiter和Poll评估了九种常用的传输层安全（transport layer security，TLS）协议的实现，使用黑盒模糊技术结合状态机学习，提供一个抽象消息列表（也称为输入字母表），可以通过测试线束将其转换为发送到被测试系统的具体消息；Dewey等人提出了一种通过约束逻辑编程（CLP）生成使用复杂类型系统的C#程序的新方法，并将其应用于生成Rust或JavaScript程序；Cao等人首先调查了Android系统服务的输入验证情况，并针对Android设备构建了一个输入验证漏洞扫描器。这个扫描器可以创建半有效的参数，这些参数可以通过目标系统服务方法实现的初步检查。</p>
<p>环境验证：只有在特定环境下（即特定配置、特定运行时状态/条件等），许多软件漏洞才会暴露出来；Dai等人提出了一种配置模糊技术，正在运行的应用程序的配置会在某些执行点发生变化，以检查只有在某些情况下才会出现的漏洞；FuzzDroid还可以自动生成一个Android执行环境，在该环境中，应用程序会暴露其恶意行为，FuzzDroid通过一种基于搜索的算法，将一组可扩展的静态和动态分析结合起来，将应用程序导向一个可配置的目标位置；</p>
<p>输入覆盖率：Tsankov等人定义了半有效输入覆盖（SVCov），只要有效输入可以由一组有限的约束定义，该准则就适用，通过增加SVCov下的覆盖率，他们在一个成熟的Internet密钥交换（IKE）实现中发现了一个以前未知的漏洞。</p>
<p>为了解决现有语法推理算法的严重缓慢和过度泛化的缺点，Bastani等人提出了一种合成无上下文语法的算法，该算法从一组输入示例和对程序的黑盒访问中对有效程序输入的语言进行编码；与许多通过目标程序崩溃来确定输入是否有效的方法不同，ArtFuzz旨在捕捉非崩溃缓冲区溢出漏洞，它利用类型信息并动态地发现可能的内存布局来帮助模糊化过程，如果超出内存布局中标识的缓冲区边界，则会报告错误；Groce等人提出了一种低成本和有效的方法，称为swarm testing，通过增加（随机生成的）测试用例的多样性提高效率，该方法使用不同的测试配置swarm，每种配置都故意省略某些API调用或输入特性。此外，为了减轻无法专注于被测系统的一部分，定向swarm testing利用并记录过去测试结果的统计数据，生成针对任何给定源代码元素的新随机测试；根据观察，开发人员有时会在提交的补丁中附带一个测试用例，该测试用例可以部分地执行新代码，并且该测试用例可以很容易地用作符号探索的起点，Marinescu和Cadar提供了一种自动生成测试套件的方法，以实现软件补丁的高覆盖率。</p>
<h4 id="handling-crash-inducing-test-cases">Handling Crash-Inducing Test Cases</h4>
<p>对于大量可能引发程序错误的测试用例集合，Chen等人提出了一种基于排名的方法，通过这种方法，引入差异的测试用例将排在列表的首位；崩溃诱导测试用例的唯一性可以通过目标线程的调用堆栈和导致错误的指令的地址来确定；与记录调用堆栈相比，跟踪执行路径是确定唯一性的更简单但更不可靠的方法；定期对生成的测试用例进行裁剪，可以提高整体效率，修剪的原则是被处理的对象的行为应该与原始对象相同，修剪的一般步骤是依次从测试用例中删除数据块并重新评估测试用例的其余部分，那些不能影响执行路径的数据块将被修剪；评估模糊输出的可利用性通常需要代码分析和调试工作，这些工作可以受益于专用工具，如GDB、Valgrind、AddressSanitizer等。这些工具提供目标程序的运行时上下文（如调用堆栈和寄存器的状态、故障诱导指令的地址等），或者可以检测特定类型的程序错误，如内存错误，在工具的帮助下测试人员能够更有效地发现和评估程序错误。</p>
<h4 id="leveraging-runtime-information">Leveraging Runtime Information</h4>
<p>路径爆炸是符号执行中一个固有的也是最困难的问题，从程序分析方法和路径搜索算法两个方面，有以下改善方法：函数摘要用于描述低级函数的属性，以便高级函数可以重用它们以减少执行路径的数量；冗余路径剪枝用于避免执行那些与某些先前覆盖的路径具有相同副作用的路径，如果一条路径在与一些先前探索的路径相同的条件下到达一个程序点，那么导致相同后续效果的路径就可以被剪除；合并不同路径上获得的状态也可以减少路径搜索空间，但这种方法加重了求解器的负担；随机路径选择和自动部分循环摘要在实践中被证明是成功的，主要是因为它们避免了在遇到一些可以快速创建新状态的紧循环时被卡住；另一个例子是控制流图（CFG）定向路径选择，它利用静态控制流图来指导测试用例生成，以探索最近的未覆盖分支；代际搜索会探索每个扩展执行的所有子路径，对它们进行评分，最后为下一个执行选择一个得分最高的路径；考虑到现有的基于覆盖率的灰盒模糊工具访问了高密度区域中过多的状态，Bohme等人提出并实施了几种策略，通过访问更多隐藏在低密度区域中的状态，迫使AFL为高密度区域中的状态生成较少的输入；为了缓解路径爆炸问题，DeepFuzz为执行路径分配了概率，并应用了一种新的搜索启发式算法，该算法可以有效地延迟路径爆炸进入被测二进制文件的更深层；给定一组现有的测试用例，Zhang等人利用测试用例缩减和优先级排序方法来提高种子符号执行的效率，目标是尽快获得增量覆盖。</p>
<p>符号执行的不精确性主要是由复杂的程序结构（如指针）建模、库或系统调用以及约束求解引起的，为了使符号执行切实可行，需要在上述区域中执行一些简化方法。开发人员的关键是在可扩展性和精确性之间找到一个平衡点；CUTE简化了指针操作，在处理符号指针变量时只考虑等式和不等式谓词；在KLEE中，指针被视为数组，当指针p间接引用N个对象时，KLEE将当前状态复制N次，并且在每个状态下，它在p不超出相应对象的边界的前提下执行正确的读或写操作，对于库或者系统调用等源代码中不存在的符号值它将使用具体的值代替。此外，约束求解还加入了大量的约束优化（例如Sage使用无关约束限制、本地约束缓存、翻转计数限制等，以提高生成约束时的内存使用率和速度）甚至是输入语法（例如Godefroid等人提出了一种通过符号执行直接生成基于输入语法的约束的方法，这些约束的可满足性将通过一个定制的约束求解器进行验证，该求解器还利用了输入语法，因此可以生成高度结构化的输入）。</p>
<p>为了对可能导致符号执行不精确的浮点代码进行模糊测试，Godefroid和Kinder结合了轻量级局部路径不敏感的浮点指令可能静态分析和高精度全程序路径敏感的非浮点指令必须动态分析；Fu和Su把测试浮点代码的问题变成了在整个搜索空间中应用无约束规划计算函数最小点的解的问题，他们从浮点代码中导出了一个表示函数，其中任何一个最小点都是一个测试输入，保证执行被测试程序的一个新分支。</p>
<blockquote>
<p>Undertainting: Undertainting happens when implicit data flow in which data transmission is associated with control flow, and array operation, etc., are totally neglected. As shown in Fig. 4, during the conversion from plain text to Rich Text Format, the value of the input variable is transferred into output array without a direct assignment. Therefore, if input is tainted, neglecting this implicit data flow will cause undertainting. Kang et al. have made a progress to solve this problem. According to their experiment, taint propagation for all implicit flows also leads to unacceptable-large overtainting. Therefore, they only focused on the taint propagation for complete informationpreserving implicit flows like the example shown in Fig. 4.</p>
</blockquote>
<blockquote>
<p>Overtainting: Overtainting happens when taint propagation is not implemented at finer grained granularity. It causes taint explosion and false positive. Yadegari et al. proposed an approach which fulfills taint propagation at bit level to mitigate this problem. Another method of dealing with this issue is to use underapproximations to check existential “for-some-path” properties. Godefroid proposed a new approach to test generation where tests are derived from validity proofs of first-order logic formulas, rather than satisfying assignments of quantifierfree first-order logic formulas as most current approaches do. For more detailed information about symbolic execution and taint analysis, refer to professional literatures.</p>
</blockquote>
<h4 id="scalability-in-fuzzing">Scalability in Fuzzing</h4>
<p>Rawat等人提出了一种应用程序感知的进化模糊策略，它不需要任何应用程序或输入格式的先验知识，为了最大化覆盖范围并探索更深的路径，他们利用基于静态和动态分析的控制流和数据流功能来推断应用程序的基本属性，这使得与应用程序无关的方法相比，能够更快地生成感兴趣的输入；提高可扩展性的一种方法是缩小分析范围，回归分析是一个众所周知的例子，其中程序版本之间的差异是缩小分析范围的基础，DiSE结合了两个阶段：静态分析和符号执行，受影响的程序指令集在第一阶段生成，静态分析生成的信息随后被用于指导符号执行，以仅探索受更改影响的程序部分，从而潜在地避免大量未受影响的执行路径；</p>
<p>要以可扩展的方式测试移动应用程序，每个测试输入都需要在各种上下文中运行，例如：设备异构性、无线网络速度、位置和不可预测的传感器输入。每个上下文的值范围（例如位置）可能非常大。Liang等人介绍了Caiipa，这是一种云服务，用于以可扩展的方式在扩展的移动上下文空间上测试应用程序，并在虚拟机和真实设备集群上实现，可以模拟移动应用程序的各种上下文组合。 Mobile vulnerability discovery pipeline（MVDP）也是一个针对Android和iOS设备的分布式黑盒模糊系统。</p>
<h3 id="tools-in-different-application-areas">TOOLS IN DIFFERENT APPLICATION AREAS</h3>
<p><img src="/png/2021-03-03-21-47-15.png"></p>
<p><img src="/png/2021-03-03-22-21-41.png"></p>
<h4 id="general-purpose-fuzzers">General Purpose Fuzzers</h4>
<p>Peach最常见的目标是驱动程序、文件解析器、网络协议、嵌入式设备、系统等。由以下组件构成：Peach Pits，预定义的输入格式定义，可以作为单个Pit或一组相关的Pits使用。test passes，可以加权变异子以执行更多的测试用例。minset，有助于减少测试用例覆盖率的文件计数。Peach有许多突出的特性，比如威胁检测、现成的模糊定义（Peach-Pits）和可扩展的测试选项。但是也存在一些问题（特别是在开源版本中），例如使用Peach提供的语法来描述目标文件格式，构建Pit文件非常耗时。基于Peach，eFuzz测试了基于通信协议DLMS/COSEM（欧洲使用的标准协议）的智能计量装置是否存在可能的故障。Honggfuzz也是基于Peach的；beSTORM是一个商业黑盒模糊器，可用于协议、应用程序、硬件、文件、WIFI和嵌入式设备安全保证（EDSA）的测试。beSTORM采用的模糊化策略是首先测试可能的、常见的故障诱导区域，然后扩展到几乎无限的攻击变化范围，因此它可以快速交付结果。</p>
<h4 id="fuzzers-for-compilers-and-interpreters">Fuzzers for Compilers and Interpreters</h4>
<p>jsfunfuzz是一个基于语法的黑盒模糊器，专为Mozilla的SpiderMonkey JavaScript引擎设计，它将差异测试与目标应用程序的详细知识结合起来，可以有效地发现不同JavaScript引擎中与正确性相关的bug和崩溃触发bug。但是，对于每一个新的语言特性，jsfunfuzz都必须调整自己以响应模糊化过程中的新特性；Csmith是一个开源编译器，根据C99标准对随机生成的具有指定语法的C程序进行编译，利用随机差异测试来帮助发现由潜在的未定义行为和其他特定于C的问题引起的错误。尽管Csmith是一个实用的fuzzer，擅长生成错误诱导测试用例，但不会对发现的bug进行优先级排序；LangFuzz并不针对特定的语言，到目前为止已经在JavaScript和超文本预处理器（PHP）上进行了测试。LangFuzz使用随机生成和代码变异两种方法来创建测试用例，并将变异作为主要技术。它被设计成一个独立于语言的模糊器，但是要使它适应一种新的语言需要一些必要的改变；CLsmith利用随机差分测试和等价模输入（EMI）测试对许多核心编译器进行模糊化，并发现和报告了50多个OpenCL编译器错误，具体来说，CLsmith对多核环境进行随机差分测试，以生成确定性的、可通信的、功能丰富的OpenCL内核，并提出和评估了dead-by-construction代码的注入，以便在OpenCL环境下进行EMI测试；这一类的其他Fuzzer包括MongoDB的JavaScript Fuzzer，使用genetic programming的JS Fuzzer Ifuzzer。</p>
<h4 id="fuzzers-for-application-software">Fuzzers for Application Software</h4>
<p>SAGE用于模糊x86平台上运行的大型文件读取应用程序（如DocumentParser、MediaPlayer、图像处理器等），结合concolic执行和启发式搜索算法，最大限度地提高代码覆盖率；AFL是一个著名的基于代码覆盖率的模糊器，通过代码插桩收集运行时路径覆盖率的信息；QuickFuzz利用Haskell的QuickCheck（著名的基于属性的随机测试库）和Hackage（社区Haskell软件库）以及现成的位级变异模糊器，为十几种常见的文件格式提供自动模糊化，没有提供外部输入文件集，也没有为所涉及的文件类型开发模型，QuickFuzz混合使用基于语法和基于变异的模糊技术来发现目标应用程序中的意外行为，从而生成无效输入；为了测试服务器端软件，Davis等人提出Node.fz，它为事件驱动程序设置了模糊程序，具体体现为服务器端Node.js程序。Node.fz随机干扰执行Node.js程序，允许Node.js开发人员探索各种可能的时间表，这类工作还包括Dfuzzer，它是D-bus服务的模糊程；为了测试移动应用程序，近年来出现了一些模糊程序，如Droid FF、memory-leak fuzzer、DroidFuzzer、intent fuzzer和Android应用程序的Android Ripper MFT工具。</p>
<h4 id="fuzzers-for-network-protocols">Fuzzers for Network Protocols</h4>
<p>Sulley是一个针对网络协议的开源模糊框架，利用一种基于块的方法来生成单独的请求，为用户提供了构建协议描述所需的大量数据格式，用户使用这些格式来定义所有必要的块，这些块将在模糊过程中进行变异和合并，以创建新的测试用例，Sulley可以对检测到的故障进行分类，并行工作，并跟踪到触发故障的测试用例的唯一序列；Somorovsky提出了TLS-Attacker，一个用于评估TLS库安全性的开源框架。TLS-Attacker允许安全工程师创建定制的TLS消息流，并通过使用简单的接口来测试其库的行为，任意修改消息内容。它成功地在广泛使用的TLS库中发现了几个漏洞，包括OpenSSL、Botan和MatrixSSL；T-Fuzz是一个基于模型的模糊器，用于电信协议的健壮性测试；Secfuzz用于IKE协议；SNOOZE和KiF都用于VOIP/SIP协议。</p>
<h4 id="fuzzers-for-os-kernels">Fuzzers for OS Kernels</h4>
<p>Trinity支持多种体系结构，其用于生成系统调用参数的方法如下所述：如果系统调用期望某个数据类型作为参数（如描述符），则传递一个参数。如果系统调用仅接受某个值作为参数（如flag字段），则它具有可传递的所有有效标志的列表。如果系统调用只接受一个范围的值，则传递给参数的随机值通常适合该范围；Syzkaller是另一个针对Linux内核的fuzzer。它依赖于预定义的模板，这些模板指定每个系统调用的参数域。与Trinity不同，它还利用代码覆盖率信息来指导模糊化过程；IOCTL Fuzzer是一个设计用于自动搜索Windows内核驱动程序漏洞的工具，如果驱动的IOCTL操作符合配置文件中指定的条件，fuzzer将用随机生成的数据替换其输入字段；Schumilo等人以独立于操作系统和硬件辅助的方式提出了覆盖率引导的内核模糊化，其利用hypervisor来获取覆盖率，利用Intel的处理器跟踪技术来提供运行代码的控制流信息，开发了一个名为Kernel-AFL(kAFL)的框架来评估Linux、MacOS和Windows内核组件的可靠性或安全性；CAB-FUZZ是一种concolic testing工具，针对COTS操作系统，用于探索最有可能触发bug的相关路径。这种模糊优先考虑数组和循环的边界状态，并开发与COTS操作系统交互的真实程序，以构造适当的上下文，从而在没有调试信息的情况下探索深层和复杂的内核状态。</p>
<h4 id="fuzzers-for-embedded-devices-drivers-and-components">Fuzzers for Embedded Devices, Drivers and Components</h4>
<p>Kim等人提出了使用API级别的concolic testing自动生成模糊语法，并实现了一个工具（名为YMIR）来自动对ActiveX控件进行白盒模糊测试。它将ActiveX控件作为输入，并将模糊语法作为输出。API级别的concolic测试在库函数级别而不是指令级别收集约束，因此可能更快、更不准确；vUSBf是一个模糊USB驱动程序的框架，该框架实现了一个基于内核虚拟机（Linux）和QEMU的USB重定向协议的虚拟USB模糊器，允许使用简单的XML配置动态定义数百万个测试用例。每项测试都使用独特的标识进行标记，因此是可重复的。它可以触发Linux内核和设备驱动程序中的以下错误：空指针取消引用、内核分页请求、内核死机、错误页状态和分段错误。</p>
<blockquote>
<p>Besides the aforementioned fuzzers, there are also many other practical tools, including perf_fuzzer for perf_event_open() system call, libFuzzer for library, Modbus/TCP Fuzzer for internetworked industrial systems, a fuzzer for I/O buses, a fuzzer for digital certificates, Gaslight for memory forensics frameworks, etc. Moreover, along with memory error detectors (e.g., Clang’s AddressSanitizer, MemorySanitizer, etc.), fuzzers can be reinforced to expose more hidden bugs rather than shallow bugs.</p>
</blockquote>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/fuzz/" rel="tag"><i class="fa fa-tag"></i> fuzz</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/2cb5ce06/" rel="next" title="IS-crypto-非对称加密-RSA的攻击方式">
                <i class="fa fa-chevron-left"></i> IS-crypto-非对称加密-RSA的攻击方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/ed03f22a/" rel="prev" title="CS-BASIC-compiler-principles-属性文法和语法制导翻译">
                CS-BASIC-compiler-principles-属性文法和语法制导翻译 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/apple-touch-icon.png" alt="w4rd3n">
            
              <p class="site-author-name" itemprop="name">w4rd3n</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">121</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">37</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/hitworld" title="GitHub &rarr; https://github.com/hitworld" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#fuzzing-challenges-and-reflections"><span class="nav-number">1.</span> <span class="nav-text">Fuzzing: Challenges and Reflections</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#blackbox-fuzzing"><span class="nav-number">1.1.</span> <span class="nav-text">Blackbox fuzzing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#greybox-fuzzing"><span class="nav-number">1.2.</span> <span class="nav-text">Greybox fuzzing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#whitebox-fuzzing"><span class="nav-number">1.3.</span> <span class="nav-text">Whitebox fuzzing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#other-fuzzing-tools"><span class="nav-number">1.4.</span> <span class="nav-text">Other fuzzing tools</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#challenges"><span class="nav-number">1.5.</span> <span class="nav-text">Challenges</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#automation"><span class="nav-number">1.5.1.</span> <span class="nav-text">Automation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">[C.1] More Software. How can we fuzz efficiently more types of software systems?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">[C.3] More Difficult Bugs. How can we find &quot;deep bugs&quot; for which efficient oracles exist, but which nevertheless evade detection?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#the-human-component"><span class="nav-number">1.5.2.</span> <span class="nav-text">The Human Component</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">[C.6] Usability. How can we improve the usability of fuzzing tools?</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzing-theory"><span class="nav-number">1.5.3.</span> <span class="nav-text">Fuzzing Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#evaluation-and-benchmarks"><span class="nav-number">1.5.4.</span> <span class="nav-text">Evaluation and Benchmarks</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing"><span class="nav-number">2.</span> <span class="nav-text">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#introduction"><span class="nav-number">2.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#background"><span class="nav-number">2.2.</span> <span class="nav-text">Background</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#terminology"><span class="nav-number">2.2.1.</span> <span class="nav-text">Terminology</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#coverage-guide-greybox-fuzzing"><span class="nav-number">2.2.2.</span> <span class="nav-text">Coverage-guide Greybox Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#directed-greybox-fuzzing"><span class="nav-number">2.2.3.</span> <span class="nav-text">Directed Greybox Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#difference-between-cgf-and-dgf"><span class="nav-number">2.2.4.</span> <span class="nav-text">Difference between CGF and DGF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#application-of-dgf"><span class="nav-number">2.2.5.</span> <span class="nav-text">Application of DGF</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#assessment-of-the-state-of-the-art-works"><span class="nav-number">2.3.</span> <span class="nav-text">Assessment of the-state-of-the-art Works</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#directed-type"><span class="nav-number">2.3.1.</span> <span class="nav-text">Directed Type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#input-optimization"><span class="nav-number">2.3.2.</span> <span class="nav-text">Input Optimization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seed-prioritization"><span class="nav-number">2.3.3.</span> <span class="nav-text">Seed Prioritization</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#distance"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">Distance</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#similarity-coverage"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">Similarity &amp; Coverage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#probability"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">Probability</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#power-assignment"><span class="nav-number">2.3.4.</span> <span class="nav-text">Power Assignment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mutator-scheduling"><span class="nav-number">2.3.5.</span> <span class="nav-text">Mutator Scheduling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data-flow-analysis"><span class="nav-number">2.3.6.</span> <span class="nav-text">Data-flow Analysis</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#challenges-and-solutions"><span class="nav-number">2.4.</span> <span class="nav-text">Challenges and Solutions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#binary-code-support"><span class="nav-number">2.4.1.</span> <span class="nav-text">Binary Code Support</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#automatic-target-identification"><span class="nav-number">2.4.2.</span> <span class="nav-text">Automatic target identification</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#differentiated-weight-metric"><span class="nav-number">2.4.3.</span> <span class="nav-text">Differentiated weight metric</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#global-optimum-deviation"><span class="nav-number">2.4.4.</span> <span class="nav-text">Global Optimum Deviation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#missing-indirect-calls"><span class="nav-number">2.4.5.</span> <span class="nav-text">Missing Indirect Calls</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exploration-exploitation-coordination"><span class="nav-number">2.4.6.</span> <span class="nav-text">Exploration-exploitation coordination</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#discussion"><span class="nav-number">2.5.</span> <span class="nav-text">Discussion</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#multi-targets-relationship-exploitation"><span class="nav-number">2.5.1.</span> <span class="nav-text">Multi-targets Relationship Exploitation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#technology-integration"><span class="nav-number">2.5.2.</span> <span class="nav-text">Technology Integration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#implementation-limitation"><span class="nav-number">2.5.3.</span> <span class="nav-text">Implementation Limitation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#efficiency-improvement"><span class="nav-number">2.5.4.</span> <span class="nav-text">Efficiency Improvement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#future-research-suggestions"><span class="nav-number">2.5.5.</span> <span class="nav-text">Future research suggestions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fuzzing-hack-art-and-science-cacm-2020"><span class="nav-number">3.</span> <span class="nav-text">Fuzzing: Hack, Art, and Science (CACM 2020)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#blackbox-fuzzing-1"><span class="nav-number">3.1.</span> <span class="nav-text">Blackbox Fuzzing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#grammar-based-fuzzing"><span class="nav-number">3.2.</span> <span class="nav-text">Grammar-Based Fuzzing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#whitebox-fuzzing-1"><span class="nav-number">3.3.</span> <span class="nav-text">Whitebox Fuzzing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#other-approaches"><span class="nav-number">3.4.</span> <span class="nav-text">Other Approaches</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#survey-of-directed-fuzzy-technology"><span class="nav-number">4.</span> <span class="nav-text">Survey of Directed Fuzzy Technology</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dse"><span class="nav-number">4.1.</span> <span class="nav-text">DSE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#symbolic-execution-algorithm"><span class="nav-number">4.1.1.</span> <span class="nav-text">Symbolic Execution Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#静态符号执行"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">静态符号执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态符号执行"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">动态符号执行</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#directed-symbolic-execution"><span class="nav-number">4.1.2.</span> <span class="nav-text">Directed Symbolic Execution</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#a-review-of-machine-learning-applications-in-fuzzing"><span class="nav-number">5.</span> <span class="nav-text">A Review of Machine Learning Applications in Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#overview-of-fuzzing"><span class="nav-number">5.1.</span> <span class="nav-text">OVERVIEW OF FUZZING</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pre-fuzzing-program-knowledge"><span class="nav-number">5.1.1.</span> <span class="nav-text">Pre-Fuzzing: Program Knowledge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stage-1-generate-inputs"><span class="nav-number">5.1.2.</span> <span class="nav-text">Stage 1: Generate Inputs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stage-2-select-inputs"><span class="nav-number">5.1.3.</span> <span class="nav-text">Stage 2: Select Inputs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stage-3-monitor-program"><span class="nav-number">5.1.4.</span> <span class="nav-text">Stage 3: Monitor Program</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stage-4-evaluate-inputs"><span class="nav-number">5.1.5.</span> <span class="nav-text">Stage 4: Evaluate Inputs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#post-fuzzing-interesting-program-states"><span class="nav-number">5.1.6.</span> <span class="nav-text">Post-Fuzzing: Interesting Program States</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#applications-of-machine-learning-to-fuzzing"><span class="nav-number">5.2.</span> <span class="nav-text">APPLICATIONS OF MACHINE LEARNING TO FUZZING</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#generate-inputs"><span class="nav-number">5.2.1.</span> <span class="nav-text">Generate Inputs</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#genetic-algorithms"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">Genetic Algorithms</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#deep-learning-and-neural-networks"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">Deep Learning and Neural Networks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reinforcement-learning"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">Reinforcement Learning</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#machine-learning-for-symbolic-execution"><span class="nav-number">5.2.1.4.</span> <span class="nav-text">Machine Learning for Symbolic Execution</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#post-fuzzing-interesting-program-states-1"><span class="nav-number">5.2.2.</span> <span class="nav-text">Post-Fuzzing: Interesting Program States</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seed-selection"><span class="nav-number">5.2.3.</span> <span class="nav-text">Seed selection</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#a-systematic-review-of-fuzzing-based-on-machine-learning-techniques"><span class="nav-number">6.</span> <span class="nav-text">A systematic review of fuzzing based on machine learning techniques</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#applying-machine-learning-techniques-for-different-fuzzing-steps"><span class="nav-number">6.1.</span> <span class="nav-text">Applying Machine Learning Techniques for Different Fuzzing Steps</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#seed-file-generation"><span class="nav-number">6.1.1.</span> <span class="nav-text">Seed file generation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#testcase-generation"><span class="nav-number">6.1.2.</span> <span class="nav-text">Testcase generation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#testcase-filter"><span class="nav-number">6.1.3.</span> <span class="nav-text">Testcase filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mutation-operator-selection"><span class="nav-number">6.1.4.</span> <span class="nav-text">Mutation operator selection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fitness-function"><span class="nav-number">6.1.5.</span> <span class="nav-text">Fitness function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exploitability-analysis"><span class="nav-number">6.1.6.</span> <span class="nav-text">Exploitability analysis</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#analysis-of-machine-learning-based-fuzzing-model"><span class="nav-number">6.2.</span> <span class="nav-text">Analysis of Machine Learning Based Fuzzing Model</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#selection-of-machine-learning-algorithm"><span class="nav-number">6.2.1.</span> <span class="nav-text">Selection of machine learning algorithm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pre-processing-method"><span class="nav-number">6.2.2.</span> <span class="nav-text">Pre-processing method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#datasets"><span class="nav-number">6.2.3.</span> <span class="nav-text">Datasets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#evaluation-metrics"><span class="nav-number">6.2.4.</span> <span class="nav-text">Evaluation metrics</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hyperparameters-setting"><span class="nav-number">6.2.5.</span> <span class="nav-text">Hyperparameters setting</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#future-directions"><span class="nav-number">6.3.</span> <span class="nav-text">Future Directions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#the-art-science-and-engineering-of-fuzzing-a-survey"><span class="nav-number">7.</span> <span class="nav-text">The Art, Science, and Engineering of Fuzzing: A Survey</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#systemization-taxonomy-and-test-programs"><span class="nav-number">7.1.</span> <span class="nav-text">SYSTEMIZATION, TAXONOMY, AND TEST PROGRAMS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#preprocess"><span class="nav-number">7.2.</span> <span class="nav-text">PREPROCESS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scheduling"><span class="nav-number">7.3.</span> <span class="nav-text">SCHEDULING</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#black-box-fcs-algorithms"><span class="nav-number">7.3.1.</span> <span class="nav-text">Black-box FCS Algorithms</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#grey-box-fcs-algorithms"><span class="nav-number">7.3.2.</span> <span class="nav-text">Grey-box FCS Algorithms</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#input-generation"><span class="nav-number">7.4.</span> <span class="nav-text">INPUT GENERATION</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#model-based-generation-based-fuzzers"><span class="nav-number">7.4.1.</span> <span class="nav-text">Model-based (Generation-based) Fuzzers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#model-less-mutation-based-fuzzers"><span class="nav-number">7.4.2.</span> <span class="nav-text">Model-less (Mutation-based) Fuzzers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#white-box-fuzzers"><span class="nav-number">7.4.3.</span> <span class="nav-text">White-box Fuzzers</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#input-evaluation"><span class="nav-number">7.5.</span> <span class="nav-text">INPUT EVALUATION</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bug-oracles"><span class="nav-number">7.5.1.</span> <span class="nav-text">Bug Oracles</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#triage"><span class="nav-number">7.5.2.</span> <span class="nav-text">Triage</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#configuration-updating"><span class="nav-number">7.6.</span> <span class="nav-text">CONFIGURATION UPDATING</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#evolutionary-seed-pool-update"><span class="nav-number">7.6.1.</span> <span class="nav-text">Evolutionary Seed Pool Update</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fuzzing-a-survey"><span class="nav-number">8.</span> <span class="nav-text">Fuzzing: a survey</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#background-1"><span class="nav-number">8.1.</span> <span class="nav-text">Background</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#types-of-fuzzers"><span class="nav-number">8.2.</span> <span class="nav-text">Types of fuzzers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#coverage-based-fuzzing"><span class="nav-number">8.3.</span> <span class="nav-text">Coverage-based fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#how-to-get-initial-inputs"><span class="nav-number">8.3.1.</span> <span class="nav-text">How to get initial inputs?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#how-to-generate-testcases"><span class="nav-number">8.3.2.</span> <span class="nav-text">How to generate testcases?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#how-to-select-seed-from-the-pool"><span class="nav-number">8.3.3.</span> <span class="nav-text">How to select seed from the pool?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#how-to-efficiently-test-applications"><span class="nav-number">8.3.4.</span> <span class="nav-text">How to efficiently test applications?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#techniques-integrated-in-fuzzing"><span class="nav-number">8.4.</span> <span class="nav-text">Techniques integrated in fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#testcase-generation-1"><span class="nav-number">8.4.1.</span> <span class="nav-text">Testcase generation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#program-execution"><span class="nav-number">8.4.2.</span> <span class="nav-text">Program execution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fuzzing-towards-different-applications"><span class="nav-number">8.5.</span> <span class="nav-text">Fuzzing towards different applications</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#file-format-fuzzing"><span class="nav-number">8.5.1.</span> <span class="nav-text">File format fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kernel-fuzzing"><span class="nav-number">8.5.2.</span> <span class="nav-text">Kernel fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzing-of-protocols"><span class="nav-number">8.5.3.</span> <span class="nav-text">Fuzzing of protocols</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fuzzing-state-of-the-art"><span class="nav-number">9.</span> <span class="nav-text">Fuzzing: State of the Art</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#state-of-the-art-in-fuzzing"><span class="nav-number">9.1.</span> <span class="nav-text">STATE OF THE ART IN FUZZING</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#seeds-generation-and-selection"><span class="nav-number">9.1.1.</span> <span class="nav-text">Seeds Generation and Selection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#input-validation-and-coverage"><span class="nav-number">9.1.2.</span> <span class="nav-text">Input Validation and Coverage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#handling-crash-inducing-test-cases"><span class="nav-number">9.1.3.</span> <span class="nav-text">Handling Crash-Inducing Test Cases</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#leveraging-runtime-information"><span class="nav-number">9.1.4.</span> <span class="nav-text">Leveraging Runtime Information</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scalability-in-fuzzing"><span class="nav-number">9.1.5.</span> <span class="nav-text">Scalability in Fuzzing</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tools-in-different-application-areas"><span class="nav-number">9.2.</span> <span class="nav-text">TOOLS IN DIFFERENT APPLICATION AREAS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#general-purpose-fuzzers"><span class="nav-number">9.2.1.</span> <span class="nav-text">General Purpose Fuzzers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzers-for-compilers-and-interpreters"><span class="nav-number">9.2.2.</span> <span class="nav-text">Fuzzers for Compilers and Interpreters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzers-for-application-software"><span class="nav-number">9.2.3.</span> <span class="nav-text">Fuzzers for Application Software</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzers-for-network-protocols"><span class="nav-number">9.2.4.</span> <span class="nav-text">Fuzzers for Network Protocols</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzers-for-os-kernels"><span class="nav-number">9.2.5.</span> <span class="nav-text">Fuzzers for OS Kernels</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzers-for-embedded-devices-drivers-and-components"><span class="nav-number">9.2.6.</span> <span class="nav-text">Fuzzers for Embedded Devices, Drivers and Components</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-gg-circle"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">w4rd3n</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">807k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">12:13</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz",
                'X-LC-Key': "UvlYMzpJKw0Jrw61V5BA5ifU",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  
  

  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>;
  <script>
  //$("body").backstretch("/images/background.jpg");
  </script>
  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>
