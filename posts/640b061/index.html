<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.5.0">


  <link rel="mask-icon" href="/images/safari_pinned_tab.svg?v=6.5.0" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml">







<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Survey/Review 本文主要是对相关论文的阅读和摘要。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing is an automatic bug and vulnerability discovery technique which continuously generates inputs and reports those t">
<meta name="keywords" content="fuzz">
<meta property="og:type" content="article">
<meta property="og:title" content="IS-pwn-fuzz-theory-present-situation">
<meta property="og:url" content="https://hitworld.github.io/posts/640b061/index.html">
<meta property="og:site_name" content="w4rd3n">
<meta property="og:description" content="Survey/Review 本文主要是对相关论文的阅读和摘要。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing is an automatic bug and vulnerability discovery technique which continuously generates inputs and reports those t">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-22-46-04.png">
<meta property="og:updated_time" content="2021-01-02T16:57:38.438Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IS-pwn-fuzz-theory-present-situation">
<meta name="twitter:description" content="Survey/Review 本文主要是对相关论文的阅读和摘要。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing is an automatic bug and vulnerability discovery technique which continuously generates inputs and reports those t">
<meta name="twitter:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">






  <link rel="canonical" href="https://hitworld.github.io/posts/640b061/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>IS-pwn-fuzz-theory-present-situation | w4rd3n</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">w4rd3n</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">混吃等死</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>友链</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hitworld.github.io/posts/640b061/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="w4rd3n">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/apple-touch-icon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="w4rd3n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">IS-pwn-fuzz-theory-present-situation
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-01-01 23:41:38" itemprop="dateCreated datePublished" datetime="2021-01-01T23:41:38+08:00">2021-01-01</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/" itemprop="url" rel="index"><span itemprop="name">IS</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/posts/640b061/" class="leancloud_visitors" data-flag-title="IS-pwn-fuzz-theory-present-situation">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度：</span>
               
                 <span class="leancloud-visitors-count"></span>
                 <span>℃</span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">47k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">43 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="surveyreview">Survey/Review</h2>
<p>本文主要是对相关论文的阅读和摘要。</p>
<h3 id="fuzzing-challenges-and-reflections">Fuzzing: Challenges and Reflections</h3>
<p><a href="https://www.comp.nus.edu.sg/~abhik/pdf/IEEE-SW-Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>Fuzzing is an automatic bug and vulnerability discovery technique which continuously generates inputs and reports those that crash the program.</p>
<p>There are three main categories of fuzzing tools and techniques: blackbox, greybox and whitebox fuzzing.</p>
<p>自动化漏洞发现技术---通过持续不断地生成输入并报告程序crash。</p>
<h4 id="blackbox-fuzzing">Blackbox fuzzing</h4>
<p>Blackbox fuzzing generates inputs without any knowledge of the program.</p>
<p>There are two main variants of blackbox fuzzing: mutational and generational.</p>
<p>In mutational blackbox fuzzing, the fuzz campaign starts with one or more seed inputs. These seeds are modified to generate new inputs. Random mutations are applied to random locations in the input. For instance, a file fuzzer may flip random bits in a seed file. The process continues until a time budget is exhausted.</p>
<p>In generational blackbox fuzzing, inputs are generated from scratch. If a structural specification of the input format is provided, new inputs are generated that meet the grammar.</p>
<p>Peach (http://community.peachfuzzer.com) is one popular blackbox fuzzer.</p>
<p>两种黑盒模糊测试区别在于前者通过初始语料库开始变异，后者通过提供的输入格式进行生成。</p>
<h4 id="greybox-fuzzing">Greybox fuzzing</h4>
<p>Greybox fuzzing leverages program instrumentation to get lightweight feedback which is used to steer the fuzzer.</p>
<p>Typically, a few control locations in the program are instrumented at compile time and an initial seed corpus is provided.</p>
<p>Seed inputs are mutated to generate new inputs. Generated inputs that cover new control locations, and thus increase code coverage, are added to the seed corpus.</p>
<p>The coverage feedback allows a greybox fuzzer to gradually reach deeper into the code.</p>
<p>In order to identify bugs and vulnerabilities, sanitizers inject assertions into the program.</p>
<p>Existing greybox fuzzing tools include AFL (https://lcamtuf.coredump.cx/afl/), LibFuzzer (https://llvm.org/docs/LibFuzzer.html), and Honggfuzz (https://github.com/google/honggfuzz).</p>
<p>灰盒模糊测试通过在编译时对一些位置（例如代码块跳转点）进行插桩来获取运行时反馈，从而更好的筛选语料进入语料库，获取更好的覆盖率，深入代码发现漏洞。</p>
<h4 id="whitebox-fuzzing">Whitebox fuzzing</h4>
<p>Whitebox fuzzing is based on a technique called symbolic execution, which uses program analysis and constraint solvers to systematically enumerate interesting program paths. The constraint solvers used as the back-end in whitebox fuzzing are Satisfiability Modulo Theory (SMT) solvers, which allow for reasoning about (quantifier free) first-order logic formulas with equality and function/predicate symbols drawn from different background theories.</p>
<p>Whitebox fuzzers calculate the path condition of an input i—the set of inputs which traverse the same path as i. The path condition is represented as an SMTformula, e.g. i[0] = 42 ∧ i[0] − i[1] &gt; 7.</p>
<p>Given a seed input s, the path condition is calculated and mutated (as opposed to mutating the program input). The mutated path condition is then sent to a constraint solver to generate new inputs.</p>
<p>The main benefit of this technique is that by carefully keeping track of path conditions of all inputs seen so far, it always generates an input traversing a new path (new control flow).</p>
<p>Existing whitebox fuzzing tools include KLEE (https://klee. github.io/) and SAGE.</p>
<p>基于符号执行的白盒模糊测试，通过变异路径条件，然后利用约束求解器生成新的输入，这种方式总是能生成一个经过新的路径（深入代码）的输入。</p>
<h4 id="other-fuzzing-tools">Other fuzzing tools</h4>
<p>DeepState, a unit testing framework that allows developers to fuzz the various units of their system (https://github. com/trailofbits/deepstate).</p>
<p>The Mayhem system. --- Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, David Brumley. 2012. Unleashing Mayhem on Binary Code. IEEE Symposium on Security and Privacy (S&amp;P’12).</p>
<h4 id="challenges">Challenges</h4>
<p>现阶段模糊测试的挑战。</p>
<h5 id="automation">Automation</h5>
<p>自动化模糊测试方面的挑战。</p>
<h6 id="c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems">[C.1] More Software. How can we fuzz efficiently more types of software systems?</h6>
<p>How to fuzz programs that take highly-structured inputs, such as file parsers or object-oriented programs.</p>
<p>Fuzzing cyber-physical systems, which interact with the environment as part of their execution, or machine learning systems, whose behavior is determined by their training data, is an under-explored area.</p>
<p>How do we fuzz stateful software, such as protocol implementations, which can produce different outputs for the same input?</p>
<p>How do we fuzz polyglot software which is written in several languages?</p>
<p>How do we fuzz GUI-based programs that take as inputs a sequence of events executed on a user interface?</p>
<p>Given a program whose input domain is defined by a grammar and/or protocol, how can a symbolic execution tool effectively formulate constraints on such ,,structured” input domains?</p>
<p>如何扩展能够进行模糊测试的领域和范围。</p>
<h6 id="c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</h6>
<p>Vulnerabilities are often encoded as assertions on the program state.</p>
<p>Using such assertions, we already know how we can discover memory- or concurrency related errors.</p>
<p>The discovery of side-channel vulnerabilities, such as information leaks or timing, cache, or energy-related side-channels is currently an active research topic.</p>
<p>Going forward, we should invent techniques to automatically detect and invoke privilege escalation, remote code execution, and other types of critical security flaws, not only in C/C++ but also in other programming languages.</p>
<p>如何扩展模糊测试发现的漏洞类型？现在已经可以利用断言检测程序运行状态发现内存和并发漏洞。侧信道漏洞发现已经成为热门，未来应该着眼于其他的关键性安全漏洞，包括其他编程语言中的。</p>
<h6 id="c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection">[C.3] More Difficult Bugs. How can we find “deep bugs” for which efficient oracles exist, but which nevertheless evade detection?</h6>
<p>Are there certain kinds of deep bugs that can be found efficiently with specialized approaches? Structure-aware and grammar-based fuzzing as well as the integration of static analysis and symbolic execution with greybox fuzzing are promising directions.</p>
<p>Software also changes all the time—techniques that can target software patches will prove essential for finding bugs as they are introduced.</p>
<p>We should investigate strategies to boost fault finding, such as AFLFast which enables faster crash detection in greybox fuzzers, and study the utility of GPUs and other means of efficient parallelization to maximize the number of executions per unit time.</p>
<p>Ranking bugs in terms of their importance can also improve the effectiveness of fuzzing in practice.</p>
<p>如何发现更深层次的漏洞？</p>
<ol type="1">
<li>结构感知和基于语法的模糊测试，以及静态分析和符号执行与灰盒模糊测试的结合是很有前途的方向。</li>
<li>针对软件补丁的技术可能是发现错误的关键。</li>
<li>应该研究促进故障发现的策略。</li>
</ol>
<h6 id="c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</h6>
<p>Why have they evaded discovery? We need empirical studies to understand the nature and distribution of security vulnerabilities in source code.</p>
<p>需要实证研究来了解源代码中安全漏洞的性质和分布。</p>
<h5 id="the-human-component">The Human Component</h5>
<p>模糊测试中的人工成分。</p>
<h6 id="c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</h6>
<p>During our meeting, Ned Williamson, a prolific security researcher at Google, demonstrated his semi-automated approach to vulnerability discovery.</p>
<p>Ned would first audit the code to identify units that may contain a security flaw.</p>
<p>He would prepare the unit for fuzzing, run the fuzzer for a while, and identify roadblocks for the fuzzer.</p>
<p>Ned would manually patch out the roadblock to help the fuzzer make better progress.</p>
<p>If the fuzzer spends more time fuzzing less relevant portions of the code, Ned would adjust the test driver and re-focus the fuzzer.</p>
<p>Once a potential vulnerability is found, he would backtrack, add each roadblock back, and adjust the vulnerability-exposing input accordingly.</p>
<p>This semi-automated process raises several research questions. How can we facilitate a more effective communication between fuzzer and security auditor? How can the security auditor dynamically direct the fuzzer? How can the fuzzer explain what prevents it from progressing, and how can the auditor instruct the fuzzer to overcome the roadblock?</p>
<p>人在模糊测试中能起到的作用，也就是什么才是最合理的半自动化模糊测试方案？</p>
<h6 id="c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools">[C.6] Usability. How can we improve the usability of fuzzing tools?</h6>
<p>如何提高模糊工具的可用性？</p>
<h5 id="fuzzing-theory">Fuzzing Theory</h5>
<p>Why do some fuzzers work so much better than others? What are their limitations? We want to be able to explain interesting phenomena that we have observed empirically, make predictions and extrapolate from these observations.</p>
<p>To do this, we need a sound theoretical model of the fuzzing process.</p>
<h6 id="c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</h6>
<p>Blackbox and whitebox fuzzing sit on two ends of a spectrum.</p>
<p>A whitebox fuzzer might provide a formal guarantee about the absence of detectable vulnerabilities. If we assume that a symbolic execution engine can enumerate all paths in piece of code and the oracle is encoded as assertions, then whitebox fuzzing can formally verify the absence of bugs.</p>
<p>If it can enumerate only some paths in reasonable time, we can still provide partial guarantees.</p>
<p>To make symbolic execution applicable in practice, correctness or completeness are traded for scalability. How does this trade-off affect the guarantees?</p>
<p>In contrast, a blackbox fuzzer can never guarantee the absence of vulnerabilities for all inputs.</p>
<p>What is the residual risk that at the end of a fuzzing campaign a bug still exists in the program that has not been found? If we model blackbox fuzzing as a random sampling from the program’s input space, we can leverage methods from applied statistics to estimate the residual risk.</p>
<p>A greybox fuzzer uses program feedback to boost the efficiency of finding errors. However, this program feedback introduces an adaptive bias. How do we account for this adaptive bias when assessing residual risk? To answer such questions, we should develop statistical and probabilistic frameworks, and methodologies for sound estimation with quantifiable accuracy.</p>
<p>除了白盒模糊测试，灰盒模糊测试和黑盒模糊测试都不能保证没有未发现的漏洞。白盒模糊测试受限于时间和可扩展性也无法完全保证，灰盒模糊测试存在适应性偏差，黑盒模糊测试存在剩余风险。</p>
<h6 id="c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</h6>
<p>Given a program and a time budget, how can we select that fuzzing technique, or combination of techniques, which finds the most vulnerabilities within the time budget?</p>
<p>How do program size and complexity affect the scalability and performance of each technique?</p>
<p>How much more efficient is an attacker that has an order of magnitude more computational resources?</p>
<h5 id="evaluation-and-benchmarks">Evaluation and Benchmarks</h5>
<p>[C.9] How can we evaluate specialized fuzzers?</p>
<p>[C.10] How can we prevent overfitting to a specific benchmark?</p>
<p>[C.11] Are synthetic bugs representative?</p>
<p>[C.12] Are real bugs, which have previously been discovered with other fuzzers, representative?</p>
<p>[C.13] Is coverage a good measure of fuzzer effectiveness?</p>
<p>[C.14] What is a fair choice of time budget?</p>
<p>[C.15] How do we evaluate techniques instead of implementations?</p>
<h4 id="survey">Survey</h4>
<p>The survey participants marked improving automation (71%), building a theory of fuzzing (63%), and finding valid measures of fuzzer performance (63%) as their Top-3 most important challenges.</p>
<p>While practitioners and researchers were mostly in agreement, practitioners demonstrated a particularly greater interest in the development of human-in-the-loop approaches (+0.8 Likert points).</p>
<p>On average, a respondent marked all identified challenges as important or very important on a 5-point Likert-scale.</p>
<h3 id="sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv20_SoK.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>Abstract—Greybox fuzzing has been the most scalable and practical approach to software testing.</p>
<p>Most greybox fuzzing tools are coverage guided as code coverage is strongly correlated with bug coverage.</p>
<p>However, since most covered codes may not contain bugs, blindly extending code coverage is less efficient, especially for corner cases.</p>
<p>Unlike coverage-based fuzzers who extend the code coverage in an undirected manner, a directed fuzzer spends most of its time budget on reaching specific target locations (e.g., the bug-prone zone) without wasting resources stressing unrelated parts.</p>
<p>Thus, directed greybox fuzzing is particularly suitable for scenarios such as patch testing, bug reproduction, and special bug hunting.</p>
<p>与盲目扩展路径覆盖范围的基于覆盖范围的模糊测试程序不同，定向模糊测试程序将其大部分时间预算花在到达特定的目标位置（例如，容易出错的区域）上，而不会浪费资源来强调不相关的部分。因此，定向灰盒模糊测试特别适用于补丁测试、bug复制以及与其他工具集成等场景。</p>
<h4 id="introduction">Introduction</h4>
<p>Traditionally, directed fuzzers are based on symbolic execution, which uses program analysis and constraint solving to generate inputs that exercise different program paths. Such directed fuzzers cast the reachability problem as iterative constraint satisfaction problem. However, since directed symbolic execution relies on heavyweight program analysis and constraint solving, it suffers from scalability and compatibility limitations.</p>
<p>By specifying a set of target sites in the program under test (PUT) and leveraging lightweight compile-time instrumentation of the PUT, a directed greybox fuzzer calculates the distance between the seed and the target to assist seed selection.</p>
<p>By giving more mutation chances to the seeds that are closer to the target, it can steer the greybox fuzzing to reach the target locations.</p>
<p>DGF casts reachability as an optimization problem to minimize the distance of the generated seeds to the targets.</p>
<p>Compared with directed symbolic execution, DGF has much better scalability and improves the efficiency by several magnitudes.</p>
<p>For now, DGF has evolved beyond the primary pattern that depends on manually labeled target sites and distance-based metrics to prioritize the seeds. A great number of variations have been realized to boost software testing under different scenarios, such as fuzzers directed by target sequence, by semantic information, by parser, by typestate, by sanitizer checks, by memory usage, and by vulnerable probability. Complex deep behavioral testing scenes, such as use-afterfree bugs, memory consumption bugs, memory violation bugs, algorithmic complexity vulnerabilities, input validation bugs in robotic vehicles, and deep stateful bugs.</p>
<p>定向灰盒模糊测试技术将目标位置的可达性问题转化为一个优化问题，以最小化生成的输入种子到目标位置的距离为标准来进行语料库的筛选。目前，定向灰盒模糊测试技术已经超越了依赖于手动标记的目标位置和基于距离的度量来确定输入种子优先级的主要模式。为了在不同的场景下提高软件测试，已经实现了大量的变体。</p>
<h4 id="background">Background</h4>
<p>This section provides the background knowledge on CGF and DGF.</p>
<h5 id="terminology">Terminology</h5>
<p>To avoid the confusion on the presentation of different literature, we unify the terminology in fuzzing.</p>
<ul>
<li>Fuzzing. In this paper, fuzzing refers to traditional blackbox fuzzing and greybox fuzzing. We exclude whitebox fuzzing as it depends on constraint solving of symbolic execution to generate inputs, which is quite different from evolutionary fuzzers based on mutation.</li>
<li>Testcase. A testcase is an input to the PUT, which is generated by randomly mutating a seed.</li>
<li>Seed. A seed is a testcase that is favored (trigger a new path or close to the target) and retained for the mutation to generate new testcases in the next fuzzing iteration.</li>
<li>Seed prioritization. Seed prioritization means to evaluate and sort the seeds according to its performance. Prioritized seeds would be given more fuzzing chances.</li>
<li>Power schedule Power schedule means to determine the number of fuzzing tests to be applied on a seed (i.e., energy).</li>
<li>Fuzzing cycle All seeds in the seed queue have been fuzzed at least once.</li>
</ul>
<p>本论文对模糊测试中术语的定义。</p>
<h5 id="coverage-guide-greybox-fuzzing">Coverage-guide Greybox Fuzzing</h5>
<p>Coverage-guide greybox fuzzing is the most prevalent fuzzing scheme that aims to maximize the code coverage to find hidden bugs.</p>
<p>AFL (American fuzzy lop) is the stateof-the-art coverage-based greybox fuzzer, and many stateof-the-art greybox fuzzers are built on top of it. Here we use AFL as a representative to illustrate the principle of CGF.</p>
<p>AFL uses lightweight instrumentation to capture basic block transitions and gain coverage information during runtime.</p>
<p>Then it selects a seed from the seed queue and mutates the seed to generate testcases.</p>
<p>If a testcase exercises a new path, it is added to the queue as a new seed.</p>
<p>AFL favors seeds that triggered new paths and give them preference over the non-favored ones.</p>
<p>Compared to other instrumented fuzzers, AFL has a modest performance overhead.</p>
<p>Edge coverage. AFL obtains the execution trace and calculates the edge coverage by instrumenting the PUT at compile time. It inserts random numbers for each branch jump at compile-time and collects these inserted numbers from the register at run-time to identify the basic block transition. Edge coverage is more delicate and sensitive than basic block coverage as it takes into account the transition between basic blocks. It is also more scalable than path coverage as it avoids path explosion.</p>
<p>Seed prioritization. AFL leverages the edge-coverage information to select seeds. It maintains a seed queue and fuzzes the seed within it one by one. It labels some seeds as “favored” when they execute fast and are small in size. AFL uses a bitmap with edges as keys and top-rate seeds as values to maintain the best performance seeds for each edge. It selects favored seeds from the top_rated queue, and gives these seeds preference over the non-favored ones by giving the favored one more fuzzing chances.</p>
<p>Mutation strategies. AFL has two categories of mutation strategies: deterministic strategies and non-deterministic strategies.</p>
<p>The deterministic strategies are applied first, which leverage mutators based on bit-flip, arithmetic, token, dictionary, and interest values to sequentially mutate the seeds with different granularity.</p>
<p>After doing deterministic strategies, AFL introduces non-deterministic strategies, including the havoc stage and splice stage. In the havoc stage, AFL mutates the seed by randomly choosing a sequence of mutation operators from the deterministic strategies and apply them to random locations in the seed file. As a result, the generated testcase is significantly different from the original seed. Then, AFL uses the splice strategy to randomly choose another seed from the seed queue and recombine it with the current seed to generate a new seed. Then, the havoc strategies are re-implemented to the new seed.</p>
<p>Power schedule. In the deterministic stage, mutation strategies are involved sequentially, but in the non-deterministic stage, AFL can assign energy to the seed to decide the fuzzing chances of each seed. The energy is assigned according to the performance score of each seed, which is based on coverage (prioritize inputs that cover more paths), execution time (prioritize inputs that execute faster), and discovery time (prioritize inputs discovered later) Particularly, if the test case exercises a new path, AFL will double the assigned energy.</p>
<p>以AFL为例介绍了覆盖率导向灰盒模糊测试技术。</p>
<p>AFL使用边缘覆盖替代一般的基本块覆盖。边缘覆盖比基本块覆盖更精细和敏感，因为它考虑了基本块之间的过渡。它也比路径覆盖更具可伸缩性，因为它避免了路径爆炸。AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器收集这些随机数获知跳转信息，统计边缘覆盖。</p>
<p>AFL偏爱出发新路径的输入种子，AFL通过一个位图记录每个种子的优先级，对于优先级高的种子，AFL给予更多的模糊机会，也就是后面说的能量。</p>
<p>AFL有两类变异策略：确定性策略和非确定性策略。AFL首先采用确定性策略，利用基于位翻转、算术、令牌、字典和兴趣值的变异器依次变异不同粒度的种子。在进行确定性策略之后，AFL就会进行非确定性策略，包括havoc阶段和拼接阶段。在havoc阶段，AFL通过从确定性策略中随机选择一系列变异算子对种子进行变异，并将其应用于种子文件中的随机位置。因此，生成的testcase与原始种子有很大的不同。然后，AFL使用剪接策略从种子队列中随机选择另一个种子，并将其与当前种子重新组合以生成新的种子。最后，对新种子重新实施破坏策略。</p>
<p>AFL通过能量调度来分配一轮模糊测试的时间。在确定性阶段，变异策略依次参与，而在非确定性阶段，AFL可以给种子分配能量来决定每个种子的模糊机会。能量是根据每个种子的性能得分来分配的，这是基于覆盖率（优先考虑覆盖更多路径的输入）、执行情况时间（对执行速度更快的输入进行优先级排序）和发现时间（对稍后发现的输入进行优先级排序）。特别的，如果测试用例执行一条新路径，AFL将加倍分配的能量。</p>
<h5 id="directed-greybox-fuzzing">Directed Greybox Fuzzing</h5>
<p><img src="/png/2021-01-02-21-17-13.png"></p>
<p>In 2017, B¨ohme et al. introduced the concept of Directed Greybox Fuzzing (DGF) and implemented a tool called AFLGo based on the modern greybox fuzzing framework.</p>
<p>Unlike blindly increasing the path coverage in coverage-based greybox fuzzing, DGF aims to reach a set of pre-identified locations in the code (potentially the buggy parts) and spends most of its time budget on reaching target locations without wasting resources stressing unrelated parts.</p>
<p>Here we use AFLGo as the representative to illustrate how DGF works.</p>
<p>AFLGo follows the general principles and architecture as coverage-guided fuzzing.</p>
<p>During the compiletime, in addition to instrument to obtain the execution path and path coverage information, AFLGo also calculate the distances between the input and the pre-defined targets. The distance is calculated based on the average of basic blocks on the input seed’s execution trace weight to the target basic blocks, where the weight is determined by the number of edges in the call graph and control-flow graphs of the program.</p>
<p>Then, at runtime, AFLGo prioritize seeds based on distance instead of new path coverage and give preference to seeds closer to the targets at basic block level distance.</p>
<p>B¨ohme et al. view the greybox fuzzing process as a Markov chain that can be efficiently navigated using a “power schedule”. They leverage a simulated annealing strategy to gradually assign more energy to a seed that is closer to the targets than to a seed that is further away. They cast reachability as an optimization problem to minimize the distance of the generated seeds to the targets.</p>
<p>The exploration-exploitation problem. For DGF, the whole fuzzing process is divided as the exploration phase and the exploitation phase. The exploration phase is designed to uncover as many paths as possible. Like many coverageguided fuzzers, DGF in this phase favors the seeds that trigger new paths and prioritizes them. This is because new paths increase the potential to lead to the targets. It is particularly necessary when the initial seeds are quite far from the targets.</p>
<p>Then, based on the known paths, the exploitation phase is invoked to drive the engine to the target code areas. In this phase, B¨ohme et al. prioritize seeds that are closer to the targets and assign more energy to them. The intuition is that if the path that the current seed executes is closer to any of the expected paths that can reach the target, more mutations on that seed should be more likely to generate expected seeds that fulfill the target. The exploration-exploitation tradeoff lies in how to coordinates these two phases. B¨ohme et al use a fixed splitting of the exploration and exploitation phases.</p>
<p>For example, for 24-hour testing, AFLGo uses 20 hours for the exploration and then 4 hours for the exploitation.</p>
<p>以AFLGo为例介绍了定向灰盒模糊测试技术。</p>
<p>与AFL不同，除了获取执行路径和路径覆盖信息外，AFLGo还计算输入与预定义目标之间的距离。该距离基于输入种子的执行跟踪权值上的基本块到目标基本块的平均值来计算，其中权值由程序的调用图和控制流图中的边数来确定。</p>
<p>Bo¨hme等人将灰盒模糊化过程视为一个马尔可夫链，可以使用“功率调度”进行有效导航。他们利用模拟退火策略，逐渐将更多的能量分配给距离目标较近的种子，而不是距离目标较远的种子。他们将可达性问题转化为一个优化问题，以最小化生成的种子到目标的距离。</p>
<p>AFLGo将整个DGF分为两个阶段，探索阶段和开发阶段。</p>
<p>勘探阶段的目的是尽可能多地揭示路径，像许多覆盖率导向模糊程序一样，这个阶段的DGF偏爱触发新路径并对其进行优先级排序的种子，因为新的路径增加了通向目标的可能性。当最初的种子离目标相当远时，这是合理的。</p>
<p>开发阶段的目的是最小化生成的种子到目标的距离。在这一阶段，Bo¨hme等人对更接近目标的种子进行优先排序，并为它们分配更多的能量。直觉是，如果当前种子执行的路径更接近可以到达目标的任何预期路径，那么该种子上的更多突变应该更有可能生成实现目标的预期种子。</p>
<p>勘探开发的权衡在于如何协调这两个阶段。Bo¨hme等人使用固定的勘探和开发阶段划分。例如，对于24小时测试，AFLGo使用20小时进行勘探，然后使用4小时进行开发。</p>
<h5 id="difference-between-cgf-and-dgf">Difference between CGF and DGF</h5>
<ol type="1">
<li>Seed prioritization. A major difference between CGF and DGF lies in the seed prioritization. Since CGF aims to maximize the path coverage, CGF gives preference to seeds that trigger new paths. Differently, DGF aims to reach specific locations in the code. Thus, it prioritizes seeds that are “closer” to the targets. The evaluation metrics of the seeds varies a lot, including distance, coverage, path, and probability.</li>
<li>Target involvement. CGF expands code coverage in an undirected manner, which wastes testing resources on code regions do not contain bugs. While for DGF, a set of targets are marked in advance, manually or automatically, to guide the fuzzing process and save the power. The target selection can affect the performance of DGF. For example, selecting critical sites, such as memory allocation function malloc() or string manipulation function strcpy(), as targets are more likely to trigger memory corruption bugs. Besides, we can leverage the relationship among targets to accelerate detecting complex behavioral bugs, such as use-after-free. Thus, the involvement of targets gives more chance to optimize DGF by applying customized techniques that are specific to DGF.</li>
<li>Exploration-exploitation. Researchers model the greybox fuzzing process as a “multi-armed bandit problem” where the seeds are considered as arms of a multiarmed bandit. For coverage-based greybox fuzzing, the whole process is essentially a tradeoff of the exploration-exploitation problem, where exploration stands for trying as many seeds as possible while exploitation means mutating a certain seed as much as possible. For DGF, the exploration-exploitation problem lies in coordinating the exploration phase and the exploitation phase. In the exploration phase, DGF try to discover as many seeds as possible and learn information from them to increase the potential to reach the targets. At the same time, the exploitation phase gives more chances of mutation to seeds that are more likely to generate inputs to reach the target.</li>
</ol>
<p>CGF和DGF技术的不同点。</p>
<ol type="1">
<li>种子优先级。CGF的目标是最大化路径覆盖，所以会偏爱触发新路径的种子。而DGF的目标是到达代码中的特定位置，所以它偏爱更接近目标的种子。也就是两者对于种子优先级的评价指标不同，包括距离、覆盖率、路径和概率。</li>
<li>探索目标。CGF以一种无方向的方式扩展代码覆盖范围，在不包含bug的代码区域浪费能量。DGF则预先对一组目标位置进行人工或自动标记，以指导整个模糊测试过程，从而节省能量。目标的选择会影响DGF的性能。例如，选择关键目标（如内存分配函数malloc或字符串操作函数strcpy）作为目标更可能触发内存溢出漏洞。此外，我们还可以利用目标之间的关系来加速检测复杂的逻辑漏洞，例如UAF。</li>
<li>勘探开发。对于基于覆盖率的灰盒模糊测试，整个过程本质上是一个探索-开发问题的折衷，其中探索意味着尝试尽可能多的种子，而开发意味着尽可能多地变异某个种子。对于DGF来说，勘探开发问题在于勘探阶段与开发阶段的协调。在探索阶段，DGF试图发现尽可能多的种子，并从中获取更多的新路径，以增加到达目标的可能性。同时，开发阶段给了一些种子更多的变异机会，这些种子更有可能产生到达目标的输入。</li>
</ol>
<h5 id="application-of-dgf">Application of DGF</h5>
<p>DGF is a promising direction as it is especially suitable and effective for specific testing scenarios. We summarize the following common practical application of DGF.</p>
<ul>
<li>Patch testing. DGF can be used to test whether a patch is complete and compatible. A patch is incomplete when a bug can be triggered by multiple inputs, for example, CVE-2017-15939 is caused by an incomplete fix for CVE-2017-15023. Meanwhile, a patch can introduce new bugs. For example, CVE-2016-5728 is introduced by a careless code update. Thus, directed fuzzing towards problematic changes or patches has a higher chance of exposing bugs.</li>
<li>Bug reproduction. DGF is useful when reproducing a known bug without the buggy input. For example, due to concerns such as privacy, some applications (e.g., video player) are not allowed to send the input file. With DGF, the in-house development team can use DGF to reproduce the crash with the method calls in stack-trace and some environmental parameters. DGF is also helpful when generating Proof-of-Concept (PoC) inputs of disclosed vulnerabilities given bug report information. In fact, DGF is in demand because 45.1% of the usual bug reports cannot be reproduced due to missing information and users privacy violations.</li>
<li>Knowledge boost. DGF can boost program testing by integrating the knowledge from a human analyst or auxiliary techniques. Human-in-the loop is commonly used in software testing, which can help to identify the critical syscalls or security-sensitive program sites (e.g., memory allocation function malloc(), string manipulation function strcpy()) based on the previous experience to guide fuzzing to error-prone parts. Auxiliary techniques, such as symbolic execution and tait analysis can be leveraged to overcome roadblocks in the testing. Preliminary results from static analysis and machine learning based detection approach can be used as the potential vulnerable targets for DGF.</li>
<li>Energy saving. Another interesting application of DGF is when the testing resource is limited, for example, fuzzing the IoT devices. Under this circumstance, to save the time and computational resources spent on non-buggy like code regions, identifying critical code areas to guide the testing is more efficient than testing the whole program in an undirected manner.</li>
<li>Special bug hunting. Finally, DGF can be applied to hunting special bugs based on customized indicators. For example, finding uncontrolled memory consumption bugs under the guidance of memory usage, find useafter-free bugs under the guidance of typestate violation. With DGF, the efficiency of discovering behavioral complex bugs can be greatly improved.</li>
</ul>
<p>DGF常见的应用。</p>
<ul>
<li>补丁测试。DGF可以用来测试补丁是否完整和兼容。修补程序在以下情况下是不完整的：一个错误可以由多个输入触发；一个补丁可能会引入新的bug。因此，针对有问题的更改或补丁的定向模糊有更高的暴露bug的机会。</li>
<li>bug复现。对于复现没有触发bug的输入的已知bug，DGF是非常擅长的。例如，出于隐私等考虑，某些应用程序（如视频播放器）不允许发送输入文件。使用DGF，内部开发团队可以使用DGF通过stack-trace中的方法调用和一些环境参数来再现崩溃。在给定错误报告信息的情况下，DGF也可以生成已披露漏洞的概念验证（PoC）输入。事实上，DGF的需求量很大，因为45.1%的常见错误报告由于信息丢失和用户隐私侵犯而无法复现。</li>
<li>人机合一（意译法）。DGF可以集合来自分析人员的知识或辅助技术来促进程序测试。通过分析人员的知识和经验可以帮助DFG识别关键的系统调用或security-sensitive的程序站点（例如，内存分配函数malloc、字符串操作函数strcpy），基于以前的经验来引导模糊化到容易出错的部分。如符号执行和tait analysis之类的辅助技术可以用来解决测试中的障碍，而静态分析和基于机器学习的检测方法的初步结果可以用作DGF的潜在易受攻击目标。</li>
<li>资源的有效利用。当测试资源有限时，例如，对物联网设备进行模糊测试。为了节省花费在非bug类代码区域上的时间和计算资源，识别关键代码区域来指导测试比无方向地测试整个程序更有效。</li>
<li>特定bug狩猎。DGF可以应用于基于定制指标的特定bug搜索。例如，在内存使用状况的指导下查找内存泄漏bug，在typestate violation（应该是指违反了特定的使用范例，例如free后并未清除指针）的指导下查找UAF漏洞。使用DGF，可以大大提高发现行为复杂bug的效率。</li>
</ul>
<h4 id="assessment-of-the-state-of-the-art-works">Assessment of the-state-of-the-art Works</h4>
<p>To conduct a thorough assessment, we extract 15 metrics based on the features of DGF. We further divide the metrics into three categories, including basic information, implementation details, and optimization methods. In the following, we concentrate on properties that related to the critical techniques of DGF, including directed type, input optimization, seed prioritization, power assignment, mutation scheduling, and data-flow analysis. Detailed assessment is listed in Table I.</p>
<p><img src="/png/2021-01-02-22-46-04.png"></p>
<p>为了进行全面的评估，论文根据DGF的特征提取了15个度量。同时进一步将度量分为三类，包括基本信息、实现细节和优化方法。在下文中，论文集中讨论与DGF关键技术相关的特性，包括定向类型、输入优化、种子优先级、能量分配、变异调度和数据流分析。上图（表1）为具体评价。</p>
<h5 id="directed-type">Directed Type</h5>
<p>Although this paper focuses on directed greybox fuzzing (noted as G in Table I), some of the works we investigated adopt symbolic execution to enhance the directedness, forming directed hybrid fuzzing (noted as H), we also include them in this table.</p>
<p>For the directed type, DGF was initially directed by target sites that are manually labeled in the PUT, such as AFLGo and Hawkeye.</p>
<p>Then, researchers noticed that the relationship among the targets is also helpful. For example, in order to trigger use-after-free vulnerabilities, a sequence of operations (e.g., allocate memory, use memory, and free memory) must be executed in a specific order. UAFuzz and UAFL leverages target sequences instead of target sites to find use-after-free vulnerabilities. LOLLY also uses target statement sequences to guide greybox fuzzing to trigger bugs that resulted from the sequential execution of multiple statements. Berry uses symbolic execution to enhance the directedness of LOLLY when reaching deep targets along complex paths.</p>
<p>Apart from the target sequence, researchers have proposed various mechanisms to direct the fuzzing process. Memlock is directed by memory usage to find uncontrolled memory consumption bugs. V-Fuzz is directed by vulnerable probability, which is predicted by a deep learning model to guide the fuzzing process to potentially vulnerable code area. SemFuzz and DrillerGo leverage semantic information retrieved from CVE description and git logs to direct fuzzing and generate PoC exploits. 1DVUL is directed by patch-related branches that directly change the original data flow or control flow to discover 1-day vulnerabilities. SAVIOR and ParmeSan are directed by information from sanitizers. IJON leverages annotations from a human analyst to guide the fuzzer to overcome significant roadblocks. RVFUZZER is directed by control instability to find input validation bugs in robotic vehicles. PFUZZER is directed explicitly at input parser to cover the space of possible inputs well.</p>
<p>DGF has evolved from reaching target locations to hunting complex deep behavioral bugs.</p>
<p>该论文主要研究有向灰盒模糊测试（表1中记为G），不过在某些工作中采用了符号执行来增强有向性，形成了有向混合模糊测试（表1中记为H）。</p>
<p>对于定向类型，DGF最初由PUT中手动标记的目标位置定向，如AFLGo和Hawkeye。</p>
<p>研究人员后来发现目标之间的关系也是有帮助的，也就是改变单独的目标为目标序列。例如，为了出发UAF漏洞，必须按特定顺序执行一系列操作：分配内存、使用内存和释放内存。UAFuzz和UAFL利用目标序列而不是目标位置发现UAF漏洞。LOLLY还使用目标语句序列来引导灰盒模糊测试触发由多个语句的顺序执行导致的bug。Berry使用符号执行来增强LOLLY沿着复杂路径到达深层目标时的方向性。</p>
<p>除了目标序列之外，研究人员还提出了各种机制来指导模糊测试程序。Memlock通过内存使用来查找内存泄漏漏洞。V-Fuzz以易受攻击概率为指导，通过深度学习模型预测易受攻击概率，将模糊测试程序引导到潜在易受攻击的代码区域。SemFuzz和DrillerGo利用从CVE描述和git日志中检索到的语义信息来指导模糊测试并生成PoC报告。1DVUL通过那些直接改变原始数据流或控制流的补丁指导以发现1-day漏洞。SAVIOR和Parmasan是由来自sanitizers（Sanitizers是谷歌发起的开源工具集）的信息指导的。IJON利用来自分析人员的注释来指导模糊测试程序克服重要的障碍。RVFUZZER受control instability的指导，在机器人车辆中发现输入验证漏洞。PFUZZER明确地指向输入解析器，从而更好地覆盖代码区域。</p>
<p>DGF已经从到达目标位置发展到猎取复杂的深层的行为漏洞。</p>
<h5 id="input-optimization">Input Optimization</h5>
<p>Once the targets are marked, DGF needs to generate a seed input to invoke the fuzzing process. A good seed input can drive the fuzzing process closer to the target location and improve the performance of the later mutation process.</p>
<p>According to Zong et al., on average, over 91.7% of the inputs of AFLGo cannot reach the buggy code. Thus, optimizing the input generation has much room to improve the directedness of DGF.</p>
<p>SeededFuzz focuses on improving the generation and selection of initial seeds to achieve the goal of directed fuzzing. It utilizes dynamic taint analysis to identify the bytes of seeds which can influence values at security-sensitive program sites and generates new inputs by mutating the relative bytes and feeds them to target programs to trigger errors.</p>
<p>FuzzGuard uses a deep-learning-based approach to filter out unreachable inputs before exercising them. It views program inputs as a kind of pattern and uses a large number of inputs labeled with the reachability to the target code learned from previous executions to train a model. Then, FuzzGuard utilizes the model to predict the reachability of the newly generated inputs without running them, which saves the time spent on real execution.</p>
<p>A fuzzer can perform much better if it generates the input concerning the input grammar.</p>
<p>TOFU takes advantage of the known structure of the programs inputs in the form of a protobuf specification to generate valid inputs. TOFU augments the input space to include command-line flags by dividing the fuzzing process into syntactic-fuzzing and semantic-fuzzing. However, it usually takes one or two days to implement input-language grammar even if the user is familiar with the input language.</p>
<p>SemFuzz leverages information (syscalls and parameters) retrieved from CVE description and git log to build designed seed inputs to increases the probability of hitting the vulnerable functions.</p>
<p>TIFF and ProFuzzer identify input types to assist mutation towards maximizing the likelihood of triggering memory corruption bugs.</p>
<p>PFUZZER is a syntax-driven approach that specifically targets input parsers to maximize the input space coverage without generating plausible inputs.</p>
<p>优化输入生成对提高DGF的方向性有很大的提升空间。</p>
<p>seedfuzz致力于改进初始种子的生成和选择，以达到定向模糊的目的。它利用动态污点分析来识别种子当中那些会影响security-sensitive程序位置的值的字节，通过改变这些字节来生成新的输入提供给目标程序以触发错误。</p>
<p>FuzzGuard使用了一种基于深度学习的方法，在练习之前过滤掉无法达到的输入。它将程序的输入看作一种模式，并使用大量的在之前的执行中能够到达目标代码的输入来训练模型。然后，FuzzGuard利用该模型预测新生成的输入的可达性，而无需运行它们，从而节省了实际执行所需的时间。</p>
<p>TOFU利用protobuf规范形式的程序输入的已知结构来生成有效的输入。TOFU将模糊测试过程分为语法模糊化和语义模糊化以包含命令行标志，扩展了输入空间。然而，即使用户熟悉输入语言，实现输入语言语法通常也需要一到两天的时间。</p>
<p>SemFuzz利用从CVE描述和git日志中检索到的信息（系统调用和参数）来构建设计好的种子输入，以增加命中易受攻击函数的概率。</p>
<p>TIFF和ProFuzzer识别输入类型，以帮助变异最大化触发内存溢出漏洞的可能性。</p>
<p>PFUZZER是一种语法驱动的方法，专门针对输入解析器，在生成不合理输入的情况下最大化输入空间覆盖率。</p>
<h5 id="seed-prioritization">Seed Prioritization</h5>
<p>The crux of DGF is selecting and prioritizing the seeds that perform better in directedness under certain metrics. We summarize three prevalent metrics widely adopted by modern works, including distance, coverage, and probability.</p>
<ol type="1">
<li>Distance: As we can see from Table I, 32% (9/28) of the directed fuzzers prioritize seeds based on distance and give preference to the seeds that are closer to the target. As a groundbreaking work, AFLGo instruments the source code at compile-time and calculates the distances to the target basic blocks by the number of edges in the call graph and control-flow graphs of the PUT. Then at run-time, it aggregates the distance values of each exercised basic block to compute an average value to evaluate the seed. Many followups inherit this distance-based scheme, such as ParmeSan, and 1DVUL. TOFU’s distance metric is defined as the number of correct branching decisions needed to reach the target. RDFuzz combines distance with frequency to prioritize seeds. The code areas are separated into highfrequency and low-frequency areas by counting the execution frequency. The inputs are classified into high/low distance and high/low frequency four types. In the exploration phase, the low-frequency seeds are prioritized to improve the coverage, and for the exploitation phase, the low distance seeds are preferred to achieve the target code areas. UAFuzz is a tailored directed greybox fuzzer for complex behavioral use-after-free vulnerabilities. Different from the distance based on the control-flow graph, it uses a distance metric of call chains leading to the target functions that are more likely to include both allocation and free functions. W¨ustholz et al uses an online static lookahead analysis to determine a path prefix for which all suffix paths cannot reach a target location. By stressing the path prefix that might reach the target locations, the power schedule of the fuzzer can allocate its resources more strategically. One drawback of the distance-based method is that it only focuses on the shortest distance. When there is more than one path reaching the same targets, the longer options might be ignored, leading to a deviation. We will illustrate it with an example in Section IV-D.</li>
<li>Similarity &amp; Coverage: In addition to distance, similarity is another useful metric, which indicates the coverage of certain target forms, such as functions, locations, and bug traces. This metric is particularly suitable when there are many targets. Hawkeye leverages a static analysis of the PUT and combines the basic block trace distance with covered function similarity for the seed prioritization and power scheduling. LOLLY uses a user-specified program statement sequence as the target and takes the seed’s ability of covering the target sequences (i.e., sequence coverage) as a metric to evaluate the seed. UAFL uses the operation sequence coverage as the feedback to guide the testcase generation to progressively cover the operation sequences that are likely to trigger use-after-free vulnerabilities. UAFuzz also uses a sequenceness-aware target similarity metric to measure the similarity between the execution of a seed and the target UAF bug trace. The sequenceness-aware target similarity metric concretely assesses how many targets a seed execution trace covers at runtime and takes ordering of the targets into account. Berry takes into account the coverage of nodes in the target sequences and their execution context. It enhances the target sequences with necessary nodes, namely the basic blocks required to reach the nodes in the target sequences for all paths. In addition to the branch coverage, Berry also considers the similarity between the target execution trace and the enhanced target sequence to prioritize the seeds. SAVIOR prioritizes seeds that have higher potentials to trigger vulnerabilities based on the coverage of labels predicted by UBSan. TortoiseFuzz differentiates edges that are more likely to be destined vulnerable based on the fact that memory corruption vulnerabilities are closely related to sensitive memory operations. It prioritizes inputs by a combination of coverige and security impact, which is represented by the memory operations on three different types of granularity at function, loop, and basic block.</li>
<li>Probability: Probability is another useful metric that prioritizes the seed by how likely to reach the targets. It usually combines the seed prioritization metric with the target identification metric to direct fuzzing towards potentially vulnerable locations. V-Fuzz and SUZZER predicts the vulnerable probability of functions based on a deep learningbased model and gives each basic block in the vulnerable function a static score. Then for each input, it calculates the sum of the static score of all the basic blocks on its execution path and prioritizes the inputs with higher scores. SAVIOR leverage UBSan to label code areas with buggy potentials. TAFL strengthens fuzzing toward regions that have a higher probability of containing vulnerabilities, which is based on static semantic metrics including sensitive, complex, deep and rare-to-reach regions.</li>
</ol>
<p>现代文献中广泛采用的三个种子优先级的度量标准：距离、覆盖率和概率。</p>
<h6 id="distance">Distance</h6>
<p>从表1可以看出，32%（9/28）的定向模糊器根据距离对种子进行排序，并优先选择距离目标较近的种子。</p>
<p>作为一项开创性的工作，AFLGo在编译时对源代码进行检测，并通过PUT的调用图和控制流图中的边数计算到目标基本块的距离。然后在运行时聚合每个基本块的距离值，以计算平均值来评估种子。许多后续版本继承了这种基于距离的方案，如Parmasan和1DVUL。</p>
<p>TOFU的距离度量定义为达到目标所需的正确分支决策数。RDFuzz将距离和频率结合起来，对种子进行优先级排序。通过计算代码的执行频率，将代码区分为高频区和低频区。输入分为高/低距离和高/低频四种类型。在探测阶段，优先选择低频种子来提高覆盖率；在开发阶段，优先选择低距离种子来实现目标编码区域。UAFuzz是一个定制的定向灰盒模糊测试程序，用于复杂的UAF漏洞。与基于控制流图的距离不同，它使用了通向目标函数的调用链的距离度量，目标函数更可能同时包含分配函数和释放函数。</p>
<p>W¨ustholz et al使用online static lookahead analysis来找到并避免那些所有后缀路径都无法到达目标位置的路径前缀。通过强调可能到达目标位置的路径前缀，模糊测试程序的能量调度可以更有策略地分配其资源。</p>
<p>基于距离的方法的一个缺点是它只关注最短距离。当有多条路径到达同一目标时，可能会忽略较长的选项，从而导致偏差。</p>
<h6 id="similarity-coverage">Similarity &amp; Coverage</h6>
<p>除了距离，相似性是另一个有用的度量，它表示某些目标形式的覆盖范围，例如函数、位置和bug traces。当有许多目标时，这个指标特别适用。</p>
<p>Hawkeye利用对PUT的静态分析，并将基本块跟踪距离与覆盖函数相似性结合起来，用于种子优先级排序和能量调度。</p>
<p>LOLLY使用用户指定的程序语句序列作为目标，并将种子覆盖目标序列的能力（即序列覆盖率）作为评估种子的度量。</p>
<p>UAFL使用操作序列覆盖率作为反馈，引导测试用例生成逐步覆盖触发UAF漏洞可能使用的操作序列。</p>
<p>UAFuzz还使用序列感知目标相似性度量来度量种子执行和目标UAF bug traces之间的相似性。序列感知目标相似性度量具体评估了种子在运行时执行trace所覆盖的目标的数量和顺序。</p>
<p>Berry考虑了目标序列中节点的覆盖率及其执行上下文。它用必要的节点来增强目标序列，即到达所有路径的目标序列中的节点所需的基本块。除了分支覆盖之外，Berry还考虑了目标执行trace和增强目标序列之间的相似性，从而对种子进行优先级排序。</p>
<p>SAVIOR根据UBSan预测的标签覆盖率，优先考虑具有更高触发漏洞潜力的种子。</p>
<p>TortoiseFuzz基于内存损坏漏洞与敏感内存操作密切相关的事实，区分了更可能注定易受攻击的边缘。它通过覆盖率和安全影响因子的组合对输入进行优先级排序，这由函数、循环和基本块的三种不同粒度类型的内存操作表示。</p>
<h6 id="probability">Probability</h6>
<p>概率是另一个有用的指标，它通过达到目标的可能性来确定种子的优先级。它通常将种子优先级度量与目标识别度量相结合，以将模糊化引向潜在的易受攻击的位置。</p>
<p>V-Fuzz和SUZZER基于一个通过深度学习的模型得到函数的脆弱概率，并给函数中的每个基本块一个静态分数。然后，对于每个输入，它计算其执行路径上所有基本块的静态得分之和，并对得分较高的输入进行优先级排序。</p>
<p>SAVIOR利用UBSan为代码区域添加可能存在bug的标签。</p>
<p>TAFL加强了对包含漏洞的概率较高的区域的模糊化，该模糊化基于静态语义度量，包括敏感、复杂、深入和罕见的区域。</p>
<h5 id="power-assignment">Power Assignment</h5>
<p>After the seeds are selected and prioritized, the preferenced seeds are given more power, namely more chances of fuzzing tests. Although power assignment is crucial for DGF, very few works, try to optimize this step.</p>
<p>AFLGo uses a simulated annealing-based power schedule to gradually assign more energy to seeds that are closer to the target locations while reducing energy for further away seeds. Unlike the traditional random walk scheduling that always accepts better solutions which may be trapped in a local optimum, simulated annealing accepts the solution which is not as good as the current one with a certain probability, so it is possible to jump out of the local optimum and reach the global optimal solution. Hawkeye also adopted simulated annealing but added prioritization. Thus, seeds closer to the target are mutated first, which further improves the directedness. LOLLY adopts an optimized simulated annealing-based power schedule to achieve maximum sequence coverage. Controlled by a temperature threshold, the cooling schedule in the exploration stage randomly mutates the provided seeds to generate many new inputs, while in the exploitation stage, it generates more new inputs from seeds that have higher sequence coverage.</p>
<p>AFLGo使用一种基于模拟退火的能量调度，逐渐将更多的能量分配给距离目标位置较近的种子，同时减少距离较远的种子的能量。传统的随机游走调度总是接受更好的解从而可能陷入局部最优，而模拟退火则以一定的概率接受不如当前最优解的解，因此有可能跳出局部最优解而达到全局最优解。Hawkeye也采用了模拟退火，但增加了优先级。因此，更接近目标的种子首先发生变异，这进一步提高了方向性。LOLLY采用了一种优化的基于模拟退火的能量调度来实现最大的序列覆盖。在温度阈值的控制下，探测阶段的会随机地对所提供的种子进行变异以产生许多新的输入；而在开发阶段，它会从具有更高序列覆盖率的种子中产生更多的新输入。</p>
<h5 id="mutator-scheduling">Mutator Scheduling</h5>
<p>Some fuzzers (8 out of 28) optimize mutation strategies to assist directed fuzzing, which is mainly realized by classifying the mutators into different granularities.</p>
<p>Hawkeye leverages an adaptive mutation strategy, which categorizes the mutators as coarse-grained and fine-grained. Coarse-grained mutators are used to change bulks of bytes during the mutations, while fine-grained only involve a few byte-level modifications, insertions, or deletions. It gives less chance of coarse-grained mutations when a seed can reach the target function. Once the seed reaches targets, the times of doing fine-grained mutations increase, and coarse-grained mutations decrease. In practice, the scheduling of mutators is controlled by empirical values.</p>
<p>Similarly, V-Fuzz classify the mutation strategies into slight mutation and heavy mutation and dynamically adjust the mutation strategy via a threshold according to the actual fuzzing states.</p>
<p>SemFuzz performs a resemble classification, except it focuses on the syscall. SemFuzz utilizes coarse mutation on the inputs to find a syscall sequence that can move the execution towards the “vulnerable functions”. After that, it switches to a fine-grained mutation on the syscall sequence to monitor the “critical variables”. TAFL also adopts granularity-aware scheduling of mutators based on an empirical observation that (1) coarse-grained mutators outperforms fine-grained mutators on path growth; (2) combining multiple mutators performs better than using a single kind of mutator. ProFuzzer entails different mutation policies according to the input field types recognized by input type probing.</p>
<p>一些模糊程序（8/28）优化变异策略来辅助定向模糊测试，这主要是通过将变异分类成不同的粒度（类型）来实现的。</p>
<p>Hawkeye利用了一种自适应变异策略，将变异分为粗粒度和细粒度。粗粒度的变异在突变期间会更改大量字节，而细粒度的变异只涉及少量字节级的修改、插入或删除。当一个种子接近目标函数时，粗粒度变异的机会就变少。一旦种子达到目标函数，进行细粒度变异的次数增加，而粗粒度变异的次数减少。</p>
<p>同样，V-Fuzz将变异策略分为轻微变异和严重变异，并根据实际模糊测试的状态通过阈值动态调整变异策略。</p>
<p>SemFuzz执行类似的分类，只是它关注于系统调用。SemFuzz利用对输入的粗变异来找到一个系统调用序列，该序列可以将执行移向易受攻击的函数。之后，它将切换到syscall序列上的细粒度变异，以监视关键变量。</p>
<p>TAFL还采用了基于经验观察的粒度感知的变异调度，即：粗粒度变异在路径增长方面优于细粒度变异；组合多个变异的性能优于使用单一类型的变异。</p>
<p>ProFuzzer根据输入类型探测识别的输入字段类型，如何进行不同的变异策略。</p>
<h5 id="data-flow-analysis">Data-flow Analysis</h5>
<p>Data-flow analysis, such as taint analysis, can reflect the effect of mutation in the generated inputs, thus, it is helpful to optimize mutation strategy and input generation.</p>
<p>RDFuzz leverages a disturb-and-check method to identify and protect the distance sensitive content from the input, which is vital to maintain the distance. Preventing such content during mutation can help to approach the target code location more efficiently. UAFL adopts an information flow analysis to identify the relationship between the input and the program variables in the conditional statement, and assigns higher mutation possibility for these input bytes with high information flow strength, as they are more likely to change the values of target statement. SemFuzz tracks the kernel function parameters that the critical variables depend on via backward data-flow analysis. SeededFuzz utilizes dynamic taint analysis to identify the bytes of seeds which can influence values at security-sensitive program sites. PFUZZER uses dynamic tainting of inputs to relate each value processed to the input characters it is derived from. TIFF infers input type by means of in-memory data-structure identification and dynamic taint analysis, which increases the probability of triggering memory corruption vulnerabilities by type-based mutation. Nevertheless, data-flow analysis usually enlarges the run-time overhead.</p>
<p>数据流分析（如污点分析）可以反映变异对生成输入的影响，有助于优化变异策略和输入生成。</p>
<p>RDFuzz利用一种干扰-检查方法来识别和保护对输入的距离敏感的内容，这对保持距离至关重要（该句不太理解，可能翻译错误）。在变异过程中防止这些内容有助于更有效地接近目标代码位置。</p>
<p>UAFL采用信息流分析来识别条件语句中的输入和程序变量之间的关系，并为那些信息流更多的输入字节赋予更高的变异可能性，因为它们更可能改变目标语句的值。</p>
<p>SemFuzz通过反向数据流分析跟踪关键变量所依赖的核函数参数。</p>
<p>SeedFuzz利用动态污点分析来识别种子中可能影响security-sensitive程序位置的值的字节。</p>
<p>PFUZZER使用输入的动态污染，将处理的每个值与其派生的输入字符相关联。</p>
<p>TIFF通过内存中的数据结构识别和动态污点分析来推断输入类型，这增加了基于类型的变异触发内存损坏漏洞的概率。</p>
<p>当然，数据流分析通常会增加运行时开销。</p>
<h4 id="challenges-and-solutions">Challenges and Solutions</h4>
<p>DFG中现在的挑战及可能的解决方案。</p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/fuzz/" rel="tag"><i class="fa fa-tag"></i> fuzz</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/2cb5ce06/" rel="next" title="IS-crypto-非对称加密-RSA的攻击方式">
                <i class="fa fa-chevron-left"></i> IS-crypto-非对称加密-RSA的攻击方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/apple-touch-icon.png" alt="w4rd3n">
            
              <p class="site-author-name" itemprop="name">w4rd3n</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">168</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/hitworld" title="GitHub &rarr; https://github.com/hitworld" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#surveyreview"><span class="nav-number">1.</span> <span class="nav-text">Survey/Review</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fuzzing-challenges-and-reflections"><span class="nav-number">1.1.</span> <span class="nav-text">Fuzzing: Challenges and Reflections</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#blackbox-fuzzing"><span class="nav-number">1.1.1.</span> <span class="nav-text">Blackbox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#greybox-fuzzing"><span class="nav-number">1.1.2.</span> <span class="nav-text">Greybox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#whitebox-fuzzing"><span class="nav-number">1.1.3.</span> <span class="nav-text">Whitebox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#other-fuzzing-tools"><span class="nav-number">1.1.4.</span> <span class="nav-text">Other fuzzing tools</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#challenges"><span class="nav-number">1.1.5.</span> <span class="nav-text">Challenges</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#automation"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">Automation</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems"><span class="nav-number">1.1.5.1.1.</span> <span class="nav-text">[C.1] More Software. How can we fuzz efficiently more types of software systems?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities"><span class="nav-number">1.1.5.1.2.</span> <span class="nav-text">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection"><span class="nav-number">1.1.5.1.3.</span> <span class="nav-text">[C.3] More Difficult Bugs. How can we find “deep bugs” for which efficient oracles exist, but which nevertheless evade detection?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns"><span class="nav-number">1.1.5.1.4.</span> <span class="nav-text">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#the-human-component"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">The Human Component</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor"><span class="nav-number">1.1.5.2.1.</span> <span class="nav-text">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools"><span class="nav-number">1.1.5.2.2.</span> <span class="nav-text">[C.6] Usability. How can we improve the usability of fuzzing tools?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fuzzing-theory"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">Fuzzing Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful"><span class="nav-number">1.1.5.3.1.</span> <span class="nav-text">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing"><span class="nav-number">1.1.5.3.2.</span> <span class="nav-text">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#evaluation-and-benchmarks"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">Evaluation and Benchmarks</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#survey"><span class="nav-number">1.1.6.</span> <span class="nav-text">Survey</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing"><span class="nav-number">1.2.</span> <span class="nav-text">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#introduction"><span class="nav-number">1.2.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#background"><span class="nav-number">1.2.2.</span> <span class="nav-text">Background</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#terminology"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Terminology</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#coverage-guide-greybox-fuzzing"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">Coverage-guide Greybox Fuzzing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#directed-greybox-fuzzing"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">Directed Greybox Fuzzing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#difference-between-cgf-and-dgf"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">Difference between CGF and DGF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#application-of-dgf"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">Application of DGF</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#assessment-of-the-state-of-the-art-works"><span class="nav-number">1.2.3.</span> <span class="nav-text">Assessment of the-state-of-the-art Works</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#directed-type"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Directed Type</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#input-optimization"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">Input Optimization</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#seed-prioritization"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">Seed Prioritization</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#distance"><span class="nav-number">1.2.3.3.1.</span> <span class="nav-text">Distance</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#similarity-coverage"><span class="nav-number">1.2.3.3.2.</span> <span class="nav-text">Similarity &amp; Coverage</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#probability"><span class="nav-number">1.2.3.3.3.</span> <span class="nav-text">Probability</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#power-assignment"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">Power Assignment</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mutator-scheduling"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">Mutator Scheduling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#data-flow-analysis"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">Data-flow Analysis</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#challenges-and-solutions"><span class="nav-number">1.2.4.</span> <span class="nav-text">Challenges and Solutions</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-gg-circle"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">w4rd3n</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">844k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">12:47</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz",
                'X-LC-Key': "UvlYMzpJKw0Jrw61V5BA5ifU",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  
  

  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>;
  <script>
  //$("body").backstretch("/images/background.jpg");
  </script>
  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
