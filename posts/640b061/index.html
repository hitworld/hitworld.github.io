<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.5.0">


  <link rel="mask-icon" href="/images/safari_pinned_tab.svg?v=6.5.0" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml">







<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Survey/Review 本文主要是对fuzz相关论文的笔记。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing是一种自动化漏洞发现技术---通过持续不断地生成输入并报告程序的crash。 现在有三种主要的fuzzing技术和工具：黑盒，灰盒和白盒fuzzing。 Blackbox fuzzing 黑盒fuzzing不需要任何关于">
<meta name="keywords" content="fuzz">
<meta property="og:type" content="article">
<meta property="og:title" content="IS-pwn-fuzz-theory-present-situation">
<meta property="og:url" content="https://hitworld.github.io/posts/640b061/index.html">
<meta property="og:site_name" content="w4rd3n">
<meta property="og:description" content="Survey/Review 本文主要是对fuzz相关论文的笔记。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing是一种自动化漏洞发现技术---通过持续不断地生成输入并报告程序的crash。 现在有三种主要的fuzzing技术和工具：黑盒，灰盒和白盒fuzzing。 Blackbox fuzzing 黑盒fuzzing不需要任何关于">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-22-46-04.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-13-09-41.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-09-55.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-40-06.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-40-26.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-17-05-33.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-17-14-22.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-17-09-36-29.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-17-10-19-48.png">
<meta property="og:updated_time" content="2021-01-17T12:54:43.510Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IS-pwn-fuzz-theory-present-situation">
<meta name="twitter:description" content="Survey/Review 本文主要是对fuzz相关论文的笔记。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing是一种自动化漏洞发现技术---通过持续不断地生成输入并报告程序的crash。 现在有三种主要的fuzzing技术和工具：黑盒，灰盒和白盒fuzzing。 Blackbox fuzzing 黑盒fuzzing不需要任何关于">
<meta name="twitter:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">






  <link rel="canonical" href="https://hitworld.github.io/posts/640b061/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>IS-pwn-fuzz-theory-present-situation | w4rd3n</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">w4rd3n</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">混吃等死</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>友链</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hitworld.github.io/posts/640b061/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="w4rd3n">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/apple-touch-icon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="w4rd3n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">IS-pwn-fuzz-theory-present-situation
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-01-01 23:41:38" itemprop="dateCreated datePublished" datetime="2021-01-01T23:41:38+08:00">2021-01-01</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/" itemprop="url" rel="index"><span itemprop="name">IS</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/posts/640b061/" class="leancloud_visitors" data-flag-title="IS-pwn-fuzz-theory-present-situation">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度：</span>
               
                 <span class="leancloud-visitors-count"></span>
                 <span>℃</span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">24k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">22 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="surveyreview">Survey/Review</h2>
<p>本文主要是对fuzz相关论文的笔记。</p>
<h3 id="fuzzing-challenges-and-reflections">Fuzzing: Challenges and Reflections</h3>
<p><a href="https://www.comp.nus.edu.sg/~abhik/pdf/IEEE-SW-Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>Fuzzing是一种自动化漏洞发现技术---通过持续不断地生成输入并报告程序的crash。</p>
<p>现在有三种主要的fuzzing技术和工具：黑盒，灰盒和白盒fuzzing。</p>
<h4 id="blackbox-fuzzing">Blackbox fuzzing</h4>
<p>黑盒fuzzing不需要任何关于程序的先验知识。</p>
<p>黑盒fuzzing主要有两种的variants：突变和生成。</p>
<p>前者通过初始语料库(seed inputs)开始变异，通过对随机位置的随机突变来生成新的输入。</p>
<p>后者是从头开始生成的，通过提供的输入格式来生成满足所提供语法的新的输入。</p>
<p>黑盒fuzzing工具：Peach (http://community.peachfuzzer.com)。</p>
<h4 id="greybox-fuzzing">Greybox fuzzing</h4>
<p>灰盒fuzzing通过在编译时对一些位置（例如代码块跳转点）进行插桩来获取轻量级的运行时反馈从而引导fuzzer。</p>
<p>通常，程序会在代码块交界处被插桩，并且一些初始的语料库会被提供，初始的种子输入会被用于突变产生新的输入，那些覆盖了新的代码块或者其他增加了代码覆盖的输入将被加入语料库。</p>
<p>所以随着这种覆盖反馈fuzzer的运行，输入会逐渐深入程序的深处。</p>
<p>sanitizers还会注入断言到程序中来判断漏洞的种类。</p>
<p>灰盒fuzzing工具：AFL (https://lcamtuf.coredump.cx/afl/), LibFuzzer (https://llvm.org/docs/LibFuzzer.html), and Honggfuzz (https://github.com/google/honggfuzz)。</p>
<h4 id="whitebox-fuzzing">Whitebox fuzzing</h4>
<p>基于符号执行的白盒fuzzing使用程序分析和约束求解器来系统地枚举感兴趣的程序路径，其中用作后端的约束求解器是Satisfiability Modulo Theory (SMT)求解器。</p>
<p>白盒fuzzing通过分析与i经过同一路径的输入集合来计算i经过的路径的条件，路径条件用SMT表示，例如：i[0] = 42 ∧ i[0] − i[1] &gt; 7。</p>
<p>白盒fuzzer对于给定的种子输入s，计算并改变路径条件而不是改变程序输入，然后将改变后的路径条件发送到一个约束解算器来产生新的输入。</p>
<p>白盒fuzzing会跟踪到目前为止获取的所有输入的路径状况，所以始终能够生成一个经过新路径的输入。</p>
<p>白盒fuzzing工具：KLEE (https://klee.github.io/) and SAGE。</p>
<h4 id="other-fuzzing-tools">Other fuzzing tools</h4>
<p>DeepState (https://github.com/trailofbits/deepstate)：一个单元测试框架.</p>
<p>The Mayhem system. --- Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, David Brumley. 2012. Unleashing Mayhem on Binary Code. IEEE Symposium on Security and Privacy (S&amp;P’12).</p>
<h4 id="challenges">Challenges</h4>
<p>fuzzing技术现在面临的问题与挑战。</p>
<h5 id="automation">Automation</h5>
<p>自动化方面的挑战。</p>
<h6 id="c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems">[C.1] More Software. How can we fuzz efficiently more types of software systems?</h6>
<p>如何扩展能够fuzzing的领域和范围？</p>
<p>现在的fuzzer基本上都是生成不规则的输入，而对于文件解析器和面对对象程序来说，需要的是高度结构化的输入。</p>
<p>还有网络程序，机器学习系统的fuzzing方式应该是怎么样的？</p>
<p>对于那些有状态的软件，它们对于相同的输入会产生不同的输出，应该如何进行fuzz？还有多语言构建的软件和GUI软件。</p>
<p>给定一个程序，它的输入域是由语法/协议定义的，那么符号执行工具如何对这种结构化的输入域制定约束?</p>
<h6 id="c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</h6>
<p>如何扩展fuzzing发现的漏洞类型？</p>
<p>现在已经可以利用断言检测程序运行状态发现内存和并发漏洞。</p>
<p>侧信道漏洞发现已经成为热门，未来应该着眼于其他的关键性安全漏洞，包括其他编程语言中的。</p>
<h6 id="c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection">[C.3] More Difficult Bugs. How can we find “deep bugs” for which efficient oracles exist, but which nevertheless evade detection?</h6>
<p>fuzzing如何发现更深层次的漏洞？</p>
<ol type="1">
<li>结构感知和基于语法的fuzzing，以及静态分析和符号执行与灰盒fuzzing的结合是很有前途的方向。</li>
<li>针对软件补丁的技术对于发现软件补丁引入的错误是至关重要的。</li>
<li>应该研究促进bug发现的策略。例如AFLFast，它可以在灰盒fuzzing中更快地检测崩溃，并通过研究gpu的效用和其他有效的并行化方法以最大限度地增加单位时间内的执行次数。</li>
</ol>
<h6 id="c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</h6>
<p>需要实证研究来了解源代码中安全漏洞的性质和分布。</p>
<h5 id="the-human-component">The Human Component</h5>
<p>fuzzing中的人。</p>
<h6 id="c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</h6>
<p>人在模糊测试中能起到的作用，也就是什么才是最合理的半自动化fuzzing方案？</p>
<p>Ned Williamson给出了下面这种方法。</p>
<ol type="1">
<li>首先审核代码，以识别可能存在安全漏洞的代码区域。</li>
<li>为设备准备fuzzing，运行fuzzing一段时间，并确定fuzzing的遇到的障碍和问题。</li>
<li>手动修补遇到的障碍和问题。</li>
<li>如果fuzzer花费很多时间来测试代码中不重要的部分，对fuzzer进行调整。</li>
<li>一旦发现了一个潜在的漏洞，就要回溯并之前修补的部分，并相应地调整输入再次触发漏洞。</li>
</ol>
<h6 id="c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools">[C.6] Usability. How can we improve the usability of fuzzing tools?</h6>
<p>如何提高模糊工具的可用性？也就是说如何让一个技术人员快速掌握并使用。</p>
<h5 id="fuzzing-theory">Fuzzing Theory</h5>
<p>需要一个可靠的Fuzzing Theory。</p>
<h6 id="c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</h6>
<p>除了白盒模糊测试，灰盒模糊测试和黑盒模糊测试都不能保证没有未发现的漏洞。白盒模糊测试受限于时间和可扩展性也无法完全保证，灰盒模糊测试存在适应性偏差，黑盒模糊测试存在剩余风险。</p>
<h6 id="c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</h6>
<p>给定程序和时间预算，什么是能在时间预算内找到最多漏洞的模糊技术或技术组合程序的大小和复杂性如何影响可伸缩性和性能？计算资源对程序效率的影响程度？</p>
<h5 id="evaluation-and-benchmarks">Evaluation and Benchmarks</h5>
<p>[C.9] How can we evaluate specialized fuzzers?</p>
<p>[C.10] How can we prevent overfitting to a specific benchmark?</p>
<p>[C.11] Are synthetic bugs representative?</p>
<p>[C.12] Are real bugs, which have previously been discovered with other fuzzers, representative?</p>
<p>[C.13] Is coverage a good measure of fuzzer effectiveness?</p>
<p>[C.14] What is a fair choice of time budget?</p>
<p>[C.15] How do we evaluate techniques instead of implementations?</p>
<h3 id="sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv20_SoK.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>大多数greybox fuzzing工具是由代码覆盖率引导的，因为代码覆盖率和bug覆盖率是正相关的，但其实大部分代码是不存在bug的。</p>
<p>与盲目扩展路径覆盖范围的基于代码覆盖率的fuzzing不同，定向greybox fuzzing将其大部分时间预算花在到达特定的目标站点上，例如，容易出bug的区域。</p>
<p>因此，定向灰盒模糊测试特别适用于补丁测试、1 day bug复现以及与其他工具集成等场景。</p>
<h4 id="introduction">Introduction</h4>
<p>传统的定向fuzzing是基于符号执行，但是这种方法会受到符号执行一些问题而限制，例如：复杂的约束求解和路径爆炸等问题。</p>
<p>通过在测试程序(PUT)中指定一组目标站点，并利用编译时插桩获取运行时信息来计算输入种子和目标之间的距离，通过给更接近目标的种子更多的变异机会来将fuzzer导向目标站点。</p>
<p>定向greybox fuzzing将目标站点的可达性问题转化为一个优化问题，以最小化生成的输入种子到目标站点的距离为标准来进行语料库的筛选。</p>
<p>定向greybox fuzzing并未止步于依赖于手动标记的目标站点和基于距离的度量来确定输入种子优先级的主要模式。为了在不同的场景下提高软件测试，已经实现了大量的变体。</p>
<h4 id="background">Background</h4>
<p>CGF(覆盖率导向greybox fuzzing)和DGF(定向greybox fuzzing)的背景知识。</p>
<h5 id="terminology">Terminology</h5>
<p>该文献中使用的术语及其解释。</p>
<ul>
<li>Fuzzing. In this paper, fuzzing refers to traditional blackbox fuzzing and greybox fuzzing. We exclude whitebox fuzzing as it depends on constraint solving of symbolic execution to generate inputs, which is quite different from evolutionary fuzzers based on mutation.</li>
<li>Testcase. A testcase is an input to the PUT, which is generated by randomly mutating a seed.</li>
<li>Seed. A seed is a testcase that is favored (trigger a new path or close to the target) and retained for the mutation to generate new testcases in the next fuzzing iteration.</li>
<li>Seed prioritization. Seed prioritization means to evaluate and sort the seeds according to its performance. Prioritized seeds would be given more fuzzing chances.</li>
<li>Power schedule Power schedule means to determine the number of fuzzing tests to be applied on a seed (i.e., energy).</li>
<li>Fuzzing cycle All seeds in the seed queue have been fuzzed at least once.</li>
</ul>
<h5 id="coverage-guide-greybox-fuzzing">Coverage-guide Greybox Fuzzing</h5>
<p>下面用ALF来介绍典型的CGF技术。</p>
<p>AFL使用上下文不敏感的边缘覆盖替代一般的基本块覆盖。AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器收集这些随机数获知跳转信息，统计边缘覆盖。</p>
<p>边缘覆盖比基本块覆盖更精细和敏感，因为它考虑了基本块之间的过渡。边缘覆盖也比路径覆盖更具可伸缩性，因为它避免了路径爆炸。</p>
<p>AFL偏爱触发新路径的输入种子，AFL通过一个位图记录每个种子的优先级，对于优先级高的种子，AFL给予更多的模糊机会，也就是后面说的能量。</p>
<p>AFL有两类变异策略：确定性策略和非确定性策略。</p>
<p>AFL首先采用确定性策略，利用基于位翻转、算术、令牌、字典和特殊值的变异器依次变异不同粒度的种子。</p>
<p>在进行确定性策略之后，AFL就会进行非确定性策略，包括havoc阶段和拼接阶段。</p>
<p>在havoc阶段，AFL通过从确定性策略中随机选择一系列变异算子对种子进行变异，并将其应用于种子文件中的随机位置。因此，生成的testcase与原始种子有很大的不同。</p>
<p>然后，AFL使用剪接策略从种子队列中随机选择另一个种子，并将其与当前种子重新组合以生成新的种子。最后，对新种子重新实施破坏策略。</p>
<p>AFL通过能量调度来分配一轮模糊测试的时间。</p>
<p>在确定性阶段，变异策略依次参与，而在非确定性阶段，AFL可以给种子分配能量来决定每个种子的模糊机会。</p>
<p>能量是根据每个种子的性能得分来分配的，而性能得分基于覆盖率（优先考虑覆盖更多路径的输入）、执行情况时间（对执行速度更快的输入进行优先级排序）和发现时间（对稍后发现的输入进行优先级排序）来计算出来的。</p>
<p>特别的，如果测试用例执行一条新路径，AFL将加倍分配的能量。</p>
<h5 id="directed-greybox-fuzzing">Directed Greybox Fuzzing</h5>
<p><img src="/png/2021-01-02-21-17-13.png"></p>
<p>下面以用AFLGo为代表来说明DGF的工作原理。</p>
<p>AFLGo遵循CGF的一般原理和体系结构。不同的是，除了获取执行路径和边缘覆盖信息外，AFLGo还计算输入与目标站点之间的距离。该距离基于输入种子的执行跟踪权值上的基本块到目标基本块的平均值来计算，其中权值由程序的调用图和控制流图中的边数来确定。</p>
<p>B¨ohme et al.将灰盒模糊化过程视为一个马尔可夫链，所以可以使用功率调度进行有效的引导。利用模拟退火策略，逐渐将更多的能量分配给距离目标较近的种子，从而将可达性问题转化为优化问题，以最小化生成的种子到目标站点的距离为目的。</p>
<p>AFLGo将整个DGF分为两个阶段，探索阶段和开发阶段。</p>
<p>勘探阶段的目的是尽可能多地揭示路径，像许多覆盖率导向模糊程序一样，这个阶段的DGF偏爱触发新路径并对其进行优先级排序的种子，因为新的路径增加了通向目标的可能性。</p>
<p>开发阶段的目的是最小化生成的种子到目标的距离。在这一阶段，B¨ohme et al.对更接近目标的种子进行优先排序，并为它们分配更多的能量。</p>
<p>勘探开发的权衡在于如何协调这两个阶段。B¨ohme et al.使用固定的勘探和开发阶段划分。例如，对于24小时测试，AFLGo使用20小时进行勘探，然后使用4小时进行开发。</p>
<h5 id="difference-between-cgf-and-dgf">Difference between CGF and DGF</h5>
<p>CGF和DGF技术的不同点。</p>
<ol type="1">
<li>种子优先级。CGF的目标是最大化路径覆盖，所以会偏爱触发新路径的种子。而DGF的目标是到达代码中的特定位置，所以它偏爱更接近目标的种子。</li>
<li>探索目标。CGF以一种无方向的方式扩展代码覆盖范围，在不包含bug的代码区域浪费能量。DGF则预先对一组目标站点进行人工或自动标记，以指导整个模糊测试过程，从而节省能量。目标的选择会影响DGF的性能。</li>
<li>勘探开发。对于基于覆盖率的灰盒模糊测试，整个过程本质上是一个探索-开发问题的折衷，其中探索意味着尝试尽可能多的种子，而开发意味着尽可能多地变异某个种子。对于DGF来说，勘探开发问题在于勘探阶段与开发阶段的协调。在探索阶段，DGF试图发现尽可能多的种子，并从中获取更多的新路径，以增加到达目标的可能性。同时，开发阶段给了一些种子更多的变异机会，这些种子更有可能产生到达目标的输入。</li>
</ol>
<h5 id="application-of-dgf">Application of DGF</h5>
<p>DGF常见的应用方向。</p>
<ul>
<li>补丁测试。DGF可以用来测试补丁是否完整和兼容，修补程序在以下情况下是不完整的：错误可能由多个输入触发；补丁可能会引入新的bug。因此，针对有问题的更改或补丁的DGF有更高的发现bug的机会。</li>
<li>bug复现。DGF可以用于复现没有crash输入的已知bug。例如，出于隐私等考虑，某些应用程序（如视频播放器）不允许发送输入文件，这种情况下内部开发团队可以使用DGF通过stack trace中的方法调用和一些环境参数来再现崩溃。在给定错误报告信息的情况下，DGF也可以生成已披露漏洞的PoC。</li>
<li>人机合一（意译法）。DGF可以配合分析人员的知识或辅助技术来促进fuzz。通过分析人员的知识和经验可以帮助DGF识别关键的系统调用或security-sensitive的程序站点（例如，内存分配函数malloc、字符串操作函数strcpy），基于以前的经验来引导模糊化到容易出错的部分。如符号执行和taint analysis之类的辅助技术可以用来解决测试中的障碍，而静态分析和基于机器学习的检测方法的初步结果可以用作DGF的潜在易受攻击目标。</li>
<li>测试资源有限。当测试资源有限时，例如对物联网设备进行fuzz，识别关键代码区域来指导fuzz比无方向地fuzz整个程序更有效。</li>
<li>特定类型bug检测。DGF可以应用于基于定制指标的特定bug检测。例如，在内存使用状况的指导下查找内存泄漏bug，在typestate violation（应该是指违反了特定的使用范例，例如free后并未清除指针）的指导下查找UAF漏洞。</li>
</ul>
<h4 id="assessment-of-the-state-of-the-art-works">Assessment of the-state-of-the-art Works</h4>
<figure>
<img src="/png/2021-01-02-22-46-04.png" alt=""><figcaption>表1</figcaption>
</figure>
<p>为了进行全面的评估，论文根据DGF的特征提取了15个度量。同时进一步将度量分为三类，包括基本信息、实现细节和优化方法。</p>
<p>在下文中，论文集中讨论与DGF关键技术相关的特性，包括定向类型、输入优化、种子优先级、能量分配、变异调度和数据流分析。</p>
<p>该论文主要研究DGF（表1中记为G），不过在某些工作中采用了符号执行来增强有向性，形成了有向混合模糊测试（表1中记为H）。</p>
<h5 id="directed-type">Directed Type</h5>
<p>对于定向目标的类型，DGF最初通过在PUT中手动标记的目标站点来进行定向，如AFLGo和Hawkeye。</p>
<p>后来发现目标之间的关系对于bug的触发也是有影响的，所以改变单独的目标站点为目标序列。</p>
<p>为了触发UAF漏洞，必须按特定顺序执行一系列操作：分配内存、使用内存和释放内存。所以UAFuzz和UAFL利用目标序列而不是目标站点来发现UAF漏洞。LOLLY还使用目标语句序列来引导DGF触发由多个语句的顺序执行导致的bug。Berry使用符号执行来增强LOLLY沿着复杂路径到达深层目标时的方向性。</p>
<p>除了目标序列之外，研究人员还提出了各种机制来指导DGF。</p>
<p>Memlock通过监控内存使用情况来发现内存泄漏漏洞。V-Fuzz以易受攻击概率为指导，通过深度学习模型预测易受攻击概率，将DGF引导到潜在易受攻击的代码区域。SemFuzz和DrillerGo利用从CVE描述和git日志中检索到的语义信息来指导DGF并生成PoC报告。1DVUL通过那些直接改变原始数据流或控制流的补丁指导以发现1-day漏洞。SAVIOR和Parmasan是由来自sanitizers（Sanitizers是谷歌发起的开源工具集）的信息指导的。IJON利用来自分析人员的注释来指导DGF克服重要的障碍。RVFUZZER受control instability的指导，在机器人车辆中发现输入验证漏洞。PFUZZER明确地指向输入解析器，从而更好地覆盖代码区域。</p>
<p>DGF已经从到达目标站点发展到发现复杂的深层的行为漏洞。</p>
<h5 id="input-optimization">Input Optimization</h5>
<p>优化输入的生成策略对于提高DGF的性能有很大的帮助。</p>
<p>seedfuzz致力于改进初始种子的生成和选择，以达到定向模糊的目的。它利用动态污点分析来识别种子当中那些会影响security-sensitive程序位置的值的字节，通过改变这些字节来生成新的输入提供给目标程序以触发错误。</p>
<p>FuzzGuard使用了一种基于深度学习的方法，在fuzz之前过滤掉无法达到目标站点的输入。它将程序的输入看作一种模式，并使用大量的在之前的执行中能够到达目标代码的输入来训练模型，然后利用该模型预测新生成的输入的可达性，从而节省了实际执行所需的时间。</p>
<p>TOFU利用protobuf规范形式的程序输入的已知结构来生成有效的输入。通过将模糊处理分为语法模糊处理和语义模糊处理，TOFU扩大了输入空间，以包含命令行标志。然而，即使用户熟悉输入语言，实现输入语言语法通常也需要一到两天的时间。</p>
<p>SemFuzz利用从CVE描述和git日志中检索到的信息（系统调用和参数）来构建设计好的种子输入，以增加命中易受攻击函数的概率。</p>
<p>TIFF和ProFuzzer通过识别输入类型辅助变异，从而最大化触发内存溢出漏洞的可能性。</p>
<p>PFUZZER是一种语法驱动的方法，专门针对输入解析器，在生成不合理输入的情况下最大化输入空间覆盖率。</p>
<h5 id="seed-prioritization">Seed Prioritization</h5>
<p>DGF文献中广泛采用的三个种子优先级的度量标准：距离、覆盖率和概率。</p>
<h6 id="distance">Distance</h6>
<p>作为一项开创性的工作，AFLGo在编译时对源代码进行检测，并通过PUT的调用图和控制流图中的边数计算到目标基本块的距离。然后在运行时聚合每个基本块的距离值，以计算平均值来评估种子。许多后续版本继承了这种基于距离的方案，如Parmasan和1DVUL。</p>
<p>TOFU的距离度量定义为达到目标所需的正确分支决策数。</p>
<p>RDFuzz将距离和频率结合起来，对种子进行优先级排序。通过代码的执行频率将代码区分为高频区和低频区。输入分为高/低距离和高/低频四种类型。在探测阶段，优先选择低频种子来提高覆盖率；在开发阶段，优先选择低距离种子来靠近目标区域。</p>
<p>UAFuzz是一个定制的DGF程序，用于复杂的UAF漏洞。与基于控制流图的距离不同，它使用了通向目标函数的调用链的距离度量，目标函数一般包含分配函数和释放函数。</p>
<p>W¨ustholz et al使用online static lookahead analysis来找到并避免那些所有后缀路径都无法到达目标站点的路径前缀。通过强调可能到达目标站点的路径前缀，DGF的能量调度可以更合理地分配其资源。</p>
<p>基于距离的方法的一个缺点是它只关注最短距离。当有多条路径到达同一目标时，可能会忽略较长的选项，从而导致偏差。</p>
<h6 id="similarity-coverage">Similarity &amp; Coverage</h6>
<p>相似性表示某些目标形式的覆盖范围，例如函数、位置和bug traces。当有许多目标时，这个指标特别适用。</p>
<p>Hawkeye利用对PUT的静态分析，将基本块跟踪距离与覆盖函数相似性结合起来，用于种子优先级排序和能量调度。LOLLY使用指定的程序语句序列作为目标，并将种子覆盖目标序列的能力（即序列覆盖率）作为评估种子的度量。UAFL使用操作序列覆盖率作为反馈，引导测试用例生成逐步覆盖触发UAF漏洞可能使用的操作序列。</p>
<p>UAFuzz还使用序列感知目标相似性度量来度量种子执行和目标UAF bug traces之间的相似性。序列感知目标相似性度量具体评估了种子在运行时执行trace所覆盖的目标的数量和顺序。</p>
<p>Berry考虑了目标序列中节点的覆盖率及其执行上下文。它用必要的节点来增强目标序列，即到达所有路径的目标序列中的节点所需的基本块。除了分支覆盖之外，Berry还考虑了目标执行trace和增强目标序列之间的相似性，从而对种子进行优先级排序。</p>
<p>SAVIOR根据UBSan预测的标签覆盖率，优先考虑具有更高触发漏洞潜力的种子。TortoiseFuzz基于内存损坏漏洞与敏感内存操作密切相关的事实，区分了更可能注定易受攻击的边缘。它通过覆盖率和安全影响因子的组合对输入进行优先级排序，这由函数、循环和基本块的三种不同粒度类型的内存操作表示。</p>
<h6 id="probability">Probability</h6>
<p>概率是另一个有用的指标，它通过达到目标的可能性来确定种子的优先级。通常将种子优先级度量与目标识别度量相结合，以将模糊化引向潜在的易受攻击的位置。</p>
<p>V-Fuzz和SUZZER基于一个通过深度学习的模型得到函数的脆弱概率，并给函数中的每个基本块一个静态分数。然后对于每个输入计算其执行路径上所有基本块的静态得分之和，并对得分较高的输入进行优先级排序。</p>
<p>SAVIOR利用UBSan为代码区域添加可能存在bug的标签。TAFL加强了对包含漏洞的概率较高的区域的模糊化，该模糊化基于静态语义度量，包括敏感、复杂、深入和罕见的区域。</p>
<h5 id="power-assignment">Power Assignment</h5>
<p>AFLGo使用一种基于模拟退火的能量调度，逐渐将更多的能量分配给距离目标站点较近的种子，同时减少距离较远的种子的能量。</p>
<p>传统的随机游走调度总是接受更好的解从而可能陷入局部最优，而模拟退火则以一定的概率接受不如当前最优解的解，因此有可能跳出局部最优解而达到全局最优解。</p>
<p>Hawkeye也采用了模拟退火，但增加了优先级。因此，更接近目标的种子首先发生变异，这进一步提高了方向性。LOLLY采用了一种优化的基于模拟退火的能量调度来实现最大的序列覆盖。在温度阈值的控制下，探测阶段的会随机地对所提供的种子进行变异以产生许多新的输入；而在开发阶段，它会从具有更高序列覆盖率的种子中产生更多的新输入。</p>
<h5 id="mutator-scheduling">Mutator Scheduling</h5>
<p>一些模糊程序通过优化变异策略来辅助DGF，这主要是通过将变异分类成不同的粒度（类型）来实现的。</p>
<p>Hawkeye利用了一种自适应变异策略，将变异分为粗粒度和细粒度。粗粒度的变异在突变期间会更改大量字节，而细粒度的变异只涉及少量字节级的修改、插入或删除。当一个种子接近目标函数时，粗粒度变异的机会就变少。一旦种子达到目标函数，进行细粒度变异的次数增加，而粗粒度变异的次数减少。同样，V-Fuzz将变异策略分为轻微变异和严重变异，并根据实际模糊测试的状态通过阈值动态调整变异策略。</p>
<p>SemFuzz执行类似的分类，只是它关注于系统调用。SemFuzz利用对输入的粗变异来找到一个系统调用序列，该序列可以将执行移向易受攻击的函数。之后，它将切换到syscall序列上的细粒度变异，以监视关键变量。</p>
<p>TAFL还采用了基于经验观察的粒度感知的变异调度，即：粗粒度变异在路径增长方面优于细粒度变异；组合多个变异的性能优于使用单一类型的变异。</p>
<p>ProFuzzer根据输入类型探测识别的输入字段类型，如何进行不同的变异策略。</p>
<h5 id="data-flow-analysis">Data-flow Analysis</h5>
<p>数据流分析（如污点分析）可以反映变异对生成输入的影响，有助于优化变异策略和输入生成。</p>
<p>RDFuzz利用一种干扰-检查方法来识别和保护对输入的距离敏感的内容，这对保持距离至关重要（该句不太理解，可能翻译错误）。在变异过程中防止这些内容有助于更有效地接近目标代码位置。</p>
<p>UAFL采用信息流分析来识别条件语句中的输入和程序变量之间的关系，并为那些信息流更多的输入字节赋予更高的变异可能性，因为它们更可能改变目标语句的值。</p>
<p>SemFuzz通过反向数据流分析跟踪关键变量所依赖的核函数参数。SeedFuzz利用动态污点分析来识别种子中可能影响security-sensitive程序位置的值的字节。PFUZZER使用输入的动态污染，将处理的每个值与其派生的输入字符相关联。TIFF通过内存中的数据结构识别和动态污点分析来推断输入类型，这增加了基于类型的变异触发内存损坏漏洞的概率。</p>
<p>当然，数据流分析通常会增加运行时开销。</p>
<h4 id="challenges-and-solutions">Challenges and Solutions</h4>
<p>DGF面临的挑战及可能的解决方案。</p>
<h5 id="binary-code-support">Binary Code Support</h5>
<p>大多数已知的DGF都是在AFL的基础上实现的，并继承其编译时插桩方案来反馈执行状态或计算基于距离的度量。这种方案不适合没有测试源代码的场景，例如商用闭源COTS软件或部分依赖第三方库的关键程序。</p>
<p>二进制级别的DGF存在以下问题。</p>
<ol type="1">
<li>运行时开销很大。最简单的方法就是利用一个完整的系统仿真器。例如，UAFuzz处理二进制代码，并通过QEMU提取执行路径。然而，基于仿真器的工具通常效率较低。</li>
<li>目标信息收集困难。对于二进制代码中的PUT，只能从bug trace中提取目标信息。</li>
<li>标靶困难。由于二进制代码很难读取，必须对其进行反汇编，如使用idapro，并用虚拟地址标记目标。</li>
</ol>
<p>一个可行解决方案是通过硬件辅助减轻性能限制。Intel PT是最新Intel处理器中的一种轻量级硬件功能，可以捕获有关程序执行的trace数据，同时Intel PT可以动态跟踪程序执行，开销可以忽略不计。安全分析人员通过Intel PT捕获的数据包trace以及PUT的二进制文件可以重建PUT的执行路径。平均而言，基于PT的方法比QEMU-AFL快4.3倍。</p>
<p>以前的硬件功能（如Intel Last Branch Record）也可以执行程序跟踪，但其输出存储在特殊寄存器中，而不是主内存中，这限制了跟踪大小。CGF与PT的结合也有尝试，比如kAFL、PTfuzz、Ptrix和Honggfuzz。然而，PT从未被用于DGF。</p>
<p>对于二进制代码级别的目标识别和标记问题，可以利用基于机器学习的方法或启发式二进制差分方法来自动识别易受攻击的代码。</p>
<h5 id="automatic-target-identification">Automatic target identification</h5>
<p>大多数已知的DGF都要求分析人员手动标记目标（如AFLGo、Hawkeye），这依赖对于目标站点的先验知识。</p>
<p>为了实现目标的自动识别，可以使用静态分析工具在PUT中找到潜在的危险区域。然而，这些工具通常特定于所使用的bug类型和编程语言。</p>
<p>另一个方向是利用compiler sanitizer passes，比如UBSan，来注释PUT中的潜在bug。</p>
<p>对于二进制代码，1DVUL通过基于Bindiff的二进制级比较，提取不同的函数及其不同的基本块，识别与补丁相关的目标分支。基于深度学习的方法在预测脆弱性和使用预测信息指导模糊化方面也是有效的。最后，攻击面识别组件也可用于自动识别DGF的易受攻击目标。</p>
<h5 id="differentiated-weight-metric">Differentiated weight metric</h5>
<figure>
<img src="/png/2021-01-03-13-09-41.png" alt=""><figcaption>图1</figcaption>
</figure>
<p>在大多数最先进的DGF中，种子的优先级是基于等权度量的。以广泛应用的距离度量为例，通过种子与目标之间的距离来度量到达目标的能力。特别是距离由多条边表示，即基本块之间的过渡。然而，这样的测量忽略了一个事实，即不同的分支跳跃有不同的概率。</p>
<p>图1显示了一个控制流图片段，其中输入x是一个从0到9的整数。很容易知道从节点A跳到节点C的概率是0.1，从节点A跳到节点B的概率是0.9。如果据根据分支跳数计算距离，则A→C的距离比A→G短，这是因为A→C只有一个跳，而A→G有三个跳。但是如果考虑分支跳跃概率，则A→C的概率为0.1，而A→G的概率为0.9×0.7×0.5≈0.3，这比A→C更短。因此，在计算距离时考虑权重差异更为合理。其他种子优先级度量，如相似性和概率，应该遵循相同的原理。</p>
<p>一种可能的解决方案是考虑分支跳转概率。当基于概率评估目标的可达性时，每个种子基于该种子生成到达目标的输入的可能性，即将该种子的当前执行路径转换为穿过该目标的目标路径的概率来优先排序。由于执行路径可以看作是连续分支的马尔可夫链，因此可以通过收集路径中所有分支的概率来计算路径的概率。</p>
<p>基于统计模拟方法，可以通过统计计算分支概率来估计分支概率。平稳分布的密度形式上描述了DGF经过一定次数的迭代后执行某条路径的可能性。基于统计模拟方法方法需要两个条件：1）抽样应该是随机的；2）抽样规模应该很大。</p>
<p>模糊过程本质上满足了这些要求。由随机变异的测试用例驱动的执行路径可以看作是满足第一个需求的随机样本。模糊程序生成的测试用例的高吞吐量使得估计具有统计意义，满足第二个需求。因此，将模糊化作为一个抽样过程，可以以一种轻量级的方式统计估计分支跳跃概率。</p>
<p>这种基于概率的方法的一个可能缺点是潜在的运行时开销。统计跳跃计数和概率计算都引入了额外的计算。减少性能降低的一个简单方法是间隔采样。</p>
<p>另一个可能的解决方案是加速计算，这涉及到元数据的存储和访问方式。</p>
<p>传统上，基于图的数据存储在邻接表中。然而，由于基于概率的方法经常更新跳跃统计信息，并且可达性判断也需要快速的边缘跟踪，因此邻接表在访问数据时效率较低，不适合使用。另一种选择是邻接矩阵，它支持快速数据访问。然而，由于一个跳转通常有两个分支，矩阵将是巨大的，但数据分布相对稀疏，这大大增加了空间消耗。</p>
<p>因此，利用基于概率的方法的先决条件是设计一个平衡时间复杂性和空间复杂性的定制数据结构。</p>
<h5 id="global-optimum-deviation">Global Optimum Deviation</h5>
<figure>
<img src="/png/2021-01-03-16-09-55.png" alt=""><figcaption>图2</figcaption>
</figure>
<p>当DGF测试中存在多个目标时，如何协调这些目标是另一个挑战。</p>
<p>一种策略是基于Dijkstras算法来寻找全局最短距离，AFLGo就是这样做的。然而，这样的全局最优可能会错过最接近某个目标的局部最优种子，从而导致偏差。</p>
<p>图2显示了一个控制流图片段，其中节点K和O是目标节点。这里测试了三个种子，路径分别为：A→B→D→G→K，A→C→E→I→M→N→O，A→C→E→H→L。论文作者基于B¨ohme et al.定义的距离公式计算了两个目标的三条路径中每个节点之间的harmonic distances，并在每个节点的侧面标记它们。</p>
<p>路径A→C→E→H→L的种子应该是三个之中距离最小的，但这是不合理的，因为路径A→B→D→G→K穿过目标节点K，路径A→C→E→I→M→N→O穿过目标节点O，但路径A→C→E→H→L没有到达任何目标。直觉上，路径A→C→E→H→L远离目标，不应优先考虑。因此，当存在多个目标时，寻找全局最短距离存在偏差，影响模糊化的方向性。</p>
<p>这种偏差背后的原因是基于距离的种子测量只关注最短路径。当有多条路径到达同一目标时，可能会忽略较长的路径，从而导致结果出现偏差。</p>
<p>图2中，如果考虑路径A→C→K和路径A→C→E→H→O，会发现d(ACK) &lt; d(ACEIMNO) &lt; d(ACEIMNL)。这是因为路径A→C→K和路径A→C→E→H→O分别是到目标K和O的最短路径。最短路径总是优先考虑的。为了避免在评估种子时产生偏差，应该考虑到所有可能到达目标的路径。</p>
<p>为了实现这一目标，Hawkeye使用了基于轻量级静态分析的相邻函数距离扩充，该分析基于生成的调用图考虑（立即）调用关系的模式。</p>
<p>多目标协调的另一种策略是目标分离。对于每个种子，仅选择所有目标之间的最小距离作为种子的距离，并基于该最小距离对种子进行优先级排序。这样可以避免局部最优偏差，但可能会减慢达到特定目标的速度。</p>
<h5 id="missing-indirect-calls">Missing Indirect Calls</h5>
<p>无论采用何种度量，DGF都依赖于控制流分析来确定种子的优先级。以基于距离的度量为例，通常基于控制流图和调用图来度量距离。</p>
<p>然而，由于LLVM的调用流和通过LLVM的间接调用图的构造是不完整的。在实际程序中，间接函数调用非常普遍。例如，在libpng中，44.11%的函数调用是间接函数调用。对于静态分析方法，不能直接从源代码或二进制指令中观察到间接函数调用站点，例如在C中作为参数传递函数指针或使用函数对象和指针。对于二进制代码，间接调用的目标地址取决于寄存器中的值，这些值也无法获得。</p>
<p>此外，为了构造一个过程间控制流图需要将基于LLVM的IR生成的每个函数的控制流图与整个程序的调用图结合起来。因此，基于调用图和控制流图的距离测量在没有间接调用的情况下是不准确的，影响了DGF到达目标的能力。</p>
<p>对于静态方法，解决这个问题的一个简单方法是对函数指针执行Andersen的points to analysis。但是，这种基于包含的上下文不敏感指针分析会导致间接调用具有许多传出边缘，可能会产生给定输入不可能的执行路径。</p>
<p>TOFU使用函数类型签名来近似每个间接调用站点的可调用集。但是，它不考虑类型转换，这可能会允许调用不同类型的函数，从而引入不精确性。</p>
<p>对于动态情况，ParmeSan在实际执行过程中识别间接调用的缺失边，并逐渐补全调用图。最后，在执行足够数量的模糊测试之后，图趋于完整。然而，这样的解决方案不可避免地增加了运行时开销，并且不能保证完整性。</p>
<h5 id="exploration-exploitation-coordination">Exploration-exploitation coordination</h5>
<p>DGF面临的最后一个挑战是如何协调勘探与开发之间的权衡。</p>
<p>一方面，多勘探可以为开发提供充分的信息，另一方面，勘探过度会占用大量资源，延缓开发。很难确定勘探阶段和开发阶段之间的界限。</p>
<p>AFLGo采用勘探阶段和开发阶段的固定分割。测试前，时间预算在测试配置中预先设置。这样的方案是初步的，因为分离点是经验性的和不灵活的。由于每个PUT具有不同的字符，因此这种固定拆分的适应性较差。一旦勘探阶段转入开发阶段，即使由于路径不足导致方向性能较差，也不会有回头路。</p>
<figure>
<img src="/png/2021-01-03-16-40-06.png" alt=""><figcaption>图3</figcaption>
</figure>
<p>论文作者对libxml使用AFLGo进行了一个简单的实验。使用AFLGo的-z参数为勘探阶段设置不同的时间预算，并比较其性能。如图3所示，水平坐标表示测试的持续时间，垂直坐标表示所有生成的输入到目标代码区域的最小距离。实验持续24小时，AFLGo-1意味着1小时的探索加上23小时的开发，其余的依此类推。从结果可以看出，勘探阶段和开发阶段的分配会影响DGF的性能，而最佳性能（AFLGo-16）需要两个阶段都有足够的时间。然而，很难得到一个最佳的分配。</p>
<p>RDFuzz统计执行期间的分支级统计信息，以将代码区域分为高频区域和低频区域。根据频率和距离两个评价准则，将输入信号分为高、低距离和高、低频两类。低频输入有助于提高勘探所需的覆盖率；低距离输入有助于实现勘探所需的目标码区。最后，采用一个相互交织的测试时间表，交替进行勘探和开发。</p>
<p>解决这一难题的另一个可能方法是利用动态策略来协调勘探阶段和开发阶段的划分，该策略可以在勘探阶段和开发阶段之间自适应切换。</p>
<p>为了实现这一方案，论文作者建议将模糊阶段的分配转化为种子的分配，即将种子分为两组：覆盖种子用于探索和定向种子用于开发。每组种子的数目表示在相应阶段所消耗的能量。这两个阶段的协调是通过控制每组种子的数量来实现的。使用一个称为dp的变量来表示所有种子中定向种子的百分比，这也表示花费在开发阶段上的能量的百分比。在种子评价过程中，对覆盖种子进行标记，在每个模糊周期后，对有向种子进行标记，并通过dp进行调整。</p>
<figure>
<img src="/png/2021-01-03-16-40-26.png" alt=""><figcaption>算法2</figcaption>
</figure>
<p>使用算法2来说明这个设计。具有自适应分裂的DGF应该从探索阶段（dp=0）开始，该阶段侧重于发现新路径。然后，随着已知路径的增加，逐渐增加dp来调用开发阶段，在开发阶段，基于dp选择高值的有向种子并对其进行优先级排序以增强可达性。</p>
<p>当模糊测试程序在很长一段时间内找不到新的路径时，勘探阶段已经到了瓶颈，应该通过大幅度提高dp来迅速进入开发阶段。同样，也需要偶尔从开采阶段回到勘探阶段。例如，当模糊测试程序已经处于开采阶段，dp非常大（例如，dp&gt;0.9），但仍然无法在许多模糊循环中更接近目标，就应该大幅降低dp以返回勘探阶段。这是因为现有的定向种子性能较差，应该扩大路径覆盖范围以发现更多潜在的定向种子。</p>
<p>在该方案中，两个阶段可以共存，以获得最佳的性能和自适应性。值得注意的是，算法中的阈值是用来说明原理的。应该基于启发式算法产生合理的阈值。</p>
<h4 id="discussion">Discussion</h4>
<p>DGF技术中的研究热点。</p>
<h5 id="multi-targets-relationship-exploitation">Multi-targets Relationship Exploitation</h5>
<p>虽然大多数的有向模糊测试程序支持多目标，但只有少部分关注目标之间的关系。当存在多个目标时，可以通过目标之间的关系来优化DGF。如果它们是不相关的，可以给它们分配权重来区分重要性或概率。否则，可以提取隐藏关系并加以利用，以提高方向性。</p>
<p>UAFL在利用目标序列寻找UAF漏洞时，考虑了操作序列的顺序。这是因为，要触发这种行为复杂的漏洞，不仅需要覆盖单个边缘，还需要以特定顺序遍历一些长的边缘序列。这种方法可以扩展到检测语义错误，比如double-free和API误用。Berry使用所有路径的执行上下文（即到达目标序列中的节点所需的必要节点）增强目标序列。</p>
<p>在这里进一步提出以下关系。</p>
<ol type="1">
<li>执行空间关系。目标在执行树上的相对位置。假设有两个目标，可以考虑它们之间的关系，包括它们是否在同一个执行路径上，它们共享多少个执行路径，以及哪一个是另一个的前继节点还是后继节点。</li>
<li>状态空间关系。对于涉及程序状态的目标，可以考虑它们在状态空间中的位置。例如，两个目标是否共享相同的状态，以及两个状态是否可以在状态转换映射上相互转换。</li>
<li>交错关系。对于多线程程序，线程调度会影响不同线程中事件的执行顺序。在同一线程交织下可以达到的目标在交织空间中应该是一个密切的关系。</li>
</ol>
<p>基于上述讨论，建议在选择目标和确定目标优先级时考虑目标之间的关系。具有较高可达性的目标应该有更高的优先级。关系更密切的目标应该用更少的测试运行来覆盖。</p>
<h5 id="technology-integration">Technology Integration</h5>
<figure>
<img src="/png/2021-01-03-17-05-33.png" alt=""><figcaption>表4</figcaption>
</figure>
<p>DGF依赖于随机变异来产生测试输入，所以它很难到达深层目标，并且在复杂路径上触发深层缺陷的效果较差。为了增强到达角落案例和片状缺陷的方向性，采用了各种程序分析技术，如静态分析、控制流分析、数据流分析、机器学习、语义分析和符号执行（统计数据如表4所示）。</p>
<p>在论文作者调查的工具中，75%的工具依赖于控制流分析来评估种子并确定对目标的可达性；46%的工具利用静态分析来自动识别目标，并从PUT中提取信息；32%的工具使用数据流分析（主要是污点分析）来识别目标之间的关系输入和关键程序变量，优化变异策略调度；11%使用机器学习预测易受攻击的代码，过滤掉无法到达的输入；18%采用语义分析自动识别易受攻击目标，学习输入字段语义优化变异；最后，18%集成符号（concolic）执行来解决复杂的路径约束。</p>
<h5 id="implementation-limitation">Implementation Limitation</h5>
<figure>
<img src="/png/2021-01-03-17-14-22.png" alt=""><figcaption>图5</figcaption>
</figure>
<p>大约一半的工具是在AFL之上实现的。因此，性能在一定程度上受到AFL实现的限制。从两个方面来说明这种局限性。</p>
<p>第一个问题在于，AFL的边缘覆盖是基于基本块转换的，因此它只在基本块级敏感，不能在指令级区分路径差异。图5显示了两个相邻基本块之间的跳转示例。由于仅对路径敏感，因此无法区分地址0x400657处的跳转是采用（路径2）还是不采用（路径1），因为在控制流图中会有相同的边，即0x400657→0x400671。</p>
<p>另一个问题在于，AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器中收集这些插入数，以标识基本块转换（即控制流图中的边）。然后通过一个算法将插入数转换映射到64KB位图。由于不同的边可能有机会共享同一位置，因此该方案会导致路径冲突。</p>
<p>AFL的这两个局限性都会导致控制流图的不精确性，最终影响基于控制流图分析的种子优先级，无论是基于距离还是其他度量。</p>
<p>尽管这种限制可以通过构造更细粒度的控制流图或设计定制的哈希方案来缓解，但是，额外的工作不可避免地会增加运行时开销。</p>
<h5 id="efficiency-improvement">Efficiency Improvement</h5>
<p>为了实现模糊化的方向性，大多数研究人员使用额外的工具和数据分析。然而，这种额外的分析不可避免地会导致性能降低，对于给定的模糊时间预算，更高的效率意味着更多的模糊执行，=也就是更多的机会达到目标。因此，优化模糊化效率是提高方向性的另一个方向。</p>
<p>一种解决方案是将与执行无关的计算从运行时转移到编译时。例如，AFLGo通过解析PUT的调用图和过程内控制流图来度量每个基本块与目标站点之间的距离。由于解析图和计算距离都非常耗时，AFLGo在编译时将大部分程序分析转移到插桩阶段，以换取运行时的效率。</p>
<p>另一个优化是在实现级别。由于在分析过程中使用的大多数数据都是基于图的，因此如何存储和访问此类元数据对效率至关重要。可以设计一个优化的数据结构来存储这些数据，这样在基于图的拓扑结构进行搜索时就可以方便地频繁、快速地访问这些数据。例如，使用图数据库模型。</p>
<p>最后，可以利用并行计算来进一步提高效率。以前的工作已经成功地将并行性应用于CGF，但尚未应用于DGF。对于DGF，可以使用一个中心节点来维护一个种子队列，该队列保存DGF的所有种子并对其进行优先级排序。然后，将种子分发到计算节点上的并行模糊实例中，测试PUT并收集反馈信息。</p>
<h5 id="future-research-suggestions">Future research suggestions</h5>
<ul>
<li>在论文作者评估的工具中，只有SemFuzz支持内核代码测试。因此，在内核代码中引入DGF，并引导对关键站点（如syscalls和错误处理代码）的模糊化应该是一个有效的方向。</li>
<li>虽然DGF一直在尝试发现新的bug类型，比如UAF漏洞和内存泄漏漏洞，但许多常见的bug还没有被包括在内。因此，另一个研究方向是将DGF应用于特定的bug类型，如信息泄漏bug、并发bug、语义bug（TOCTTOU、double fetch）。</li>
<li>对于种子优先级度量，大多数工作都利用了基于距离和覆盖率（相似性）的方法，这有助于在不引入太多开销的情况下对种子进行量化评估。然而，较小的距离或较宽的覆盖范围并不一定意味着更接近目标，因为存在不同的权重原因和全局偏差原因。作者认为基于概率的度量应该更合理。</li>
<li>最后，分阶段模糊测试是一种可行的方法，可以进一步用于DGF。通过将到达目标的路径划分为连续的多个阶段，分阶段定向模糊算法可以在每个阶段到达子目标，逐步到达目标。此外，可以利用不同的模糊策略来满足不同阶段的需求。例如，TOFU对命令行标志使用语法模糊，对主要输入文件使用语义模糊。因此，分阶段模糊化可以降低模糊化各个阶段输入空间的维数，提高模糊化效率。</li>
</ul>
<h3 id="fuzzing-hack-art-and-science-cacm-2020">Fuzzing: Hack, Art, and Science (CACM 2020)</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/CACM20_Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>三种检测软件中安全漏洞的方法。</p>
<p>静态程序分析器：能够自动检查代码并标记错误的代码模式，它们可以标记出许多浅显的错误，但是工具也容易发出虚假的警报。</p>
<p>人工代码审计：包括发布之前的peer-reviewing和渗透测试，这个步骤可以检测很多问题，包括安全漏洞，设计缺陷和编码错误等超出了自动化工具的范围的问题。</p>
<p>然后就是模糊测试Fuzzing。</p>
<h4 id="blackbox-fuzzing-1">Blackbox Fuzzing</h4>
<p>Fuzzing最简单的形式是Blackbox random fuzzing，它随机地改变格式良好的应用程序输入，然后用这些修改后的输入测试应用程序。</p>
<figure>
<img src="/png/2021-01-17-09-36-29.png" alt=""><figcaption>图2 一个简单的Blackbox random fuzzing</figcaption>
</figure>
<p>程序采用格式良好的（第1行）作为输入。然后，它选择一个随机数的字节，这些字节将在该输入中被模糊化（第2行）。这个数字从1到输入长度除以1000不等。这个任意的1000值是可选的，但是它可以防止模糊化原始文件中的太多字节。</p>
<p>接下来，第4-8行循环重复选择输入中的一个随机位置（第5行）和一个新的随机字节（第6行），然后在该位置（第7行）写入该字节，直到所选的字节数被模糊化。</p>
<p>然后，程序用它执行被测试的应用程序（第9行），如果检测到错误，则报告错误（第10行）。</p>
<p>实际上，应用程序是在运行时检查工具的监视下运行的，如Purify、Valgrind、AppVerifier或AddressSanitizer，以增加发现非崩溃安全漏洞（如缓冲区溢出）的机会。</p>
<p>图2的程序可以重复执行，以生成任意多个新的模糊输入。尽管它很简单，但这种fuzzing策略已经可以有效地发现那些处理二进制格式输入的应用程序中的安全漏洞，特别是如果它们以前从未被fuzzing过。</p>
<p>实际上，对于JPEG图像格式，通常使用原始字节值来编码键输入属性，如图像大小、尺寸和输入文件数据指针；在其他格式良好的输入中fuzzing这些关键字节值（其位置因图像而异）可能会发现由于输入验证不完整而导致的缓冲区溢出错误。</p>
<p>在实践中，Blackbox random fuzzing的有效性关键取决于一组形式良好的种子输入来启动fuzz过程。事实上，格式良好的种子输入将在应用程序中更快地执行更多的代码，并且涵盖输入格式支持的各种选项和编码，以进行全面的fuzzing。</p>
<p>相反，没有格式良好的种子输入的fuzzing很可能会生成纯垃圾，被测试的应用程序将快速检测并丢弃这些垃圾。这就是为什么图2的程序将第2行中的常数1000定义为其模糊密度，如果种子输入中的每个字节都被模糊化，则生成的新输入将完全是乱码和随机的；但是如果平均每1000字节最多有一个字节被模糊化，模糊化只会给原始种子输入添加有限的噪声，并用此进行测试稍微损坏的新输入更有可能在被测应用程序的更多不同部分执行更多的错误处理代码，从而增加发现错误的机会。</p>
<h4 id="grammar-based-fuzzing">Grammar-Based Fuzzing</h4>
<p>Blackbox random fuzzing提供了一个Fuzzing的基准，但其有效性有限：产生新的有效的输入的几率非常小，尤其是对于那些接受结构化输入的程序，随机模糊输入可能会破坏关键结构 的属性，导致应用程序快速检测到错误然后丢弃，而并没有对太多的应用程序代码进行fuzzing。</p>
<p>Grammar-based fuzzing对于接受格式化输入的程序是非常有效的。分析人员提供指定的输入语法来指明被测试的应用程序的输入格式。通常，分析人员还会指定需要模糊哪些输入部分，以及怎么样模糊。然后根据这样的输入语法生成许多新的输入，每个都满足输入语法的约束。基于语法的模糊器有Peach，SPIKE和Sulley等。</p>
<figure>
<img src="/png/2021-01-17-10-19-48.png" alt=""><figcaption>图3</figcaption>
</figure>
<p>图3显示了一个代码片段，展示了基于语法的模糊器（如SPIKE）生成新输入的过程，输入语法在这里直接表示为可以解释执行的代码。</p>
<p>代码中通过调用s_string按顺序指定那些固定的常量字符串，用s_blocksize_string获取clock变量的字符串长度作为之前Content-Length的参数，s_block_start表示开始定义block，继续使用s_string定义常量字符串，关键点在于使用s_string_variable生成随机化的数据来进行fuzz，后面s_string同理，最后使用s_block_end结束block的定义。</p>
<p>通过执行图3所示的代码，SPIKE可能会生成以下字符串序列。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/api/blog/</span> HTTP/1.2</span><br><span class="line"><span class="attribute">Content-Length:10&#123;body:XXX&#125;</span></span><br></pre></td></tr></table></figure>
<p>Grammar-based fuzzing的优势和优点。</p>
<ol type="1">
<li>可以通过分析人员的专业知识将fuzzing集中于那些可能永远不会被Blackbox random fuzzing覆盖到的代码区域。</li>
<li>可以将不可靠的输入作为Web页面，包括复杂的HTML文档和JavaScript代码，从而发现浏览器中的安全漏洞，以及那些复杂的代码编译器中的bug。</li>
<li>也适用于网络协议的fuzzing，如图3所示。</li>
</ol>
<p>Grammar-based fuzzing is also related to model-based testing. Given an abstract representation of a program—called a model—model-based testing consists in generating tests by analyzing the model in order to check the conformance of the program with respect to the model. Test generation algorithms used in model-based testing often try to generate a minimum number of tests covering, say, every state and transition of a finite-state machine model in order to generate test suites that are as small as possible. Similar algorithms can be used to cover all production rules of a grammar without exhaustively enumerating all possible combinations.</p>
<p>机器学习在Grammar-based fuzzing中的应用仍处于初步阶段，如何自动学习输入样本的语法是一个研究领域。例如，可以学习上下文无关的语法，使用自定义输入的示例概括步骤，或使用程序的动态污点分析以确定在测试中程序是如何处理其输入的。基于神经网络的统计机器学习技术可以也可以用来学习输入文法。</p>
<p>由于语法的编写过程是开放性的，并且可选择性如此之多，例如：如何fuzzing，何时停止，如何进一步编辑语法等实际问题。</p>
<h4 id="whitebox-fuzzing-1">Whitebox Fuzzing</h4>
<p>Blackbox Fuzzing的效果是非常有限的，Grammar-based fuzzing是劳动密集型的。而且什么时候可以认为已经发现了所有的漏洞？前两者是无法做到的。</p>
<p>whitebox fuzzing从一个格式良好的输入开始，对测试程序进行动态符号执行并收集符号执行过程中遇到的条件分支的输入约束。然后，将收集到的约束条件一一systematically否定，并使用约束条件求解器求解，该约束条件求解器的结果将用于生成进入程序不同的执行路径的新输入。</p>
<p>使用systematic搜索技术来重复此过程，该技术尝试遍历程序的所有（实际上是许多）可行的执行路径，同时使用运行时检查器检查许多运行时状态来判断是否触发了bug（如缓冲区溢出）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// x is an input</span></span><br><span class="line"> <span class="keyword">int</span> y = x + <span class="number">3</span>;</span><br><span class="line"> <span class="keyword">if</span> (y == <span class="number">13</span>) <span class="built_in">abort</span> (); <span class="comment">// error</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态符号执行具有初始具体值，变量x为0的程序输入，此时执行的为else的分支，并生成路径约束x + 3 ≠ 13。</p>
<p>否定此约束条件并用约束求解后求解器，求解器产生解决方案x = 10。新输入使程序遵循条件语句的then分支语句并找到错误。而这在blackbox random fuzzing只有1/2^32的几率命中（假设输入变量x的变量大小为32bit）。这直观地解释了为什么白盒模糊通常提供更高的代码覆盖率。</p>
<p>whitebox fuzzing可以生成比其他方法执行更多程序路径的输入，因为它更精确。而且whitebox fuzzing可以自动发现并测试出程序遇到的极端情况，例如由于无法正确分配内存或操作缓冲区而导致的安全漏洞。从理论上讲，whitebox fuzzing提供了完整的程序路径覆盖，也就是说达到了程序验证的效果（针对达到指定大小的任何输入）。</p>
<p>例如，简单程序foo有两个可行的执行路径，可以穷举和探索所有路径以证明该程序不包含任何缓冲区溢出。但是实际上，探索通常是不完整的，因为程序中的执行路径的数量是巨大的，而且符号执行，约束生成和约束求解可能由于复杂的程序语句（指针操作，浮点操作等）导致结果不精确，同时还有外部操作系统和库功能产生的大量约束，这些约束无法在限定的时间内完全解决。</p>
<p>由于这些限制，whitebox fuzzing的有效性仍然依赖于各种各样的合适的种子输入。</p>
<p>whitebox fuzzing最初是在SAGE中实现的，它扩展了dynamic test generation的工作范围，从单元测试到大型程序的安全性测试。被称为execution-generated tests或concolic testing。</p>
<p>SAGE执行x86级别动态符号执行，并实现几个至关重要的优化用于处理来自于数亿条机器指令的执行痕迹，以便对应那些包含数百万行代码的文件解析器，例如Microsoft Excel或PowerPoint。</p>
<p>当探索巨大状态空间的时候，SAGE也会使用基于代码覆盖率的启发式探索。</p>
<ul>
<li>对执行的每个测试都测量其指令覆盖率，对于发现更多新指令（新路径）的符号优先执行，以便探索更多未开发代码区域。</li>
<li>测试和符号执行可以在多个内核或机器上并行运行。whitebox fuzzing也可以从给定的种子输入开始，同时如果输入语法可用还可以使用Grammar-based fuzzing来生成种子输入。</li>
</ul>
<p>whitebox fuzzing已在许多其他工具中采用，包括开源工具KLEE，S2E，和Symbolic PathFinder。</p>
<h4 id="other-approaches">Other Approaches</h4>
<p>Portfolio approaches同时运行多种的fuzzer并收集它们的结果，因此结合了它们的互补优势。</p>
<h3 id="survey-of-directed-fuzzy-technology">Survey of Directed Fuzzy Technology</h3>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/fuzz/" rel="tag"><i class="fa fa-tag"></i> fuzz</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/2cb5ce06/" rel="next" title="IS-crypto-非对称加密-RSA的攻击方式">
                <i class="fa fa-chevron-left"></i> IS-crypto-非对称加密-RSA的攻击方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/ed03f22a/" rel="prev" title="CS-BASIC-compiler-principles-属性文法和语法制导翻译">
                CS-BASIC-compiler-principles-属性文法和语法制导翻译 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/apple-touch-icon.png" alt="w4rd3n">
            
              <p class="site-author-name" itemprop="name">w4rd3n</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">172</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">39</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/hitworld" title="GitHub &rarr; https://github.com/hitworld" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#surveyreview"><span class="nav-number">1.</span> <span class="nav-text">Survey/Review</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fuzzing-challenges-and-reflections"><span class="nav-number">1.1.</span> <span class="nav-text">Fuzzing: Challenges and Reflections</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#blackbox-fuzzing"><span class="nav-number">1.1.1.</span> <span class="nav-text">Blackbox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#greybox-fuzzing"><span class="nav-number">1.1.2.</span> <span class="nav-text">Greybox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#whitebox-fuzzing"><span class="nav-number">1.1.3.</span> <span class="nav-text">Whitebox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#other-fuzzing-tools"><span class="nav-number">1.1.4.</span> <span class="nav-text">Other fuzzing tools</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#challenges"><span class="nav-number">1.1.5.</span> <span class="nav-text">Challenges</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#automation"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">Automation</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems"><span class="nav-number">1.1.5.1.1.</span> <span class="nav-text">[C.1] More Software. How can we fuzz efficiently more types of software systems?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities"><span class="nav-number">1.1.5.1.2.</span> <span class="nav-text">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection"><span class="nav-number">1.1.5.1.3.</span> <span class="nav-text">[C.3] More Difficult Bugs. How can we find “deep bugs” for which efficient oracles exist, but which nevertheless evade detection?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns"><span class="nav-number">1.1.5.1.4.</span> <span class="nav-text">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#the-human-component"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">The Human Component</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor"><span class="nav-number">1.1.5.2.1.</span> <span class="nav-text">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools"><span class="nav-number">1.1.5.2.2.</span> <span class="nav-text">[C.6] Usability. How can we improve the usability of fuzzing tools?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fuzzing-theory"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">Fuzzing Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful"><span class="nav-number">1.1.5.3.1.</span> <span class="nav-text">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing"><span class="nav-number">1.1.5.3.2.</span> <span class="nav-text">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#evaluation-and-benchmarks"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">Evaluation and Benchmarks</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing"><span class="nav-number">1.2.</span> <span class="nav-text">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#introduction"><span class="nav-number">1.2.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#background"><span class="nav-number">1.2.2.</span> <span class="nav-text">Background</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#terminology"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Terminology</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#coverage-guide-greybox-fuzzing"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">Coverage-guide Greybox Fuzzing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#directed-greybox-fuzzing"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">Directed Greybox Fuzzing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#difference-between-cgf-and-dgf"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">Difference between CGF and DGF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#application-of-dgf"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">Application of DGF</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#assessment-of-the-state-of-the-art-works"><span class="nav-number">1.2.3.</span> <span class="nav-text">Assessment of the-state-of-the-art Works</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#directed-type"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Directed Type</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#input-optimization"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">Input Optimization</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#seed-prioritization"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">Seed Prioritization</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#distance"><span class="nav-number">1.2.3.3.1.</span> <span class="nav-text">Distance</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#similarity-coverage"><span class="nav-number">1.2.3.3.2.</span> <span class="nav-text">Similarity &amp; Coverage</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#probability"><span class="nav-number">1.2.3.3.3.</span> <span class="nav-text">Probability</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#power-assignment"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">Power Assignment</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mutator-scheduling"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">Mutator Scheduling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#data-flow-analysis"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">Data-flow Analysis</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#challenges-and-solutions"><span class="nav-number">1.2.4.</span> <span class="nav-text">Challenges and Solutions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#binary-code-support"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">Binary Code Support</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#automatic-target-identification"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">Automatic target identification</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#differentiated-weight-metric"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">Differentiated weight metric</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#global-optimum-deviation"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">Global Optimum Deviation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#missing-indirect-calls"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">Missing Indirect Calls</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exploration-exploitation-coordination"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">Exploration-exploitation coordination</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#discussion"><span class="nav-number">1.2.5.</span> <span class="nav-text">Discussion</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#multi-targets-relationship-exploitation"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">Multi-targets Relationship Exploitation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#technology-integration"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">Technology Integration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#implementation-limitation"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">Implementation Limitation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#efficiency-improvement"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">Efficiency Improvement</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#future-research-suggestions"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">Future research suggestions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fuzzing-hack-art-and-science-cacm-2020"><span class="nav-number">1.3.</span> <span class="nav-text">Fuzzing: Hack, Art, and Science (CACM 2020)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#blackbox-fuzzing-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">Blackbox Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#grammar-based-fuzzing"><span class="nav-number">1.3.2.</span> <span class="nav-text">Grammar-Based Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#whitebox-fuzzing-1"><span class="nav-number">1.3.3.</span> <span class="nav-text">Whitebox Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#other-approaches"><span class="nav-number">1.3.4.</span> <span class="nav-text">Other Approaches</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#survey-of-directed-fuzzy-technology"><span class="nav-number">1.4.</span> <span class="nav-text">Survey of Directed Fuzzy Technology</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-gg-circle"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">w4rd3n</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">824k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">12:29</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz",
                'X-LC-Key': "UvlYMzpJKw0Jrw61V5BA5ifU",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  
  

  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>;
  <script>
  //$("body").backstretch("/images/background.jpg");
  </script>
  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>
