<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.5.0">


  <link rel="mask-icon" href="/images/safari_pinned_tab.svg?v=6.5.0" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml">







<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Survey/Review 本文主要是对fuzz相关论文的笔记。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing是一种自动化漏洞发现技术---通过持续不断地生成输入并报告程序的crash。 现在有三种主要的fuzzing技术和工具：黑盒，灰盒和白盒fuzzing。 Blackbox fuzzing 黑盒fuzzing不需要任何关于">
<meta name="keywords" content="fuzz">
<meta property="og:type" content="article">
<meta property="og:title" content="IS-pwn-fuzz-theory-present-situation">
<meta property="og:url" content="https://hitworld.github.io/posts/640b061/index.html">
<meta property="og:site_name" content="w4rd3n">
<meta property="og:description" content="Survey/Review 本文主要是对fuzz相关论文的笔记。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing是一种自动化漏洞发现技术---通过持续不断地生成输入并报告程序的crash。 现在有三种主要的fuzzing技术和工具：黑盒，灰盒和白盒fuzzing。 Blackbox fuzzing 黑盒fuzzing不需要任何关于">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-22-46-04.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-13-09-41.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-09-55.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-40-06.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-40-26.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-17-05-33.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-17-14-22.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-17-09-36-29.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-17-10-19-48.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-22-13-45-05.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-24-10-39-35.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-21-17-00-18.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-20-39-01.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-20-40-35.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-21-17-04.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-21-17-18.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-21-19-03.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-26-20-55-03.png">
<meta property="og:updated_time" content="2021-03-02T12:09:27.408Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IS-pwn-fuzz-theory-present-situation">
<meta name="twitter:description" content="Survey/Review 本文主要是对fuzz相关论文的笔记。 Fuzzing: Challenges and Reflections 在线pdf. Fuzzing是一种自动化漏洞发现技术---通过持续不断地生成输入并报告程序的crash。 现在有三种主要的fuzzing技术和工具：黑盒，灰盒和白盒fuzzing。 Blackbox fuzzing 黑盒fuzzing不需要任何关于">
<meta name="twitter:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">






  <link rel="canonical" href="https://hitworld.github.io/posts/640b061/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>IS-pwn-fuzz-theory-present-situation | w4rd3n</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">w4rd3n</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">混吃等死</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>友链</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hitworld.github.io/posts/640b061/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="w4rd3n">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/apple-touch-icon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="w4rd3n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">IS-pwn-fuzz-theory-present-situation
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-01-01 23:41:38" itemprop="dateCreated datePublished" datetime="2021-01-01T23:41:38+08:00">2021-01-01</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/" itemprop="url" rel="index"><span itemprop="name">IS</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/posts/640b061/" class="leancloud_visitors" data-flag-title="IS-pwn-fuzz-theory-present-situation">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度：</span>
               
                 <span class="leancloud-visitors-count"></span>
                 <span>℃</span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">54k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">49 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="surveyreview">Survey/Review</h2>
<p>本文主要是对fuzz相关论文的笔记。</p>
<h3 id="fuzzing-challenges-and-reflections">Fuzzing: Challenges and Reflections</h3>
<p><a href="https://www.comp.nus.edu.sg/~abhik/pdf/IEEE-SW-Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>Fuzzing是一种自动化漏洞发现技术---通过持续不断地生成输入并报告程序的crash。</p>
<p>现在有三种主要的fuzzing技术和工具：黑盒，灰盒和白盒fuzzing。</p>
<h4 id="blackbox-fuzzing">Blackbox fuzzing</h4>
<p>黑盒fuzzing不需要任何关于程序的先验知识。</p>
<p>黑盒fuzzing主要有两种的variants：突变和生成。</p>
<p>前者通过初始语料库(seed inputs)开始变异，通过对随机位置的随机突变来生成新的输入。</p>
<p>后者是从头开始生成的，通过提供的输入格式来生成满足所提供语法的新的输入。</p>
<p>黑盒fuzzing工具：Peach (http://community.peachfuzzer.com)。</p>
<h4 id="greybox-fuzzing">Greybox fuzzing</h4>
<p>灰盒fuzzing通过在编译时对一些位置（例如代码块跳转点）进行插桩来获取轻量级的运行时反馈从而引导fuzzer。</p>
<p>通常，程序会在代码块交界处被插桩，并且一些初始的语料库会被提供，初始的种子输入会被用于突变产生新的输入，那些覆盖了新的代码块或者其他增加了代码覆盖的输入将被加入语料库。</p>
<p>所以随着这种覆盖反馈fuzzer的运行，输入会逐渐深入程序的深处。</p>
<p>sanitizers还会注入断言到程序中来判断漏洞的种类。</p>
<p>灰盒fuzzing工具：AFL (https://lcamtuf.coredump.cx/afl/), LibFuzzer (https://llvm.org/docs/LibFuzzer.html), and Honggfuzz (https://github.com/google/honggfuzz)。</p>
<h4 id="whitebox-fuzzing">Whitebox fuzzing</h4>
<p>基于符号执行的白盒fuzzing使用程序分析和约束求解器来系统地枚举感兴趣的程序路径，其中用作后端的约束求解器是Satisfiability Modulo Theory (SMT)求解器。</p>
<p>白盒fuzzing通过分析与i经过同一路径的输入集合来计算i经过的路径的条件，路径条件用SMT表示，例如：i[0] = 42 ∧ i[0] − i[1] &gt; 7。</p>
<p>白盒fuzzer对于给定的种子输入s，计算并改变路径条件而不是改变程序输入，然后将改变后的路径条件发送到一个约束解算器来产生新的输入。</p>
<p>白盒fuzzing会跟踪到目前为止获取的所有输入的路径状况，所以始终能够生成一个经过新路径的输入。</p>
<p>白盒fuzzing工具：KLEE (https://klee.github.io/) and SAGE。</p>
<h4 id="other-fuzzing-tools">Other fuzzing tools</h4>
<p>DeepState (https://github.com/trailofbits/deepstate)：一个单元测试框架.</p>
<p>The Mayhem system. --- Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, David Brumley. 2012. Unleashing Mayhem on Binary Code. IEEE Symposium on Security and Privacy (S&amp;P’12).</p>
<h4 id="challenges">Challenges</h4>
<p>fuzzing技术现在面临的问题与挑战。</p>
<h5 id="automation">Automation</h5>
<p>自动化方面的挑战。</p>
<h6 id="c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems">[C.1] More Software. How can we fuzz efficiently more types of software systems?</h6>
<p>如何扩展能够fuzzing的领域和范围？</p>
<p>现在的fuzzer基本上都是生成不规则的输入，而对于文件解析器和面对对象程序来说，需要的是高度结构化的输入。</p>
<p>还有网络程序，机器学习系统的fuzzing方式应该是怎么样的？</p>
<p>对于那些有状态的软件，它们对于相同的输入会产生不同的输出，应该如何进行fuzz？还有多语言构建的软件和GUI软件。</p>
<p>给定一个程序，它的输入域是由语法/协议定义的，那么符号执行工具如何对这种结构化的输入域制定约束?</p>
<h6 id="c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</h6>
<p>如何扩展fuzzing发现的漏洞类型？</p>
<p>现在已经可以利用断言检测程序运行状态发现内存和并发漏洞。</p>
<p>侧信道漏洞发现已经成为热门，未来应该着眼于其他的关键性安全漏洞，包括其他编程语言中的。</p>
<h6 id="c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection">[C.3] More Difficult Bugs. How can we find “deep bugs” for which efficient oracles exist, but which nevertheless evade detection?</h6>
<p>fuzzing如何发现更深层次的漏洞？</p>
<ol type="1">
<li>结构感知和基于语法的fuzzing，以及静态分析和符号执行与灰盒fuzzing的结合是很有前途的方向。</li>
<li>针对软件补丁的技术对于发现软件补丁引入的错误是至关重要的。</li>
<li>应该研究促进bug发现的策略。例如AFLFast，它可以在灰盒fuzzing中更快地检测崩溃，并通过研究gpu的效用和其他有效的并行化方法以最大限度地增加单位时间内的执行次数。</li>
</ol>
<h6 id="c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</h6>
<p>需要实证研究来了解源代码中安全漏洞的性质和分布。</p>
<h5 id="the-human-component">The Human Component</h5>
<p>fuzzing中的人。</p>
<h6 id="c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</h6>
<p>人在模糊测试中能起到的作用，也就是什么才是最合理的半自动化fuzzing方案？</p>
<p>Ned Williamson给出了下面这种方法。</p>
<ol type="1">
<li>首先审核代码，以识别可能存在安全漏洞的代码区域。</li>
<li>为设备准备fuzzing，运行fuzzing一段时间，并确定fuzzing的遇到的障碍和问题。</li>
<li>手动修补遇到的障碍和问题。</li>
<li>如果fuzzer花费很多时间来测试代码中不重要的部分，对fuzzer进行调整。</li>
<li>一旦发现了一个潜在的漏洞，就要回溯并之前修补的部分，并相应地调整输入再次触发漏洞。</li>
</ol>
<h6 id="c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools">[C.6] Usability. How can we improve the usability of fuzzing tools?</h6>
<p>如何提高模糊工具的可用性？也就是说如何让一个技术人员快速掌握并使用。</p>
<h5 id="fuzzing-theory">Fuzzing Theory</h5>
<p>需要一个可靠的Fuzzing Theory。</p>
<h6 id="c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</h6>
<p>除了白盒模糊测试，灰盒模糊测试和黑盒模糊测试都不能保证没有未发现的漏洞。白盒模糊测试受限于时间和可扩展性也无法完全保证，灰盒模糊测试存在适应性偏差，黑盒模糊测试存在剩余风险。</p>
<h6 id="c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</h6>
<p>给定程序和时间预算，什么是能在时间预算内找到最多漏洞的模糊技术或技术组合程序的大小和复杂性如何影响可伸缩性和性能？计算资源对程序效率的影响程度？</p>
<h5 id="evaluation-and-benchmarks">Evaluation and Benchmarks</h5>
<p>[C.9] How can we evaluate specialized fuzzers?</p>
<p>[C.10] How can we prevent overfitting to a specific benchmark?</p>
<p>[C.11] Are synthetic bugs representative?</p>
<p>[C.12] Are real bugs, which have previously been discovered with other fuzzers, representative?</p>
<p>[C.13] Is coverage a good measure of fuzzer effectiveness?</p>
<p>[C.14] What is a fair choice of time budget?</p>
<p>[C.15] How do we evaluate techniques instead of implementations?</p>
<h3 id="sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv20_SoK.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>大多数greybox fuzzing工具是由代码覆盖率引导的，因为代码覆盖率和bug覆盖率是正相关的，但其实大部分代码是不存在bug的。</p>
<p>与盲目扩展路径覆盖范围的基于代码覆盖率的fuzzing不同，定向greybox fuzzing将其大部分时间预算花在到达特定的目标站点上，例如，容易出bug的区域。</p>
<p>因此，定向灰盒模糊测试特别适用于补丁测试、1 day bug复现以及与其他工具集成等场景。</p>
<h4 id="introduction">Introduction</h4>
<p>传统的定向fuzzing是基于符号执行，但是这种方法会受到符号执行一些问题而限制，例如：复杂的约束求解和路径爆炸等问题。</p>
<p>通过在测试程序(PUT)中指定一组目标站点，并利用编译时插桩获取运行时信息来计算输入种子和目标之间的距离，通过给更接近目标的种子更多的变异机会来将fuzzer导向目标站点。</p>
<p>定向greybox fuzzing将目标站点的可达性问题转化为一个优化问题，以最小化生成的输入种子到目标站点的距离为标准来进行语料库的筛选。</p>
<p>定向greybox fuzzing并未止步于依赖于手动标记的目标站点和基于距离的度量来确定输入种子优先级的主要模式。为了在不同的场景下提高软件测试，已经实现了大量的变体。</p>
<h4 id="background">Background</h4>
<p>CGF(覆盖率导向greybox fuzzing)和DGF(定向greybox fuzzing)的背景知识。</p>
<h5 id="terminology">Terminology</h5>
<p>该文献中使用的术语及其解释。</p>
<ul>
<li>Fuzzing. In this paper, fuzzing refers to traditional blackbox fuzzing and greybox fuzzing. We exclude whitebox fuzzing as it depends on constraint solving of symbolic execution to generate inputs, which is quite different from evolutionary fuzzers based on mutation.</li>
<li>Testcase. A testcase is an input to the PUT, which is generated by randomly mutating a seed.</li>
<li>Seed. A seed is a testcase that is favored (trigger a new path or close to the target) and retained for the mutation to generate new testcases in the next fuzzing iteration.</li>
<li>Seed prioritization. Seed prioritization means to evaluate and sort the seeds according to its performance. Prioritized seeds would be given more fuzzing chances.</li>
<li>Power schedule Power schedule means to determine the number of fuzzing tests to be applied on a seed (i.e., energy).</li>
<li>Fuzzing cycle All seeds in the seed queue have been fuzzed at least once.</li>
</ul>
<h5 id="coverage-guide-greybox-fuzzing">Coverage-guide Greybox Fuzzing</h5>
<p>下面用ALF来介绍典型的CGF技术。</p>
<p>AFL使用上下文不敏感的边缘覆盖替代一般的基本块覆盖。AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器收集这些随机数获知跳转信息，统计边缘覆盖。</p>
<p>边缘覆盖比基本块覆盖更精细和敏感，因为它考虑了基本块之间的过渡。边缘覆盖也比路径覆盖更具可伸缩性，因为它避免了路径爆炸。</p>
<p>AFL偏爱触发新路径的输入种子，AFL通过一个位图记录每个种子的优先级，对于优先级高的种子，AFL给予更多的模糊机会，也就是后面说的能量。</p>
<p>AFL有两类变异策略：确定性策略和非确定性策略。</p>
<p>AFL首先采用确定性策略，利用基于位翻转、算术、令牌、字典和特殊值的变异器依次变异不同粒度的种子。</p>
<p>在进行确定性策略之后，AFL就会进行非确定性策略，包括havoc阶段和拼接阶段。</p>
<p>在havoc阶段，AFL通过从确定性策略中随机选择一系列变异算子对种子进行变异，并将其应用于种子文件中的随机位置。因此，生成的testcase与原始种子有很大的不同。</p>
<p>然后，AFL使用剪接策略从种子队列中随机选择另一个种子，并将其与当前种子重新组合以生成新的种子。最后，对新种子重新实施破坏策略。</p>
<p>AFL通过能量调度来分配一轮模糊测试的时间。</p>
<p>在确定性阶段，变异策略依次参与，而在非确定性阶段，AFL可以给种子分配能量来决定每个种子的模糊机会。</p>
<p>能量是根据每个种子的性能得分来分配的，而性能得分基于覆盖率（优先考虑覆盖更多路径的输入）、执行情况时间（对执行速度更快的输入进行优先级排序）和发现时间（对稍后发现的输入进行优先级排序）来计算出来的。</p>
<p>特别的，如果测试用例执行一条新路径，AFL将加倍分配的能量。</p>
<h5 id="directed-greybox-fuzzing">Directed Greybox Fuzzing</h5>
<p><img src="/png/2021-01-02-21-17-13.png"></p>
<p>下面以用AFLGo为代表来说明DGF的工作原理。</p>
<p>AFLGo遵循CGF的一般原理和体系结构。不同的是，除了获取执行路径和边缘覆盖信息外，AFLGo还计算输入与目标站点之间的距离。该距离基于输入种子的执行跟踪权值上的基本块到目标基本块的平均值来计算，其中权值由程序的调用图和控制流图中的边数来确定。</p>
<p>B¨ohme et al.将灰盒模糊化过程视为一个马尔可夫链，所以可以使用功率调度进行有效的引导。利用模拟退火策略，逐渐将更多的能量分配给距离目标较近的种子，从而将可达性问题转化为优化问题，以最小化生成的种子到目标站点的距离为目的。</p>
<p>AFLGo将整个DGF分为两个阶段，探索阶段和开发阶段。</p>
<p>勘探阶段的目的是尽可能多地揭示路径，像许多覆盖率导向模糊程序一样，这个阶段的DGF偏爱触发新路径并对其进行优先级排序的种子，因为新的路径增加了通向目标的可能性。</p>
<p>开发阶段的目的是最小化生成的种子到目标的距离。在这一阶段，B¨ohme et al.对更接近目标的种子进行优先排序，并为它们分配更多的能量。</p>
<p>勘探开发的权衡在于如何协调这两个阶段。B¨ohme et al.使用固定的勘探和开发阶段划分。例如，对于24小时测试，AFLGo使用20小时进行勘探，然后使用4小时进行开发。</p>
<h5 id="difference-between-cgf-and-dgf">Difference between CGF and DGF</h5>
<p>CGF和DGF技术的不同点。</p>
<ol type="1">
<li>种子优先级。CGF的目标是最大化路径覆盖，所以会偏爱触发新路径的种子。而DGF的目标是到达代码中的特定位置，所以它偏爱更接近目标的种子。</li>
<li>探索目标。CGF以一种无方向的方式扩展代码覆盖范围，在不包含bug的代码区域浪费能量。DGF则预先对一组目标站点进行人工或自动标记，以指导整个模糊测试过程，从而节省能量。目标的选择会影响DGF的性能。</li>
<li>勘探开发。对于基于覆盖率的灰盒模糊测试，整个过程本质上是一个探索-开发问题的折衷，其中探索意味着尝试尽可能多的种子，而开发意味着尽可能多地变异某个种子。对于DGF来说，勘探开发问题在于勘探阶段与开发阶段的协调。在探索阶段，DGF试图发现尽可能多的种子，并从中获取更多的新路径，以增加到达目标的可能性。同时，开发阶段给了一些种子更多的变异机会，这些种子更有可能产生到达目标的输入。</li>
</ol>
<h5 id="application-of-dgf">Application of DGF</h5>
<p>DGF常见的应用方向。</p>
<ul>
<li>补丁测试。DGF可以用来测试补丁是否完整和兼容，修补程序在以下情况下是不完整的：错误可能由多个输入触发；补丁可能会引入新的bug。因此，针对有问题的更改或补丁的DGF有更高的发现bug的机会。</li>
<li>bug复现。DGF可以用于复现没有crash输入的已知bug。例如，出于隐私等考虑，某些应用程序（如视频播放器）不允许发送输入文件，这种情况下内部开发团队可以使用DGF通过stack trace中的方法调用和一些环境参数来再现崩溃。在给定错误报告信息的情况下，DGF也可以生成已披露漏洞的PoC。</li>
<li>人机合一（意译法）。DGF可以配合分析人员的知识或辅助技术来促进fuzz。通过分析人员的知识和经验可以帮助DGF识别关键的系统调用或security-sensitive的程序站点（例如，内存分配函数malloc、字符串操作函数strcpy），基于以前的经验来引导模糊化到容易出错的部分。如符号执行和taint analysis之类的辅助技术可以用来解决测试中的障碍，而静态分析和基于机器学习的检测方法的初步结果可以用作DGF的潜在易受攻击目标。</li>
<li>测试资源有限。当测试资源有限时，例如对物联网设备进行fuzz，识别关键代码区域来指导fuzz比无方向地fuzz整个程序更有效。</li>
<li>特定类型bug检测。DGF可以应用于基于定制指标的特定bug检测。例如，在内存使用状况的指导下查找内存泄漏bug，在typestate violation（应该是指违反了特定的使用范例，例如free后并未清除指针）的指导下查找UAF漏洞。</li>
</ul>
<h4 id="assessment-of-the-state-of-the-art-works">Assessment of the-state-of-the-art Works</h4>
<p><img src="/png/2021-01-02-22-46-04.png"></p>
<p>为了进行全面的评估，论文根据DGF的特征提取了15个度量。同时进一步将度量分为三类，包括基本信息、实现细节和优化方法。</p>
<p>在下文中，论文集中讨论与DGF关键技术相关的特性，包括定向类型、输入优化、种子优先级、能量分配、变异调度和数据流分析。</p>
<p>该论文主要研究DGF（表1中记为G），不过在某些工作中采用了符号执行来增强有向性，形成了有向混合模糊测试（表1中记为H）。</p>
<h5 id="directed-type">Directed Type</h5>
<p>对于定向目标的类型，DGF最初通过在PUT中手动标记的目标站点来进行定向，如AFLGo和Hawkeye。</p>
<p>后来发现目标之间的关系对于bug的触发也是有影响的，所以改变单独的目标站点为目标序列。</p>
<p>为了触发UAF漏洞，必须按特定顺序执行一系列操作：分配内存、使用内存和释放内存。所以UAFuzz和UAFL利用目标序列而不是目标站点来发现UAF漏洞。LOLLY还使用目标语句序列来引导DGF触发由多个语句的顺序执行导致的bug。Berry使用符号执行来增强LOLLY沿着复杂路径到达深层目标时的方向性。</p>
<p>除了目标序列之外，研究人员还提出了各种机制来指导DGF。</p>
<p>Memlock通过监控内存使用情况来发现内存泄漏漏洞。V-Fuzz以易受攻击概率为指导，通过深度学习模型预测易受攻击概率，将DGF引导到潜在易受攻击的代码区域。SemFuzz和DrillerGo利用从CVE描述和git日志中检索到的语义信息来指导DGF并生成PoC报告。1DVUL通过那些直接改变原始数据流或控制流的补丁指导以发现1-day漏洞。SAVIOR和Parmasan是由来自sanitizers（Sanitizers是谷歌发起的开源工具集）的信息指导的。IJON利用来自分析人员的注释来指导DGF克服重要的障碍。RVFUZZER受control instability的指导，在机器人车辆中发现输入验证漏洞。PFUZZER明确地指向输入解析器，从而更好地覆盖代码区域。</p>
<p>DGF已经从到达目标站点发展到发现复杂的深层的行为漏洞。</p>
<h5 id="input-optimization">Input Optimization</h5>
<p>优化输入的生成策略对于提高DGF的性能有很大的帮助。</p>
<p>seedfuzz致力于改进初始种子的生成和选择，以达到定向模糊的目的。它利用动态污点分析来识别种子当中那些会影响security-sensitive程序位置的值的字节，通过改变这些字节来生成新的输入提供给目标程序以触发错误。</p>
<p>FuzzGuard使用了一种基于深度学习的方法，在fuzz之前过滤掉无法达到目标站点的输入。它将程序的输入看作一种模式，并使用大量的在之前的执行中能够到达目标代码的输入来训练模型，然后利用该模型预测新生成的输入的可达性，从而节省了实际执行所需的时间。</p>
<p>TOFU利用protobuf规范形式的程序输入的已知结构来生成有效的输入。通过将模糊处理分为语法模糊处理和语义模糊处理，TOFU扩大了输入空间，以包含命令行标志。然而，即使用户熟悉输入语言，实现输入语言语法通常也需要一到两天的时间。</p>
<p>SemFuzz利用从CVE描述和git日志中检索到的信息（系统调用和参数）来构建设计好的种子输入，以增加命中易受攻击函数的概率。</p>
<p>TIFF和ProFuzzer通过识别输入类型辅助变异，从而最大化触发内存溢出漏洞的可能性。</p>
<p>PFUZZER是一种语法驱动的方法，专门针对输入解析器，在生成不合理输入的情况下最大化输入空间覆盖率。</p>
<h5 id="seed-prioritization">Seed Prioritization</h5>
<p>DGF文献中广泛采用的三个种子优先级的度量标准：距离、覆盖率和概率。</p>
<h6 id="distance">Distance</h6>
<p>作为一项开创性的工作，AFLGo在编译时对源代码进行检测，并通过PUT的调用图和控制流图中的边数计算到目标基本块的距离。然后在运行时聚合每个基本块的距离值，以计算平均值来评估种子。许多后续版本继承了这种基于距离的方案，如Parmasan和1DVUL。</p>
<p>TOFU的距离度量定义为达到目标所需的正确分支决策数。</p>
<p>RDFuzz将距离和频率结合起来，对种子进行优先级排序。通过代码的执行频率将代码区分为高频区和低频区。输入分为高/低距离和高/低频四种类型。在探测阶段，优先选择低频种子来提高覆盖率；在开发阶段，优先选择低距离种子来靠近目标区域。</p>
<p>UAFuzz是一个定制的DGF程序，用于复杂的UAF漏洞。与基于控制流图的距离不同，它使用了通向目标函数的调用链的距离度量，目标函数一般包含分配函数和释放函数。</p>
<p>W¨ustholz et al使用online static lookahead analysis来找到并避免那些所有后缀路径都无法到达目标站点的路径前缀。通过强调可能到达目标站点的路径前缀，DGF的能量调度可以更合理地分配其资源。</p>
<p>基于距离的方法的一个缺点是它只关注最短距离。当有多条路径到达同一目标时，可能会忽略较长的选项，从而导致偏差。</p>
<h6 id="similarity-coverage">Similarity &amp; Coverage</h6>
<p>相似性表示某些目标形式的覆盖范围，例如函数、位置和bug traces。当有许多目标时，这个指标特别适用。</p>
<p>Hawkeye利用对PUT的静态分析，将基本块跟踪距离与覆盖函数相似性结合起来，用于种子优先级排序和能量调度。LOLLY使用指定的程序语句序列作为目标，并将种子覆盖目标序列的能力（即序列覆盖率）作为评估种子的度量。UAFL使用操作序列覆盖率作为反馈，引导测试用例生成逐步覆盖触发UAF漏洞可能使用的操作序列。</p>
<p>UAFuzz还使用序列感知目标相似性度量来度量种子执行和目标UAF bug traces之间的相似性。序列感知目标相似性度量具体评估了种子在运行时执行trace所覆盖的目标的数量和顺序。</p>
<p>Berry考虑了目标序列中节点的覆盖率及其执行上下文。它用必要的节点来增强目标序列，即到达所有路径的目标序列中的节点所需的基本块。除了分支覆盖之外，Berry还考虑了目标执行trace和增强目标序列之间的相似性，从而对种子进行优先级排序。</p>
<p>SAVIOR根据UBSan预测的标签覆盖率，优先考虑具有更高触发漏洞潜力的种子。TortoiseFuzz基于内存损坏漏洞与敏感内存操作密切相关的事实，区分了更可能注定易受攻击的边缘。它通过覆盖率和安全影响因子的组合对输入进行优先级排序，这由函数、循环和基本块的三种不同粒度类型的内存操作表示。</p>
<h6 id="probability">Probability</h6>
<p>概率是另一个有用的指标，它通过达到目标的可能性来确定种子的优先级。通常将种子优先级度量与目标识别度量相结合，以将模糊化引向潜在的易受攻击的位置。</p>
<p>V-Fuzz和SUZZER基于一个通过深度学习的模型得到函数的脆弱概率，并给函数中的每个基本块一个静态分数。然后对于每个输入计算其执行路径上所有基本块的静态得分之和，并对得分较高的输入进行优先级排序。</p>
<p>SAVIOR利用UBSan为代码区域添加可能存在bug的标签。TAFL加强了对包含漏洞的概率较高的区域的模糊化，该模糊化基于静态语义度量，包括敏感、复杂、深入和罕见的区域。</p>
<h5 id="power-assignment">Power Assignment</h5>
<p>AFLGo使用一种基于模拟退火的能量调度，逐渐将更多的能量分配给距离目标站点较近的种子，同时减少距离较远的种子的能量。</p>
<p>传统的随机游走调度总是接受更好的解从而可能陷入局部最优，而模拟退火则以一定的概率接受不如当前最优解的解，因此有可能跳出局部最优解而达到全局最优解。</p>
<p>Hawkeye也采用了模拟退火，但增加了优先级。因此，更接近目标的种子首先发生变异，这进一步提高了方向性。LOLLY采用了一种优化的基于模拟退火的能量调度来实现最大的序列覆盖。在温度阈值的控制下，探测阶段的会随机地对所提供的种子进行变异以产生许多新的输入；而在开发阶段，它会从具有更高序列覆盖率的种子中产生更多的新输入。</p>
<h5 id="mutator-scheduling">Mutator Scheduling</h5>
<p>一些模糊程序通过优化变异策略来辅助DGF，这主要是通过将变异分类成不同的粒度（类型）来实现的。</p>
<p>Hawkeye利用了一种自适应变异策略，将变异分为粗粒度和细粒度。粗粒度的变异在突变期间会更改大量字节，而细粒度的变异只涉及少量字节级的修改、插入或删除。当一个种子接近目标函数时，粗粒度变异的机会就变少。一旦种子达到目标函数，进行细粒度变异的次数增加，而粗粒度变异的次数减少。同样，V-Fuzz将变异策略分为轻微变异和严重变异，并根据实际模糊测试的状态通过阈值动态调整变异策略。</p>
<p>SemFuzz执行类似的分类，只是它关注于系统调用。SemFuzz利用对输入的粗变异来找到一个系统调用序列，该序列可以将执行移向易受攻击的函数。之后，它将切换到syscall序列上的细粒度变异，以监视关键变量。</p>
<p>TAFL还采用了基于经验观察的粒度感知的变异调度，即：粗粒度变异在路径增长方面优于细粒度变异；组合多个变异的性能优于使用单一类型的变异。</p>
<p>ProFuzzer根据输入类型探测识别的输入字段类型，如何进行不同的变异策略。</p>
<h5 id="data-flow-analysis">Data-flow Analysis</h5>
<p>数据流分析（如污点分析）可以反映变异对生成输入的影响，有助于优化变异策略和输入生成。</p>
<p>RDFuzz利用一种干扰-检查方法来识别和保护对输入的距离敏感的内容，这对保持距离至关重要（该句不太理解，可能翻译错误）。在变异过程中防止这些内容有助于更有效地接近目标代码位置。</p>
<p>UAFL采用信息流分析来识别条件语句中的输入和程序变量之间的关系，并为那些信息流更多的输入字节赋予更高的变异可能性，因为它们更可能改变目标语句的值。</p>
<p>SemFuzz通过反向数据流分析跟踪关键变量所依赖的核函数参数。SeedFuzz利用动态污点分析来识别种子中可能影响security-sensitive程序位置的值的字节。PFUZZER使用输入的动态污染，将处理的每个值与其派生的输入字符相关联。TIFF通过内存中的数据结构识别和动态污点分析来推断输入类型，这增加了基于类型的变异触发内存损坏漏洞的概率。</p>
<p>当然，数据流分析通常会增加运行时开销。</p>
<h4 id="challenges-and-solutions">Challenges and Solutions</h4>
<p>DGF面临的挑战及可能的解决方案。</p>
<h5 id="binary-code-support">Binary Code Support</h5>
<p>大多数已知的DGF都是在AFL的基础上实现的，并继承其编译时插桩方案来反馈执行状态或计算基于距离的度量。这种方案不适合没有测试源代码的场景，例如商用闭源COTS软件或部分依赖第三方库的关键程序。</p>
<p>二进制级别的DGF存在以下问题。</p>
<ol type="1">
<li>运行时开销很大。最简单的方法就是利用一个完整的系统仿真器。例如，UAFuzz处理二进制代码，并通过QEMU提取执行路径。然而，基于仿真器的工具通常效率较低。</li>
<li>目标信息收集困难。对于二进制代码中的PUT，只能从bug trace中提取目标信息。</li>
<li>标靶困难。由于二进制代码很难读取，必须对其进行反汇编，如使用idapro，并用虚拟地址标记目标。</li>
</ol>
<p>一个可行解决方案是通过硬件辅助减轻性能限制。Intel PT是最新Intel处理器中的一种轻量级硬件功能，可以捕获有关程序执行的trace数据，同时Intel PT可以动态跟踪程序执行，开销可以忽略不计。安全分析人员通过Intel PT捕获的数据包trace以及PUT的二进制文件可以重建PUT的执行路径。平均而言，基于PT的方法比QEMU-AFL快4.3倍。</p>
<p>以前的硬件功能（如Intel Last Branch Record）也可以执行程序跟踪，但其输出存储在特殊寄存器中，而不是主内存中，这限制了跟踪大小。CGF与PT的结合也有尝试，比如kAFL、PTfuzz、Ptrix和Honggfuzz。然而，PT从未被用于DGF。</p>
<p>对于二进制代码级别的目标识别和标记问题，可以利用基于机器学习的方法或启发式二进制差分方法来自动识别易受攻击的代码。</p>
<h5 id="automatic-target-identification">Automatic target identification</h5>
<p>大多数已知的DGF都要求分析人员手动标记目标（如AFLGo、Hawkeye），这依赖对于目标站点的先验知识。</p>
<p>为了实现目标的自动识别，可以使用静态分析工具在PUT中找到潜在的危险区域。然而，这些工具通常特定于所使用的bug类型和编程语言。</p>
<p>另一个方向是利用compiler sanitizer passes，比如UBSan，来注释PUT中的潜在bug。</p>
<p>对于二进制代码，1DVUL通过基于Bindiff的二进制级比较，提取不同的函数及其不同的基本块，识别与补丁相关的目标分支。基于深度学习的方法在预测脆弱性和使用预测信息指导模糊化方面也是有效的。最后，攻击面识别组件也可用于自动识别DGF的易受攻击目标。</p>
<h5 id="differentiated-weight-metric">Differentiated weight metric</h5>
<p><img src="/png/2021-01-03-13-09-41.png"></p>
<p>在大多数最先进的DGF中，种子的优先级是基于等权度量的。以广泛应用的距离度量为例，通过种子与目标之间的距离来度量到达目标的能力。特别是距离由多条边表示，即基本块之间的过渡。然而，这样的测量忽略了一个事实，即不同的分支跳跃有不同的概率。</p>
<p>图1显示了一个控制流图片段，其中输入x是一个从0到9的整数。很容易知道从节点A跳到节点C的概率是0.1，从节点A跳到节点B的概率是0.9。如果据根据分支跳数计算距离，则A→C的距离比A→G短，这是因为A→C只有一个跳，而A→G有三个跳。但是如果考虑分支跳跃概率，则A→C的概率为0.1，而A→G的概率为0.9×0.7×0.5≈0.3，这比A→C更短。因此，在计算距离时考虑权重差异更为合理。其他种子优先级度量，如相似性和概率，应该遵循相同的原理。</p>
<p>一种可能的解决方案是考虑分支跳转概率。当基于概率评估目标的可达性时，每个种子基于该种子生成到达目标的输入的可能性，即将该种子的当前执行路径转换为穿过该目标的目标路径的概率来优先排序。由于执行路径可以看作是连续分支的马尔可夫链，因此可以通过收集路径中所有分支的概率来计算路径的概率。</p>
<p>基于统计模拟方法，可以通过统计计算分支概率来估计分支概率。平稳分布的密度形式上描述了DGF经过一定次数的迭代后执行某条路径的可能性。基于统计模拟方法方法需要两个条件：1）抽样应该是随机的；2）抽样规模应该很大。</p>
<p>模糊过程本质上满足了这些要求。由随机变异的测试用例驱动的执行路径可以看作是满足第一个需求的随机样本。模糊程序生成的测试用例的高吞吐量使得估计具有统计意义，满足第二个需求。因此，将模糊化作为一个抽样过程，可以以一种轻量级的方式统计估计分支跳跃概率。</p>
<p>这种基于概率的方法的一个可能缺点是潜在的运行时开销。统计跳跃计数和概率计算都引入了额外的计算。减少性能降低的一个简单方法是间隔采样。</p>
<p>另一个可能的解决方案是加速计算，这涉及到元数据的存储和访问方式。</p>
<p>传统上，基于图的数据存储在邻接表中。然而，由于基于概率的方法经常更新跳跃统计信息，并且可达性判断也需要快速的边缘跟踪，因此邻接表在访问数据时效率较低，不适合使用。另一种选择是邻接矩阵，它支持快速数据访问。然而，由于一个跳转通常有两个分支，矩阵将是巨大的，但数据分布相对稀疏，这大大增加了空间消耗。</p>
<p>因此，利用基于概率的方法的先决条件是设计一个平衡时间复杂性和空间复杂性的定制数据结构。</p>
<h5 id="global-optimum-deviation">Global Optimum Deviation</h5>
<p><img src="/png/2021-01-03-16-09-55.png"></p>
<p>当DGF测试中存在多个目标时，如何协调这些目标是另一个挑战。</p>
<p>一种策略是基于Dijkstras算法来寻找全局最短距离，AFLGo就是这样做的。然而，这样的全局最优可能会错过最接近某个目标的局部最优种子，从而导致偏差。</p>
<p>图2显示了一个控制流图片段，其中节点K和O是目标节点。这里测试了三个种子，路径分别为：A→B→D→G→K，A→C→E→I→M→N→O，A→C→E→H→L。论文作者基于B¨ohme et al.定义的距离公式计算了两个目标的三条路径中每个节点之间的harmonic distances，并在每个节点的侧面标记它们。</p>
<p>路径A→C→E→H→L的种子应该是三个之中距离最小的，但这是不合理的，因为路径A→B→D→G→K穿过目标节点K，路径A→C→E→I→M→N→O穿过目标节点O，但路径A→C→E→H→L没有到达任何目标。直觉上，路径A→C→E→H→L远离目标，不应优先考虑。因此，当存在多个目标时，寻找全局最短距离存在偏差，影响模糊化的方向性。</p>
<p>这种偏差背后的原因是基于距离的种子测量只关注最短路径。当有多条路径到达同一目标时，可能会忽略较长的路径，从而导致结果出现偏差。</p>
<p>图2中，如果考虑路径A→C→K和路径A→C→E→H→O，会发现d(ACK) &lt; d(ACEIMNO) &lt; d(ACEIMNL)。这是因为路径A→C→K和路径A→C→E→H→O分别是到目标K和O的最短路径。最短路径总是优先考虑的。为了避免在评估种子时产生偏差，应该考虑到所有可能到达目标的路径。</p>
<p>为了实现这一目标，Hawkeye使用了基于轻量级静态分析的相邻函数距离扩充，该分析基于生成的调用图考虑（立即）调用关系的模式。</p>
<p>多目标协调的另一种策略是目标分离。对于每个种子，仅选择所有目标之间的最小距离作为种子的距离，并基于该最小距离对种子进行优先级排序。这样可以避免局部最优偏差，但可能会减慢达到特定目标的速度。</p>
<h5 id="missing-indirect-calls">Missing Indirect Calls</h5>
<p>无论采用何种度量，DGF都依赖于控制流分析来确定种子的优先级。以基于距离的度量为例，通常基于控制流图和调用图来度量距离。</p>
<p>然而，由于LLVM的调用流和通过LLVM的间接调用图的构造是不完整的。在实际程序中，间接函数调用非常普遍。例如，在libpng中，44.11%的函数调用是间接函数调用。对于静态分析方法，不能直接从源代码或二进制指令中观察到间接函数调用站点，例如在C中作为参数传递函数指针或使用函数对象和指针。对于二进制代码，间接调用的目标地址取决于寄存器中的值，这些值也无法获得。</p>
<p>此外，为了构造一个过程间控制流图需要将基于LLVM的IR生成的每个函数的控制流图与整个程序的调用图结合起来。因此，基于调用图和控制流图的距离测量在没有间接调用的情况下是不准确的，影响了DGF到达目标的能力。</p>
<p>对于静态方法，解决这个问题的一个简单方法是对函数指针执行Andersen的points to analysis。但是，这种基于包含的上下文不敏感指针分析会导致间接调用具有许多传出边缘，可能会产生给定输入不可能的执行路径。</p>
<p>TOFU使用函数类型签名来近似每个间接调用站点的可调用集。但是，它不考虑类型转换，这可能会允许调用不同类型的函数，从而引入不精确性。</p>
<p>对于动态情况，ParmeSan在实际执行过程中识别间接调用的缺失边，并逐渐补全调用图。最后，在执行足够数量的模糊测试之后，图趋于完整。然而，这样的解决方案不可避免地增加了运行时开销，并且不能保证完整性。</p>
<h5 id="exploration-exploitation-coordination">Exploration-exploitation coordination</h5>
<p>DGF面临的最后一个挑战是如何协调勘探与开发之间的权衡。</p>
<p>一方面，多勘探可以为开发提供充分的信息，另一方面，勘探过度会占用大量资源，延缓开发。很难确定勘探阶段和开发阶段之间的界限。</p>
<p>AFLGo采用勘探阶段和开发阶段的固定分割。测试前，时间预算在测试配置中预先设置。这样的方案是初步的，因为分离点是经验性的和不灵活的。由于每个PUT具有不同的字符，因此这种固定拆分的适应性较差。一旦勘探阶段转入开发阶段，即使由于路径不足导致方向性能较差，也不会有回头路。</p>
<p><img src="/png/2021-01-03-16-40-06.png"></p>
<p>论文作者对libxml使用AFLGo进行了一个简单的实验。使用AFLGo的-z参数为勘探阶段设置不同的时间预算，并比较其性能。如图3所示，水平坐标表示测试的持续时间，垂直坐标表示所有生成的输入到目标代码区域的最小距离。实验持续24小时，AFLGo-1意味着1小时的探索加上23小时的开发，其余的依此类推。从结果可以看出，勘探阶段和开发阶段的分配会影响DGF的性能，而最佳性能（AFLGo-16）需要两个阶段都有足够的时间。然而，很难得到一个最佳的分配。</p>
<p>RDFuzz统计执行期间的分支级统计信息，以将代码区域分为高频区域和低频区域。根据频率和距离两个评价准则，将输入信号分为高、低距离和高、低频两类。低频输入有助于提高勘探所需的覆盖率；低距离输入有助于实现勘探所需的目标码区。最后，采用一个相互交织的测试时间表，交替进行勘探和开发。</p>
<p>解决这一难题的另一个可能方法是利用动态策略来协调勘探阶段和开发阶段的划分，该策略可以在勘探阶段和开发阶段之间自适应切换。</p>
<p>为了实现这一方案，论文作者建议将模糊阶段的分配转化为种子的分配，即将种子分为两组：覆盖种子用于探索和定向种子用于开发。每组种子的数目表示在相应阶段所消耗的能量。这两个阶段的协调是通过控制每组种子的数量来实现的。使用一个称为dp的变量来表示所有种子中定向种子的百分比，这也表示花费在开发阶段上的能量的百分比。在种子评价过程中，对覆盖种子进行标记，在每个模糊周期后，对有向种子进行标记，并通过dp进行调整。</p>
<p><img src="/png/2021-01-03-16-40-26.png"></p>
<p>使用算法2来说明这个设计。具有自适应分裂的DGF应该从探索阶段（dp=0）开始，该阶段侧重于发现新路径。然后，随着已知路径的增加，逐渐增加dp来调用开发阶段，在开发阶段，基于dp选择高值的有向种子并对其进行优先级排序以增强可达性。</p>
<p>当模糊测试程序在很长一段时间内找不到新的路径时，勘探阶段已经到了瓶颈，应该通过大幅度提高dp来迅速进入开发阶段。同样，也需要偶尔从开采阶段回到勘探阶段。例如，当模糊测试程序已经处于开采阶段，dp非常大（例如，dp&gt;0.9），但仍然无法在许多模糊循环中更接近目标，就应该大幅降低dp以返回勘探阶段。这是因为现有的定向种子性能较差，应该扩大路径覆盖范围以发现更多潜在的定向种子。</p>
<p>在该方案中，两个阶段可以共存，以获得最佳的性能和自适应性。值得注意的是，算法中的阈值是用来说明原理的。应该基于启发式算法产生合理的阈值。</p>
<h4 id="discussion">Discussion</h4>
<p>DGF技术中的研究热点。</p>
<h5 id="multi-targets-relationship-exploitation">Multi-targets Relationship Exploitation</h5>
<p>虽然大多数的有向模糊测试程序支持多目标，但只有少部分关注目标之间的关系。当存在多个目标时，可以通过目标之间的关系来优化DGF。如果它们是不相关的，可以给它们分配权重来区分重要性或概率。否则，可以提取隐藏关系并加以利用，以提高方向性。</p>
<p>UAFL在利用目标序列寻找UAF漏洞时，考虑了操作序列的顺序。这是因为，要触发这种行为复杂的漏洞，不仅需要覆盖单个边缘，还需要以特定顺序遍历一些长的边缘序列。这种方法可以扩展到检测语义错误，比如double-free和API误用。Berry使用所有路径的执行上下文（即到达目标序列中的节点所需的必要节点）增强目标序列。</p>
<p>在这里进一步提出以下关系。</p>
<ol type="1">
<li>执行空间关系。目标在执行树上的相对位置。假设有两个目标，可以考虑它们之间的关系，包括它们是否在同一个执行路径上，它们共享多少个执行路径，以及哪一个是另一个的前继节点还是后继节点。</li>
<li>状态空间关系。对于涉及程序状态的目标，可以考虑它们在状态空间中的位置。例如，两个目标是否共享相同的状态，以及两个状态是否可以在状态转换映射上相互转换。</li>
<li>交错关系。对于多线程程序，线程调度会影响不同线程中事件的执行顺序。在同一线程交织下可以达到的目标在交织空间中应该是一个密切的关系。</li>
</ol>
<p>基于上述讨论，建议在选择目标和确定目标优先级时考虑目标之间的关系。具有较高可达性的目标应该有更高的优先级。关系更密切的目标应该用更少的测试运行来覆盖。</p>
<h5 id="technology-integration">Technology Integration</h5>
<p><img src="/png/2021-01-03-17-05-33.png"></p>
<p>DGF依赖于随机变异来产生测试输入，所以它很难到达深层目标，并且在复杂路径上触发深层缺陷的效果较差。为了增强到达角落案例和片状缺陷的方向性，采用了各种程序分析技术，如静态分析、控制流分析、数据流分析、机器学习、语义分析和符号执行（统计数据如表4所示）。</p>
<p>在论文作者调查的工具中，75%的工具依赖于控制流分析来评估种子并确定对目标的可达性；46%的工具利用静态分析来自动识别目标，并从PUT中提取信息；32%的工具使用数据流分析（主要是污点分析）来识别目标之间的关系输入和关键程序变量，优化变异策略调度；11%使用机器学习预测易受攻击的代码，过滤掉无法到达的输入；18%采用语义分析自动识别易受攻击目标，学习输入字段语义优化变异；最后，18%集成符号（concolic）执行来解决复杂的路径约束。</p>
<h5 id="implementation-limitation">Implementation Limitation</h5>
<p><img src="/png/2021-01-03-17-14-22.png"></p>
<p>大约一半的工具是在AFL之上实现的。因此，性能在一定程度上受到AFL实现的限制。从两个方面来说明这种局限性。</p>
<p>第一个问题在于，AFL的边缘覆盖是基于基本块转换的，因此它只在基本块级敏感，不能在指令级区分路径差异。图5显示了两个相邻基本块之间的跳转示例。由于仅对路径敏感，因此无法区分地址0x400657处的跳转是采用（路径2）还是不采用（路径1），因为在控制流图中会有相同的边，即0x400657→0x400671。</p>
<p>另一个问题在于，AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器中收集这些插入数，以标识基本块转换（即控制流图中的边）。然后通过一个算法将插入数转换映射到64KB位图。由于不同的边可能有机会共享同一位置，因此该方案会导致路径冲突。</p>
<p>AFL的这两个局限性都会导致控制流图的不精确性，最终影响基于控制流图分析的种子优先级，无论是基于距离还是其他度量。</p>
<p>尽管这种限制可以通过构造更细粒度的控制流图或设计定制的哈希方案来缓解，但是，额外的工作不可避免地会增加运行时开销。</p>
<h5 id="efficiency-improvement">Efficiency Improvement</h5>
<p>为了实现模糊化的方向性，大多数研究人员使用额外的工具和数据分析。然而，这种额外的分析不可避免地会导致性能降低，对于给定的模糊时间预算，更高的效率意味着更多的模糊执行，=也就是更多的机会达到目标。因此，优化模糊化效率是提高方向性的另一个方向。</p>
<p>一种解决方案是将与执行无关的计算从运行时转移到编译时。例如，AFLGo通过解析PUT的调用图和过程内控制流图来度量每个基本块与目标站点之间的距离。由于解析图和计算距离都非常耗时，AFLGo在编译时将大部分程序分析转移到插桩阶段，以换取运行时的效率。</p>
<p>另一个优化是在实现级别。由于在分析过程中使用的大多数数据都是基于图的，因此如何存储和访问此类元数据对效率至关重要。可以设计一个优化的数据结构来存储这些数据，这样在基于图的拓扑结构进行搜索时就可以方便地频繁、快速地访问这些数据。例如，使用图数据库模型。</p>
<p>最后，可以利用并行计算来进一步提高效率。以前的工作已经成功地将并行性应用于CGF，但尚未应用于DGF。对于DGF，可以使用一个中心节点来维护一个种子队列，该队列保存DGF的所有种子并对其进行优先级排序。然后，将种子分发到计算节点上的并行模糊实例中，测试PUT并收集反馈信息。</p>
<h5 id="future-research-suggestions">Future research suggestions</h5>
<ul>
<li>在论文作者评估的工具中，只有SemFuzz支持内核代码测试。因此，在内核代码中引入DGF，并引导对关键站点（如syscalls和错误处理代码）的模糊化应该是一个有效的方向。</li>
<li>虽然DGF一直在尝试发现新的bug类型，比如UAF漏洞和内存泄漏漏洞，但许多常见的bug还没有被包括在内。因此，另一个研究方向是将DGF应用于特定的bug类型，如信息泄漏bug、并发bug、语义bug（TOCTTOU、double fetch）。</li>
<li>对于种子优先级度量，大多数工作都利用了基于距离和覆盖率（相似性）的方法，这有助于在不引入太多开销的情况下对种子进行量化评估。然而，较小的距离或较宽的覆盖范围并不一定意味着更接近目标，因为存在不同的权重原因和全局偏差原因。作者认为基于概率的度量应该更合理。</li>
<li>最后，分阶段模糊测试是一种可行的方法，可以进一步用于DGF。通过将到达目标的路径划分为连续的多个阶段，分阶段定向模糊算法可以在每个阶段到达子目标，逐步到达目标。此外，可以利用不同的模糊策略来满足不同阶段的需求。例如，TOFU对命令行标志使用语法模糊，对主要输入文件使用语义模糊。因此，分阶段模糊化可以降低模糊化各个阶段输入空间的维数，提高模糊化效率。</li>
</ul>
<h3 id="fuzzing-hack-art-and-science-cacm-2020">Fuzzing: Hack, Art, and Science (CACM 2020)</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/CACM20_Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>三种检测软件中安全漏洞的方法。</p>
<p>静态程序分析器：能够自动检查代码并标记错误的代码模式，它们可以标记出许多浅显的错误，但是工具也容易发出虚假的警报。</p>
<p>人工代码审计：包括发布之前的peer-reviewing和渗透测试，这个步骤可以检测很多问题，包括安全漏洞，设计缺陷和编码错误等超出了自动化工具的范围的问题。</p>
<p>然后就是模糊测试Fuzzing。</p>
<h4 id="blackbox-fuzzing-1">Blackbox Fuzzing</h4>
<p>Fuzzing最简单的形式是Blackbox random fuzzing，它随机地改变格式良好的应用程序输入，然后用这些修改后的输入测试应用程序。</p>
<p><img src="/png/2021-01-17-09-36-29.png"></p>
<p>程序采用格式良好的（第1行）作为输入。然后，它选择一个随机数的字节，这些字节将在该输入中被模糊化（第2行）。这个数字从1到输入长度除以1000不等。这个任意的1000值是可选的，但是它可以防止模糊化原始文件中的太多字节。</p>
<p>接下来，第4-8行循环重复选择输入中的一个随机位置（第5行）和一个新的随机字节（第6行），然后在该位置（第7行）写入该字节，直到所选的字节数被模糊化。</p>
<p>然后，程序用它执行被测试的应用程序（第9行），如果检测到错误，则报告错误（第10行）。</p>
<p>实际上，应用程序是在运行时检查工具的监视下运行的，如Purify、Valgrind、AppVerifier或AddressSanitizer，以增加发现非崩溃安全漏洞（如缓冲区溢出）的机会。</p>
<p>图2的程序可以重复执行，以生成任意多个新的模糊输入。尽管它很简单，但这种fuzzing策略已经可以有效地发现那些处理二进制格式输入的应用程序中的安全漏洞，特别是如果它们以前从未被fuzzing过。</p>
<p>实际上，对于JPEG图像格式，通常使用原始字节值来编码键输入属性，如图像大小、尺寸和输入文件数据指针；在其他格式良好的输入中fuzzing这些关键字节值（其位置因图像而异）可能会发现由于输入验证不完整而导致的缓冲区溢出错误。</p>
<p>在实践中，Blackbox random fuzzing的有效性关键取决于一组形式良好的种子输入来启动fuzz过程。事实上，格式良好的种子输入将在应用程序中更快地执行更多的代码，并且涵盖输入格式支持的各种选项和编码，以进行全面的fuzzing。</p>
<p>相反，没有格式良好的种子输入的fuzzing很可能会生成纯垃圾，被测试的应用程序将快速检测并丢弃这些垃圾。这就是为什么图2的程序将第2行中的常数1000定义为其模糊密度，如果种子输入中的每个字节都被模糊化，则生成的新输入将完全是乱码和随机的；但是如果平均每1000字节最多有一个字节被模糊化，模糊化只会给原始种子输入添加有限的噪声，并用此进行测试稍微损坏的新输入更有可能在被测应用程序的更多不同部分执行更多的错误处理代码，从而增加发现错误的机会。</p>
<h4 id="grammar-based-fuzzing">Grammar-Based Fuzzing</h4>
<p>Blackbox random fuzzing提供了一个Fuzzing的基准，但其有效性有限：产生新的有效的输入的几率非常小，尤其是对于那些接受结构化输入的程序，随机模糊输入可能会破坏关键结构 的属性，导致应用程序快速检测到错误然后丢弃，而并没有对太多的应用程序代码进行fuzzing。</p>
<p>Grammar-based fuzzing对于接受格式化输入的程序是非常有效的。分析人员提供指定的输入语法来指明被测试的应用程序的输入格式。通常，分析人员还会指定需要模糊哪些输入部分，以及怎么样模糊。然后根据这样的输入语法生成许多新的输入，每个都满足输入语法的约束。基于语法的模糊器有Peach，SPIKE和Sulley等。</p>
<p><img src="/png/2021-01-17-10-19-48.png"></p>
<p>图3显示了一个代码片段，展示了基于语法的模糊器（如SPIKE）生成新输入的过程，输入语法在这里直接表示为可以解释执行的代码。</p>
<p>代码中通过调用s_string按顺序指定那些固定的常量字符串，用s_blocksize_string获取clock变量的字符串长度作为之前Content-Length的参数，s_block_start表示开始定义block，继续使用s_string定义常量字符串，关键点在于使用s_string_variable生成随机化的数据来进行fuzz，后面s_string同理，最后使用s_block_end结束block的定义。</p>
<p>通过执行图3所示的代码，SPIKE可能会生成以下字符串序列。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/api/blog/</span> HTTP/1.2</span><br><span class="line"><span class="attribute">Content-Length:10&#123;body:XXX&#125;</span></span><br></pre></td></tr></table></figure>
<p>Grammar-based fuzzing的优势和优点。</p>
<ol type="1">
<li>可以通过分析人员的专业知识将fuzzing集中于那些可能永远不会被Blackbox random fuzzing覆盖到的代码区域。</li>
<li>可以将不可靠的输入作为Web页面，包括复杂的HTML文档和JavaScript代码，从而发现浏览器中的安全漏洞，以及那些复杂的代码编译器中的bug。</li>
<li>也适用于网络协议的fuzzing，如图3所示。</li>
</ol>
<p>Grammar-based fuzzing is also related to model-based testing. Given an abstract representation of a program—called a model—model-based testing consists in generating tests by analyzing the model in order to check the conformance of the program with respect to the model. Test generation algorithms used in model-based testing often try to generate a minimum number of tests covering, say, every state and transition of a finite-state machine model in order to generate test suites that are as small as possible. Similar algorithms can be used to cover all production rules of a grammar without exhaustively enumerating all possible combinations.</p>
<p>机器学习在Grammar-based fuzzing中的应用仍处于初步阶段，如何自动学习输入样本的语法是一个研究领域。例如，可以学习上下文无关的语法，使用自定义输入的示例概括步骤，或使用程序的动态污点分析以确定在测试中程序是如何处理其输入的。基于神经网络的统计机器学习技术可以也可以用来学习输入文法。</p>
<p>由于语法的编写过程是开放性的，并且可选择性如此之多，例如：如何fuzzing，何时停止，如何进一步编辑语法等实际问题。</p>
<h4 id="whitebox-fuzzing-1">Whitebox Fuzzing</h4>
<p>Blackbox Fuzzing的效果是非常有限的，Grammar-based fuzzing是劳动密集型的。而且什么时候可以认为已经发现了所有的漏洞？前两者是无法做到的。</p>
<p>whitebox fuzzing从一个格式良好的输入开始，对测试程序进行动态符号执行并收集符号执行过程中遇到的条件分支的输入约束。然后，将收集到的约束条件一一systematically否定，并使用约束条件求解器求解，该约束条件求解器的结果将用于生成进入程序不同的执行路径的新输入。</p>
<p>使用systematic搜索技术来重复此过程，该技术尝试遍历程序的所有（实际上是许多）可行的执行路径，同时使用运行时检查器检查许多运行时状态来判断是否触发了bug（如缓冲区溢出）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// x is an input</span></span><br><span class="line"> <span class="keyword">int</span> y = x + <span class="number">3</span>;</span><br><span class="line"> <span class="keyword">if</span> (y == <span class="number">13</span>) <span class="built_in">abort</span> (); <span class="comment">// error</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态符号执行具有初始具体值，变量x为0的程序输入，此时执行的为else的分支，并生成路径约束x + 3 ≠ 13。</p>
<p>否定此约束条件并用约束求解后求解器，求解器产生解决方案x = 10。新输入使程序遵循条件语句的then分支语句并找到错误。而这在blackbox random fuzzing只有1/2^32的几率命中（假设输入变量x的变量大小为32bit）。这直观地解释了为什么白盒模糊通常提供更高的代码覆盖率。</p>
<p>whitebox fuzzing可以生成比其他方法执行更多程序路径的输入，因为它更精确。而且whitebox fuzzing可以自动发现并测试出程序遇到的极端情况，例如由于无法正确分配内存或操作缓冲区而导致的安全漏洞。从理论上讲，whitebox fuzzing提供了完整的程序路径覆盖，也就是说达到了程序验证的效果（针对达到指定大小的任何输入）。</p>
<p>例如，简单程序foo有两个可行的执行路径，可以穷举和探索所有路径以证明该程序不包含任何缓冲区溢出。但是实际上，探索通常是不完整的，因为程序中的执行路径的数量是巨大的，而且符号执行，约束生成和约束求解可能由于复杂的程序语句（指针操作，浮点操作等）导致结果不精确，同时还有外部操作系统和库功能产生的大量约束，这些约束无法在限定的时间内完全解决。</p>
<p>由于这些限制，whitebox fuzzing的有效性仍然依赖于各种各样的合适的种子输入。</p>
<p>whitebox fuzzing最初是在SAGE中实现的，它扩展了dynamic test generation的工作范围，从单元测试到大型程序的安全性测试。被称为execution-generated tests或concolic testing。</p>
<p>SAGE执行x86级别动态符号执行，并实现几个至关重要的优化用于处理来自于数亿条机器指令的执行痕迹，以便对应那些包含数百万行代码的文件解析器，例如Microsoft Excel或PowerPoint。</p>
<p>当探索巨大状态空间的时候，SAGE也会使用基于代码覆盖率的启发式探索。</p>
<ul>
<li>对执行的每个测试都测量其指令覆盖率，对于发现更多新指令（新路径）的符号优先执行，以便探索更多未开发代码区域。</li>
<li>测试和符号执行可以在多个内核或机器上并行运行。whitebox fuzzing也可以从给定的种子输入开始，同时如果输入语法可用还可以使用Grammar-based fuzzing来生成种子输入。</li>
</ul>
<p>whitebox fuzzing已在许多其他工具中采用，包括开源工具KLEE，S2E，和Symbolic PathFinder。</p>
<h4 id="other-approaches">Other Approaches</h4>
<p>Portfolio approaches同时运行多种的fuzzer并收集它们的结果，因此结合了它们的互补优势。</p>
<h3 id="survey-of-directed-fuzzy-technology">Survey of Directed Fuzzy Technology</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/ICSESS19_Survey.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>主流fuzz工具。</p>
<p><img src="/png/2021-01-22-13-45-05.png"></p>
<h4 id="dse">DSE</h4>
<p>符号执行实际上是将可达性问题转化为约束求解问题。</p>
<h5 id="symbolic-execution-algorithm">Symbolic Execution Algorithm</h5>
<p>符号执行最初用于编译过程，程序分析等，主要思想是将符号变量作为输入去执行程序，在执行的过程中收集条件判断时通往不同路径的约束，最后使用约束求解获得到达对应路径的输入。</p>
<h6 id="静态符号执行">静态符号执行</h6>
<p>静态符号执行首先将输入变量符号化，然后通过静态分析将程序转换为中间语言，并且在运行中更改符号化变量来获取通往不同路径的约束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = raw_input();</span><br><span class="line">b = <span class="number">2</span> * a;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">10</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"win"</span> ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">"lose"</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，正常运行是用户输入值任何程序返回结果。在静态符号执行中，a首先被符号化，即a = x，而b = 2 * x。</p>
<p>可知当10 == 2 * x时，它进入win路径，否则进入lose路径。这两条路径合并的状态被称为执行树，10 == 2 * x和10 != 2 * x则是路径约束。</p>
<p>当符号执行结束，即程序正常或异常退出时。约束解算器将求解对应路径的约束，从而获得到达此路径所需的变量的值。</p>
<p>静态符号执行存在很多实际实施过程中的问题，例如：约束无法求解。</p>
<h6 id="动态符号执行">动态符号执行</h6>
<p>结合传统静态符号执行和实际执行的符号执行称为动态符号执行。</p>
<p>动态符号执行维持两种状态：一种是实际状态，另一种是符号状态。实际状态对应随机生成的变量的值，而符号状态则是符号化的变量。</p>
<p>动态符号执行首先根据实际状态运行，运行过程中收集符号化变量在当前分支路径上的约束并进行求解。然后，将约束条件求反就得到另一条分支路径的约束。重复该过程，直到探索完所有路径或达到设置的限制。</p>
<p>还是上面的代码，在一次动态符号执行中，假设随机生成的变量a = 7，实际执行时会进入lose路径。</p>
<p>此时通过不断的收集进入lose路径的约束求返获得进入win路径的约束，并使用约束求解器来验证。这样就避免了约束不能解决或找到的问题。</p>
<ol type="1">
<li>通过动态符号执行提取来自原始的复杂的控制流图CFG的行为信息。</li>
<li>然后向控制流模型添加约束以实现一个基于控制流的有限状态机控制参数，Finite State Machine control parameters (EPBFSM)。</li>
<li>最后，通过解决EPBFSM中的约束产生的新的模糊输入，这种方法不仅可以找到可能发现漏洞的路径，也可以识别可能发现漏洞的可控对象。</li>
</ol>
<h5 id="directed-symbolic-execution">Directed Symbolic Execution</h5>
<p>通常测试出来的大多数路径都不是可以直接到达目标的，所以要通过找到一条到达中间目标的路径来继续进行搜索。</p>
<p>补丁测试工具KATCH使用符号执行器KillE到达被patch的地方。</p>
<p>而KLEE使用符号执行的方法，通过大量的程序分析和约束求解系统地探索到达目标位置的路径的状态空间。</p>
<p>一旦识别到一条可以到达目标位置的路径，就可以对相应的路径约束求解从而生成测试用例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">55</span> <span class="comment">/* Read type and payload length first */</span></span><br><span class="line"><span class="number">56</span> hbtype = *p++;</span><br><span class="line"><span class="number">57</span> n2s(p, payload);</span><br><span class="line"><span class="number">58</span> pl = p;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="number">65</span> <span class="keyword">if</span> (hbtype == TLSl _HB_REQUEST) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="number">77</span> <span class="comment">/* Enter response type, length and copy payload */</span></span><br><span class="line"><span class="number">78</span> *bp++ = TLS <span class="number">1</span>_HB_RE SPONSE;</span><br><span class="line"><span class="number">79</span> s2n(payload, bp);</span><br><span class="line"><span class="number">80</span> <span class="built_in">memcpy</span>(bp,pl,payload);</span><br></pre></td></tr></table></figure>
<p>假设KATCH将上面代码的第80行设置为目标，并且找到一个到达65行可行路径A作为中间目标。</p>
<p>接下来，KATCH通过约束求解器将收集到的A的约束和hbtype == TLSl _HB_REQUEST的约束进行求解，就可以生成运行到80行的输入。</p>
<p>与GF不同，基于符号执行的whitebox fuzzing为实现定向模糊测试提供了简单的处理方法。大多数补丁测试工具都基于DSE。</p>
<p>但是，DSE为了有效性牺牲了效率，因为DSE需要很长时间来执行程序分析和约束求解。</p>
<p>在每次迭代中，DSE使用程序分析来确定那些为了靠近目标而需要否定的分支，根据这些路径构建相应的约束，并使用约束求解器来验证。</p>
<h3 id="a-review-of-machine-learning-applications-in-fuzzing">A Review of Machine Learning Applications in Fuzzing</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv19_Machine.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>论文讲述了ML在Fuzzing中的应用，主要关注三种类型的ML：有监督学习，无监督学习，强化学习。</p>
<p>有监督学习用于训练一个模型来识别给定数据点的标签，要求训练数据集的数据点都有显式标签。</p>
<p>无监督学习用于训练一个模型来发现数据点之间的模式或相似性，不要求数据点有显式标签。</p>
<p>强化学习是用来训练一个模型（代理）基于环境而行动，以取得最大化的预期利益。强化学习会对代理在环境中所做的操作或者结果进行对应的奖励，类似于监督学习，这些奖励为代理提供了一个最佳行动的指示。</p>
<p>一个典型的强化学习场景：Flappy bird游戏。</p>
<ul>
<li>机器有一个明确的小鸟角色——代理。</li>
<li>需要控制小鸟飞的更远——目标。</li>
<li>整个游戏过程中需要躲避各种水管——环境。</li>
<li>躲避水管的方法是让小鸟用力飞一下——行动。</li>
<li>飞的越远，就会获得越多的积分——奖励。</li>
</ul>
<p>这些ML都可以采用一种特殊的ML形式--深度学习。深度学习是指一种分层学习，可用于学习一组数据点的基本特征和结构。</p>
<h4 id="overview-of-fuzzing">OVERVIEW OF FUZZING</h4>
<p>现代模糊程序的三种主要类型：基于变异的fuzzer、基于生成的fuzzer和进化fuzzer。</p>
<p>基于变异的模糊程序盲目地变异提供的初始输入以提供给程序。一般来说，基于变异的模糊程序不知道预期的输入格式。Peach是一种模糊程序，可以执行基于变异和基于生成的fuzzing。</p>
<p>基于生成的模糊程序通过规范获取有关预期输入格式或协议的信息，根据这些规范生成输入。基于生成的fuzzer包括Peach和Sulley，Sulley是一个Python实现的fuzzing框架，可以为文件传输协议、网络协议和文件格式生成输入。</p>
<p>进化模糊程序是一种最新的模糊程序，它在变异的基础上，评估每一个输入的优先级，并使用适应度函数（通常是覆盖率）对输入进行排序，并选择排序最好的输入进行变异。进化模糊程序的例子包括honggfuzz、AFL和libFuzzer。</p>
<p><img src="/png/2021-01-24-10-39-35.png"></p>
<p>上图将一般的fuzzing过程分为几个阶段。</p>
<h5 id="pre-fuzzing-program-knowledge">Pre-Fuzzing: Program Knowledge</h5>
<p>在开始fuzzing之前，fuzzer需要程序知识，也就是如何对程序进行检测或观察？什么构成了一个有趣的程序状态？需要研究哪些输入接口？</p>
<p>基于变异的fuzzer通常需要以输入语料库或一组程序输入的形式提供额外的程序知识，以便有效地生成输入，这些程序输入往往是预期输入的示例。</p>
<p>基于生成的fuzzer以输入规范的形式吸收额外的程序知识，例如预期的文件格式或协议描述。基于生成的fuzzer通常比基于变异的模糊器有更好的代码覆盖率和更深入的程序状态探索。但是更难设置，因为它需要准确的程序输入规范，这通常比生成输入语料库耗费更多时间。而且基于生成的fuzzer仅探索这些规范指定的输入空间。</p>
<p>进化fuzzer和基于变异的fuzzer一样，通过输入语料库获取额外的程序知识。</p>
<p>通常，程序知识由使用者开发和提供。</p>
<h5 id="stage-1-generate-inputs">Stage 1: Generate Inputs</h5>
<p>在fuzzing的第一阶段，fuzzer使用程序知识生成输入，通过已指定的输入接口提供给程序，这个阶段的目标是生成那些可以触发或者说到达新的代码区域的输入。</p>
<p>并不是所有的新输入都会被使用，fuzzing的下一阶段将会选择这些生成输入。</p>
<p>基于变异的fuzzer通过处理先前的优先级高的输入来生成新的输入。在第一次迭代中，fuzzer处理初始输入语料库中提供的输入。之后，fuzzer会根据监视程序的信息评估输入性能，然后调整语料库。</p>
<p>基于生成的fuzzer通过根据输入规范来生成新的输入。对于一个给定的规范，只存在有限的与该规范对应的输入，也就是说输入搜索空间是有限的，所以基于生成的fuzzer可以探索整个输入搜索空间。</p>
<p>进化fuzzer和基于变异的fuzzer类似。要么变异一个输入，要么选择两个或多个输入进行交叉组合以产生新的输入，也可以使用其他随机化技术。进化fuzzer通过评估前一阶段的输入性能来选择输入进行随机化。</p>
<p>理论上，基于变异和进化的fuzzer可以产生无限的输入，无限的输入搜索空间使得很难估计有多少输入空间已经被探索过。</p>
<p>符号执行是一种静态分析技术，它可以帮助生成新的输入，从而增加fuzzer的覆盖范围。在实际中符号执行用于为基于变异和进化的fuzzer生成新的输入提供信息。这些新的输入可以添加到输入语料库中，或者以其他方式输入到程序中。</p>
<p>符号执行通过分析程序来找出程序中数据值的约束或限制，而无需真正执行。符号执行的工作原理是将输入数据抽象为一个符号值变元，然后遍历整个变元的符号值，当程序通过一个符号值进行分支判断时（例如if(x&lt;10)），符号执行引擎将生成两个符号状态，每个状态各包括一个不同分支的执行端满足的约束（branch-take状态将包含约束x&lt;10，而branch-not-take状态将包含约束x&gt;=10；除此之外，这两个符号状态将是相同的），并继续以符号执行的方式执行这两个状态。</p>
<p>符号状态包括到达该状态所需的一系列分支决策的约束条件。例如到达这一点的x值，为了记录这些值，将符号状态建模为一组约束，这些约束为每个输入变量编码路径上的有效值范围。</p>
<p>然后用约束求解器求解这些约束从而返回有效的具体赋值或者证明不存在此类赋值（即约束不可满足）。这个赋值表示一个输入，它通过做出与原始路径中相同的分支决策，使程序达到所需的程序状态。</p>
<p>fuzzer可以使用符号执行来创建新的输入，通过约束求解器为新发现的符号状态提供有效赋值来探索新的路径。</p>
<p>不幸的是，符号执行的计算成本很高，而且大量可能的程序路径使得以符号方式执行整个程序是不可行的。所以符号执行通常用于寻找那些通过随机探索难以找到的路径。为了降低这一成本，fuzzer将符号执行与标准输入生成技术配对。符号执行引擎可以通过跟随一个感兴趣的输入来限制路径，例如，只允许新的符号状态在有限数量的分支中偏离输入。然而，计算成本和路径爆炸仍然是重要的障碍。</p>
<h5 id="stage-2-select-inputs">Stage 2: Select Inputs</h5>
<p>在fuzzing的第二阶段，fuzzer选择并发送输入到程序。</p>
<p>当基于变异和进化的fuzzer继续迭代运行时，可能会收集许多非常大的输入，这会减慢模糊过程，所以需要执行语料库最小化来减少输入的数量，或者输入最小化来减少每个输入的大小。</p>
<p>无论是合理的选择输入来减少活动输入的数量，还是减小输入，这些技术都试图减少fuzzer发现新的程序状态所需的时间。</p>
<h5 id="stage-3-monitor-program">Stage 3: Monitor Program</h5>
<p>在fuzzing的第三阶段，fuzzer将监视程序以识别感兴趣的程序状态。有趣的程序状态指表现出特定的程序行为，在大多数情况下，crash就是一种有趣的程序状态。</p>
<p>而实际上，通过程序插桩可以观察到的任何行为都可以用来识别有趣的程序状态。例如，Valgrind可以检测内存损坏，即使这个损坏不会导致崩溃；对于脆弱性评估，有趣的行为是那些与bug或脆弱性相关的可观察行为。</p>
<p>如前所述，fuzzer需要程序知识，从而了解如何对程序进行检测以及什么构成了一个有趣的程序状态。操作人员通常会提供这些信息，但是如何定义一个有趣的程序状态仍然是一个研究挑战。而在脆弱性评估案例中，如何判断可观察到的行为与识别缺陷或脆弱性是否是最相关的也是一个研究挑战。</p>
<p>一旦fuzzer识别出一个有趣的程序状态，它就需要将该状态的描述返回给用户进行分析。</p>
<h5 id="stage-4-evaluate-inputs">Stage 4: Evaluate Inputs</h5>
<p>在fuzzing的第四阶段，fuzzer评估输入的执行情况。</p>
<p>许多fuzzer使用代码覆盖率来衡量输入的效果，如果输入执行了新的代码部分，也就是说提高了代码覆盖率，就会得到较高的评价；libFuzzer工具使用了一个类似的度量，即数据覆盖率，如果该输入和先前的输入执行情况的比较中出现了新的数据值，那么就会对该输入给予较高的评价。一些fuzzer使用bug的发现情况作为度量，导致崩溃的输入被给予较高的评价。</p>
<p>基于进化的fuzzer需要反馈输入的性能指标，也就是必须能够评估输入并对其进行排序。然后fuzzer根据输入的性能指标来有选择地生成新的输入和执行。基于变异和基于生成的fuzzer通常不需要反馈输入的性能指标，但是性能指标可以帮助评估fuzzer的整体性能。</p>
<p>实际上，覆盖度量是启发式的，不能提供对输入性能的完整评估。因此，找到一个有效和可比较的指标仍然是一个研究挑战。</p>
<h5 id="post-fuzzing-interesting-program-states">Post-Fuzzing: Interesting Program States</h5>
<p>在fuzzing之后，研究人员会简单分析fuzzer反馈的有趣的程序状态，包括形成原因和是否属于漏洞，之后会进行分类，以决定对哪些程序状态进一步分析。</p>
<p>不幸的是，这些程序状态通常具有相同的原因，而且具有相同原因的状态可能会出现截然不同的情况。例如，内存损坏漏洞可能会导致程序的许多不同部分崩溃，导致内存映像差异很大。一些自动化工具试图消除fuzzer输出的"重复"状态，但这些工具往往不完善，对状态进行分类和根本原因的分类仍然是一个研究挑战。</p>
<h4 id="applications-of-machine-learning-to-fuzzing">APPLICATIONS OF MACHINE LEARNING TO FUZZING</h4>
<p>ML已被用于在fuzzing中生成新的输入，并在较小程度上促进post-fuzzing。</p>
<p>无监督学习在输入生成中得到了最成功的应用。例如，AFL等模糊工具将遗传算法（GAs）集成到输入生成过程中。最近也有监督学习和强化学习（RL）在输入生成中的应用。</p>
<p>此外，这三种类型的ML都已应用于符号执行，主要是为了减少约束方程的求解时间。</p>
<p>监督学习和非监督学习都已应用于post-fuzzing，主要用于crash的分类和根本原因分类。</p>
<p>也就是说还有两个领域没有进行应用：输入最小化和语料库最小化。可能是因为这部分fuzzing不会导致大的性能瓶颈。</p>
<h5 id="generate-inputs">Generate Inputs</h5>
<p>以下是有关ML在输入生成方面的成果。</p>
<h6 id="genetic-algorithms">Genetic Algorithms</h6>
<p>最常用的ML输入生成技术是GAs。GAs是一种受生物进化启发的无监督ML，通常是进化fuzzer的核心输入生成算法。</p>
<p>当使用GAs时，有3个主要步骤：生成一个小的base population of inputs；对inputs执行转换；测量转换后的inputs的性能。根据选定的指标，在inputs上重复上述过程。</p>
<p>base population of inputs由一组种子输入组成。GAs会变异这些种子输入来探索代码空间，目的是发现新的路径。</p>
<p>进化fuzzer通常使用一个性能函数对输入进行排序来进行选择和变异。性能函数的选择会对fuzzer的性能，fuzzer识别特定类型错误的能力，以及fuzzer陷入局部极小值的趋势等方面产生巨大影响。</p>
<p>传统的代码覆盖率是性能函数最常用的度量，但也有更高级的启发式方法，如动态马尔可夫模型（DMM）启发式方法。</p>
<p>也就是将程序控制图表示为马尔可夫过程，即控制图当中的每一条边都有对应的转移概率。DMM启发式方法使用马尔可夫模型和转移概率来创建性能函数。与代码覆盖率不同，这种方法能更精确地控制fuzzer，将其引导到代码中可能包含bug或缺陷的特定部分。</p>
<p>性能函数的选择是fuzz的一个重要决定因素，因此设计新的性能函数来引导出期望的fuzzing是一个很有前途的研究领域。特别是可以对fuzzer进行更细粒度控制的性能函数对于定向fuzz更为有利。</p>
<h6 id="deep-learning-and-neural-networks">Deep Learning and Neural Networks</h6>
<p>深度学习（DL）和神经网络（NNs）也被应用于输入生成，特别是基于生成和基于变异的fuzzer。递归神经网络（RNN）是应用于fuzzing中的最常用的DL方法。特别是已被用于输入生成的Long-Short Term Memory（LSTM，RNN的一种变体）网络。</p>
<p>在一项研究中，Godefroid等人使用LSTMs为基于生成的fuzzer中的PDF文件创建输入语法。LSTM在许多类型的序列生成任务中显示出了良好的效果。然而，Godefroid等人发现fuzzing和LSTM输入语法学习的目标经常相互冲突：LSTM倾向于产生格式良好的输入，而fuzzer的目标是产生探索新程序状态的范例输入。为了避免这一矛盾，Godefroid等人采用了抽样策略来选取LSTM生成的输入，最终创建了一个具有很强平衡性的输入语法。实验结果表明，使用ML生成输入语法是一种很有前途的提高代码覆盖率的技术。</p>
<p>在另一项研究中，Rajpal等人将DL整合到AFL中，通过变异特定字节来增加覆盖率。一个NNs被用来生成一个热图，该图给出了特定字节发生变异时增加代码覆盖率的预测可能性。Rajpal等人比较了四种不同的生成热图的序列学习结构：标准LSTM；双向LSTM，它向前和向后处理输入序列；Seq2Seq，它将一个序列转换为另一个序列；Seq2Seq的一种变体，它使用attention机制来关注序列输入的重要部分。虽然每个模型在某些情况下都增加了代码覆盖率，但总体而言，标准LSTM模型的性能略优于其他模型。实验上，在ELF、XML和PDF格式上，DL增强AFL优于标准AFL，而在PNG格式上，标准AFL优于DL增强AFL。</p>
<p>另一种生成输入的方法是对程序行为建模，使用模型选择最有希望的输入。</p>
<p>NEUZZ方法使用浅层神经网络将程序的行为建模为平滑的连续函数，该神经网络被训练用于根据种子输入预测程序的分支行为。实验发现，训练过程中产生的梯度，特别是较大的梯度，有助于识别哪些输入字节控制分支行为。</p>
<p>Chen等人还通过Angora建模程序行为，Angora使用离散函数表示从程序起点到特定分支约束的路径，然后实现梯度下降从而在函数表示中的小离散区间上，以找到满足约束的一组输入，并通过该特定分支移动程序。总的来说，这种方法证明了快速解决分支约束的能力，并且在某些程序上的实验性能优于AFL和符号执行。</p>
<p>Cheng等人实现了一种使用DL生成输入的其他替代方法。这种方法使用RNNs来预测程序的新路径，然后将这些路径输入到Seq2Seq模型中，该模型为执行预测路径的fuzzer生成新的种子输入。初步研究表明，实验生成的语料库提高了PDF、PNG和TFF格式的fuzzer代码覆盖率。</p>
<p>DL和NNs的应用仍有障碍。</p>
<p>第一个障碍是DL模型需要大量的训练计算时间。其中许多研究试图缓解这些问题。例如，Rajpal等人通过在fuzzing开始之前只在一小部分输入上训练神经网络来规避训练成本。另一方面，She等人在整个fuzzing中使用了简化形式的模型再训练，只使用最有用的数据点进行再训练。这两种方法都减少了训练时间，但对模糊性能的总体影响尚不清楚。减少数据量的另一种方法是开发在程序之间传输先前训练过的模型的方法。这种方法可能会消除或减少fuzzing以前未开发的程序所需的模型训练量，但这些方法如何影响性能尚不清楚。</p>
<p>第二个障碍是跨文件格式的性能一致性。其中许多研究表明，对于某些文件格式（如PDF），DL与以前的基线相比，始终提高了模糊性能，而其他格式则无法与最先进的技术竞争。</p>
<h6 id="reinforcement-learning">Reinforcement Learning</h6>
<p>有两个团队应用强化学习进行输入生成。Becker等人使用SARSA算法通过改变发送到主机的网络数据包来对IPv6协议fuzz。SARSA算法考虑了代理的实时状态和行为来确定最优行为。Bottinger等人在基于生成的fuzzer中使用deep Q-learning network来学习语法来描述PDF格式。deep Q-learning network使用深度神经网络将状态映射到动作。</p>
<p>这些研究表明program representation对于训练一个成功的RL代理是至关重要的。</p>
<p>Becker等人使用有限状态机来表示IPv6协议的行为，其中每个状态表示主机对特定数据包的当前响应，状态之间的转换表示数据包的可能突变。Bottinger等人还使用了马尔可夫决策过程来表示问题。马尔可夫决策过程的特点是状态之间的随机转换。在这项研究中，状态表示fuzzer的特定种子输入，而转换表示该状态下种子输入的概率重写规则。因此，Becker和Bottinger都演示了使用有限状态机作为问题表示来训练RL代理生成输入的实用性。</p>
<p>这些研究还提供了有效定义一个代理的奖励函数的经验，这通常是RL最具挑战性的方面。</p>
<p>Becker等人根据以下标准创建了一个多部分奖励函数：从单个输入调用的程序函数的数量、是否存在错误以及来自程序的响应消息存在的潜在损坏或延迟。错误的存在是向代理发出的最强信号，表明它已到达代码空间的一个有趣部分。即使在没有错误信号的情况下，程序的响应也被用来指导代理。奖励函数的每一部分都在指导代理人方面都起着各自的作用，如果忽略这些标准，可能会导致代理人的效率降低。Bottinger等人试验了多种不同的奖励函数，一种使用代码覆盖率，另一种使用执行时间，第三种结合代码覆盖率和执行时间。在这两项研究中，奖励函数都会影响fuzzer对输入空间的探索。例如，当Bottinger使用执行时间作为奖励时，代理学习导致程序快速终止的输入。Becker和Bottinger的工作都表明需要仔细定义奖励函数，考虑到软件程序类型、寻找的bug类型、可用的fuzz度量以及最终的fuzz目标。</p>
<p>标准的fuzzer还没有实现RL，这些应用仍然是理论上的。</p>
<p>目前还不清楚奖励函数应该如何依赖于程序，或者是否存在普遍有效的奖励函数。例如，相同的奖励函数可以用于每个项目，还是每个独特的项目都需要一个独特的奖励函数？文件格式（如PDF和PNG）如何影响奖励函数的定义？</p>
<p>RL面临的另一个挑战是解决代理的可转移性。目前还不清楚是否有必要为每个独特的程序训练一个新的RL代理，这样做可能是不切实际的。因此，研究和创造可转让代理可能是未来研究的必要步骤。</p>
<h6 id="machine-learning-for-symbolic-execution">Machine Learning for Symbolic Execution</h6>
<p>有监督学习被用于求解约束方程。</p>
<p>在一项研究中，图形神经网络被用来识别表明约束方程是否有有效解的特征。在另一项研究中，吴使用了逻辑回归和蒙特卡罗方法相结合的方法来确定初始值，从而提高了找到约束方程有效解的概率。蒙特卡罗方法用于确定初始有希望的值，而逻辑回归则用于说明使用这些选择值的约束方程解的有效性。合并这些新的初始值会减少Minisat solver的运行时间。在另一项研究中，LSTMs（即DL）被训练用于求解约束方程。虽然LSTMs无法击败最先进的约束求解器，但它们能够从未经训练的域中求解约束方程，这表明DL模型具有泛化能力。Shiqi等人开发的另一种方法使用NNs表示约束方程。这些约束方程的解通过梯度下降被发现。</p>
<p>总的来说，这些研究都提供了求解约束方程的独特方法。虽然不能和目前的技术水平竞争，但它们为使用监督学习来减少求解约束方程所需的计算时间提供了一个强有力的起点。</p>
<p>Mairy等人使用RL改进了局部邻域搜索方法。局部邻域搜索方法通过求解约束方程的各个子集，并将这些子集组合起来形成最终解，从而迭代地找到约束方程的解。为了发现有用的子集，这些局部邻域搜索方法必须智能地探索可能的子集空间。引导RL代理选择更可能导致有效解决方案的子集，以减少找到此类解决方案所需的时间。</p>
<p>还有一项研究工作使用ML来减少解搜索空间的大小，而不是直接求解约束方程。Li等人将路径约束的典型集合重新表述为优化问题，并试图减少不可行路径的数量，即由于约束冲突而永远无法到达的路径。他们使用ML技术RACOS来解决优化问题，这是一种优化技术，可以很好地扩展到高维问题，然而只分析了非常小的程序。</p>
<h5 id="post-fuzzing-interesting-program-states-1">Post-Fuzzing: Interesting Program States</h5>
<p>ML主要用于分类崩溃（分类）或分类错误（根本原因分析），不过也有例外，Yan等人使用贝叶斯方法和!exploitable工具来提高确定漏洞可利用性的可靠性。</p>
<p>Dang等人使用aggregative hierarchy clustering将具有类似调用堆栈的崩溃进行分组，这是一种无监督学习技术，可以对具有类似特征的数据点进行聚类。他们在调用堆栈上引入了自己的相似性度量，即位置相关模型，允许他们使用未标记的调用堆栈数据集进行训练。他们在微软的各种产品上测试了他们的模型，并且在很多情况下比以前的碰撞相似性识别方法表现得更好。</p>
<p>已经有几次尝试使用ML对软件中的bug进行分类。</p>
<p>Harsh等人使用多种监督技术（包括决策树、支持向量机和朴素贝叶斯）对根本原因分类进行了实验。然而他们指出由于缺乏标记数据应用监督技术可能具有挑战性。为了解决缺少标记数据的问题，Harsh等人还尝试了无监督和半监督技术。不幸的是，这项研究的技术是有限的，因为bug的类别是非常广泛和系统特定的。</p>
<p>在另一项研究中，Long等人使用ML来确定根本原因，并生成修补程序来修复相关的bug。他们的工具Prophet使用了一个参数化的对数线性概率模型，该模型能够识别决定一段代码必须如何修复的重要特征。这项工作的一个重要方面是Prophet模型的可解释性；模型参数可用于确定生成特定patch的各种特征的重要性。这种可解释性非常重要，因为它可以帮助用户理解生成特定修补程序的原因。</p>
<p>有监督的ML技术用于更频繁地识别软件领域之外的根本原因。在一个例子中，决策树和支持向量机被用于工业生产系统的根本原因分析。在另一个例子中，神经网络用于工业储罐系统内的故障定位。支持向量机在加速电路板故障定位方面也显示出良好的前景。虽然这些研究都没有直接应用到软件上，但是可以扩展研究以帮助软件领域的根本原因分析。</p>
<p>ML很少应用于Post-Fuzzing，原因有二。</p>
<p>首先，大多数ML分类技术返回的是预测，而不是解释。这使得用户很难确定预测的标签是否正确以及为什么应用该标签。例如，在根本原因分析中，用户会发现很难理解根本原因应该在代码中显示在哪里，或者验证标签，或者纠正根本原因。此外，ML算法往往建立不透明的规则，很难映射到领域知识。</p>
<p>其次，只有极少数可用的标记数据集，目前还不清楚什么是强大的、可概括的基准数据集。在为Post-Fuzzing构建数据集时，有几个没有明确答案的问题必须解决，例如：</p>
<ol type="1">
<li>应该包括哪些可能的错误？</li>
<li>应该表示为哪些编程语言？</li>
<li>应该如何为ML算法编码错误及其根本原因？特别是考虑到根本原因是细微差别的，并且可能因系统而异？</li>
</ol>
<h5 id="seed-selection">Seed selection</h5>
<p>用ML进行种子选择方面的研究很少。</p>
<p>Wang等人进行了一项广泛的研究，使用NNs来选择更可能导致模糊代码中的漏洞的输入。虽然这项研究显示了有希望的结果，但诸如训练模型到新项目的可转移性等挑战仍然存在。与输入生成一样，模型的可传递性仍然是ML应用于种子选择的潜在瓶颈。</p>
<p>先前的种子选择研究指出了未来ML研究的另一种可能性。种子选择必须在使用已知性能水平的当前输入与探索未知但可能更好性能的新输入之间取得平衡。RL算法通常成功地应用于这类需要平衡新输入的探索和当前输入的利用的场景中。因此，RL算法可能非常适合于确定最优种子调度。未来的研究可能包括：为最佳种子选择创建奖励函数；确定离线RL代理在程序之间的可转移性；在fuzzing中集成在线RL代理。</p>
<h5 id="input-and-corpus-minimization">Input and Corpus Minimization</h5>
<p>目前似乎还没有任何关于输入最小化或语料库最小化的研究。因为输入最小化和语料库最小化都不是一个很大的性能瓶颈，最大的瓶颈存在于输入生成和Post-Fuzzing过程中，因此，大多数研究往往集中在这些领域；而且最小化输入或总语料库大小并不能自然地适合于ML技术。</p>
<h3 id="a-systematic-review-of-fuzzing-based-on-machine-learning-techniques">A systematic review of fuzzing based on machine learning techniques</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv19_Machine2.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>Fuzzing的工作过程由四个主要阶段组成：测试用例生成阶段、程序执行阶段、运行状态监控阶段和崩溃分析阶段。</p>
<p>机器学习技术在模糊测试中的应用的实质是将漏洞检测作为一个程序或样本分类的问题来对待。研究人员利用现有的机器学习技术帮助fuzzer从现有的大量脆弱性相关数据中提取经验和知识，然后根据训练生成的模型对新样本进行分类和预测。</p>
<p><img src="/png/2021-02-21-17-00-18.png"></p>
<h4 id="applying-machine-learning-techniques-for-different-fuzzing-steps">Applying Machine Learning Techniques for Different Fuzzing Steps</h4>
<p>根据机器学习所解决的问题，模糊化的步骤可分为以下几步：种子文件生成，测试用例生成，测试用例过滤器，突变操作选择，性能函数，可利用性分析。</p>
<h5 id="seed-file-generation">Seed file generation</h5>
<p>现有的种子选择策略存在着一些不足，比如需要更多的时间来获取种子集，选择的种子的执行效果与随机选择的种子几乎相同。利用机器学习技术可以学习传统模糊测试中导致代码覆盖率更高、崩溃次数更多、执行路径更独特的种子文件的共同特征，并通过基于生成或基于变异的方法生成更多具有该特征的种子文件。</p>
<p>Skyfire（Wang et al.2017）实现的data-driven种子生成方法使用PCFG（包含语义规则和语法特征的Probabilistic context-sensitive grammar）自动提取语义信息。这些语义信息和语法规则用于种子生成，从而保证生成的种子文件通过语法分析和语义检查。Skyfire可以执行到目标程序的更深路径，从而更有效地发现深层漏洞。</p>
<p>Fast fuzzing（Nichols et al.2017）使用深层神经模型来增强随机突变测试的有效性，从AFL（Zalewski M 2016）生成的样本中学习特征并生成种子文件，通过生成对抗网络（GAN）的对抗训练增加执行路径。</p>
<p>SmartSeed（Lv et al.2018）读取输入文件并将其转换为二进制形式的统一类型矩阵，然后使用WGAN和MLP从收集的数据集中自动学习触发唯一崩溃或唯一路径的特征。经过训练的模型可以生成更容易导致崩溃和唯一路径的种子文件。</p>
<p>Cheng等人（Cheng et al.2019）使用RNN和seq2seq找到PDF文件和目标程序执行路径之间的相关性。然后，这种相关性被用来生成新的种子文件，这些文件更有可能在目标程序中探索新的路径。</p>
<p>NeuFuzz（Wang et al.2019）通过LSTM学习样本中已知的漏洞程序和隐藏的漏洞模式，发现可能包含漏洞的执行路径。然后，NeuFuzz优先执行能够覆盖包含漏洞路径的种子文件，并根据预测结果为这些种子文件分配更多的变异能量。</p>
<h5 id="testcase-generation">Testcase generation</h5>
<p>testcase可以通过对种子文件执行变异来生成，也可以基于已知的输入文件格式来构建。作为最终输入，testcase的内容将直接影响bug是否被触发。因此，构造一个代码覆盖率高或能触发漏洞的testcase可以有效地提高fuzzer中漏洞检测的效率。</p>
<p>Samplefuzz（Godefroid et al.2017）首次尝试使用基于神经网络的统计学习技术从样本输入自动生成输入语法。提出了一种基于seq2seq递归神经网络的PDF对象自动学习生成模型，并对其进行了评价。该模型不仅可以生成大量新的testcase，而且可以提高覆盖率。</p>
<p>Fan等人（Fan and Chang 2017）提出了一种为专有网络协议自动生成黑盒模糊testcase的方法。该方法使用seq2seq来处理专有网络协议的通信流量来学习生成的输入模型，并使用该学习模型生成testcase。</p>
<p>GANFuzz（Hu et al.2018）通过在生成对抗网络中训练生成的模型来学习协议语法，以估计工业网络协议消息的潜在分布函数。基于这个生成模型可以生成一个格式良好的testcase。</p>
<p>DeepSmith（Cummins等人，2018）将随机程序的生成作为一个语言建模问题。它使用LSTM模型在代码语料库上学习编程语言的语法、语义、常规结构和模式。DeepSmith根据编译器模糊化的生成方法生成语法格式的testcase。</p>
<p>Sablotny et al.（Sablotny et al.2018）构建了堆叠RNN的模型，以生成HTML标记和新的testcase，用于fuzz浏览器的渲染引擎。其主要思想是根据从大量HTML标记中学习字符序列的概率分布来生成HTML标记。</p>
<p>IUST DeepFuzz（Nasrabadi et al.2018）使用基于深度递归神经网络（RNN）的神经语言模型（NLM）学习复杂输入文件的结构。IUST DeepFuzz首先删除输入文件的非文本部分，并用令牌替换它。在训练结束后，用删除部分的变体替换令牌以生成新的testcase。</p>
<p>NEUZZ（She et al.2019）进一步提出了一种梯度引导搜索策略，该策略计算并使用平滑近似梯度（即NN模型）来识别目标突变位置，这可以最大化目标程序中检测到的bug数量。研究成果还说明了如何通过对错误预测的程序行为进行逐步再训练来改进神经网络模型。</p>
<p>Paduraru等人（Paduraru和Melemciuc 2018）对不同文件格式的语料库进行了聚类。将输入文件的语料库作为一系列字符，通过seq2seq学习每个聚类的生成模型。该方法可以在训练好的模型的基础上生成新的testcase，从而可以执行更多的分支。</p>
<p>Li et al.（Li et al.2019b）提出了一种基于WGAN的工业控制协议testcase生成方法。该方法可以在不知道具体协议规范的情况下，通过实际数据帧的结构和分布生成相似的数据帧。</p>
<p>DeepFuzz（Liu等人，2019b）通过seq2seq模型从原始GCC测试套件学习正确的C程序语法。该模型基于所学语法连续生成语法正确的C程序。然后，使用insert、replace和remove策略生成testcase来fuzz编译器。</p>
<p>V-Fuzz（Li等人，2019a）构建了一个图形嵌入式网络来训练脆弱性预测模型。根据训练后的模型，引导fuzzer生成倾向于到达潜在漏洞区域的testcase。提取漏洞函数和安全函数的属性控制流图，在函数级进行学习。在预测阶段，评估的概率被用作testcase的性能度量。</p>
<h5 id="testcase-filter">Testcase filter</h5>
<p>如果fuzzer要执行所有质量参差不齐的样本，这是费时又低效的。Testcase filter的目的是从大量样本中选择更有可能触发新路径或漏洞的样本。利用机器学习技术可以对样本进行分析和分类。</p>
<p>Gong et al.（Gong et al.2017）基于AFL生成的样本训练了一个深度学习模型。通过训练模型可以预测新一轮AFL生成的样本是否会改变程序状态。</p>
<p>Augmented-AFL（Rajpal et al.2017）实现了几种神经网络架构，以学习预测给定输入修改集的预期代码覆盖率的能力。在fuzzing中，学习函数用于预测完整输入文件的热图，对应于每个文件位置突变导致新代码覆盖的概率。然后使用覆盖图确定突变位置的优先级。</p>
<p>Siddharth（Karamcheti et al.2018b）将程序输入映射到执行轨迹，并对执行轨迹分布的熵进行排序。Siddharth假设不确定性越高，执行新代码路径的可能性越大，因此选择熵最大（最不确定）的输入来执行下一个输入。</p>
<h5 id="mutation-operator-selection">Mutation operator selection</h5>
<p>fuzzing中不同位置的不同突变会产生不同的影响。变异算子的选择策略是为了达到提高模糊化效率的目的，例如增加代码覆盖率或包含脆弱路径。</p>
<p>Becker等人（Becker et al.2010）指定了一个有限状态机并分解了不同的消息类型来分析neighbor discovery协议。工作的主要思想是利用基于跟踪、调试和监控三种不同奖励函数的强化学习模型对模糊化网络进行优化，选择最佳的模糊化测试策略。</p>
<p>LEFT（Fang和Yan 2018）构建了一个基于强化学习的模型对Android手机中的LTE功能进行fuzz。该模型主要包括三种模糊处理方法：emulation-instrumented black-box fuzzing，threat-model-aware fuzzing，RL-guided fuzzing。</p>
<p>受反馈驱动随机测试和强化学习的启发，Böttinger等人（Böttinger et al.2018）提出了第一种使用强化学习的模糊化方法，以最大限度地提高代码覆盖率和减少处理时间。该模型可以在获得高收益的情况下学习突变的运行特征。</p>
<p>FuzzerGym（Drozd和Wagner 2018）使用LLVM Santizers的程序监视器获取状态信息，这些信息被用来优化基于强化学习（RL）的变异算子选择。结合强化学习和模糊化的优点，通过OpenAI-Gym与libFuzzer的集成，实现对多个基准的更深入的覆盖，并直接从输入数据中实现变异选择策略的学习。</p>
<p>Karamcheti等人（Karamcheti等人2018a）提出了一种基于robers的Thompson抽样优化方法，该方法可以在fuzz单个程序的过程中自适应调整变异算子的分布。通过学习每个变异算子对代码覆盖率的影响，确定应该选择哪个变异算子。最后，在下一次迭代中使用所选择的变异算子对测试输入进行变异。</p>
<p>FUZZBOOST（Liu等人，2019）使用从运行时跟踪收集的代码覆盖率信息作为奖励，并使用Deep Q-learning算法优化此奖励。通过这样做，模糊代理学习如何选择变异算子对种子程序进行变异，以提高模糊测试的覆盖率。</p>
<h5 id="fitness-function">Fitness function</h5>
<p>基于遗传算法的fuzzer使用性能函数评价测试用例满意和不满意，常见的性能函数包括代码覆盖率、潜在漏洞位置。</p>
<p>Xiao等人（Sun et al.2018）提出了一种新的基于遗传规划的适应度函数，不同于目前主流的基于代码覆盖率的方法。它将马尔可夫链和PCFG模型相结合，从程序员开发的普通脚本语料库中学习脚本的共性，并通过测量脚本与普通脚本的偏差来计算脚本的uncommonness。该偏差用于计算基于GP的语言模糊脚本的性能，偏差较大的脚本更容易引发解释器的错误。</p>
<h5 id="exploitability-analysis">Exploitability analysis</h5>
<p>常用的脆弱性分析方法有静态分析和动态分析。采用工具技术如!exploitable（Team MSECMSS 2013），CERT tools。</p>
<p>ExploitMeter（Yan et al.2017）使用贝叶斯机器学习算法对从软件中提取的静态特征进行初始判断。将fuzzing中的初始判断和可利用性判断相结合，更新最终的可利用性结果。</p>
<p>Exniffer（Tripathi et al.2018）建议使用机器学习来自动确定碰撞可利用性预测的更一般规则。该方法使用支持向量机（SVM）学习从核心转储文件（崩溃期间生成）中提取的特征和从最新处理器硬件调试扩展中获取的信息。</p>
<p>Zhan et al.（Zhang and Thing 2019）基于n-gram分析和特征散列生成紧凑的指纹，用于动态跟踪每个崩溃输入。然后将指纹输入在线分类器，建立识别模型。在线分类器支持的增量学习允许模型即使在大量崩溃时也能很好地扩展，同时对于新的崩溃也很容易更新。</p>
<h4 id="analysis-of-machine-learning-based-fuzzing-model">Analysis of Machine Learning Based Fuzzing Model</h4>
<p>从五个方面分析机器学习在fuzzing中的使用：机器学习算法的选择，预处理方法，数据集，评估指标，Hyperparameters设置。</p>
<h5 id="selection-of-machine-learning-algorithm">Selection of machine learning algorithm</h5>
<p>fuzzer的输入数据可以是文本、源代码、二进制字符串、网络包等形式。PUT还包含复杂的语法、语义和逻辑结构。在复杂的模糊测试环境中，判断哪种机器学习算法有效是一个难题。</p>
<p><img src="/png/2021-02-23-20-39-01.png"></p>
<p>每种传统的机器学习算法只使用了一次，造成这种现象的原因可能是传统的机器学习技术需要人工提取特征。然而，输入样本格式和目标程序都包含复杂的语法和语义结构，并且没有有效的漏洞模型或漏洞特征。</p>
<p>深度学习依赖于它的representation learning，能够自动提取模糊测试中广泛应用的特征。最常用的两种算法是LSTM和seq2seq，LSTM使用最多的原因是它擅长处理顺序数据：程序执行路径与自然语言中的语句非常相似，一段代码是否包含漏洞取决于上下文。另一方面，LSTM具有适于处理长依赖关系的记忆功能，因为与漏洞相关联的代码可能位于路径中相对较长的距离处（Wang等人，2019）。seq2seq模型的输入输出序列长度是可变的，可以有效地利用模糊化的输入作为文本数据来学习局部或全局的语法信息。模糊测试中还使用了新的神经网络，如生成对抗网络（Goodfello et al.2014）和图卷积网络（Kipf and Welling 2016）。</p>
<p>在模糊测试中，由于强化学习需要在不同的环境中选择不同的行为，因此强化学习被用于变异算子的选择，这与变异算子的选择类似。然而，强化学习本身存在训练时间长、收敛性弱、局部优化等局限性，导致其在模糊测试中的应用较少（Mnih等，2013）。</p>
<h5 id="pre-processing-method">Pre-processing method</h5>
<p>由于PUT的类型不同，输入格式也有很大的不同，这些数据需要转换成可用于机器学习的输入。</p>
<p><img src="/png/2021-02-23-20-40-35.png"></p>
<p>预处理方法分为三类：程序分析、自然语言处理和其他。</p>
<p>程序分析是指利用静态或动态分析技术提取程序特征或运行时信息，如堆栈、寄存器、汇编指令、跳转、程序控制流图、抽象语法树和程序执行路径（Wang et al.2017；Tripathi et al.2018；Li et al.2019a）。</p>
<p>自然语言处理是指直接以文本形式输入的方法，利用复杂的文本处理技术提取输入数据中隐藏的特征，如n-gram（Damashek 1995）、count statistics、Word2vec（Goldberg and Levy 2014）、heat map（Wilkinson and Friendly 2009）等方法（Fan and Chang 2017；Yan等人，2017年；Karamcheti等人，2018b）。</p>
<p>其他包括将程序分析与自然语言处理技术相结合（Wang et al.2019；Zhang and Thing 2019），或将整个文档或pdf对象转换为向量（Rajpal et al.2017；Lv et al.2018），以及自定义方法。</p>
<p>根据文献（Gong et al.2017）的定义，测试用例的二进制序列用32位表示，模糊技术用4位表示，变异位用10位表示，变异值用32位表示，是否是新测试用例用1位表示。最后，每段数据都可以组合成一个79位的二进制序列，第一个78位作为输入，最后一个1位作为标签。</p>
<h5 id="datasets">Datasets</h5>
<p>机器学习的性能主要受训练数据的影响，在目前的工作中，用于基于机器学习算法的模糊测试的数据集有以下来源：网络爬虫，fuzzing过程中产生，自建，公共数据集。</p>
<h5 id="evaluation-metrics">Evaluation metrics</h5>
<p>基于机器学习技术的fuzz的性能评价可以分为两个方面：机器学习模型的性能评价和漏洞检测能力的评价。</p>
<p><img src="/png/2021-02-23-21-17-04.png"></p>
<p><img src="/png/2021-02-23-21-17-18.png"></p>
<p>机器学习模型的评价是基于分类度量的，而基于机器学习的模糊方法的漏洞检测能力评价与传统的模糊方法相同，传统的模糊化方法和基于机器学习的模糊化方法都是为了发现漏洞而设计的。因此，覆盖率、崩溃和bug是评估模糊模型性能的有效指标。然而，基于机器学习的模糊化方法有模型训练、特征提取等步骤，因此效率这一指标也被大量文献所采用。</p>
<h5 id="hyperparameters-setting">Hyperparameters setting</h5>
<p>在机器学习模型的实现中，Hyperparameters的值不是通过训练得到的，而是需要在训练前进行人工设置。一般来说，需要对超参数进行优化，选择一组最优的超参数来提高学习的性能和有效性。</p>
<p><img src="/png/2021-02-23-21-19-03.png"></p>
<p>深度学习算法中的超参数主要用来完成比较，包括层数、每层节点数、epoch数、激活函数和学习率。当每层中的节点数较大时会发生过拟合。随着epoch数的增加，神经网络的权值更新迭代次数增加，损失函数曲线从初始的不拟合状态进入最优拟合状态。激活函数的选择可以提高神经网络的建模表达能力，解决线性模型无法解决的问题。然而，不同激活函数的优缺点是不同的，例如sigmoid输入范围在0和1之间，但存在"sigmoid saturate and kill gradients"而不是"zero-centered"的问题（LeCun et al.2012）。Tanh（fan2000）解决了sigmoid输出不"zero-centered"的问题，但仍存在其他问题。学习速率控制着模型的学习进度，也影响着模型收敛到局部极小值的速度。较高的学习率容易导致损失值的爆炸和冲击，而较低的学习率会导致过拟合和收敛速度减慢速度。</p>
<h4 id="performance-evaluation-of-fuzzing-model-based-on-machine-learning">Performance Evaluation of Fuzzing Model Based on Machine Learning</h4>
<p>机器学习模型性能评价：准确率、查准率、召回率和损失率是所选研究文献中最常用的绩效指标。准确度、准确度和召回率这三种性能指标的值越高，表示预测越准确。性能指标损失值越低，模型的鲁棒性就越高。</p>
<p>漏洞检测能力的性能评估：覆盖率，特定代码路径，特定的崩溃或错误，合格率（生成的样本中可以通过程序语法检查的百分比），效率。</p>
<h4 id="future-directions">Future Directions</h4>
<p>未来的方向可以从以下三个方面进行：</p>
<ol type="1">
<li>数据集。将机器学习引入fuzz必须建立开放且全面的数据集，作为测试基准。</li>
<li>特征选择。程序的结构和执行信息与漏洞没有直接关系，因此如何从程序或样本中选择实用的特征成为影响fuzz性能的一个重要因素。目前自然语言处理技术比较成熟，可以考虑利用自然语言处理领域的先进技术，提取程序的代码属性、语义和语法特征等有用信息进行fuzz。</li>
<li>学习算法的选择。应根据fuzz不同阶段的特点、对应数据的大小、不同算法的优缺点作为算法选择的依据。其次，graph convolutional networks，fusion neural networks和interpretable deep learning models都可以尝试与fuzz相结合，有必要研究更复杂、更合适的神经网络模型来提高生成样本的质量。</li>
</ol>
<h3 id="the-art-science-and-engineering-of-fuzzing-a-survey">The Art, Science, and Engineering of Fuzzing: A Survey</h3>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/TSE19_Survey.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<h4 id="systemization-taxonomy-and-test-programs">SYSTEMIZATION, TAXONOMY, AND TEST PROGRAMS</h4>
<p>几乎所有的fuzz算法都依赖于PUT之外的一些参数,这些参数的设置称为模糊配置。</p>
<p>将随机字节流发送到PUT的fuzz算法有一个简单的配置空间{(PUT)}。而复杂的fuzzer包含的算法接受一组配置，并随着时间的推移添加和删除配置。例如，CERT BFF在fuzzing中会改变突变率和seed，因此它的配置空间是{(PUT),(PUT),...}的形式。</p>
<p>fuzzer通常维护一个称为种子池的seed集合，seed是PUT的输入（通常结构良好），通过修改它来生成新的测试用例，一些fuzzer会随着fuzzing演化种子池。最后，fuzzer能够在每个配置中存储一些数据，例如覆盖率。</p>
<p><img src="/png/2021-02-26-20-55-03.png"></p>
<p>上图是一个用于模糊测试的通用算法模型，算法以一组模糊配置C和一个超时时间作为输入，输出为发现的bug。</p>
<p>第一部分是预处理函数，它在模糊活动开始前执行。第二部分是循环中的五个函数：SCHEDULE，INPUTGEN，INPUTEVAL，CONFUPDATE，CONTINUE。有些fuzzer并没有实现所有五个函数，例如，对于从不更新模糊配置集的Radamsa模型，CONFUPDATE总是返回当前配置集不变。</p>
<ul>
<li>PREPROCESS：预处理函数以一组fuzz配置C作为参数，并返回一组可能被修改的模糊配置。预处理可以执行多种操作，例如向PUT进行插桩，或者测量种子文件的执行速度。</li>
<li>SCHEDULE：SCHEDULE以一组fuzz配置C、当前时间和超时时间作为参数，并返回一个模糊配置conf用于该轮fuzz。</li>
<li>INPUTGEN：INPUTGEN以当前fuzz配置C作为参数，并返回一组具体的测试用例tcs。一些fuzzer使用conf中的种子来生成测试用例，而另一些使用模型或语法。</li>
<li>INPUTEVAL：INPUTEVAL以当前fuzz配置conf、测试用例tcs和一个嵌入在fuzzer中的Obug（bug oracle）作为参数，并返回每个fuzz运行时获取的信息集，这些信息可用于更新fuzz配置。INPUTEVAL使用bug oracle和测试用例tcs执行PUT，并检查执行是否违反了正确性策略。</li>
<li>CONFUPDATE：CONFUPDATE以一组fuzz配置C、当前配置conf和每个fuzz运行时获取的信息集作为参数。CONFUPDATE会更新这组fuzz配置，例如，许多灰盒模糊器基于运行时信息减少C中fuzz配置的数量。</li>
<li>CONTINUE：CONTINU以一组fuzz配置C作为参数，并输出一个布尔值指示是否应该继续。</li>
</ul>
<h4 id="preprocess">PREPROCESS</h4>
<p>预处理通常用于检测PUT、剔除潜在的冗余配置、修剪种子以及生成驱动程序应用程序，预处理也可用于为INPUTGEN准备模型。</p>
<h5 id="instrumentation">Instrumentation</h5>
<p>静态插桩通常通过在编译时对源代码或中间代码修改来进行，除了基于源代码的工具之外，研究人员还开发了二进制级静态插桩（即二进制重写）工具。</p>
<p>动态插桩比静态插桩有更高的开销，因为它是在运行时执行的，动态插桩工具：DynInst、DynamoRIO、Pin、Valgrind和QEMU。</p>
<p>给定的fuzzer可以支持多种类型的检测。例如，AFL支持在源代码级别使用修改过的编译器进行静态插桩，或者在QEMU的帮助下在二进制级别进行动态插桩。使用动态插桩时，AFL可以插桩PUT本身中的可执行代码（默认设置），或着PUT和任何外部库中的可执行代码（AFL_INST_LIBS选项）。第二个选项会检测所有遇到的代码，获取包括外部库中代码的覆盖率信息，从而提供更完整的覆盖率图。</p>
<h5 id="execution-feedback">Execution Feedback</h5>
<p>灰盒fuzzer通常将执行反馈作为参数来生成新的测试用例。</p>
<h5 id="thread-scheduling">Thread Scheduling</h5>
<p>通过显式控制线程的调度方式来触发不同的不确定性的程序行为，例如条件竞争漏洞。</p>
<h5 id="in-memory-fuzzing">In-Memory Fuzzing</h5>
<p>模糊大型程序的一种方法是在程序初始化之后对PUT进行快照，这样就可以通过恢复内存快照直接进行一次新的执行，这种方法也适用于模糊网络应用程序，称为内存模糊化。</p>
<p>一些fuzzer在每次迭代后只对函数执行内存模糊化，而不恢复整个PUT的状态，这种技术叫做内存API模糊化。</p>
<p>AFL有一个名为persistent mode的选项，它在循环中重复执行内存API模糊化，而不重新启动进程。在这种情况下，AFL忽略了在同一执行中多次调用函数的潜在副作用。</p>
<h5 id="seed-selection-1">Seed Selection</h5>
<p>种子选择：即减小初始种子池大小，常见的有minset，它找到一组最小的种子，使覆盖度量（如节点覆盖）最大化。</p>
<p>fuzzer在实践中使用各种不同的覆盖度量。例如，AFL的minset基于分支覆盖率，Hongfuzz基于执行的指令、分支和基本块的数量来计算覆盖率。</p>
<h5 id="seed-trimming">Seed Trimming</h5>
<p>种子修剪：即减小种子的大小，较小的种子可能消耗更少的内存，并带来更高的吞吐量。种子修剪可以发生在预处理时，也可以作为更新的一部分。</p>
<h5 id="preparing-a-driver-application">Preparing a Driver Application</h5>
<p>当fuzz的目标是一个库时，需要研究人员准备一个调用了库中函数的驱动程序。类似地，内核fuzzer可以fuzz用户态程序来测试内核，IoTFuzzer通过让驱动程序与相应的智能手机应用程序通信，将IoT设备作为目标。</p>
<h4 id="scheduling">SCHEDULING</h4>
<p>调度即为下一次模糊迭代选择一个模糊配置，模糊配置的内容取决于fuzzer的类型。对应的问题称为FCS问题（Fuzz Configuration Scheduling）。</p>
<h5 id="black-box-fcs-algorithms">Black-box FCS Algorithms</h5>
<p>Black-box FCS Algorithms依据的信息为配置的模糊结果、发现的崩溃和错误的数量以及迄今为止花费在该配置上的时间。</p>
<p>Householder和Foote是第一个研究如何在CERT-BFF中利用这些信息的人，Woo等人在多个方面进一步改进了他们的结果。</p>
<p>首先，他们将模型细化为Weighted Coupon Collector's Problem with Unknown Weights(WCCP/UW)。其次，他们将multi-armed bandit(MAB)算法应用于模糊化，这是当面临勘探与开发冲突时的常见应对策略。第三，他们将配置的成功概率与已经花费在配置中的时间关联，从而选择更快的配置。第四，他们重新定义了fuzz迭代，从运行固定数量的fuzz进程变为运行固定时间，进一步降低了较慢配置的优先级。</p>
<h5 id="grey-box-fcs-algorithms">Grey-box FCS Algorithms</h5>
<p>Grey-box FCS Algorithms拥有更丰富的信息集，例如覆盖范围。</p>
<p>AFL是这一领域的先驱，它基于evolutionary algorithm(EA)。EA维护一组配置，每个配置都有一些适度值。EA会选择合适的配置，并对其进行突变和重组，然后从中选择新的配置。</p>
<p>AFL维护一个配置队列，从中选择下一个合适的配置。一旦选中，AFL会将更多的运行时间分配给速度最快、分支覆盖率更高的配置。</p>
<p>Bohme等人的AFLFast在三个方面改进了AFL。</p>
<blockquote>
<p>To start, it modifies configuration fitness setting and selection to prioritize exploration of new and rare paths. Moreover, AFLFast fuzzes a selected configuration a variable number of times as determined by a power schedule. Its FAST power schedule starts with a small “energy” value to ensure initial exploration among configurations and increases exponentially up to a limit to quickly ensure sufficient exploitation. Finally, it also normalizes the energy by the number of generated inputs that exercise the same path, thus promoting explorations of less-frequently fuzzed configurations.</p>
</blockquote>
<p>AFLFast中的创新已作为FidgetyAFL的一部分集成到AFL中。Zalewski发现AFLFast最大的改进是快速检查所有新添加的种子。在相关工作中，AFLGo通过修改其优先级属性针对特定的程序位置。Hawkeye通过在种子调度和输入生成中利用静态分析进一步改进了定向模糊。FairFuzz通过为每对种子和一个稀有分支使用一个mutation mask来指导fuzzing，以探索稀有分支。QTEP使用静态分析来推断二进制文件的哪个部分更有可能存在漏洞，并优先考虑覆盖这些地方的配置。</p>
<h4 id="input-generation">INPUT GENERATION</h4>
<p>输入生成是模糊测试一个非常重要的过程，可以分为Model-based (Generation-based) Fuzzers，Model-less (Mutation-based) Fuzzers和White-box Fuzzers。</p>
<h5 id="model-based-generation-based-fuzzers">Model-based (Generation-based) Fuzzers</h5>
<p>基于模型的模糊器基于描述PUT可能接受的输入或执行的给定模型生成测试用例，例如精确描述输入格式的语法或不太精确的约束，例如标识文件类型的魔法值。</p>
<p>5.1.1预定义模型 一些模糊程序使用一个可以由用户配置的模型。例如，Peach[79]、PROTOS[124]和Dharma[5]接受了用户提供的规范。</p>
<p>Autodafe[224]、Sulley[19]、SPIKE[16]、SPIKEfile[211]、´和LibFuzzer[6]、[12]公开了允许分析师创建自己的输入模型的API。Tavor[250]还接受以扩展的Backus-Naur形式（EBNF）编写的输入规范，并生成符合相应语法的测试用例。类似地，PROTOS[124]、SNOOZE[32]、KiF[15]和TFuzz[118]等网络协议模糊器也从用户那里获取协议规范。内核API模糊器[119]、[226]、[163]、[168]、[231]以系统调用模板的形式定义输入模型。这些模板通常指定系统调用期望作为输入的参数的数量和类型。在内核模糊化中使用模型的想法起源于Koopman等人的开创性工作[132]，他们将操作系统的健壮性与为系统调用手动选择的有限测试用例集进行了比较。Nautilus[25]使用基于语法的输入生成进行通用模糊处理，并使用其语法进行种子修剪（见§3.3）。</p>
<p>其他基于模型的模糊器以特定的语言或语法为目标，这种语言的模型构建在模糊器本身中。例如，cross fuzz[242]和DOMfuzz[195]生成随机文档对象模型（DOM）对象。同样地，jsfuzz[195]基于自己的语法模型生成随机但语法正确的JavaScript代码。QuickFuzz[97]利用现有的Haskell库来描述生成测试用例时的文件格式。一些网络协议模糊器，如Frankencerts[44]、TLS-Attacker[203]、tlsfuzzer[128]和llfuzzer[207]，是用特定网络协议（如TLS和NFC）的模型设计的。杜威等人[72]，[73]提出了一种方法，通过利用约束逻辑编程来生成不仅语法正确，而且语义多样的测试用例。LangFuzz[109]通过解析作为输入的一组种子来生成代码片段。然后，它随机组合片段，并将种子与片段突变，以生成测试用例。因为它提供了语法，所以它总是产生语法正确的代码。虽然LangFuzz应用于JavaScript和PHP，但BlendFuzz[239]以XML和正则表达式解析器为目标，基于与LangFuzz类似的思想。</p>
<p>5.1.2推断模型 推断模型而不是依赖于预定义的或用户提供的模型最近得到了广泛的关注。尽管已经有大量关于自动输入格式和协议逆向工程的研究发表[69]、[48]、[146]、[66]、[31]，但是只有少数模糊程序利用这些技术。与插装（§3.1）类似，模型推理可以在预处理或混淆更新中发生。</p>
<p>5.1.2.1预处理中的模型推理：一些模糊程序将模型作为预处理步骤进行推理。TestMiner[70]搜索PUT中可用的数据，如文字，以预测合适的输入。给定一组种子和一个语法，Skyfire[227]使用数据驱动的方法来推断概率上下文敏感语法，然后使用它来生成一组新的种子。与以前的工作不同，它侧重于生成语义上有效的输入。IMF[103]通过分析系统API日志学习内核API模型，并生成C代码，该代码使用推断出的模型调用一系列API调用。CodeAlchemist[104]将JavaScript代码分解为“代码块”并计算组装约束，这些约束描述了何时可以将不同的代码块组装或合并在一起以生成语义上有效的测试用例。使用静态和动态分析计算这些约束。Neural[65]和Learn&amp;Fuzz[94]使用基于神经网络的机器学习技术从一组给定的测试文件中学习模型，然后从推断的模型中生成测试用例。Liu等人[147]提出了一种类似的方法，专门针对文本输入。</p>
<p>5.1.2.2 CONFUPDATE中的模型推理：其他模糊程序可能在每次模糊迭代后更新其模型。PULSAR[88]从程序生成的一组捕获的网络数据包中自动推断出网络协议模型。学习的网络协议，然后用于模糊程序。PULSAR在内部构建一个状态机，并映射哪个消息令牌与一个状态相关。这些信息稍后用于生成覆盖状态机中更多状态的测试用例。Doupe等人[76]提出了一种通过观察I/O行为来推断web服务状态机的方法。然后使用推断出的模型来扫描web漏洞。Ruiter等人[187]的工作类似，但它以TLS为目标，并以LearnLib[181]为实现基础。GLADE[33]从一组I/O样本中合成一个上下文无关语法，并使用推断的语法模糊PUT。gofuzz[225]是一个灰盒fuzzer，它为添加到其种子库中的每个种子建立一个模型。此模型用于从该种子生成新的输入。为了克服符号执行的局限性，Shen等人[201]使用神经网络来解决困难的分支条件。</p>
<p>5.1.3编码器型号 模糊化通常用于测试解析某种文件格式的解码器程序。许多文件格式都有相应的编码程序，可以看作是文件格式的隐式模型。诱变剂[127]利用编码器程序中包含的隐式模型来生成新的测试用例。与大多数基于变异的模糊程序不同，它变异现有的测试用例（见§5.2）来生成测试用例，诱变剂变异编码器程序。具体来说，为了产生一个新的测试用例，诱变剂计算编码器程序的动态程序片并运行它。其基本思想是，程序片段将略微改变编码器程序的行为，从而生成格式稍微不正确的测试用例。</p>
<h5 id="model-less-mutation-based-fuzzers">Model-less (Mutation-based) Fuzzers</h5>
<p>经典随机测试[23]，[102]在生成满足特定路径条件的测试用例时效率不高。假设有一个简单的C语句：if（input==42）。如果输入是32位整数，则随机猜测正确输入值的概率为1/232。当我们考虑结构良好的输入（如MP3文件）时，情况会变得更糟。实际上，随机测试不太可能在任何合理的时间内生成有效的MP3文件作为测试用例。因此，MP3播放器很可能会在解析阶段拒绝随机测试生成的测试用例，然后再访问程序的更深层部分。</p>
<p>这个问题促使使用基于种子的输入生成和白盒输入生成（见§5.3）。大多数无模型模糊器使用种子，这是PUT的一个输入，以便通过修改种子来生成测试用例。种子通常是PUT支持的类型的结构良好的输入：文件、网络包或UI事件序列。通过只对有效文件的一小部分进行变异，通常可以生成一个新的测试用例，该测试用例大部分是有效的，但也包含异常值以触发PUT崩溃。有各种各样的方法可以用来突变种子，下面我们将介绍常见的方法。</p>
<p>5.2.1位翻转 位翻转是许多无模型模糊器常用的技术[243]、[213]、[107]、[1]、[106]。一些模糊器只是简单地翻转固定数量的位，而另一些模糊器则确定要随机翻转的位的数量。为了随机变异种子，一些模糊程序使用一个用户可配置的参数，称为变异比率，它决定了INPUTGEN一次执行时要翻转的位位置的数量。要翻转给定位种子中的随机位，突变率为。K公司不K/N公司</p>
<p>SymFuzz[55]表明，模糊性能对变异率非常敏感，没有一个单一的比率适用于所有的PUTs。幸运的是，有几种方法可以设置一个好的突变率。BFF[52]和FOE[53]为每个种子使用了一组指数级的突变比率，并分配了更多的迭代次数，以证明在统计上是有效的比率[111]。symfush利用白盒程序分析来推断每个种子的良好突变率。</p>
<p>5.2.2算术变异 AFL[243]和honggfuzz[213]包含另一个变异操作，它们将选定的字节序列视为整数，并对该值执行简单的算术运算。然后使用计算出的值来替换选定的字节序列。关键的直觉是用一个小数字来限制突变的影响。例如，AFL可以从种子中选择一个4字节的值，并将该值视为整数。然后将种子中的值替换为±r，其中是随机生成的小整数。范围取决于模糊器，通常是用户可配置的。在AFL中，默认范围为0≤r&lt;35。我我右右</p>
<p>5.2.3基于块的变异 有几种基于块的变异方法，其中块是种子的字节序列：（1）将随机生成的块插入种子的随机位置[243]，[6]；（2）从种子[243]，[106]，[213]，[6]中删除随机选择的块；（3）用随机值[243]，[213]，[106]，[6]替换随机选择的块；（4） 随机排列块序列的顺序[106]，[6]；（5）通过附加随机块[213]来调整种子大小；（6）从种子中取出随机块以插入/替换另一种子的随机块[243]，[6]。</p>
<p>5.2.4基于词典的变异 一些模糊程序使用一组预定义的值，这些值具有潜在的重要语义意义。例如，AFL[243]、honggfuzz[213]和LibFuzzer[6]在对整数进行变异时使用0、−1和1等值。Radamsa[106]使用Unicode字符串，GPF[1]使用格式化字符（如%x和%s）来改变字符串[58]。</p>
<h5 id="white-box-fuzzers">White-box Fuzzers</h5>
<p>白盒模糊器也可以分为基于模型的模糊器和无模型的模糊器。例如，传统的动态符号执行[93]、[116]、[30]、[152]、[209]不像基于变异的模糊器那样需要任何模型，但是一些符号执行器[91]、[179]、[129]利用语法等输入模型来指导符号执行器。</p>
<p>尽管许多白盒模糊器（包括Godefroid等人的开创性工作）使用动态符号执行来生成测试用例，但并非所有白盒模糊器都是动态符号执行器。一些模糊程序[229]、[55]、[150]、[189]利用白盒程序分析来查找PUT接受的输入信息，以便与黑盒或灰盒模糊一起使用。在本小节的其余部分，我们简要总结了现有的基于底层测试用例生成算法的白盒模糊技术。请注意，正如我们在§2.2中提到的，我们有意省略动态符号执行器，如[92]、[198]、[63]、[49]、[218]、[54]，因为它们的作者没有明确地将它们的工作描述为模糊器。</p>
<p>5.3.1动态符号执行 在高层次上，经典符号执行[130]、[42]、[112]以符号值作为输入来运行程序，它表示所有可能的值。在执行PUT时，它构建符号表达式，而不是计算具体的值。每当它到达一条条件分支指令时，它就在概念上派生两个符号解释程序，一个用于真分支，另一个用于假分支。对于每条路径，符号解释器为执行过程中遇到的每条分支指令建立一个路径公式（或路径谓词）。如果存在执行所需路径的具体输入，则路径公式是可满足的。通过查询SMT解算器[160]以获得路径公式的解，可以生成具体的输入。动态符号执行是传统符号执行的一种变体，符号执行和具体执行同时进行。因此，我们经常将动态符号执行称为concolic（具体+符号）测试。具体的执行状态可以帮助降低符号约束的复杂性。对动态符号执行的学术文献的广泛回顾超出了它在模糊化中的应用范围。关于动态符号执行的更广泛的处理方法可以在其他来源[20]，[192]中找到。</p>
<p>与灰盒或黑盒方法相比，动态符号执行速度较慢，因为它涉及检测和分析PUT的每条指令。为了应对高昂的成本，一种常见的策略是缩小其使用范围，例如，让用户指定代码中不感兴趣的部分[219]，或者交替使用共同测试和灰盒模糊。Driller[209]和Cyberdyne[95]在DARPA Cyber Grand Challenge上展示了这种技术的有用性。QSYM[240]试图通过实现一个快速的concolic执行引擎来改进灰盒模糊和白盒模糊之间的集成。DigFuzz[249]通过首先估计使用灰盒模糊的每条路径的执行概率，优化灰盒模糊和白盒模糊之间的切换。这使得它可以让它的白盒模糊集中在路径，被认为是最具挑战性的灰盒模糊。</p>
<p>5.3.2导向起毛 一些模糊程序利用静态或动态程序分析技术来增强模糊的有效性。这些技术通常涉及两个阶段的模糊化：（i）一个代价高昂的程序分析，以获得有关PUT的有用信息，以及（ii）在前面分析的指导下生成测试用例。表1第6栏（第6页）对此进行了说明。例如，TaintScope[229]使用细粒度的污点分析来查找“热字节”，即流入关键系统调用或API调用的输入字节。其他安全研究人员也提出了类似的想法[78]，[114]。Dowser[101]在编译过程中执行静态分析，根据启发式方法查找可能包含bug的循环。具体来说，它查找包含指针解引用的循环。然后通过污点分析计算输入字节和候选循环之间的关系。最后，Dowser运行动态符号执行，同时仅使关键字节具有符号性，从而提高了性能。VUzzer[183]和GRT[150]利用静态和动态分析技术从PUT中提取控制流和数据流特征，并使用它们指导输入生成。</p>
<p>Angora[59]和RedQueen[26]通过首先使用昂贵的工具运行每个种子，并使用这些信息生成使用较轻工具运行的输入，从而降低了分析成本。Angora改进了“热字节”的思想，使用污点分析将每个路径约束与相应的字节相关联。然后它执行一个受梯度下降算法启发的搜索，以引导其突变来解决这些约束。另一方面，RedQueen试图通过检测所有比较并查找它们的操作数与给定输入之间的对应关系来检测PUT中如何使用输入。一旦找到匹配项，就可以用它来求解约束。</p>
<p>5.3.3突变 模糊化的一个实际挑战是绕过校验和验证。例如，当PUT在解析输入之前计算输入的校验和时，许多测试用例将被PUT拒绝。为了应对这一挑战，TaintScope[229]提出了一种校验和感知模糊技术，该技术通过污点分析识别校验和测试指令，并对PUT进行修补以绕过校验和验证。一旦他们发现程序崩溃，他们就为输入生成正确的校验和，以生成一个使未修改的PUT崩溃的测试用例。Caballero等人[47]提出了一种称为缝合动态符号执行的技术，这种技术可以在存在校验和的情况下生成测试用例。</p>
<p>T-Fuzz[177]扩展了这一思想，有效地穿透了所有类型的条件分支。它首先构建一组无需修改程序逻辑即可进行转换的分支，称为非关键检查（Non-Critical Checks，NCCs）。当fuzz活动停止发现新路径时，它选择一个NCC，对其进行转换，然后在修改后的PUT上重新启动fuzz活动。最后，T-Fuzz在一个修改后的PUT上用fuzzing发现崩溃后，试图用符号执行在原来的PUT上重建崩溃。</p>
<h4 id="input-evaluation">INPUT EVALUATION</h4>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/fuzz/" rel="tag"><i class="fa fa-tag"></i> fuzz</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/2cb5ce06/" rel="next" title="IS-crypto-非对称加密-RSA的攻击方式">
                <i class="fa fa-chevron-left"></i> IS-crypto-非对称加密-RSA的攻击方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/ed03f22a/" rel="prev" title="CS-BASIC-compiler-principles-属性文法和语法制导翻译">
                CS-BASIC-compiler-principles-属性文法和语法制导翻译 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/apple-touch-icon.png" alt="w4rd3n">
            
              <p class="site-author-name" itemprop="name">w4rd3n</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">173</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/hitworld" title="GitHub &rarr; https://github.com/hitworld" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#surveyreview"><span class="nav-number">1.</span> <span class="nav-text">Survey/Review</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fuzzing-challenges-and-reflections"><span class="nav-number">1.1.</span> <span class="nav-text">Fuzzing: Challenges and Reflections</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#blackbox-fuzzing"><span class="nav-number">1.1.1.</span> <span class="nav-text">Blackbox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#greybox-fuzzing"><span class="nav-number">1.1.2.</span> <span class="nav-text">Greybox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#whitebox-fuzzing"><span class="nav-number">1.1.3.</span> <span class="nav-text">Whitebox fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#other-fuzzing-tools"><span class="nav-number">1.1.4.</span> <span class="nav-text">Other fuzzing tools</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#challenges"><span class="nav-number">1.1.5.</span> <span class="nav-text">Challenges</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#automation"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">Automation</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems"><span class="nav-number">1.1.5.1.1.</span> <span class="nav-text">[C.1] More Software. How can we fuzz efficiently more types of software systems?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities"><span class="nav-number">1.1.5.1.2.</span> <span class="nav-text">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection"><span class="nav-number">1.1.5.1.3.</span> <span class="nav-text">[C.3] More Difficult Bugs. How can we find “deep bugs” for which efficient oracles exist, but which nevertheless evade detection?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns"><span class="nav-number">1.1.5.1.4.</span> <span class="nav-text">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#the-human-component"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">The Human Component</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor"><span class="nav-number">1.1.5.2.1.</span> <span class="nav-text">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools"><span class="nav-number">1.1.5.2.2.</span> <span class="nav-text">[C.6] Usability. How can we improve the usability of fuzzing tools?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fuzzing-theory"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">Fuzzing Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful"><span class="nav-number">1.1.5.3.1.</span> <span class="nav-text">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing"><span class="nav-number">1.1.5.3.2.</span> <span class="nav-text">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#evaluation-and-benchmarks"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">Evaluation and Benchmarks</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing"><span class="nav-number">1.2.</span> <span class="nav-text">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#introduction"><span class="nav-number">1.2.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#background"><span class="nav-number">1.2.2.</span> <span class="nav-text">Background</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#terminology"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Terminology</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#coverage-guide-greybox-fuzzing"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">Coverage-guide Greybox Fuzzing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#directed-greybox-fuzzing"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">Directed Greybox Fuzzing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#difference-between-cgf-and-dgf"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">Difference between CGF and DGF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#application-of-dgf"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">Application of DGF</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#assessment-of-the-state-of-the-art-works"><span class="nav-number">1.2.3.</span> <span class="nav-text">Assessment of the-state-of-the-art Works</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#directed-type"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Directed Type</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#input-optimization"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">Input Optimization</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#seed-prioritization"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">Seed Prioritization</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#distance"><span class="nav-number">1.2.3.3.1.</span> <span class="nav-text">Distance</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#similarity-coverage"><span class="nav-number">1.2.3.3.2.</span> <span class="nav-text">Similarity &amp; Coverage</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#probability"><span class="nav-number">1.2.3.3.3.</span> <span class="nav-text">Probability</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#power-assignment"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">Power Assignment</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mutator-scheduling"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">Mutator Scheduling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#data-flow-analysis"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">Data-flow Analysis</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#challenges-and-solutions"><span class="nav-number">1.2.4.</span> <span class="nav-text">Challenges and Solutions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#binary-code-support"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">Binary Code Support</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#automatic-target-identification"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">Automatic target identification</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#differentiated-weight-metric"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">Differentiated weight metric</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#global-optimum-deviation"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">Global Optimum Deviation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#missing-indirect-calls"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">Missing Indirect Calls</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exploration-exploitation-coordination"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">Exploration-exploitation coordination</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#discussion"><span class="nav-number">1.2.5.</span> <span class="nav-text">Discussion</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#multi-targets-relationship-exploitation"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">Multi-targets Relationship Exploitation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#technology-integration"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">Technology Integration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#implementation-limitation"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">Implementation Limitation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#efficiency-improvement"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">Efficiency Improvement</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#future-research-suggestions"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">Future research suggestions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fuzzing-hack-art-and-science-cacm-2020"><span class="nav-number">1.3.</span> <span class="nav-text">Fuzzing: Hack, Art, and Science (CACM 2020)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#blackbox-fuzzing-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">Blackbox Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#grammar-based-fuzzing"><span class="nav-number">1.3.2.</span> <span class="nav-text">Grammar-Based Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#whitebox-fuzzing-1"><span class="nav-number">1.3.3.</span> <span class="nav-text">Whitebox Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#other-approaches"><span class="nav-number">1.3.4.</span> <span class="nav-text">Other Approaches</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#survey-of-directed-fuzzy-technology"><span class="nav-number">1.4.</span> <span class="nav-text">Survey of Directed Fuzzy Technology</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dse"><span class="nav-number">1.4.1.</span> <span class="nav-text">DSE</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#symbolic-execution-algorithm"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Symbolic Execution Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#静态符号执行"><span class="nav-number">1.4.1.1.1.</span> <span class="nav-text">静态符号执行</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#动态符号执行"><span class="nav-number">1.4.1.1.2.</span> <span class="nav-text">动态符号执行</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#directed-symbolic-execution"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">Directed Symbolic Execution</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-review-of-machine-learning-applications-in-fuzzing"><span class="nav-number">1.5.</span> <span class="nav-text">A Review of Machine Learning Applications in Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#overview-of-fuzzing"><span class="nav-number">1.5.1.</span> <span class="nav-text">OVERVIEW OF FUZZING</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#pre-fuzzing-program-knowledge"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">Pre-Fuzzing: Program Knowledge</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stage-1-generate-inputs"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">Stage 1: Generate Inputs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stage-2-select-inputs"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">Stage 2: Select Inputs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stage-3-monitor-program"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">Stage 3: Monitor Program</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stage-4-evaluate-inputs"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">Stage 4: Evaluate Inputs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#post-fuzzing-interesting-program-states"><span class="nav-number">1.5.1.6.</span> <span class="nav-text">Post-Fuzzing: Interesting Program States</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#applications-of-machine-learning-to-fuzzing"><span class="nav-number">1.5.2.</span> <span class="nav-text">APPLICATIONS OF MACHINE LEARNING TO FUZZING</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#generate-inputs"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">Generate Inputs</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#genetic-algorithms"><span class="nav-number">1.5.2.1.1.</span> <span class="nav-text">Genetic Algorithms</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#deep-learning-and-neural-networks"><span class="nav-number">1.5.2.1.2.</span> <span class="nav-text">Deep Learning and Neural Networks</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#reinforcement-learning"><span class="nav-number">1.5.2.1.3.</span> <span class="nav-text">Reinforcement Learning</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#machine-learning-for-symbolic-execution"><span class="nav-number">1.5.2.1.4.</span> <span class="nav-text">Machine Learning for Symbolic Execution</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#post-fuzzing-interesting-program-states-1"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">Post-Fuzzing: Interesting Program States</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#seed-selection"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">Seed selection</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#input-and-corpus-minimization"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">Input and Corpus Minimization</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-systematic-review-of-fuzzing-based-on-machine-learning-techniques"><span class="nav-number">1.6.</span> <span class="nav-text">A systematic review of fuzzing based on machine learning techniques</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#applying-machine-learning-techniques-for-different-fuzzing-steps"><span class="nav-number">1.6.1.</span> <span class="nav-text">Applying Machine Learning Techniques for Different Fuzzing Steps</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#seed-file-generation"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">Seed file generation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#testcase-generation"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">Testcase generation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#testcase-filter"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">Testcase filter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mutation-operator-selection"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">Mutation operator selection</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fitness-function"><span class="nav-number">1.6.1.5.</span> <span class="nav-text">Fitness function</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exploitability-analysis"><span class="nav-number">1.6.1.6.</span> <span class="nav-text">Exploitability analysis</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#analysis-of-machine-learning-based-fuzzing-model"><span class="nav-number">1.6.2.</span> <span class="nav-text">Analysis of Machine Learning Based Fuzzing Model</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#selection-of-machine-learning-algorithm"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">Selection of machine learning algorithm</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pre-processing-method"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">Pre-processing method</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#datasets"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">Datasets</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#evaluation-metrics"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">Evaluation metrics</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hyperparameters-setting"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">Hyperparameters setting</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#performance-evaluation-of-fuzzing-model-based-on-machine-learning"><span class="nav-number">1.6.3.</span> <span class="nav-text">Performance Evaluation of Fuzzing Model Based on Machine Learning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#future-directions"><span class="nav-number">1.6.4.</span> <span class="nav-text">Future Directions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-art-science-and-engineering-of-fuzzing-a-survey"><span class="nav-number">1.7.</span> <span class="nav-text">The Art, Science, and Engineering of Fuzzing: A Survey</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#systemization-taxonomy-and-test-programs"><span class="nav-number">1.7.1.</span> <span class="nav-text">SYSTEMIZATION, TAXONOMY, AND TEST PROGRAMS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#preprocess"><span class="nav-number">1.7.2.</span> <span class="nav-text">PREPROCESS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#instrumentation"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">Instrumentation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#execution-feedback"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">Execution Feedback</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#thread-scheduling"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">Thread Scheduling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#in-memory-fuzzing"><span class="nav-number">1.7.2.4.</span> <span class="nav-text">In-Memory Fuzzing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#seed-selection-1"><span class="nav-number">1.7.2.5.</span> <span class="nav-text">Seed Selection</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#seed-trimming"><span class="nav-number">1.7.2.6.</span> <span class="nav-text">Seed Trimming</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#preparing-a-driver-application"><span class="nav-number">1.7.2.7.</span> <span class="nav-text">Preparing a Driver Application</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scheduling"><span class="nav-number">1.7.3.</span> <span class="nav-text">SCHEDULING</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#black-box-fcs-algorithms"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">Black-box FCS Algorithms</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#grey-box-fcs-algorithms"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">Grey-box FCS Algorithms</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#input-generation"><span class="nav-number">1.7.4.</span> <span class="nav-text">INPUT GENERATION</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#model-based-generation-based-fuzzers"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">Model-based (Generation-based) Fuzzers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#model-less-mutation-based-fuzzers"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">Model-less (Mutation-based) Fuzzers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#white-box-fuzzers"><span class="nav-number">1.7.4.3.</span> <span class="nav-text">White-box Fuzzers</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#input-evaluation"><span class="nav-number">1.7.5.</span> <span class="nav-text">INPUT EVALUATION</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-gg-circle"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">w4rd3n</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">874k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">13:14</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz",
                'X-LC-Key': "UvlYMzpJKw0Jrw61V5BA5ifU",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  
  

  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>;
  <script>
  //$("body").backstretch("/images/background.jpg");
  </script>
  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>
