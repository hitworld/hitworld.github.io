<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.5.0">


  <link rel="mask-icon" href="/images/safari_pinned_tab.svg?v=6.5.0" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml">







<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Fuzzing: Challenges and Reflections 在线pdf. Blackbox fuzzing Blackbox fuzzing不需要任何关于程序的先验知识，主要有两种的测试用例的生成方式：突变和生成。 前者通过初始语料库(seed inputs)开始变异，通过对随机位置的随机突变来生成新的测试用例。后者则通过提供的输入格式来生成新的测试用例。 Blackbox">
<meta name="keywords" content="fuzz">
<meta property="og:type" content="article">
<meta property="og:title" content="IS-pwn-fuzz-theory-present-situation">
<meta property="og:url" content="https://hitworld.github.io/posts/640b061/index.html">
<meta property="og:site_name" content="w4rd3n">
<meta property="og:description" content="Fuzzing: Challenges and Reflections 在线pdf. Blackbox fuzzing Blackbox fuzzing不需要任何关于程序的先验知识，主要有两种的测试用例的生成方式：突变和生成。 前者通过初始语料库(seed inputs)开始变异，通过对随机位置的随机突变来生成新的测试用例。后者则通过提供的输入格式来生成新的测试用例。 Blackbox">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-02-22-46-04.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-13-09-41.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-09-55.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-40-06.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-16-40-26.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-17-05-33.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-03-17-14-22.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-17-09-36-29.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-17-10-19-48.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-22-13-45-05.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-01-24-10-39-35.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-21-17-00-18.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-20-39-01.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-20-40-35.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-21-17-04.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-21-17-18.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-23-21-19-03.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-02-26-20-55-03.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-03-03-18-00-05.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-03-03-18-07-52.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-03-03-18-30-10.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-03-03-21-47-15.png">
<meta property="og:image" content="https://hitworld.github.io/png/2021-03-03-22-21-41.png">
<meta property="og:updated_time" content="2021-03-07T09:02:37.493Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IS-pwn-fuzz-theory-present-situation">
<meta name="twitter:description" content="Fuzzing: Challenges and Reflections 在线pdf. Blackbox fuzzing Blackbox fuzzing不需要任何关于程序的先验知识，主要有两种的测试用例的生成方式：突变和生成。 前者通过初始语料库(seed inputs)开始变异，通过对随机位置的随机突变来生成新的测试用例。后者则通过提供的输入格式来生成新的测试用例。 Blackbox">
<meta name="twitter:image" content="https://hitworld.github.io/png/2021-01-02-21-17-13.png">






  <link rel="canonical" href="https://hitworld.github.io/posts/640b061/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>IS-pwn-fuzz-theory-present-situation | w4rd3n</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">w4rd3n</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">混吃等死</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>友链</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hitworld.github.io/posts/640b061/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="w4rd3n">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/apple-touch-icon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="w4rd3n">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">IS-pwn-fuzz-theory-present-situation
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-01-01 23:41:38" itemprop="dateCreated datePublished" datetime="2021-01-01T23:41:38+08:00">2021-01-01</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/" itemprop="url" rel="index"><span itemprop="name">IS</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IS/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/posts/640b061/" class="leancloud_visitors" data-flag-title="IS-pwn-fuzz-theory-present-situation">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度：</span>
               
                 <span class="leancloud-visitors-count"></span>
                 <span>℃</span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">77k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:10</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="fuzzing-challenges-and-reflections">Fuzzing: Challenges and Reflections</h2>
<p><a href="https://www.comp.nus.edu.sg/~abhik/pdf/IEEE-SW-Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<h3 id="blackbox-fuzzing">Blackbox fuzzing</h3>
<p>Blackbox fuzzing不需要任何关于程序的先验知识，主要有两种的测试用例的生成方式：突变和生成。</p>
<p>前者通过初始语料库(seed inputs)开始变异，通过对随机位置的随机突变来生成新的测试用例。后者则通过提供的输入格式来生成新的测试用例。</p>
<p>Blackbox fuzzing工具：Peach(http://community.peachfuzzer.com)。</p>
<h3 id="greybox-fuzzing">Greybox fuzzing</h3>
<p>Greybox fuzzing通过在编译时对一些位置（例如代码块交界处）进行插桩来获取运行时状态从而引导fuzzing的进行。</p>
<p>通常一些初始语料库会被提供，并被用于突变产生新的输入，那些增加了代码覆盖率的输入（优质的输入）将被加入语料库，随着覆盖率反馈fuzzer的运行，输入会逐渐深入程序的深处。还可以通过sanitizers注入断言到程序中来判断漏洞的种类。</p>
<p>Greybox fuzzing工具：AFL(https://lcamtuf.coredump.cx/afl/)，LibFuzzer(https://llvm.org/docs/LibFuzzer.html)，Honggfuzz(https://github.com/google/honggfuzz)。</p>
<h3 id="whitebox-fuzzing">Whitebox fuzzing</h3>
<p>基于符号执行的Whitebox fuzzing使用程序分析和约束求解器Satisfiability Modulo Theory(SMT)来系统地枚举感兴趣的程序路径。</p>
<p>Whitebox fuzzing对于给定的种子输入s，计算并改变路径条件而不是改变程序输入，然后将改变后的路径条件发送到约束解算器来产生新的输入。因为Whitebox fuzzing会跟踪到目前为止获取的所有输入的路径状况，所以始终能够生成一个经过新路径的输入。</p>
<p>Whitebox fuzzing工具：KLEE(https://klee.github.io/)，SAGE。</p>
<h3 id="other-fuzzing-tools">Other fuzzing tools</h3>
<p>DeepState(https://github.com/trailofbits/deepstate)：一个单元测试框架。</p>
<p>The Mayhem system. --- Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, David Brumley. 2012. Unleashing Mayhem on Binary Code. IEEE Symposium on Security and Privacy (S&amp;P’12).</p>
<h3 id="challenges">Challenges</h3>
<h4 id="automation">Automation</h4>
<h5 id="c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems">[C.1] More Software. How can we fuzz efficiently more types of software systems?</h5>
<ul>
<li>对于文件解析器和面对对象程序来说，需要的是高度结构化的输入，应该如何生成测试用例？</li>
<li>网络应用程序，机器学习系统，多语言构建的软件和GUI软件的fuzz方式应该是怎么样的？</li>
<li>对于那些有状态的软件，它们对于相同的输入会产生不同的输出，应该如何进行fuzz？</li>
<li>给定一个程序，它的输入域是由语法/协议定义的，那么符号执行工具如何对这种结构化的输入域制定约束?</li>
</ul>
<h5 id="c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</h5>
<p>现在已经可以利用sanitizers类型软件检测复杂的漏洞类型，侧信道漏洞发现已经成为热门。</p>
<h5 id="c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection">[C.3] More Difficult Bugs. How can we find "deep bugs" for which efficient oracles exist, but which nevertheless evade detection?</h5>
<p>结构感知，基于语法的fuzzing，静态分析和符号执行与Greybox fuzzing的结合都是很有前途的方向，针对软件补丁的测试技术对于发现软件补丁引入的错误是很有效的。</p>
<h5 id="c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</h5>
<p>需要实证研究来了解源代码中安全漏洞的性质和分布。</p>
<h4 id="the-human-component">The Human Component</h4>
<h5 id="c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</h5>
<p>Ned Williamson给出了下面这种方法。</p>
<ol type="1">
<li>首先审核代码，以识别可能存在安全漏洞的代码区域。</li>
<li>为设备准备fuzzing，运行fuzzing一段时间，并确定fuzzing过程的遇到的障碍和问题。</li>
<li>手动修补遇到的障碍和问题。</li>
<li>如果fuzzer花费很多时间来测试代码中不重要的部分，对fuzzer进行调整。</li>
<li>一旦发现了一个潜在的漏洞，就要回溯并之前修补的部分，并相应地调整输入再次触发漏洞。</li>
</ol>
<h5 id="c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools">[C.6] Usability. How can we improve the usability of fuzzing tools?</h5>
<p>如何提高模糊工具的可用性？也就是说如何让一个技术人员快速掌握并使用。</p>
<h4 id="fuzzing-theory">Fuzzing Theory</h4>
<h5 id="c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</h5>
<p>除了白盒模糊测试，灰盒模糊测试和黑盒模糊测试都不能保证没有未发现的漏洞。白盒模糊测试受限于时间和可扩展性也无法完全保证，而灰盒模糊测试存在适应性偏差，黑盒模糊测试则存在剩余风险。</p>
<h5 id="c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</h5>
<p>给定程序和时间预算，什么是能在时间预算内找到最多漏洞的模糊技术或技术组合程序的大小和复杂性如何影响可扩展性和性能？计算资源对程序效率的影响程度？</p>
<h4 id="evaluation-and-benchmarks">Evaluation and Benchmarks</h4>
<p>[C.9] How can we evaluate specialized fuzzers?</p>
<p>[C.10] How can we prevent overfitting to a specific benchmark?</p>
<p>[C.11] Are synthetic bugs representative?</p>
<p>[C.12] Are real bugs, which have previously been discovered with other fuzzers, representative?</p>
<p>[C.13] Is coverage a good measure of fuzzer effectiveness?</p>
<p>[C.14] What is a fair choice of time budget?</p>
<p>[C.15] How do we evaluate techniques instead of implementations?</p>
<h2 id="sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv20_SoK.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>大多数greybox fuzzing工具是由代码覆盖率引导的，因为代码覆盖率和bug覆盖率是正相关的，但其实大部分代码是不存在bug的。</p>
<p>与盲目扩展路径覆盖范围的基于代码覆盖率的fuzzing不同，定向greybox fuzzing将其大部分时间预算花在到达特定的目标站点上，例如，容易出bug的区域。</p>
<p>因此，定向灰盒模糊测试特别适用于补丁测试、1 day bug复现以及与其他工具集成等场景。</p>
<h3 id="introduction">Introduction</h3>
<p>传统的定向fuzzing是基于符号执行，但是这种方法会受到符号执行一些问题而限制，例如：复杂的约束求解和路径爆炸等问题。</p>
<p>通过在测试程序(PUT)中指定一组目标站点，并利用编译时插桩获取运行时信息来计算输入种子和目标之间的距离，通过给更接近目标的种子更多的变异机会来将fuzzer导向目标站点。</p>
<p>定向greybox fuzzing将目标站点的可达性问题转化为一个优化问题，以最小化生成的输入种子到目标站点的距离为标准来进行语料库的筛选。</p>
<p>定向greybox fuzzing并未止步于依赖于手动标记的目标站点和基于距离的度量来确定输入种子优先级的主要模式。为了在不同的场景下提高软件测试，已经实现了大量的变体。</p>
<h3 id="background">Background</h3>
<p>CGF(覆盖率导向greybox fuzzing)和DGF(定向greybox fuzzing)的背景知识。</p>
<h4 id="terminology">Terminology</h4>
<p>该文献中使用的术语及其解释。</p>
<ul>
<li>Fuzzing. In this paper, fuzzing refers to traditional blackbox fuzzing and greybox fuzzing. We exclude whitebox fuzzing as it depends on constraint solving of symbolic execution to generate inputs, which is quite different from evolutionary fuzzers based on mutation.</li>
<li>Testcase. A testcase is an input to the PUT, which is generated by randomly mutating a seed.</li>
<li>Seed. A seed is a testcase that is favored (trigger a new path or close to the target) and retained for the mutation to generate new testcases in the next fuzzing iteration.</li>
<li>Seed prioritization. Seed prioritization means to evaluate and sort the seeds according to its performance. Prioritized seeds would be given more fuzzing chances.</li>
<li>Power schedule Power schedule means to determine the number of fuzzing tests to be applied on a seed (i.e., energy).</li>
<li>Fuzzing cycle All seeds in the seed queue have been fuzzed at least once.</li>
</ul>
<h4 id="coverage-guide-greybox-fuzzing">Coverage-guide Greybox Fuzzing</h4>
<p>下面用ALF来介绍典型的CGF技术。</p>
<p>AFL使用上下文不敏感的边缘覆盖替代一般的基本块覆盖。AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器收集这些随机数获知跳转信息，统计边缘覆盖。</p>
<p>边缘覆盖比基本块覆盖更精细和敏感，因为它考虑了基本块之间的过渡。边缘覆盖也比路径覆盖更具可扩展性，因为它避免了路径爆炸。</p>
<p>AFL偏爱触发新路径的输入种子，AFL通过一个位图记录每个种子的优先级，对于优先级高的种子，AFL给予更多的模糊机会，也就是后面说的能量。</p>
<p>AFL有两类变异策略：确定性策略和非确定性策略。</p>
<p>AFL首先采用确定性策略，利用基于位翻转、算术、令牌、字典和特殊值的变异器依次变异不同粒度的种子。</p>
<p>在进行确定性策略之后，AFL就会进行非确定性策略，包括havoc阶段和拼接阶段。</p>
<p>在havoc阶段，AFL通过从确定性策略中随机选择一系列变异算子对种子进行变异，并将其应用于种子文件中的随机位置。因此，生成的testcase与原始种子有很大的不同。</p>
<p>然后，AFL使用剪接策略从种子队列中随机选择另一个种子，并将其与当前种子重新组合以生成新的种子。最后，对新种子重新实施破坏策略。</p>
<p>AFL通过能量调度来分配一轮模糊测试的时间。</p>
<p>在确定性阶段，变异策略依次参与，而在非确定性阶段，AFL可以给种子分配能量来决定每个种子的模糊机会。</p>
<p>能量是根据每个种子的性能得分来分配的，而性能得分基于覆盖率（优先考虑覆盖更多路径的输入）、执行情况时间（对执行速度更快的输入进行优先级排序）和发现时间（对稍后发现的输入进行优先级排序）来计算出来的。</p>
<p>特别的，如果测试用例执行一条新路径，AFL将加倍分配的能量。</p>
<h4 id="directed-greybox-fuzzing">Directed Greybox Fuzzing</h4>
<p><img src="/png/2021-01-02-21-17-13.png"></p>
<p>下面以用AFLGo为代表来说明DGF的工作原理。</p>
<p>AFLGo遵循CGF的一般原理和体系结构。不同的是，除了获取执行路径和边缘覆盖信息外，AFLGo还计算输入与目标站点之间的距离。该距离基于输入种子的执行跟踪权值上的基本块到目标基本块的平均值来计算，其中权值由程序的调用图和控制流图中的边数来确定。</p>
<p>B¨ohme et al.将灰盒模糊化过程视为一个马尔可夫链，所以可以使用功率调度进行有效的引导。利用模拟退火策略，逐渐将更多的能量分配给距离目标较近的种子，从而将可达性问题转化为优化问题，以最小化生成的种子到目标站点的距离为目的。</p>
<p>AFLGo将整个DGF分为两个阶段，探索阶段和开发阶段。</p>
<p>勘探阶段的目的是尽可能多地揭示路径，像许多覆盖率导向模糊程序一样，这个阶段的DGF偏爱触发新路径并对其进行优先级排序的种子，因为新的路径增加了通向目标的可能性。</p>
<p>开发阶段的目的是最小化生成的种子到目标的距离。在这一阶段，B¨ohme et al.对更接近目标的种子进行优先排序，并为它们分配更多的能量。</p>
<p>勘探开发的权衡在于如何协调这两个阶段。B¨ohme et al.使用固定的勘探和开发阶段划分。例如，对于24小时测试，AFLGo使用20小时进行勘探，然后使用4小时进行开发。</p>
<h4 id="difference-between-cgf-and-dgf">Difference between CGF and DGF</h4>
<p>CGF和DGF技术的不同点。</p>
<ol type="1">
<li>种子优先级。CGF的目标是最大化路径覆盖，所以会偏爱触发新路径的种子。而DGF的目标是到达代码中的特定位置，所以它偏爱更接近目标的种子。</li>
<li>探索目标。CGF以一种无方向的方式扩展代码覆盖范围，在不包含bug的代码区域浪费能量。DGF则预先对一组目标站点进行人工或自动标记，以指导整个模糊测试过程，从而节省能量。目标的选择会影响DGF的性能。</li>
<li>勘探开发。对于基于覆盖率的灰盒模糊测试，整个过程本质上是一个探索-开发问题的折衷，其中探索意味着尝试尽可能多的种子，而开发意味着尽可能多地变异某个种子。对于DGF来说，勘探开发问题在于勘探阶段与开发阶段的协调。在探索阶段，DGF试图发现尽可能多的种子，并从中获取更多的新路径，以增加到达目标的可能性。同时，开发阶段给了一些种子更多的变异机会，这些种子更有可能产生到达目标的输入。</li>
</ol>
<h4 id="application-of-dgf">Application of DGF</h4>
<p>DGF常见的应用方向。</p>
<ul>
<li>补丁测试。DGF可以用来测试补丁是否完整和兼容，修补程序在以下情况下是不完整的：错误可能由多个输入触发；补丁可能会引入新的bug。因此，针对有问题的更改或补丁的DGF有更高的发现bug的机会。</li>
<li>bug复现。DGF可以用于复现没有crash输入的已知bug。例如，出于隐私等考虑，某些应用程序（如视频播放器）不允许发送输入文件，这种情况下内部开发团队可以使用DGF通过stack trace中的方法调用和一些环境参数来再现崩溃。在给定错误报告信息的情况下，DGF也可以生成已披露漏洞的PoC。</li>
<li>人机合一（意译法）。DGF可以配合分析人员的知识或辅助技术来促进fuzz。通过分析人员的知识和经验可以帮助DGF识别关键的系统调用或security-sensitive的程序站点（例如，内存分配函数malloc、字符串操作函数strcpy），基于以前的经验来引导模糊化到容易出错的部分。如符号执行和taint analysis之类的辅助技术可以用来解决测试中的障碍，而静态分析和基于机器学习的检测方法的初步结果可以用作DGF的潜在易受攻击目标。</li>
<li>测试资源有限。当测试资源有限时，例如对物联网设备进行fuzz，识别关键代码区域来指导fuzz比无方向地fuzz整个程序更有效。</li>
<li>特定类型bug检测。DGF可以应用于基于定制指标的特定bug检测。例如，在内存使用状况的指导下查找内存泄漏bug，在typestate violation（应该是指违反了特定的使用范例，例如free后并未清除指针）的指导下查找UAF漏洞。</li>
</ul>
<h3 id="assessment-of-the-state-of-the-art-works">Assessment of the-state-of-the-art Works</h3>
<p><img src="/png/2021-01-02-22-46-04.png"></p>
<p>为了进行全面的评估，论文根据DGF的特征提取了15个度量。同时进一步将度量分为三类，包括基本信息、实现细节和优化方法。</p>
<p>在下文中，论文集中讨论与DGF关键技术相关的特性，包括定向类型、输入优化、种子优先级、能量分配、变异调度和数据流分析。</p>
<p>该论文主要研究DGF（表1中记为G），不过在某些工作中采用了符号执行来增强有向性，形成了有向混合模糊测试（表1中记为H）。</p>
<h4 id="directed-type">Directed Type</h4>
<p>对于定向目标的类型，DGF最初通过在PUT中手动标记的目标站点来进行定向，如AFLGo和Hawkeye。</p>
<p>后来发现目标之间的关系对于bug的触发也是有影响的，所以改变单独的目标站点为目标序列。</p>
<p>为了触发UAF漏洞，必须按特定顺序执行一系列操作：分配内存、使用内存和释放内存。所以UAFuzz和UAFL利用目标序列而不是目标站点来发现UAF漏洞。LOLLY还使用目标语句序列来引导DGF触发由多个语句的顺序执行导致的bug。Berry使用符号执行来增强LOLLY沿着复杂路径到达深层目标时的方向性。</p>
<p>除了目标序列之外，研究人员还提出了各种机制来指导DGF。</p>
<p>Memlock通过监控内存使用情况来发现内存泄漏漏洞。V-Fuzz以易受攻击概率为指导，通过深度学习模型预测易受攻击概率，将DGF引导到潜在易受攻击的代码区域。SemFuzz和DrillerGo利用从CVE描述和git日志中检索到的语义信息来指导DGF并生成PoC报告。1DVUL通过那些直接改变原始数据流或控制流的补丁指导以发现1-day漏洞。SAVIOR和Parmasan是由来自sanitizers（Sanitizers是谷歌发起的开源工具集）的信息指导的。IJON利用来自分析人员的注释来指导DGF克服重要的障碍。RVFUZZER受control instability的指导，在机器人车辆中发现输入验证漏洞。PFUZZER明确地指向输入解析器，从而更好地覆盖代码区域。</p>
<p>DGF已经从到达目标站点发展到发现复杂的深层的行为漏洞。</p>
<h4 id="input-optimization">Input Optimization</h4>
<p>优化输入的生成策略对于提高DGF的性能有很大的帮助。</p>
<p>seedfuzz致力于改进初始种子的生成和选择，以达到定向模糊的目的。它利用动态污点分析来识别种子当中那些会影响security-sensitive程序位置的值的字节，通过改变这些字节来生成新的输入提供给目标程序以触发错误。</p>
<p>FuzzGuard使用了一种基于深度学习的方法，在fuzz之前过滤掉无法达到目标站点的输入。它将程序的输入看作一种模式，并使用大量的在之前的执行中能够到达目标代码的输入来训练模型，然后利用该模型预测新生成的输入的可达性，从而节省了实际执行所需的时间。</p>
<p>TOFU利用protobuf规范形式的程序输入的已知结构来生成有效的输入。通过将模糊处理分为语法模糊处理和语义模糊处理，TOFU扩大了输入空间，以包含命令行标志。然而，即使用户熟悉输入语言，实现输入语言语法通常也需要一到两天的时间。</p>
<p>SemFuzz利用从CVE描述和git日志中检索到的信息（系统调用和参数）来构建设计好的种子输入，以增加命中易受攻击函数的概率。</p>
<p>TIFF和ProFuzzer通过识别输入类型辅助变异，从而最大化触发内存溢出漏洞的可能性。</p>
<p>PFUZZER是一种语法驱动的方法，专门针对输入解析器，在生成不合理输入的情况下最大化输入空间覆盖率。</p>
<h4 id="seed-prioritization">Seed Prioritization</h4>
<p>DGF文献中广泛采用的三个种子优先级的度量标准：距离、覆盖率和概率。</p>
<h5 id="distance">Distance</h5>
<p>作为一项开创性的工作，AFLGo在编译时对源代码进行检测，并通过PUT的调用图和控制流图中的边数计算到目标基本块的距离。然后在运行时聚合每个基本块的距离值，以计算平均值来评估种子。许多后续版本继承了这种基于距离的方案，如Parmasan和1DVUL。</p>
<p>TOFU的距离度量定义为达到目标所需的正确分支决策数。</p>
<p>RDFuzz将距离和频率结合起来，对种子进行优先级排序。通过代码的执行频率将代码区分为高频区和低频区。输入分为高/低距离和高/低频四种类型。在探测阶段，优先选择低频种子来提高覆盖率；在开发阶段，优先选择低距离种子来靠近目标区域。</p>
<p>UAFuzz是一个定制的DGF程序，用于复杂的UAF漏洞。与基于控制流图的距离不同，它使用了通向目标函数的调用链的距离度量，目标函数一般包含分配函数和释放函数。</p>
<p>W¨ustholz et al使用online static lookahead analysis来找到并避免那些所有后缀路径都无法到达目标站点的路径前缀。通过强调可能到达目标站点的路径前缀，DGF的能量调度可以更合理地分配其资源。</p>
<p>基于距离的方法的一个缺点是它只关注最短距离。当有多条路径到达同一目标时，可能会忽略较长的选项，从而导致偏差。</p>
<h5 id="similarity-coverage">Similarity &amp; Coverage</h5>
<p>相似性表示某些目标形式的覆盖范围，例如函数、位置和bug traces。当有许多目标时，这个指标特别适用。</p>
<p>Hawkeye利用对PUT的静态分析，将基本块跟踪距离与覆盖函数相似性结合起来，用于种子优先级排序和能量调度。LOLLY使用指定的程序语句序列作为目标，并将种子覆盖目标序列的能力（即序列覆盖率）作为评估种子的度量。UAFL使用操作序列覆盖率作为反馈，引导测试用例生成逐步覆盖触发UAF漏洞可能使用的操作序列。</p>
<p>UAFuzz还使用序列感知目标相似性度量来度量种子执行和目标UAF bug traces之间的相似性。序列感知目标相似性度量具体评估了种子在运行时执行trace所覆盖的目标的数量和顺序。</p>
<p>Berry考虑了目标序列中节点的覆盖率及其执行上下文。它用必要的节点来增强目标序列，即到达所有路径的目标序列中的节点所需的基本块。除了分支覆盖之外，Berry还考虑了目标执行trace和增强目标序列之间的相似性，从而对种子进行优先级排序。</p>
<p>SAVIOR根据UBSan预测的标签覆盖率，优先考虑具有更高触发漏洞潜力的种子。TortoiseFuzz基于内存损坏漏洞与敏感内存操作密切相关的事实，区分了更可能注定易受攻击的边缘。它通过覆盖率和安全影响因子的组合对输入进行优先级排序，这由函数、循环和基本块的三种不同粒度类型的内存操作表示。</p>
<h5 id="probability">Probability</h5>
<p>概率是另一个有用的指标，它通过达到目标的可能性来确定种子的优先级。通常将种子优先级度量与目标识别度量相结合，以将模糊化引向潜在的易受攻击的位置。</p>
<p>V-Fuzz和SUZZER基于一个通过深度学习的模型得到函数的脆弱概率，并给函数中的每个基本块一个静态分数。然后对于每个输入计算其执行路径上所有基本块的静态得分之和，并对得分较高的输入进行优先级排序。</p>
<p>SAVIOR利用UBSan为代码区域添加可能存在bug的标签。TAFL加强了对包含漏洞的概率较高的区域的模糊化，该模糊化基于静态语义度量，包括敏感、复杂、深入和罕见的区域。</p>
<h4 id="power-assignment">Power Assignment</h4>
<p>AFLGo使用一种基于模拟退火的能量调度，逐渐将更多的能量分配给距离目标站点较近的种子，同时减少距离较远的种子的能量。</p>
<p>传统的随机游走调度总是接受更好的解从而可能陷入局部最优，而模拟退火则以一定的概率接受不如当前最优解的解，因此有可能跳出局部最优解而达到全局最优解。</p>
<p>Hawkeye也采用了模拟退火，但增加了优先级。因此，更接近目标的种子首先发生变异，这进一步提高了方向性。LOLLY采用了一种优化的基于模拟退火的能量调度来实现最大的序列覆盖。在温度阈值的控制下，探测阶段的会随机地对所提供的种子进行变异以产生许多新的输入；而在开发阶段，它会从具有更高序列覆盖率的种子中产生更多的新输入。</p>
<h4 id="mutator-scheduling">Mutator Scheduling</h4>
<p>一些模糊程序通过优化变异策略来辅助DGF，这主要是通过将变异分类成不同的粒度（类型）来实现的。</p>
<p>Hawkeye利用了一种自适应变异策略，将变异分为粗粒度和细粒度。粗粒度的变异在突变期间会更改大量字节，而细粒度的变异只涉及少量字节级的修改、插入或删除。当一个种子接近目标函数时，粗粒度变异的机会就变少。一旦种子达到目标函数，进行细粒度变异的次数增加，而粗粒度变异的次数减少。同样，V-Fuzz将变异策略分为轻微变异和严重变异，并根据实际模糊测试的状态通过阈值动态调整变异策略。</p>
<p>SemFuzz执行类似的分类，只是它关注于系统调用。SemFuzz利用对输入的粗变异来找到一个系统调用序列，该序列可以将执行移向易受攻击的函数。之后，它将切换到syscall序列上的细粒度变异，以监视关键变量。</p>
<p>TAFL还采用了基于经验观察的粒度感知的变异调度，即：粗粒度变异在路径增长方面优于细粒度变异；组合多个变异的性能优于使用单一类型的变异。</p>
<p>ProFuzzer根据输入类型探测识别的输入字段类型，如何进行不同的变异策略。</p>
<h4 id="data-flow-analysis">Data-flow Analysis</h4>
<p>数据流分析（如污点分析）可以反映变异对生成输入的影响，有助于优化变异策略和输入生成。</p>
<p>RDFuzz利用一种干扰-检查方法来识别和保护对输入的距离敏感的内容，这对保持距离至关重要（该句不太理解，可能翻译错误）。在变异过程中防止这些内容有助于更有效地接近目标代码位置。</p>
<p>UAFL采用信息流分析来识别条件语句中的输入和程序变量之间的关系，并为那些信息流更多的输入字节赋予更高的变异可能性，因为它们更可能改变目标语句的值。</p>
<p>SemFuzz通过反向数据流分析跟踪关键变量所依赖的核函数参数。SeedFuzz利用动态污点分析来识别种子中可能影响security-sensitive程序位置的值的字节。PFUZZER使用输入的动态污点分析，将处理的每个值与其派生的输入字符相关联。TIFF通过内存中的数据结构识别和动态污点分析来推断输入类型，这增加了基于类型的变异触发内存损坏漏洞的概率。</p>
<p>当然，数据流分析通常会增加运行时开销。</p>
<h3 id="challenges-and-solutions">Challenges and Solutions</h3>
<p>DGF面临的挑战及可能的解决方案。</p>
<h4 id="binary-code-support">Binary Code Support</h4>
<p>大多数已知的DGF都是在AFL的基础上实现的，并继承其编译时插桩方案来反馈执行状态或计算基于距离的度量。这种方案不适合没有测试源代码的场景，例如商用闭源COTS软件或部分依赖第三方库的关键程序。</p>
<p>二进制级别的DGF存在以下问题。</p>
<ol type="1">
<li>运行时开销很大。最简单的方法就是利用一个完整的系统仿真器。例如，UAFuzz处理二进制代码，并通过QEMU提取执行路径。然而，基于仿真器的工具通常效率较低。</li>
<li>目标信息收集困难。对于二进制代码中的PUT，只能从bug trace中提取目标信息。</li>
<li>标靶困难。由于二进制代码很难读取，必须对其进行反汇编，如使用idapro，并用虚拟地址标记目标。</li>
</ol>
<p>一个可行解决方案是通过硬件辅助减轻性能限制。Intel PT是最新Intel处理器中的一种轻量级硬件功能，可以捕获有关程序执行的trace数据，同时Intel PT可以动态跟踪程序执行，开销可以忽略不计。安全分析人员通过Intel PT捕获的数据包trace以及PUT的二进制文件可以重建PUT的执行路径。平均而言，基于PT的方法比QEMU-AFL快4.3倍。</p>
<p>以前的硬件功能（如Intel Last Branch Record）也可以执行程序跟踪，但其输出存储在特殊寄存器中，而不是主内存中，这限制了跟踪大小。CGF与PT的结合也有尝试，比如kAFL、PTfuzz、Ptrix和Honggfuzz。然而，PT从未被用于DGF。</p>
<p>对于二进制代码级别的目标识别和标记问题，可以利用基于机器学习的方法或启发式二进制差分方法来自动识别易受攻击的代码。</p>
<h4 id="automatic-target-identification">Automatic target identification</h4>
<p>大多数已知的DGF都要求分析人员手动标记目标（如AFLGo、Hawkeye），这依赖对于目标站点的先验知识。</p>
<p>为了实现目标的自动识别，可以使用静态分析工具在PUT中找到潜在的危险区域。然而，这些工具通常特定于所使用的bug类型和编程语言。</p>
<p>另一个方向是利用compiler sanitizer passes，比如UBSan，来注释PUT中的潜在bug。</p>
<p>对于二进制代码，1DVUL通过基于Bindiff的二进制级比较，提取不同的函数及其不同的基本块，识别与补丁相关的目标分支。基于深度学习的方法在预测脆弱性和使用预测信息指导模糊化方面也是有效的。最后，攻击面识别组件也可用于自动识别DGF的易受攻击目标。</p>
<h4 id="differentiated-weight-metric">Differentiated weight metric</h4>
<p><img src="/png/2021-01-03-13-09-41.png"></p>
<p>在大多数最先进的DGF中，种子的优先级是基于等权度量的。以广泛应用的距离度量为例，通过种子与目标之间的距离来度量到达目标的能力。特别是距离由多条边表示，即基本块之间的过渡。然而，这样的测量忽略了一个事实，即不同的分支跳跃有不同的概率。</p>
<p>图1显示了一个控制流图片段，其中输入x是一个从0到9的整数。很容易知道从节点A跳到节点C的概率是0.1，从节点A跳到节点B的概率是0.9。如果据根据分支跳数计算距离，则A→C的距离比A→G短，这是因为A→C只有一个跳，而A→G有三个跳。但是如果考虑分支跳跃概率，则A→C的概率为0.1，而A→G的概率为0.9×0.7×0.5≈0.3，这比A→C更短。因此，在计算距离时考虑权重差异更为合理。其他种子优先级度量，如相似性和概率，应该遵循相同的原理。</p>
<p>一种可能的解决方案是考虑分支跳转概率。当基于概率评估目标的可达性时，每个种子基于该种子生成到达目标的输入的可能性，即将该种子的当前执行路径转换为穿过该目标的目标路径的概率来优先排序。由于执行路径可以看作是连续分支的马尔可夫链，因此可以通过收集路径中所有分支的概率来计算路径的概率。</p>
<p>基于统计模拟方法，可以通过统计计算分支概率来估计分支概率。平稳分布的密度形式上描述了DGF经过一定次数的迭代后执行某条路径的可能性。基于统计模拟方法方法需要两个条件：1）抽样应该是随机的；2）抽样规模应该很大。</p>
<p>模糊过程本质上满足了这些要求。由随机变异的测试用例驱动的执行路径可以看作是满足第一个需求的随机样本。模糊程序生成的测试用例的高吞吐量使得估计具有统计意义，满足第二个需求。因此，将模糊化作为一个抽样过程，可以以一种轻量级的方式统计估计分支跳跃概率。</p>
<p>这种基于概率的方法的一个可能缺点是潜在的运行时开销。统计跳跃计数和概率计算都引入了额外的计算。减少性能降低的一个简单方法是间隔采样。</p>
<p>另一个可能的解决方案是加速计算，这涉及到元数据的存储和访问方式。</p>
<p>传统上，基于图的数据存储在邻接表中。然而，由于基于概率的方法经常更新跳跃统计信息，并且可达性判断也需要快速的边缘跟踪，因此邻接表在访问数据时效率较低，不适合使用。另一种选择是邻接矩阵，它支持快速数据访问。然而，由于一个跳转通常有两个分支，矩阵将是巨大的，但数据分布相对稀疏，这大大增加了空间消耗。</p>
<p>因此，利用基于概率的方法的先决条件是设计一个平衡时间复杂性和空间复杂性的定制数据结构。</p>
<h4 id="global-optimum-deviation">Global Optimum Deviation</h4>
<p><img src="/png/2021-01-03-16-09-55.png"></p>
<p>当DGF测试中存在多个目标时，如何协调这些目标是另一个挑战。</p>
<p>一种策略是基于Dijkstras算法来寻找全局最短距离，AFLGo就是这样做的。然而，这样的全局最优可能会错过最接近某个目标的局部最优种子，从而导致偏差。</p>
<p>图2显示了一个控制流图片段，其中节点K和O是目标节点。这里测试了三个种子，路径分别为：A→B→D→G→K，A→C→E→I→M→N→O，A→C→E→H→L。论文作者基于B¨ohme et al.定义的距离公式计算了两个目标的三条路径中每个节点之间的harmonic distances，并在每个节点的侧面标记它们。</p>
<p>路径A→C→E→H→L的种子应该是三个之中距离最小的，但这是不合理的，因为路径A→B→D→G→K穿过目标节点K，路径A→C→E→I→M→N→O穿过目标节点O，但路径A→C→E→H→L没有到达任何目标。直觉上，路径A→C→E→H→L远离目标，不应优先考虑。因此，当存在多个目标时，寻找全局最短距离存在偏差，影响模糊化的方向性。</p>
<p>这种偏差背后的原因是基于距离的种子测量只关注最短路径。当有多条路径到达同一目标时，可能会忽略较长的路径，从而导致结果出现偏差。</p>
<p>图2中，如果考虑路径A→C→K和路径A→C→E→H→O，会发现d(ACK) &lt; d(ACEIMNO) &lt; d(ACEIMNL)。这是因为路径A→C→K和路径A→C→E→H→O分别是到目标K和O的最短路径。最短路径总是优先考虑的。为了避免在评估种子时产生偏差，应该考虑到所有可能到达目标的路径。</p>
<p>为了实现这一目标，Hawkeye使用了基于轻量级静态分析的相邻函数距离扩充，该分析基于生成的调用图考虑（立即）调用关系的模式。</p>
<p>多目标协调的另一种策略是目标分离。对于每个种子，仅选择所有目标之间的最小距离作为种子的距离，并基于该最小距离对种子进行优先级排序。这样可以避免局部最优偏差，但可能会减慢达到特定目标的速度。</p>
<h4 id="missing-indirect-calls">Missing Indirect Calls</h4>
<p>无论采用何种度量，DGF都依赖于控制流分析来确定种子的优先级。以基于距离的度量为例，通常基于控制流图和调用图来度量距离。</p>
<p>然而，由于LLVM的调用流和通过LLVM的间接调用图的构造是不完整的。在实际程序中，间接函数调用非常普遍。例如，在libpng中，44.11%的函数调用是间接函数调用。对于静态分析方法，不能直接从源代码或二进制指令中观察到间接函数调用站点，例如在C中作为参数传递函数指针或使用函数对象和指针。对于二进制代码，间接调用的目标地址取决于寄存器中的值，这些值也无法获得。</p>
<p>此外，为了构造一个过程间控制流图需要将基于LLVM的IR生成的每个函数的控制流图与整个程序的调用图结合起来。因此，基于调用图和控制流图的距离测量在没有间接调用的情况下是不准确的，影响了DGF到达目标的能力。</p>
<p>对于静态方法，解决这个问题的一个简单方法是对函数指针执行Andersen的points to analysis。但是，这种基于包含的上下文不敏感指针分析会导致间接调用具有许多传出边缘，可能会产生给定输入不可能的执行路径。</p>
<p>TOFU使用函数类型签名来近似每个间接调用站点的可调用集。但是，它不考虑类型转换，这可能会允许调用不同类型的函数，从而引入不精确性。</p>
<p>对于动态情况，ParmeSan在实际执行过程中识别间接调用的缺失边，并逐渐补全调用图。最后，在执行足够数量的模糊测试之后，图趋于完整。然而，这样的解决方案不可避免地增加了运行时开销，并且不能保证完整性。</p>
<h4 id="exploration-exploitation-coordination">Exploration-exploitation coordination</h4>
<p>DGF面临的最后一个挑战是如何协调勘探与开发之间的权衡。</p>
<p>一方面，多勘探可以为开发提供充分的信息，另一方面，勘探过度会占用大量资源，延缓开发。很难确定勘探阶段和开发阶段之间的界限。</p>
<p>AFLGo采用勘探阶段和开发阶段的固定分割。测试前，时间预算在测试配置中预先设置。这样的方案是初步的，因为分离点是经验性的和不灵活的。由于每个PUT具有不同的字符，因此这种固定拆分的适应性较差。一旦勘探阶段转入开发阶段，即使由于路径不足导致方向性能较差，也不会有回头路。</p>
<p><img src="/png/2021-01-03-16-40-06.png"></p>
<p>论文作者对libxml使用AFLGo进行了一个简单的实验。使用AFLGo的-z参数为勘探阶段设置不同的时间预算，并比较其性能。如图3所示，水平坐标表示测试的持续时间，垂直坐标表示所有生成的输入到目标代码区域的最小距离。实验持续24小时，AFLGo-1意味着1小时的探索加上23小时的开发，其余的依此类推。从结果可以看出，勘探阶段和开发阶段的分配会影响DGF的性能，而最佳性能（AFLGo-16）需要两个阶段都有足够的时间。然而，很难得到一个最佳的分配。</p>
<p>RDFuzz统计执行期间的分支级统计信息，以将代码区域分为高频区域和低频区域。根据频率和距离两个评价准则，将输入信号分为高、低距离和高、低频两类。低频输入有助于提高勘探所需的覆盖率；低距离输入有助于实现勘探所需的目标码区。最后，采用一个相互交织的测试时间表，交替进行勘探和开发。</p>
<p>解决这一难题的另一个可能方法是利用动态策略来协调勘探阶段和开发阶段的划分，该策略可以在勘探阶段和开发阶段之间自适应切换。</p>
<p>为了实现这一方案，论文作者建议将模糊阶段的分配转化为种子的分配，即将种子分为两组：覆盖种子用于探索和定向种子用于开发。每组种子的数目表示在相应阶段所消耗的能量。这两个阶段的协调是通过控制每组种子的数量来实现的。使用一个称为dp的变量来表示所有种子中定向种子的百分比，这也表示花费在开发阶段上的能量的百分比。在种子评价过程中，对覆盖种子进行标记，在每个模糊周期后，对有向种子进行标记，并通过dp进行调整。</p>
<p><img src="/png/2021-01-03-16-40-26.png"></p>
<p>使用算法2来说明这个设计。具有自适应分裂的DGF应该从探索阶段（dp=0）开始，该阶段侧重于发现新路径。然后，随着已知路径的增加，逐渐增加dp来调用开发阶段，在开发阶段，基于dp选择高值的有向种子并对其进行优先级排序以增强可达性。</p>
<p>当模糊测试程序在很长一段时间内找不到新的路径时，勘探阶段已经到了瓶颈，应该通过大幅度提高dp来迅速进入开发阶段。同样，也需要偶尔从开采阶段回到勘探阶段。例如，当模糊测试程序已经处于开采阶段，dp非常大（例如，dp&gt;0.9），但仍然无法在许多模糊循环中更接近目标，就应该大幅降低dp以返回勘探阶段。这是因为现有的定向种子性能较差，应该扩大路径覆盖范围以发现更多潜在的定向种子。</p>
<p>在该方案中，两个阶段可以共存，以获得最佳的性能和自适应性。值得注意的是，算法中的阈值是用来说明原理的。应该基于启发式算法产生合理的阈值。</p>
<h3 id="discussion">Discussion</h3>
<p>DGF技术中的研究热点。</p>
<h4 id="multi-targets-relationship-exploitation">Multi-targets Relationship Exploitation</h4>
<p>虽然大多数的有向模糊测试程序支持多目标，但只有少部分关注目标之间的关系。当存在多个目标时，可以通过目标之间的关系来优化DGF。如果它们是不相关的，可以给它们分配权重来区分重要性或概率。否则，可以提取隐藏关系并加以利用，以提高方向性。</p>
<p>UAFL在利用目标序列寻找UAF漏洞时，考虑了操作序列的顺序。这是因为，要触发这种行为复杂的漏洞，不仅需要覆盖单个边缘，还需要以特定顺序遍历一些长的边缘序列。这种方法可以扩展到检测语义错误，比如double-free和API误用。Berry使用所有路径的执行上下文（即到达目标序列中的节点所需的必要节点）增强目标序列。</p>
<p>在这里进一步提出以下关系。</p>
<ol type="1">
<li>执行空间关系。目标在执行树上的相对位置。假设有两个目标，可以考虑它们之间的关系，包括它们是否在同一个执行路径上，它们共享多少个执行路径，以及哪一个是另一个的前继节点还是后继节点。</li>
<li>状态空间关系。对于涉及程序状态的目标，可以考虑它们在状态空间中的位置。例如，两个目标是否共享相同的状态，以及两个状态是否可以在状态转换映射上相互转换。</li>
<li>交错关系。对于多线程程序，线程调度会影响不同线程中事件的执行顺序。在同一线程交织下可以达到的目标在交织空间中应该是一个密切的关系。</li>
</ol>
<p>基于上述讨论，建议在选择目标和确定目标优先级时考虑目标之间的关系。具有较高可达性的目标应该有更高的优先级。关系更密切的目标应该用更少的测试运行来覆盖。</p>
<h4 id="technology-integration">Technology Integration</h4>
<p><img src="/png/2021-01-03-17-05-33.png"></p>
<p>DGF依赖于随机变异来产生测试输入，所以它很难到达深层目标，并且在复杂路径上触发深层缺陷的效果较差。为了增强到达角落案例和片状缺陷的方向性，采用了各种程序分析技术，如静态分析、控制流分析、数据流分析、机器学习、语义分析和符号执行（统计数据如表4所示）。</p>
<p>在论文作者调查的工具中，75%的工具依赖于控制流分析来评估种子并确定对目标的可达性；46%的工具利用静态分析来自动识别目标，并从PUT中提取信息；32%的工具使用数据流分析（主要是污点分析）来识别目标之间的关系输入和关键程序变量，优化变异策略调度；11%使用机器学习预测易受攻击的代码，过滤掉无法到达的输入；18%采用语义分析自动识别易受攻击目标，学习输入字段语义优化变异；最后，18%集成符号（concolic）执行来解决复杂的路径约束。</p>
<h4 id="implementation-limitation">Implementation Limitation</h4>
<p><img src="/png/2021-01-03-17-14-22.png"></p>
<p>大约一半的工具是在AFL之上实现的。因此，性能在一定程度上受到AFL实现的限制。从两个方面来说明这种局限性。</p>
<p>第一个问题在于，AFL的边缘覆盖是基于基本块转换的，因此它只在基本块级敏感，不能在指令级区分路径差异。图5显示了两个相邻基本块之间的跳转示例。由于仅对路径敏感，因此无法区分地址0x400657处的跳转是采用（路径2）还是不采用（路径1），因为在控制流图中会有相同的边，即0x400657→0x400671。</p>
<p>另一个问题在于，AFL在编译时为每个分支跳转插入随机数，并在运行时从寄存器中收集这些插入数，以标识基本块转换（即控制流图中的边）。然后通过一个算法将插入数转换映射到64KB位图。由于不同的边可能有机会共享同一位置，因此该方案会导致路径冲突。</p>
<p>AFL的这两个局限性都会导致控制流图的不精确性，最终影响基于控制流图分析的种子优先级，无论是基于距离还是其他度量。</p>
<p>尽管这种限制可以通过构造更细粒度的控制流图或设计定制的hash方案来缓解，但是，额外的工作不可避免地会增加运行时开销。</p>
<h4 id="efficiency-improvement">Efficiency Improvement</h4>
<p>为了实现模糊化的方向性，大多数研究人员使用额外的工具和数据分析。然而，这种额外的分析不可避免地会导致性能降低，对于给定的模糊时间预算，更高的效率意味着更多的模糊执行，=也就是更多的机会达到目标。因此，优化模糊化效率是提高方向性的另一个方向。</p>
<p>一种解决方案是将与执行无关的计算从运行时转移到编译时。例如，AFLGo通过解析PUT的调用图和过程内控制流图来度量每个基本块与目标站点之间的距离。由于解析图和计算距离都非常耗时，AFLGo在编译时将大部分程序分析转移到插桩阶段，以换取运行时的效率。</p>
<p>另一个优化是在实现级别。由于在分析过程中使用的大多数数据都是基于图的，因此如何存储和访问此类元数据对效率至关重要。可以设计一个优化的数据结构来存储这些数据，这样在基于图的拓扑结构进行搜索时就可以方便地频繁、快速地访问这些数据。例如，使用图数据库模型。</p>
<p>最后，可以利用并行计算来进一步提高效率。以前的工作已经成功地将并行性应用于CGF，但尚未应用于DGF。对于DGF，可以使用一个中心节点来维护一个种子队列，该队列保存DGF的所有种子并对其进行优先级排序。然后，将种子分发到计算节点上的并行模糊实例中，测试PUT并收集反馈信息。</p>
<h4 id="future-research-suggestions">Future research suggestions</h4>
<ul>
<li>在论文作者评估的工具中，只有SemFuzz支持内核代码测试。因此，在内核代码中引入DGF，并引导对关键站点（如syscalls和错误处理代码）的模糊化应该是一个有效的方向。</li>
<li>虽然DGF一直在尝试发现新的bug类型，比如UAF漏洞和内存泄漏漏洞，但许多常见的bug还没有被包括在内。因此，另一个研究方向是将DGF应用于特定的bug类型，如信息泄漏bug、并发bug、语义bug（TOCTTOU、double fetch）。</li>
<li>对于种子优先级度量，大多数工作都利用了基于距离和覆盖率（相似性）的方法，这有助于在不引入太多开销的情况下对种子进行量化评估。然而，较小的距离或较宽的覆盖范围并不一定意味着更接近目标，因为存在不同的权重原因和全局偏差原因。作者认为基于概率的度量应该更合理。</li>
<li>最后，分阶段模糊测试是一种可行的方法，可以进一步用于DGF。通过将到达目标的路径划分为连续的多个阶段，分阶段定向模糊算法可以在每个阶段到达子目标，逐步到达目标。此外，可以利用不同的模糊策略来满足不同阶段的需求。例如，TOFU对命令行标志使用语法模糊，对主要输入文件使用语义模糊。因此，分阶段模糊化可以降低模糊化各个阶段输入空间的维数，提高模糊化效率。</li>
</ul>
<h2 id="fuzzing-hack-art-and-science-cacm-2020">Fuzzing: Hack, Art, and Science (CACM 2020)</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/CACM20_Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>三种检测软件中安全漏洞的方法。</p>
<p>静态程序分析器：能够自动检查代码并标记错误的代码模式，它们可以标记出许多浅显的错误，但是工具也容易发出虚假的警报。</p>
<p>人工代码审计：包括发布之前的peer-reviewing和渗透测试，这个步骤可以检测很多问题，包括安全漏洞，设计缺陷和编码错误等超出了自动化工具的范围的问题。</p>
<p>然后就是模糊测试Fuzzing。</p>
<h3 id="blackbox-fuzzing-1">Blackbox Fuzzing</h3>
<p>Fuzzing最简单的形式是Blackbox random fuzzing，它随机地改变格式良好的应用程序输入，然后用这些修改后的输入测试应用程序。</p>
<p><img src="/png/2021-01-17-09-36-29.png"></p>
<p>程序采用格式良好的（第1行）作为输入。然后，它选择一个随机数的字节，这些字节将在该输入中被模糊化（第2行）。这个数字从1到输入长度除以1000不等。这个任意的1000值是可选的，但是它可以防止模糊化原始文件中的太多字节。</p>
<p>接下来，第4-8行循环重复选择输入中的一个随机位置（第5行）和一个新的随机字节（第6行），然后在该位置（第7行）写入该字节，直到所选的字节数被模糊化。</p>
<p>然后，程序用它执行被测试的应用程序（第9行），如果检测到错误，则报告错误（第10行）。</p>
<p>实际上，应用程序是在运行时检查工具的监视下运行的，如Purify、Valgrind、AppVerifier或AddressSanitizer，以增加发现非崩溃安全漏洞（如缓冲区溢出）的机会。</p>
<p>图2的程序可以重复执行，以生成任意多个新的模糊输入。尽管它很简单，但这种fuzzing策略已经可以有效地发现那些处理二进制格式输入的应用程序中的安全漏洞，特别是如果它们以前从未被fuzzing过。</p>
<p>实际上，对于JPEG图像格式，通常使用原始字节值来编码键输入属性，如图像大小、尺寸和输入文件数据指针；在其他格式良好的输入中fuzzing这些关键字节值（其位置因图像而异）可能会发现由于输入验证不完整而导致的缓冲区溢出错误。</p>
<p>在实践中，Blackbox random fuzzing的有效性关键取决于一组形式良好的种子输入来启动fuzz过程。事实上，格式良好的种子输入将在应用程序中更快地执行更多的代码，并且涵盖输入格式支持的各种选项和编码，以进行全面的fuzzing。</p>
<p>相反，没有格式良好的种子输入的fuzzing很可能会生成纯垃圾，被测试的应用程序将快速检测并丢弃这些垃圾。这就是为什么图2的程序将第2行中的常数1000定义为其模糊密度，如果种子输入中的每个字节都被模糊化，则生成的新输入将完全是乱码和随机的；但是如果平均每1000字节最多有一个字节被模糊化，模糊化只会给原始种子输入添加有限的噪声，并用此进行测试稍微损坏的新输入更有可能在被测应用程序的更多不同部分执行更多的错误处理代码，从而增加发现错误的机会。</p>
<h3 id="grammar-based-fuzzing">Grammar-Based Fuzzing</h3>
<p>Blackbox random fuzzing提供了一个Fuzzing的基准，但其有效性有限：产生新的有效的输入的几率非常小，尤其是对于那些接受结构化输入的程序，随机模糊输入可能会破坏关键结构 的属性，导致应用程序快速检测到错误然后丢弃，而并没有对太多的应用程序代码进行fuzzing。</p>
<p>Grammar-based fuzzing对于接受格式化输入的程序是非常有效的。分析人员提供指定的输入语法来指明被测试的应用程序的输入格式。通常，分析人员还会指定需要模糊哪些输入部分，以及怎么样模糊。然后根据这样的输入语法生成许多新的输入，每个都满足输入语法的约束。基于语法的模糊器有Peach，SPIKE和Sulley等。</p>
<p><img src="/png/2021-01-17-10-19-48.png"></p>
<p>图3显示了一个代码片段，展示了基于语法的模糊器（如SPIKE）生成新输入的过程，输入语法在这里直接表示为可以解释执行的代码。</p>
<p>代码中通过调用s_string按顺序指定那些固定的常量字符串，用s_blocksize_string获取clock变量的字符串长度作为之前Content-Length的参数，s_block_start表示开始定义block，继续使用s_string定义常量字符串，关键点在于使用s_string_variable生成随机化的数据来进行fuzz，后面s_string同理，最后使用s_block_end结束block的定义。</p>
<p>通过执行图3所示的代码，SPIKE可能会生成以下字符串序列。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/api/blog/</span> HTTP/1.2</span><br><span class="line"><span class="attribute">Content-Length:10&#123;body:XXX&#125;</span></span><br></pre></td></tr></table></figure>
<p>Grammar-based fuzzing的优势和优点。</p>
<ol type="1">
<li>可以通过分析人员的专业知识将fuzzing集中于那些可能永远不会被Blackbox random fuzzing覆盖到的代码区域。</li>
<li>可以将不可靠的输入作为Web页面，包括复杂的HTML文档和JavaScript代码，从而发现浏览器中的安全漏洞，以及那些复杂的代码编译器中的bug。</li>
<li>也适用于网络协议的fuzzing，如图3所示。</li>
</ol>
<p>Grammar-based fuzzing is also related to model-based testing. Given an abstract representation of a program—called a model—model-based testing consists in generating tests by analyzing the model in order to check the conformance of the program with respect to the model. Test generation algorithms used in model-based testing often try to generate a minimum number of tests covering, say, every state and transition of a finite-state machine model in order to generate test suites that are as small as possible. Similar algorithms can be used to cover all production rules of a grammar without exhaustively enumerating all possible combinations.</p>
<p>机器学习在Grammar-based fuzzing中的应用仍处于初步阶段，如何自动学习输入样本的语法是一个研究领域。例如，可以学习上下文无关的语法，使用自定义输入的示例概括步骤，或使用程序的动态污点分析以确定在测试中程序是如何处理其输入的。基于神经网络的统计机器学习技术可以也可以用来学习输入文法。</p>
<p>由于语法的编写过程是开放性的，并且可选择性如此之多，例如：如何fuzzing，何时停止，如何进一步编辑语法等实际问题。</p>
<h3 id="whitebox-fuzzing-1">Whitebox Fuzzing</h3>
<p>Blackbox Fuzzing的效果是非常有限的，Grammar-based fuzzing是劳动密集型的。而且什么时候可以认为已经发现了所有的漏洞？前两者是无法做到的。</p>
<p>whitebox fuzzing从一个格式良好的输入开始，对测试程序进行动态符号执行并收集符号执行过程中遇到的条件分支的输入约束。然后，将收集到的约束条件一一systematically否定，并使用约束条件求解器求解，该约束条件求解器的结果将用于生成进入程序不同的执行路径的新输入。</p>
<p>使用systematic搜索技术来重复此过程，该技术尝试遍历程序的所有（实际上是许多）可行的执行路径，同时使用运行时检查器检查许多运行时状态来判断是否触发了bug（如缓冲区溢出）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// x is an input</span></span><br><span class="line"> <span class="keyword">int</span> y = x + <span class="number">3</span>;</span><br><span class="line"> <span class="keyword">if</span> (y == <span class="number">13</span>) <span class="built_in">abort</span> (); <span class="comment">// error</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态符号执行具有初始具体值，变量x为0的程序输入，此时执行的为else的分支，并生成路径约束x + 3 ≠ 13。</p>
<p>否定此约束条件并用约束求解后求解器，求解器产生解决方案x = 10。新输入使程序遵循条件语句的then分支语句并找到错误。而这在blackbox random fuzzing只有1/2^32的几率命中（假设输入变量x的变量大小为32bit）。这直观地解释了为什么白盒模糊通常提供更高的代码覆盖率。</p>
<p>whitebox fuzzing可以生成比其他方法执行更多程序路径的输入，因为它更精确。而且whitebox fuzzing可以自动发现并测试出程序遇到的极端情况，例如由于无法正确分配内存或操作缓冲区而导致的安全漏洞。从理论上讲，whitebox fuzzing提供了完整的程序路径覆盖，也就是说达到了程序验证的效果（针对达到指定大小的任何输入）。</p>
<p>例如，简单程序foo有两个可行的执行路径，可以穷举和探索所有路径以证明该程序不包含任何缓冲区溢出。但是实际上，探索通常是不完整的，因为程序中的执行路径的数量是巨大的，而且符号执行，约束生成和约束求解可能由于复杂的程序语句（指针操作，浮点操作等）导致结果不精确，同时还有外部操作系统和库功能产生的大量约束，这些约束无法在限定的时间内完全解决。</p>
<p>由于这些限制，whitebox fuzzing的有效性仍然依赖于各种各样的合适的种子输入。</p>
<p>whitebox fuzzing最初是在SAGE中实现的，它扩展了dynamic test generation的工作范围，从单元测试到大型程序的安全性测试。被称为execution-generated tests或concolic testing。</p>
<p>SAGE执行x86级别动态符号执行，并实现几个至关重要的优化用于处理来自于数亿条机器指令的执行痕迹，以便对应那些包含数百万行代码的文件解析器，例如Microsoft Excel或PowerPoint。</p>
<p>当探索巨大状态空间的时候，SAGE也会使用基于代码覆盖率的启发式探索。</p>
<ul>
<li>对执行的每个测试都测量其指令覆盖率，对于发现更多新指令（新路径）的符号优先执行，以便探索更多未开发代码区域。</li>
<li>测试和符号执行可以在多个内核或机器上并行运行。whitebox fuzzing也可以从给定的种子输入开始，同时如果输入语法可用还可以使用Grammar-based fuzzing来生成种子输入。</li>
</ul>
<p>whitebox fuzzing已在许多其他工具中采用，包括开源工具KLEE，S2E，和Symbolic PathFinder。</p>
<h3 id="other-approaches">Other Approaches</h3>
<p>Portfolio approaches同时运行多种的fuzzer并收集它们的结果，因此结合了它们的互补优势。</p>
<h2 id="survey-of-directed-fuzzy-technology">Survey of Directed Fuzzy Technology</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/ICSESS19_Survey.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>主流fuzz工具。</p>
<p><img src="/png/2021-01-22-13-45-05.png"></p>
<h3 id="dse">DSE</h3>
<p>符号执行实际上是将可达性问题转化为约束求解问题。</p>
<h4 id="symbolic-execution-algorithm">Symbolic Execution Algorithm</h4>
<p>符号执行最初用于编译过程，程序分析等，主要思想是将符号变量作为输入去执行程序，在执行的过程中收集条件判断时通往不同路径的约束，最后使用约束求解获得到达对应路径的输入。</p>
<h5 id="静态符号执行">静态符号执行</h5>
<p>静态符号执行首先将输入变量符号化，然后通过静态分析将程序转换为中间语言，并且在运行中更改符号化变量来获取通往不同路径的约束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = raw_input();</span><br><span class="line">b = <span class="number">2</span> * a;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">10</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"win"</span> ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">"lose"</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，正常运行是用户输入值任何程序返回结果。在静态符号执行中，a首先被符号化，即a = x，而b = 2 * x。</p>
<p>可知当10 == 2 * x时，它进入win路径，否则进入lose路径。这两条路径合并的状态被称为执行树，10 == 2 * x和10 != 2 * x则是路径约束。</p>
<p>当符号执行结束，即程序正常或异常退出时。约束解算器将求解对应路径的约束，从而获得到达此路径所需的变量的值。</p>
<p>静态符号执行存在很多实际实施过程中的问题，例如：约束无法求解。</p>
<h5 id="动态符号执行">动态符号执行</h5>
<p>结合传统静态符号执行和实际执行的符号执行称为动态符号执行。</p>
<p>动态符号执行维持两种状态：一种是实际状态，另一种是符号状态。实际状态对应随机生成的变量的值，而符号状态则是符号化的变量。</p>
<p>动态符号执行首先根据实际状态运行，运行过程中收集符号化变量在当前分支路径上的约束并进行求解。然后，将约束条件求反就得到另一条分支路径的约束。重复该过程，直到探索完所有路径或达到设置的限制。</p>
<p>还是上面的代码，在一次动态符号执行中，假设随机生成的变量a = 7，实际执行时会进入lose路径。</p>
<p>此时通过不断的收集进入lose路径的约束求返获得进入win路径的约束，并使用约束求解器来验证。这样就避免了约束不能解决或找到的问题。</p>
<ol type="1">
<li>通过动态符号执行提取来自原始的复杂的控制流图CFG的行为信息。</li>
<li>然后向控制流模型添加约束以实现一个基于控制流的有限状态机控制参数，Finite State Machine control parameters (EPBFSM)。</li>
<li>最后，通过解决EPBFSM中的约束产生的新的模糊输入，这种方法不仅可以找到可能发现漏洞的路径，也可以识别可能发现漏洞的可控对象。</li>
</ol>
<h4 id="directed-symbolic-execution">Directed Symbolic Execution</h4>
<p>通常测试出来的大多数路径都不是可以直接到达目标的，所以要通过找到一条到达中间目标的路径来继续进行搜索。</p>
<p>补丁测试工具KATCH使用符号执行器KillE到达被patch的地方。</p>
<p>而KLEE使用符号执行的方法，通过大量的程序分析和约束求解系统地探索到达目标位置的路径的状态空间。</p>
<p>一旦识别到一条可以到达目标位置的路径，就可以对相应的路径约束求解从而生成测试用例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">55</span> <span class="comment">/* Read type and payload length first */</span></span><br><span class="line"><span class="number">56</span> hbtype = *p++;</span><br><span class="line"><span class="number">57</span> n2s(p, payload);</span><br><span class="line"><span class="number">58</span> pl = p;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="number">65</span> <span class="keyword">if</span> (hbtype == TLSl _HB_REQUEST) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="number">77</span> <span class="comment">/* Enter response type, length and copy payload */</span></span><br><span class="line"><span class="number">78</span> *bp++ = TLS <span class="number">1</span>_HB_RE SPONSE;</span><br><span class="line"><span class="number">79</span> s2n(payload, bp);</span><br><span class="line"><span class="number">80</span> <span class="built_in">memcpy</span>(bp,pl,payload);</span><br></pre></td></tr></table></figure>
<p>假设KATCH将上面代码的第80行设置为目标，并且找到一个到达65行可行路径A作为中间目标。</p>
<p>接下来，KATCH通过约束求解器将收集到的A的约束和hbtype == TLSl _HB_REQUEST的约束进行求解，就可以生成运行到80行的输入。</p>
<p>与GF不同，基于符号执行的whitebox fuzzing为实现定向模糊测试提供了简单的处理方法。大多数补丁测试工具都基于DSE。</p>
<p>但是，DSE为了有效性牺牲了效率，因为DSE需要很长时间来执行程序分析和约束求解。</p>
<p>在每次迭代中，DSE使用程序分析来确定那些为了靠近目标而需要否定的分支，根据这些路径构建相应的约束，并使用约束求解器来验证。</p>
<h2 id="a-review-of-machine-learning-applications-in-fuzzing">A Review of Machine Learning Applications in Fuzzing</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv19_Machine.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>论文讲述了ML在Fuzzing中的应用，主要关注三种类型的ML：有监督学习，无监督学习，强化学习。</p>
<p>有监督学习用于训练一个模型来识别给定数据点的标签，要求训练数据集的数据点都有显式标签。</p>
<p>无监督学习用于训练一个模型来发现数据点之间的模式或相似性，不要求数据点有显式标签。</p>
<p>强化学习是用来训练一个模型（代理）基于环境而行动，以取得最大化的预期利益。强化学习会对代理在环境中所做的操作或者结果进行对应的奖励，类似于监督学习，这些奖励为代理提供了一个最佳行动的指示。</p>
<p>一个典型的强化学习场景：Flappy bird游戏。</p>
<ul>
<li>机器有一个明确的小鸟角色——代理。</li>
<li>需要控制小鸟飞的更远——目标。</li>
<li>整个游戏过程中需要躲避各种水管——环境。</li>
<li>躲避水管的方法是让小鸟用力飞一下——行动。</li>
<li>飞的越远，就会获得越多的积分——奖励。</li>
</ul>
<p>这些ML都可以采用一种特殊的ML形式--深度学习。深度学习是指一种分层学习，可用于学习一组数据点的基本特征和结构。</p>
<h3 id="overview-of-fuzzing">OVERVIEW OF FUZZING</h3>
<p>现代模糊程序的三种主要类型：基于变异的fuzzer、基于生成的fuzzer和进化fuzzer。</p>
<p>基于变异的模糊程序盲目地变异提供的初始输入以提供给程序。一般来说，基于变异的模糊程序不知道预期的输入格式。Peach是一种模糊程序，可以执行基于变异和基于生成的fuzzing。</p>
<p>基于生成的模糊程序通过规范获取有关预期输入格式或协议的信息，根据这些规范生成输入。基于生成的fuzzer包括Peach和Sulley，Sulley是一个Python实现的fuzzing框架，可以为文件传输协议、网络协议和文件格式生成输入。</p>
<p>进化模糊程序是一种最新的模糊程序，它在变异的基础上，评估每一个输入的优先级，并使用适应度函数（通常是覆盖率）对输入进行排序，并选择排序最好的输入进行变异。进化模糊程序的例子包括honggfuzz、AFL和libFuzzer。</p>
<p><img src="/png/2021-01-24-10-39-35.png"></p>
<p>上图将一般的fuzzing过程分为几个阶段。</p>
<h4 id="pre-fuzzing-program-knowledge">Pre-Fuzzing: Program Knowledge</h4>
<p>在开始fuzzing之前，fuzzer需要程序知识，也就是如何对程序进行检测或观察？什么构成了一个有趣的程序状态？需要研究哪些输入接口？</p>
<p>基于变异的fuzzer通常需要以输入语料库或一组程序输入的形式提供额外的程序知识，以便有效地生成输入，这些程序输入往往是预期输入的示例。</p>
<p>基于生成的fuzzer以输入规范的形式吸收额外的程序知识，例如预期的文件格式或协议描述。基于生成的fuzzer通常比基于变异的模糊器有更好的代码覆盖率和更深入的程序状态探索。但是更难设置，因为它需要准确的程序输入规范，这通常比生成输入语料库耗费更多时间。而且基于生成的fuzzer仅探索这些规范指定的输入空间。</p>
<p>进化fuzzer和基于变异的fuzzer一样，通过输入语料库获取额外的程序知识。</p>
<p>通常，程序知识由使用者开发和提供。</p>
<h4 id="stage-1-generate-inputs">Stage 1: Generate Inputs</h4>
<p>在fuzzing的第一阶段，fuzzer使用程序知识生成输入，通过已指定的输入接口提供给程序，这个阶段的目标是生成那些可以触发或者说到达新的代码区域的输入。</p>
<p>并不是所有的新输入都会被使用，fuzzing的下一阶段将会选择这些生成输入。</p>
<p>基于变异的fuzzer通过处理先前的优先级高的输入来生成新的输入。在第一次迭代中，fuzzer处理初始输入语料库中提供的输入。之后，fuzzer会根据监视程序的信息评估输入性能，然后调整语料库。</p>
<p>基于生成的fuzzer通过根据输入规范来生成新的输入。对于一个给定的规范，只存在有限的与该规范对应的输入，也就是说输入搜索空间是有限的，所以基于生成的fuzzer可以探索整个输入搜索空间。</p>
<p>进化fuzzer和基于变异的fuzzer类似。要么变异一个输入，要么选择两个或多个输入进行交叉组合以产生新的输入，也可以使用其他随机化技术。进化fuzzer通过评估前一阶段的输入性能来选择输入进行随机化。</p>
<p>理论上，基于变异和进化的fuzzer可以产生无限的输入，无限的输入搜索空间使得很难估计有多少输入空间已经被探索过。</p>
<p>符号执行是一种静态分析技术，它可以帮助生成新的输入，从而增加fuzzer的覆盖范围。在实际中符号执行用于为基于变异和进化的fuzzer生成新的输入提供信息。这些新的输入可以添加到输入语料库中，或者以其他方式输入到程序中。</p>
<p>符号执行通过分析程序来找出程序中数据值的约束或限制，而无需真正执行。符号执行的工作原理是将输入数据抽象为一个符号值变元，然后遍历整个变元的符号值，当程序通过一个符号值进行分支判断时（例如if(x&lt;10)），符号执行引擎将生成两个符号状态，每个状态各包括一个不同分支的执行端满足的约束（branch-take状态将包含约束x&lt;10，而branch-not-take状态将包含约束x&gt;=10；除此之外，这两个符号状态将是相同的），并继续以符号执行的方式执行这两个状态。</p>
<p>符号状态包括到达该状态所需的一系列分支决策的约束条件。例如到达这一点的x值，为了记录这些值，将符号状态建模为一组约束，这些约束为每个输入变量编码路径上的有效值范围。</p>
<p>然后用约束求解器求解这些约束从而返回有效的具体赋值或者证明不存在此类赋值（即约束不可满足）。这个赋值表示一个输入，它通过做出与原始路径中相同的分支决策，使程序达到所需的程序状态。</p>
<p>fuzzer可以使用符号执行来创建新的输入，通过约束求解器为新发现的符号状态提供有效赋值来探索新的路径。</p>
<p>不幸的是，符号执行的计算成本很高，而且大量可能的程序路径使得以符号方式执行整个程序是不可行的。所以符号执行通常用于寻找那些通过随机探索难以找到的路径。为了降低这一成本，fuzzer将符号执行与标准输入生成技术配对。符号执行引擎可以通过跟随一个感兴趣的输入来限制路径，例如，只允许新的符号状态在有限数量的分支中偏离输入。然而，计算成本和路径爆炸仍然是重要的障碍。</p>
<h4 id="stage-2-select-inputs">Stage 2: Select Inputs</h4>
<p>在fuzzing的第二阶段，fuzzer选择并发送输入到程序。</p>
<p>当基于变异和进化的fuzzer继续迭代运行时，可能会收集许多非常大的输入，这会减慢模糊过程，所以需要执行语料库最小化来减少输入的数量，或者输入最小化来减少每个输入的大小。</p>
<p>无论是合理的选择输入来减少活动输入的数量，还是减小输入，这些技术都试图减少fuzzer发现新的程序状态所需的时间。</p>
<h4 id="stage-3-monitor-program">Stage 3: Monitor Program</h4>
<p>在fuzzing的第三阶段，fuzzer将监视程序以识别感兴趣的程序状态。有趣的程序状态指表现出特定的程序行为，在大多数情况下，crash就是一种有趣的程序状态。</p>
<p>而实际上，通过程序插桩可以观察到的任何行为都可以用来识别有趣的程序状态。例如，Valgrind可以检测内存损坏，即使这个损坏不会导致崩溃；对于脆弱性评估，有趣的行为是那些与bug或脆弱性相关的可观察行为。</p>
<p>如前所述，fuzzer需要程序知识，从而了解如何对程序进行检测以及什么构成了一个有趣的程序状态。操作人员通常会提供这些信息，但是如何定义一个有趣的程序状态仍然是一个研究挑战。而在脆弱性评估案例中，如何判断可观察到的行为与识别缺陷或脆弱性是否是最相关的也是一个研究挑战。</p>
<p>一旦fuzzer识别出一个有趣的程序状态，它就需要将该状态的描述返回给用户进行分析。</p>
<h4 id="stage-4-evaluate-inputs">Stage 4: Evaluate Inputs</h4>
<p>在fuzzing的第四阶段，fuzzer评估输入的执行情况。</p>
<p>许多fuzzer使用代码覆盖率来衡量输入的效果，如果输入执行了新的代码部分，也就是说提高了代码覆盖率，就会得到较高的评价；libFuzzer工具使用了一个类似的度量，即数据覆盖率，如果该输入和先前的输入执行情况的比较中出现了新的数据值，那么就会对该输入给予较高的评价。一些fuzzer使用bug的发现情况作为度量，导致崩溃的输入被给予较高的评价。</p>
<p>基于进化的fuzzer需要反馈输入的性能指标，也就是必须能够评估输入并对其进行排序。然后fuzzer根据输入的性能指标来有选择地生成新的输入和执行。基于变异和基于生成的fuzzer通常不需要反馈输入的性能指标，但是性能指标可以帮助评估fuzzer的整体性能。</p>
<p>实际上，覆盖度量是启发式的，不能提供对输入性能的完整评估。因此，找到一个有效和可比较的指标仍然是一个研究挑战。</p>
<h4 id="post-fuzzing-interesting-program-states">Post-Fuzzing: Interesting Program States</h4>
<p>在fuzzing之后，研究人员会简单分析fuzzer反馈的有趣的程序状态，包括形成原因和是否属于漏洞，之后会进行分类，以决定对哪些程序状态进一步分析。</p>
<p>不幸的是，这些程序状态通常具有相同的原因，而且具有相同原因的状态可能会出现截然不同的情况。例如，内存损坏漏洞可能会导致程序的许多不同部分崩溃，导致内存映像差异很大。一些自动化工具试图消除fuzzer输出的"重复"状态，但这些工具往往不完善，对状态进行分类和根本原因的分类仍然是一个研究挑战。</p>
<h3 id="applications-of-machine-learning-to-fuzzing">APPLICATIONS OF MACHINE LEARNING TO FUZZING</h3>
<p>ML已被用于在fuzzing中生成新的输入，并在较小程度上促进post-fuzzing。</p>
<p>无监督学习在输入生成中得到了最成功的应用。例如，AFL等模糊工具将遗传算法（GAs）集成到输入生成过程中。最近也有监督学习和强化学习（RL）在输入生成中的应用。</p>
<p>此外，这三种类型的ML都已应用于符号执行，主要是为了减少约束方程的求解时间。</p>
<p>监督学习和非监督学习都已应用于post-fuzzing，主要用于crash的分类和根本原因分类。</p>
<p>也就是说还有两个领域没有进行应用：输入最小化和语料库最小化。可能是因为这部分fuzzing不会导致大的性能瓶颈。</p>
<h4 id="generate-inputs">Generate Inputs</h4>
<p>以下是有关ML在输入生成方面的成果。</p>
<h5 id="genetic-algorithms">Genetic Algorithms</h5>
<p>最常用的ML输入生成技术是GAs。GAs是一种受生物进化启发的无监督ML，通常是进化fuzzer的核心输入生成算法。</p>
<p>当使用GAs时，有3个主要步骤：生成一个小的base population of inputs；对inputs执行转换；测量转换后的inputs的性能。根据选定的指标，在inputs上重复上述过程。</p>
<p>base population of inputs由一组种子输入组成。GAs会变异这些种子输入来探索代码空间，目的是发现新的路径。</p>
<p>进化fuzzer通常使用一个性能函数对输入进行排序来进行选择和变异。性能函数的选择会对fuzzer的性能，fuzzer识别特定类型错误的能力，以及fuzzer陷入局部极小值的趋势等方面产生巨大影响。</p>
<p>传统的代码覆盖率是性能函数最常用的度量，但也有更高级的启发式方法，如动态马尔可夫模型（DMM）启发式方法。</p>
<p>也就是将程序控制图表示为马尔可夫过程，即控制图当中的每一条边都有对应的转移概率。DMM启发式方法使用马尔可夫模型和转移概率来创建性能函数。与代码覆盖率不同，这种方法能更精确地控制fuzzer，将其引导到代码中可能包含bug或缺陷的特定部分。</p>
<p>性能函数的选择是fuzz的一个重要决定因素，因此设计新的性能函数来引导出期望的fuzzing是一个很有前途的研究领域。特别是可以对fuzzer进行更细粒度控制的性能函数对于定向fuzz更为有利。</p>
<h5 id="deep-learning-and-neural-networks">Deep Learning and Neural Networks</h5>
<p>深度学习（DL）和神经网络（NNs）也被应用于输入生成，特别是基于生成和基于变异的fuzzer。递归神经网络（RNN）是应用于fuzzing中的最常用的DL方法。特别是已被用于输入生成的Long-Short Term Memory（LSTM，RNN的一种变体）网络。</p>
<p>在一项研究中，Godefroid等人使用LSTMs为基于生成的fuzzer中的PDF文件创建输入语法。LSTM在许多类型的序列生成任务中显示出了良好的效果。然而，Godefroid等人发现fuzzing和LSTM输入语法学习的目标经常相互冲突：LSTM倾向于产生格式良好的输入，而fuzzer的目标是产生探索新程序状态的范例输入。为了避免这一矛盾，Godefroid等人采用了抽样策略来选取LSTM生成的输入，最终创建了一个具有很强平衡性的输入语法。实验结果表明，使用ML生成输入语法是一种很有前途的提高代码覆盖率的技术。</p>
<p>在另一项研究中，Rajpal等人将DL整合到AFL中，通过变异特定字节来增加覆盖率。一个NNs被用来生成一个热图，该图给出了特定字节发生变异时增加代码覆盖率的预测可能性。Rajpal等人比较了四种不同的生成热图的序列学习结构：标准LSTM；双向LSTM，它向前和向后处理输入序列；Seq2Seq，它将一个序列转换为另一个序列；Seq2Seq的一种变体，它使用attention机制来关注序列输入的重要部分。虽然每个模型在某些情况下都增加了代码覆盖率，但总体而言，标准LSTM模型的性能略优于其他模型。实验上，在ELF、XML和PDF格式上，DL增强AFL优于标准AFL，而在PNG格式上，标准AFL优于DL增强AFL。</p>
<p>另一种生成输入的方法是对程序行为建模，使用模型选择最有希望的输入。</p>
<p>NEUZZ方法使用浅层神经网络将程序的行为建模为平滑的连续函数，该神经网络被训练用于根据种子输入预测程序的分支行为。实验发现，训练过程中产生的梯度，特别是较大的梯度，有助于识别哪些输入字节控制分支行为。</p>
<p>Chen等人还通过Angora建模程序行为，Angora使用离散函数表示从程序起点到特定分支约束的路径，然后实现梯度下降从而在函数表示中的小离散区间上，以找到满足约束的一组输入，并通过该特定分支移动程序。总的来说，这种方法证明了快速解决分支约束的能力，并且在某些程序上的实验性能优于AFL和符号执行。</p>
<p>Cheng等人实现了一种使用DL生成输入的其他替代方法。这种方法使用RNNs来预测程序的新路径，然后将这些路径输入到Seq2Seq模型中，该模型为执行预测路径的fuzzer生成新的种子输入。初步研究表明，实验生成的语料库提高了PDF、PNG和TFF格式的fuzzer代码覆盖率。</p>
<p>DL和NNs的应用仍有障碍。</p>
<p>第一个障碍是DL模型需要大量的训练计算时间。其中许多研究试图缓解这些问题。例如，Rajpal等人通过在fuzzing开始之前只在一小部分输入上训练神经网络来规避训练成本。另一方面，She等人在整个fuzzing中使用了简化形式的模型再训练，只使用最有用的数据点进行再训练。这两种方法都减少了训练时间，但对模糊性能的总体影响尚不清楚。减少数据量的另一种方法是开发在程序之间传输先前训练过的模型的方法。这种方法可能会消除或减少fuzzing以前未开发的程序所需的模型训练量，但这些方法如何影响性能尚不清楚。</p>
<p>第二个障碍是跨文件格式的性能一致性。其中许多研究表明，对于某些文件格式（如PDF），DL与以前的基线相比，始终提高了模糊性能，而其他格式则无法与最先进的技术竞争。</p>
<h5 id="reinforcement-learning">Reinforcement Learning</h5>
<p>有两个团队应用强化学习进行输入生成。Becker等人使用SARSA算法通过改变发送到主机的网络数据包来对IPv6协议fuzz。SARSA算法考虑了代理的实时状态和行为来确定最优行为。Bottinger等人在基于生成的fuzzer中使用deep Q-learning network来学习语法来描述PDF格式。deep Q-learning network使用深度神经网络将状态映射到动作。</p>
<p>这些研究表明program representation对于训练一个成功的RL代理是至关重要的。</p>
<p>Becker等人使用有限状态机来表示IPv6协议的行为，其中每个状态表示主机对特定数据包的当前响应，状态之间的转换表示数据包的可能突变。Bottinger等人还使用了马尔可夫决策过程来表示问题。马尔可夫决策过程的特点是状态之间的随机转换。在这项研究中，状态表示fuzzer的特定种子输入，而转换表示该状态下种子输入的概率重写规则。因此，Becker和Bottinger都演示了使用有限状态机作为问题表示来训练RL代理生成输入的实用性。</p>
<p>这些研究还提供了有效定义一个代理的奖励函数的经验，这通常是RL最具挑战性的方面。</p>
<p>Becker等人根据以下标准创建了一个多部分奖励函数：从单个输入调用的程序函数的数量、是否存在错误以及来自程序的响应消息存在的潜在损坏或延迟。错误的存在是向代理发出的最强信号，表明它已到达代码空间的一个有趣部分。即使在没有错误信号的情况下，程序的响应也被用来指导代理。奖励函数的每一部分都在指导代理人方面都起着各自的作用，如果忽略这些标准，可能会导致代理人的效率降低。Bottinger等人试验了多种不同的奖励函数，一种使用代码覆盖率，另一种使用执行时间，第三种结合代码覆盖率和执行时间。在这两项研究中，奖励函数都会影响fuzzer对输入空间的探索。例如，当Bottinger使用执行时间作为奖励时，代理学习导致程序快速终止的输入。Becker和Bottinger的工作都表明需要仔细定义奖励函数，考虑到软件程序类型、寻找的bug类型、可用的fuzz度量以及最终的fuzz目标。</p>
<p>标准的fuzzer还没有实现RL，这些应用仍然是理论上的。</p>
<p>目前还不清楚奖励函数应该如何依赖于程序，或者是否存在普遍有效的奖励函数。例如，相同的奖励函数可以用于每个项目，还是每个独特的项目都需要一个独特的奖励函数？文件格式（如PDF和PNG）如何影响奖励函数的定义？</p>
<p>RL面临的另一个挑战是解决代理的可转移性。目前还不清楚是否有必要为每个独特的程序训练一个新的RL代理，这样做可能是不切实际的。因此，研究和创造可转让代理可能是未来研究的必要步骤。</p>
<h5 id="machine-learning-for-symbolic-execution">Machine Learning for Symbolic Execution</h5>
<p>有监督学习被用于求解约束方程。</p>
<p>在一项研究中，图形神经网络被用来识别表明约束方程是否有有效解的特征。在另一项研究中，吴使用了逻辑回归和蒙特卡罗方法相结合的方法来确定初始值，从而提高了找到约束方程有效解的概率。蒙特卡罗方法用于确定初始有希望的值，而逻辑回归则用于说明使用这些选择值的约束方程解的有效性。合并这些新的初始值会减少Minisat solver的运行时间。在另一项研究中，LSTMs（即DL）被训练用于求解约束方程。虽然LSTMs无法击败最先进的约束求解器，但它们能够从未经训练的域中求解约束方程，这表明DL模型具有泛化能力。Shiqi等人开发的另一种方法使用NNs表示约束方程。这些约束方程的解通过梯度下降被发现。</p>
<p>总的来说，这些研究都提供了求解约束方程的独特方法。虽然不能和目前的技术水平竞争，但它们为使用监督学习来减少求解约束方程所需的计算时间提供了一个强有力的起点。</p>
<p>Mairy等人使用RL改进了局部邻域搜索方法。局部邻域搜索方法通过求解约束方程的各个子集，并将这些子集组合起来形成最终解，从而迭代地找到约束方程的解。为了发现有用的子集，这些局部邻域搜索方法必须智能地探索可能的子集空间。引导RL代理选择更可能导致有效解决方案的子集，以减少找到此类解决方案所需的时间。</p>
<p>还有一项研究工作使用ML来减少解搜索空间的大小，而不是直接求解约束方程。Li等人将路径约束的典型集合重新表述为优化问题，并试图减少不可行路径的数量，即由于约束冲突而永远无法到达的路径。他们使用ML技术RACOS来解决优化问题，这是一种优化技术，可以很好地扩展到高维问题，然而只分析了非常小的程序。</p>
<h4 id="post-fuzzing-interesting-program-states-1">Post-Fuzzing: Interesting Program States</h4>
<p>ML主要用于分类崩溃（分类）或分类错误（根本原因分析），不过也有例外，Yan等人使用贝叶斯方法和!exploitable工具来提高确定漏洞可利用性的可靠性。</p>
<p>Dang等人使用aggregative hierarchy clustering将具有类似调用堆栈的崩溃进行分组，这是一种无监督学习技术，可以对具有类似特征的数据点进行聚类。他们在调用堆栈上引入了自己的相似性度量，即位置相关模型，允许他们使用未标记的调用堆栈数据集进行训练。他们在微软的各种产品上测试了他们的模型，并且在很多情况下比以前的碰撞相似性识别方法表现得更好。</p>
<p>已经有几次尝试使用ML对软件中的bug进行分类。</p>
<p>Harsh等人使用多种监督技术（包括决策树、支持向量机和朴素贝叶斯）对根本原因分类进行了实验。然而他们指出由于缺乏标记数据应用监督技术可能具有挑战性。为了解决缺少标记数据的问题，Harsh等人还尝试了无监督和半监督技术。不幸的是，这项研究的技术是有限的，因为bug的类别是非常广泛和系统特定的。</p>
<p>在另一项研究中，Long等人使用ML来确定根本原因，并生成修补程序来修复相关的bug。他们的工具Prophet使用了一个参数化的对数线性概率模型，该模型能够识别决定一段代码必须如何修复的重要特征。这项工作的一个重要方面是Prophet模型的可解释性；模型参数可用于确定生成特定patch的各种特征的重要性。这种可解释性非常重要，因为它可以帮助用户理解生成特定修补程序的原因。</p>
<p>有监督的ML技术用于更频繁地识别软件领域之外的根本原因。在一个例子中，决策树和支持向量机被用于工业生产系统的根本原因分析。在另一个例子中，神经网络用于工业储罐系统内的故障定位。支持向量机在加速电路板故障定位方面也显示出良好的前景。虽然这些研究都没有直接应用到软件上，但是可以扩展研究以帮助软件领域的根本原因分析。</p>
<p>ML很少应用于Post-Fuzzing，原因有二。</p>
<p>首先，大多数ML分类技术返回的是预测，而不是解释。这使得用户很难确定预测的标签是否正确以及为什么应用该标签。例如，在根本原因分析中，用户会发现很难理解根本原因应该在代码中显示在哪里，或者验证标签，或者纠正根本原因。此外，ML算法往往建立不透明的规则，很难映射到领域知识。</p>
<p>其次，只有极少数可用的标记数据集，目前还不清楚什么是强大的、可概括的基准数据集。在为Post-Fuzzing构建数据集时，有几个没有明确答案的问题必须解决，例如：</p>
<ol type="1">
<li>应该包括哪些可能的错误？</li>
<li>应该表示为哪些编程语言？</li>
<li>应该如何为ML算法编码错误及其根本原因？特别是考虑到根本原因是细微差别的，并且可能因系统而异？</li>
</ol>
<h4 id="seed-selection">Seed selection</h4>
<p>用ML进行种子选择方面的研究很少。</p>
<p>Wang等人进行了一项广泛的研究，使用NNs来选择更可能导致模糊代码中的漏洞的输入。虽然这项研究显示了有希望的结果，但诸如训练模型到新项目的可转移性等挑战仍然存在。与输入生成一样，模型的可传递性仍然是ML应用于种子选择的潜在瓶颈。</p>
<p>先前的种子选择研究指出了未来ML研究的另一种可能性。种子选择必须在使用已知性能水平的当前输入与探索未知但可能更好性能的新输入之间取得平衡。RL算法通常成功地应用于这类需要平衡新输入的探索和当前输入的利用的场景中。因此，RL算法可能非常适合于确定最优种子调度。未来的研究可能包括：为最佳种子选择创建奖励函数；确定离线RL代理在程序之间的可转移性；在fuzzing中集成在线RL代理。</p>
<h4 id="input-and-corpus-minimization">Input and Corpus Minimization</h4>
<p>目前似乎还没有任何关于输入最小化或语料库最小化的研究。因为输入最小化和语料库最小化都不是一个很大的性能瓶颈，最大的瓶颈存在于输入生成和Post-Fuzzing过程中，因此，大多数研究往往集中在这些领域；而且最小化输入或总语料库大小并不能自然地适合于ML技术。</p>
<h2 id="a-systematic-review-of-fuzzing-based-on-machine-learning-techniques">A systematic review of fuzzing based on machine learning techniques</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Arxiv19_Machine2.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>Fuzzing的工作过程由四个主要阶段组成：测试用例生成阶段、程序执行阶段、运行状态监控阶段和崩溃分析阶段。</p>
<p>机器学习技术在模糊测试中的应用的实质是将漏洞检测作为一个程序或样本分类的问题来对待。研究人员利用现有的机器学习技术帮助fuzzer从现有的大量脆弱性相关数据中提取经验和知识，然后根据训练生成的模型对新样本进行分类和预测。</p>
<p><img src="/png/2021-02-21-17-00-18.png"></p>
<h3 id="applying-machine-learning-techniques-for-different-fuzzing-steps">Applying Machine Learning Techniques for Different Fuzzing Steps</h3>
<p>根据机器学习所解决的问题，模糊化的步骤可分为以下几步：种子文件生成，测试用例生成，测试用例过滤器，突变操作选择，性能函数，可利用性分析。</p>
<h4 id="seed-file-generation">Seed file generation</h4>
<p>现有的种子选择策略存在着一些不足，比如需要更多的时间来获取种子集，选择的种子的执行效果与随机选择的种子几乎相同。利用机器学习技术可以学习传统模糊测试中导致代码覆盖率更高、崩溃次数更多、执行路径更独特的种子文件的共同特征，并通过基于生成或基于变异的方法生成更多具有该特征的种子文件。</p>
<p>Skyfire（Wang et al.2017）实现的data-driven种子生成方法使用PCFG（包含语义规则和语法特征的Probabilistic context-sensitive grammar）自动提取语义信息。这些语义信息和语法规则用于种子生成，从而保证生成的种子文件通过语法分析和语义检查。Skyfire可以执行到目标程序的更深路径，从而更有效地发现深层漏洞。</p>
<p>Fast fuzzing（Nichols et al.2017）使用深层神经模型来增强随机突变测试的有效性，从AFL（Zalewski M 2016）生成的样本中学习特征并生成种子文件，通过生成对抗网络（GAN）的对抗训练增加执行路径。</p>
<p>SmartSeed（Lv et al.2018）读取输入文件并将其转换为二进制形式的统一类型矩阵，然后使用WGAN和MLP从收集的数据集中自动学习触发唯一崩溃或唯一路径的特征。经过训练的模型可以生成更容易导致崩溃和唯一路径的种子文件。</p>
<p>Cheng等人（Cheng et al.2019）使用RNN和seq2seq找到PDF文件和目标程序执行路径之间的相关性。然后，这种相关性被用来生成新的种子文件，这些文件更有可能在目标程序中探索新的路径。</p>
<p>NeuFuzz（Wang et al.2019）通过LSTM学习样本中已知的漏洞程序和隐藏的漏洞模式，发现可能包含漏洞的执行路径。然后，NeuFuzz优先执行能够覆盖包含漏洞路径的种子文件，并根据预测结果为这些种子文件分配更多的变异能量。</p>
<h4 id="testcase-generation">Testcase generation</h4>
<p>testcase可以通过对种子文件执行变异来生成，也可以基于已知的输入文件格式来构建。作为最终输入，testcase的内容将直接影响bug是否被触发。因此，构造一个代码覆盖率高或能触发漏洞的testcase可以有效地提高fuzzer中漏洞检测的效率。</p>
<p>Samplefuzz（Godefroid et al.2017）首次尝试使用基于神经网络的统计学习技术从样本输入自动生成输入语法。提出了一种基于seq2seq递归神经网络的PDF对象自动学习生成模型，并对其进行了评价。该模型不仅可以生成大量新的testcase，而且可以提高覆盖率。</p>
<p>Fan等人（Fan and Chang 2017）提出了一种为专有网络协议自动生成黑盒模糊testcase的方法。该方法使用seq2seq来处理专有网络协议的通信流量来学习生成的输入模型，并使用该学习模型生成testcase。</p>
<p>GANFuzz（Hu et al.2018）通过在生成对抗网络中训练生成的模型来学习协议语法，以估计工业网络协议消息的潜在分布函数。基于这个生成模型可以生成一个格式良好的testcase。</p>
<p>DeepSmith（Cummins等人，2018）将随机程序的生成作为一个语言建模问题。它使用LSTM模型在代码语料库上学习编程语言的语法、语义、常规结构和模式。DeepSmith根据编译器模糊化的生成方法生成语法格式的testcase。</p>
<p>Sablotny et al.（Sablotny et al.2018）构建了堆叠RNN的模型，以生成HTML标记和新的testcase，用于fuzz浏览器的渲染引擎。其主要思想是根据从大量HTML标记中学习字符序列的概率分布来生成HTML标记。</p>
<p>IUST DeepFuzz（Nasrabadi et al.2018）使用基于深度递归神经网络（RNN）的神经语言模型（NLM）学习复杂输入文件的结构。IUST DeepFuzz首先删除输入文件的非文本部分，并用令牌替换它。在训练结束后，用删除部分的变体替换令牌以生成新的testcase。</p>
<p>NEUZZ（She et al.2019）进一步提出了一种梯度引导搜索策略，该策略计算并使用平滑近似梯度（即NN模型）来识别目标突变位置，这可以最大化目标程序中检测到的bug数量。研究成果还说明了如何通过对错误预测的程序行为进行逐步再训练来改进神经网络模型。</p>
<p>Paduraru等人（Paduraru和Melemciuc 2018）对不同文件格式的语料库进行了聚类。将输入文件的语料库作为一系列字符，通过seq2seq学习每个聚类的生成模型。该方法可以在训练好的模型的基础上生成新的testcase，从而可以执行更多的分支。</p>
<p>Li et al.（Li et al.2019b）提出了一种基于WGAN的工业控制协议testcase生成方法。该方法可以在不知道具体协议规范的情况下，通过实际数据帧的结构和分布生成相似的数据帧。</p>
<p>DeepFuzz（Liu等人，2019b）通过seq2seq模型从原始GCC测试套件学习正确的C程序语法。该模型基于所学语法连续生成语法正确的C程序。然后，使用insert、replace和remove策略生成testcase来fuzz编译器。</p>
<p>V-Fuzz（Li等人，2019a）构建了一个图形嵌入式网络来训练脆弱性预测模型。根据训练后的模型，引导fuzzer生成倾向于到达潜在漏洞区域的testcase。提取漏洞函数和安全函数的属性控制流图，在函数级进行学习。在预测阶段，评估的概率被用作testcase的性能度量。</p>
<h4 id="testcase-filter">Testcase filter</h4>
<p>如果fuzzer要执行所有质量参差不齐的样本，这是费时又低效的。Testcase filter的目的是从大量样本中选择更有可能触发新路径或漏洞的样本。利用机器学习技术可以对样本进行分析和分类。</p>
<p>Gong et al.（Gong et al.2017）基于AFL生成的样本训练了一个深度学习模型。通过训练模型可以预测新一轮AFL生成的样本是否会改变程序状态。</p>
<p>Augmented-AFL（Rajpal et al.2017）实现了几种神经网络架构，以学习预测给定输入修改集的预期代码覆盖率的能力。在fuzzing中，学习函数用于预测完整输入文件的热图，对应于每个文件位置突变导致新代码覆盖的概率。然后使用覆盖图确定突变位置的优先级。</p>
<p>Siddharth（Karamcheti et al.2018b）将程序输入映射到执行轨迹，并对执行轨迹分布的熵进行排序。Siddharth假设不确定性越高，执行新代码路径的可能性越大，因此选择熵最大（最不确定）的输入来执行下一个输入。</p>
<h4 id="mutation-operator-selection">Mutation operator selection</h4>
<p>fuzzing中不同位置的不同突变会产生不同的影响。变异算子的选择策略是为了达到提高模糊化效率的目的，例如增加代码覆盖率或包含脆弱路径。</p>
<p>Becker等人（Becker et al.2010）指定了一个有限状态机并分解了不同的消息类型来分析neighbor discovery协议。工作的主要思想是利用基于跟踪、调试和监控三种不同奖励函数的强化学习模型对模糊化网络进行优化，选择最佳的模糊化测试策略。</p>
<p>LEFT（Fang和Yan 2018）构建了一个基于强化学习的模型对Android手机中的LTE功能进行fuzz。该模型主要包括三种模糊处理方法：emulation-instrumented black-box fuzzing，threat-model-aware fuzzing，RL-guided fuzzing。</p>
<p>受反馈驱动随机测试和强化学习的启发，Böttinger等人（Böttinger et al.2018）提出了第一种使用强化学习的模糊化方法，以最大限度地提高代码覆盖率和减少处理时间。该模型可以在获得高收益的情况下学习突变的运行特征。</p>
<p>FuzzerGym（Drozd和Wagner 2018）使用LLVM Santizers的程序监视器获取状态信息，这些信息被用来优化基于强化学习（RL）的变异算子选择。结合强化学习和模糊化的优点，通过OpenAI-Gym与libFuzzer的集成，实现对多个基准的更深入的覆盖，并直接从输入数据中实现变异选择策略的学习。</p>
<p>Karamcheti等人（Karamcheti等人2018a）提出了一种基于robers的Thompson抽样优化方法，该方法可以在fuzz单个程序的过程中自适应调整变异算子的分布。通过学习每个变异算子对代码覆盖率的影响，确定应该选择哪个变异算子。最后，在下一次迭代中使用所选择的变异算子对测试输入进行变异。</p>
<p>FUZZBOOST（Liu等人，2019）使用从运行时跟踪收集的代码覆盖率信息作为奖励，并使用Deep Q-learning算法优化此奖励。通过这样做，模糊代理学习如何选择变异算子对种子程序进行变异，以提高模糊测试的覆盖率。</p>
<h4 id="fitness-function">Fitness function</h4>
<p>基于遗传算法的fuzzer使用性能函数评价测试用例满意和不满意，常见的性能函数包括代码覆盖率、潜在漏洞位置。</p>
<p>Xiao等人（Sun et al.2018）提出了一种新的基于遗传规划的适应度函数，不同于目前主流的基于代码覆盖率的方法。它将马尔可夫链和PCFG模型相结合，从程序员开发的普通脚本语料库中学习脚本的共性，并通过测量脚本与普通脚本的偏差来计算脚本的uncommonness。该偏差用于计算基于GP的语言模糊脚本的性能，偏差较大的脚本更容易引发解释器的错误。</p>
<h4 id="exploitability-analysis">Exploitability analysis</h4>
<p>常用的脆弱性分析方法有静态分析和动态分析。采用工具技术如!exploitable（Team MSECMSS 2013），CERT tools。</p>
<p>ExploitMeter（Yan et al.2017）使用贝叶斯机器学习算法对从软件中提取的静态特征进行初始判断。将fuzzing中的初始判断和可利用性判断相结合，更新最终的可利用性结果。</p>
<p>Exniffer（Tripathi et al.2018）建议使用机器学习来自动确定碰撞可利用性预测的更一般规则。该方法使用支持向量机（SVM）学习从核心转储文件（崩溃期间生成）中提取的特征和从最新处理器硬件调试扩展中获取的信息。</p>
<p>Zhan et al.（Zhang and Thing 2019）基于n-gram分析和特征散列生成紧凑的指纹，用于动态跟踪每个崩溃输入。然后将指纹输入在线分类器，建立识别模型。在线分类器支持的增量学习允许模型即使在大量崩溃时也能很好地扩展，同时对于新的崩溃也很容易更新。</p>
<h3 id="analysis-of-machine-learning-based-fuzzing-model">Analysis of Machine Learning Based Fuzzing Model</h3>
<p>从五个方面分析机器学习在fuzzing中的使用：机器学习算法的选择，预处理方法，数据集，评估指标，Hyperparameters设置。</p>
<h4 id="selection-of-machine-learning-algorithm">Selection of machine learning algorithm</h4>
<p>fuzzer的输入数据可以是文本、源代码、二进制字符串、网络包等形式。PUT还包含复杂的语法、语义和逻辑结构。在复杂的模糊测试环境中，判断哪种机器学习算法有效是一个难题。</p>
<p><img src="/png/2021-02-23-20-39-01.png"></p>
<p>每种传统的机器学习算法只使用了一次，造成这种现象的原因可能是传统的机器学习技术需要人工提取特征。然而，输入样本格式和目标程序都包含复杂的语法和语义结构，并且没有有效的漏洞模型或漏洞特征。</p>
<p>深度学习依赖于它的representation learning，能够自动提取模糊测试中广泛应用的特征。最常用的两种算法是LSTM和seq2seq，LSTM使用最多的原因是它擅长处理顺序数据：程序执行路径与自然语言中的语句非常相似，一段代码是否包含漏洞取决于上下文。另一方面，LSTM具有适于处理长依赖关系的记忆功能，因为与漏洞相关联的代码可能位于路径中相对较长的距离处（Wang等人，2019）。seq2seq模型的输入输出序列长度是可变的，可以有效地利用模糊化的输入作为文本数据来学习局部或全局的语法信息。模糊测试中还使用了新的神经网络，如生成对抗网络（Goodfello et al.2014）和图卷积网络（Kipf and Welling 2016）。</p>
<p>在模糊测试中，由于强化学习需要在不同的环境中选择不同的行为，因此强化学习被用于变异算子的选择，这与变异算子的选择类似。然而，强化学习本身存在训练时间长、收敛性弱、局部优化等局限性，导致其在模糊测试中的应用较少（Mnih等，2013）。</p>
<h4 id="pre-processing-method">Pre-processing method</h4>
<p>由于PUT的类型不同，输入格式也有很大的不同，这些数据需要转换成可用于机器学习的输入。</p>
<p><img src="/png/2021-02-23-20-40-35.png"></p>
<p>预处理方法分为三类：程序分析、自然语言处理和其他。</p>
<p>程序分析是指利用静态或动态分析技术提取程序特征或运行时信息，如堆栈、寄存器、汇编指令、跳转、程序控制流图、抽象语法树和程序执行路径（Wang et al.2017；Tripathi et al.2018；Li et al.2019a）。</p>
<p>自然语言处理是指直接以文本形式输入的方法，利用复杂的文本处理技术提取输入数据中隐藏的特征，如n-gram（Damashek 1995）、count statistics、Word2vec（Goldberg and Levy 2014）、heat map（Wilkinson and Friendly 2009）等方法（Fan and Chang 2017；Yan等人，2017年；Karamcheti等人，2018b）。</p>
<p>其他包括将程序分析与自然语言处理技术相结合（Wang et al.2019；Zhang and Thing 2019），或将整个文档或pdf对象转换为向量（Rajpal et al.2017；Lv et al.2018），以及自定义方法。</p>
<p>根据文献（Gong et al.2017）的定义，测试用例的二进制序列用32位表示，模糊技术用4位表示，变异位用10位表示，变异值用32位表示，是否是新测试用例用1位表示。最后，每段数据都可以组合成一个79位的二进制序列，第一个78位作为输入，最后一个1位作为标签。</p>
<h4 id="datasets">Datasets</h4>
<p>机器学习的性能主要受训练数据的影响，在目前的工作中，用于基于机器学习算法的模糊测试的数据集有以下来源：网络爬虫，fuzzing过程中产生，自建，公共数据集。</p>
<h4 id="evaluation-metrics">Evaluation metrics</h4>
<p>基于机器学习技术的fuzz的性能评价可以分为两个方面：机器学习模型的性能评价和漏洞检测能力的评价。</p>
<p><img src="/png/2021-02-23-21-17-04.png"></p>
<p><img src="/png/2021-02-23-21-17-18.png"></p>
<p>机器学习模型的评价是基于分类度量的，而基于机器学习的模糊方法的漏洞检测能力评价与传统的模糊方法相同，传统的模糊化方法和基于机器学习的模糊化方法都是为了发现漏洞而设计的。因此，覆盖率、崩溃和bug是评估模糊模型性能的有效指标。然而，基于机器学习的模糊化方法有模型训练、特征提取等步骤，因此效率这一指标也被大量文献所采用。</p>
<h4 id="hyperparameters-setting">Hyperparameters setting</h4>
<p>在机器学习模型的实现中，Hyperparameters的值不是通过训练得到的，而是需要在训练前进行人工设置。一般来说，需要对超参数进行优化，选择一组最优的超参数来提高学习的性能和有效性。</p>
<p><img src="/png/2021-02-23-21-19-03.png"></p>
<p>深度学习算法中的超参数主要用来完成比较，包括层数、每层节点数、epoch数、激活函数和学习率。当每层中的节点数较大时会发生过拟合。随着epoch数的增加，神经网络的权值更新迭代次数增加，损失函数曲线从初始的不拟合状态进入最优拟合状态。激活函数的选择可以提高神经网络的建模表达能力，解决线性模型无法解决的问题。然而，不同激活函数的优缺点是不同的，例如sigmoid输入范围在0和1之间，但存在"sigmoid saturate and kill gradients"而不是"zero-centered"的问题（LeCun et al.2012）。Tanh（fan2000）解决了sigmoid输出不"zero-centered"的问题，但仍存在其他问题。学习速率控制着模型的学习进度，也影响着模型收敛到局部极小值的速度。较高的学习率容易导致损失值的爆炸和冲击，而较低的学习率会导致过拟合和收敛速度减慢速度。</p>
<h3 id="performance-evaluation-of-fuzzing-model-based-on-machine-learning">Performance Evaluation of Fuzzing Model Based on Machine Learning</h3>
<p>机器学习模型性能评价：准确率、查准率、召回率和损失率是所选研究文献中最常用的绩效指标。准确度、准确度和召回率这三种性能指标的值越高，表示预测越准确。性能指标损失值越低，模型的鲁棒性就越高。</p>
<p>漏洞检测能力的性能评估：覆盖率，特定代码路径，特定的崩溃或错误，合格率（生成的样本中可以通过程序语法检查的百分比），效率。</p>
<h3 id="future-directions">Future Directions</h3>
<p>未来的方向可以从以下三个方面进行：</p>
<ol type="1">
<li>数据集。将机器学习引入fuzz必须建立开放且全面的数据集，作为测试基准。</li>
<li>特征选择。程序的结构和执行信息与漏洞没有直接关系，因此如何从程序或样本中选择实用的特征成为影响fuzz性能的一个重要因素。目前自然语言处理技术比较成熟，可以考虑利用自然语言处理领域的先进技术，提取程序的代码属性、语义和语法特征等有用信息进行fuzz。</li>
<li>学习算法的选择。应根据fuzz不同阶段的特点、对应数据的大小、不同算法的优缺点作为算法选择的依据。其次，graph convolutional networks，fusion neural networks和interpretable deep learning models都可以尝试与fuzz相结合，有必要研究更复杂、更合适的神经网络模型来提高生成样本的质量。</li>
</ol>
<h2 id="the-art-science-and-engineering-of-fuzzing-a-survey">The Art, Science, and Engineering of Fuzzing: A Survey</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/TSE19_Survey.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<p>Fuzzing test：模糊测试是使用fuzzing测试被测程序是否存在违反安全策略。</p>
<p>Fuzzer：fuzzer是在被测程序上执行fuzz测试的程序。</p>
<p>Fuzz Campaign: 在特定安全策略下的一轮fuzz，目的是发现违反安全策略的bug。</p>
<p>Bug Oracle：检测程序执行是否违反安全策略的一种机制。</p>
<p>Fuzz Configuration：Fuzz算法的参数值。</p>
<h3 id="systemization-taxonomy-and-test-programs">SYSTEMIZATION, TAXONOMY, AND TEST PROGRAMS</h3>
<p>几乎所有的fuzz算法都依赖于PUT之外的一些参数,这些参数的设置称为模糊配置。</p>
<p>将随机字节流发送到PUT的fuzz算法有一个简单的配置空间{(PUT)}。而复杂的fuzzer包含的算法接受一组配置，并随着时间的推移添加和删除配置。例如，CERT BFF在fuzzing中会改变突变率和seed，因此它的配置空间是{(PUT),(PUT),...}的形式。</p>
<p>fuzzer通常维护一个称为种子池的seed集合，seed是PUT的输入（通常结构良好），通过修改它来生成新的测试用例，一些fuzzer会随着fuzzing演化种子池。最后，fuzzer能够在每个配置中存储一些数据，例如覆盖率。</p>
<p><img src="/png/2021-02-26-20-55-03.png"></p>
<p>上图是一个用于模糊测试的通用算法模型，算法以一组模糊配置C和一个超时时间作为输入，输出为发现的bug。</p>
<p>第一部分是预处理函数，它在模糊活动开始前执行。第二部分是循环中的五个函数：SCHEDULE，INPUTGEN，INPUTEVAL，CONFUPDATE，CONTINUE。有些fuzzer并没有实现所有五个函数，例如，对于从不更新模糊配置集的Radamsa模型，CONFUPDATE总是返回当前配置集不变。</p>
<ul>
<li>PREPROCESS：预处理函数以一组fuzz配置C作为参数，并返回一组可能被修改的模糊配置。预处理可以执行多种操作，例如向PUT进行插桩，或者测量种子文件的执行速度。</li>
<li>SCHEDULE：SCHEDULE以一组fuzz配置C、当前时间和超时时间作为参数，并返回一个模糊配置conf用于该轮fuzz。</li>
<li>INPUTGEN：INPUTGEN以当前fuzz配置C作为参数，并返回一组具体的测试用例tcs。一些fuzzer使用conf中的种子来生成测试用例，而另一些使用模型或语法。</li>
<li>INPUTEVAL：INPUTEVAL以当前fuzz配置conf、测试用例tcs和一个嵌入在fuzzer中的Obug（bug oracle）作为参数，并返回每个fuzz运行时获取的信息集，这些信息可用于更新fuzz配置。INPUTEVAL使用bug oracle和测试用例tcs执行PUT，并检查执行是否违反了正确性策略。</li>
<li>CONFUPDATE：CONFUPDATE以一组fuzz配置C、当前配置conf和每个fuzz运行时获取的信息集作为参数。CONFUPDATE会更新这组fuzz配置，例如，许多灰盒模糊器基于运行时信息减少C中fuzz配置的数量。</li>
<li>CONTINUE：CONTINU以一组fuzz配置C作为参数，并输出一个布尔值指示是否应该继续。</li>
</ul>
<h3 id="preprocess">PREPROCESS</h3>
<p>预处理通常用于检测PUT、剔除潜在的冗余配置、修剪种子以及生成驱动程序应用程序，预处理也可用于为INPUTGEN准备模型。</p>
<h4 id="instrumentation">Instrumentation</h4>
<p>静态插桩通常通过在编译时对源代码或中间代码修改来进行，除了基于源代码的工具之外，研究人员还开发了二进制级静态插桩（即二进制重写）工具。</p>
<p>动态插桩比静态插桩有更高的开销，因为它是在运行时执行的，动态插桩工具：DynInst、DynamoRIO、Pin、Valgrind和QEMU。</p>
<p>给定的fuzzer可以支持多种类型的检测。例如，AFL支持在源代码级别使用修改过的编译器进行静态插桩，或者在QEMU的帮助下在二进制级别进行动态插桩。使用动态插桩时，AFL可以插桩PUT本身中的可执行代码（默认设置），或着PUT和任何外部库中的可执行代码（AFL_INST_LIBS选项）。第二个选项会检测所有遇到的代码，获取包括外部库中代码的覆盖率信息，从而提供更完整的覆盖率图。</p>
<h4 id="execution-feedback">Execution Feedback</h4>
<p>灰盒fuzzer通常将执行反馈作为参数来生成新的测试用例。</p>
<p>路径覆盖：AFL（覆盖率），CollAFL（解决hash冲突）。</p>
<p>节点覆盖：LibFuzzer，Syzkaller。</p>
<h4 id="thread-scheduling">Thread Scheduling</h4>
<p>通过显式控制线程的调度方式来触发不同的不确定性的程序行为，例如条件竞争漏洞。</p>
<h4 id="in-memory-fuzzing">In-Memory Fuzzing</h4>
<p>模糊大型程序的一种方法是在程序初始化之后对PUT进行快照，这样就可以通过恢复内存快照直接进行一次新的执行，这种方法也适用于模糊网络应用程序，称为内存模糊化。</p>
<p>一些fuzzer在每次迭代后只对函数执行内存模糊化，而不恢复整个PUT的状态，这种技术叫做内存API模糊化。</p>
<p>AFL有一个名为persistent mode的选项，它在循环中重复执行内存API模糊化，而不重新启动进程。在这种情况下，AFL忽略了在同一执行中多次调用函数的潜在副作用。</p>
<h4 id="seed-selection-1">Seed Selection</h4>
<p>种子选择：即减小初始种子池大小，常见的有minset，它找到一组最小的种子，使覆盖度量（如节点覆盖）最大化。</p>
<p>fuzzer在实践中使用各种不同的覆盖度量。例如，AFL的minset基于分支覆盖率，Hongfuzz基于执行的指令、分支和基本块的数量来计算覆盖率。</p>
<h4 id="seed-trimming">Seed Trimming</h4>
<p>种子修剪：即减小种子的大小，较小的种子可能消耗更少的内存，并带来更高的吞吐量。种子修剪可以发生在预处理时，也可以作为更新的一部分。</p>
<h4 id="preparing-a-driver-application">Preparing a Driver Application</h4>
<p>当fuzz的目标是一个库时，需要研究人员准备一个调用了库中函数的驱动程序。类似地，内核fuzzer可以fuzz用户态程序来测试内核，IoTFuzzer通过让驱动程序与相应的智能手机应用程序通信，将IoT设备作为目标。</p>
<h3 id="scheduling">SCHEDULING</h3>
<p>调度即为下一次模糊迭代选择一个模糊配置，模糊配置的内容取决于fuzzer的类型。对应的问题称为FCS问题（Fuzz Configuration Scheduling）。</p>
<h4 id="black-box-fcs-algorithms">Black-box FCS Algorithms</h4>
<p>Black-box FCS Algorithms依据的信息为配置的模糊结果、发现的崩溃和错误的数量以及迄今为止花费在该配置上的时间。</p>
<p>Householder和Foote是第一个研究如何在CERT-BFF中利用这些信息的人，Woo等人在多个方面进一步改进了他们的结果。</p>
<p>首先，他们将模型细化为Weighted Coupon Collector's Problem with Unknown Weights(WCCP/UW)。其次，他们将multi-armed bandit(MAB)算法应用于模糊化，这是当面临勘探与开发冲突时的常见应对策略。第三，他们将配置的成功概率与已经花费在配置中的时间关联，从而选择更快的配置。第四，他们重新定义了fuzz迭代，从运行固定数量的fuzz进程变为运行固定时间，进一步降低了较慢配置的优先级。</p>
<h4 id="grey-box-fcs-algorithms">Grey-box FCS Algorithms</h4>
<p>Grey-box FCS Algorithms拥有更丰富的信息集，例如覆盖范围。</p>
<p>AFL是这一领域的先驱，它基于evolutionary algorithm(EA)。EA维护一组配置，每个配置都有一些适度值。EA会选择合适的配置，并对其进行突变和重组，然后从中选择新的配置。</p>
<p>AFL维护一个配置队列，从中选择下一个合适的配置。一旦选中，AFL会将更多的运行时间分配给速度最快、分支覆盖率更高的配置。</p>
<p>Bohme等人的AFLFast在三个方面改进了AFL。</p>
<blockquote>
<p>To start, it modifies configuration fitness setting and selection to prioritize exploration of new and rare paths. Moreover, AFLFast fuzzes a selected configuration a variable number of times as determined by a power schedule. Its FAST power schedule starts with a small “energy” value to ensure initial exploration among configurations and increases exponentially up to a limit to quickly ensure sufficient exploitation. Finally, it also normalizes the energy by the number of generated inputs that exercise the same path, thus promoting explorations of less-frequently fuzzed configurations.</p>
</blockquote>
<p>AFLFast中的创新已作为FidgetyAFL的一部分集成到AFL中。Zalewski发现AFLFast最大的改进是快速检查所有新添加的种子。在相关工作中，AFLGo通过修改其优先级属性针对特定的程序位置。Hawkeye通过在种子调度和输入生成中利用静态分析进一步改进了定向模糊。FairFuzz通过为每对种子和一个稀有分支使用一个mutation mask来指导fuzzing，以探索稀有分支。QTEP使用静态分析来推断二进制文件的哪个部分更有可能存在漏洞，并优先考虑覆盖这些地方的配置。</p>
<h3 id="input-generation">INPUT GENERATION</h3>
<p>输入生成是模糊测试一个非常重要的过程，可以分为Model-based (Generation-based) Fuzzers，Model-less (Mutation-based) Fuzzers和White-box Fuzzers。</p>
<h4 id="model-based-generation-based-fuzzers">Model-based (Generation-based) Fuzzers</h4>
<p>基于模型的fuzzer基于给定模型生成测试用例，例如描述输入格式的语法或不太精确的约束。</p>
<p>一些fuzzer可以由用户自定义模型，例如Peach、PROTOS和Dharma。Autodafe、Sulley、SPIKE、SPIKEfile和LibFuzzer也公开了创建自定义输入模型的API。Tavor接受以Extended Backus-Naur form（EBNF）编写的输入规范。类似地，PROTOS、SNOOZE、KiF和TFuzz等网络协议fuzzer也由用户配置协议规范。Kernel API fuzzers通常以系统调用模板的形式定义输入模型，通过指定系统调用的参数的数量和类型生成测试用例。Nautilus使用基于语法的输入生成，并使用语法进行种子修剪。</p>
<p>其他基于模型的fuzzer以特定的语言或语法为目标，其模型包含在fuzzer中。例如，cross fuzz和DOMfuzz生成随机文档对象模型（DOM）对象。jsfuzz基于语法模型生成随机但语法正确的JavaScript代码。QuickFuzz利用现有的Haskell库来描述生成测试用例时的文件格式。网络协议模糊器Frankencerts、TLS-Attacker、tlsfuzzer和llfuzzer是根据特定网络协议（如TLS和NFC）的模型设计的。</p>
<p>LangFuzz通过解析输入种子来生成代码片段，其随机的组合这些片段，并将种子与片段突变，以生成测试用例，LangFuzz应用于JavaScript和PHP。而BlendFuzz基于与LangFuzz类似的思想，以XML和正则表达式解析器为目标。</p>
<p>模型推理可以在PREPROCESS或CONFUPDATE中发生。</p>
<p>PREPROCESS中的模型推理：TestMiner搜索PUT中可用的数据，如文字，以预测合适的输入。给定一组种子和一个语法，Skyfire使用数据驱动的方法来推断probabilistic context-sensitive grammar，然后使用它来生成语义上有效的输入。IMF通过分析系统API日志学习内核API模型，并生成C代码，该代码使用推断出的模型调用一系列API调用。CodeAlchemist将JavaScript代码分解为代码块并计算组装约束，这些约束描述了何时可以将不同的代码块组装或合并在一起以生成语义上有效的测试用例。使用静态和动态分析计算这些约束。Neural和Learn&amp;Fuzz使用基于神经网络的机器学习技术从一组给定的测试文件中学习模型，然后从推断的模型中生成测试用例。Liu等人提出了一种类似的方法，专门针对文本输入。</p>
<p>CONFUPDATE中的模型推理：PULSAR从捕获的网络数据包中自动推断出网络协议模型，然后用于模糊程序，PULSAR在内部构建一个状态机，并判断哪个消息令牌与一个状态相关，这些信息稍后用于生成覆盖状态机中更多状态的测试用例。Doupe等人提出了一种通过观察I/O行为来推断web服务状态机的方法，然后使用推断出的模型来扫描web漏洞。Ruiter等人]的工作类似，但它以TLS为目标，并以LearnLib为实现基础。GLADE从一组I/O样本中合成一个上下文无关语法，并使用推断的语法模糊PUT。gofuzz是一个灰盒fuzzer，它为添加到其种子库中的每个种子建立一个模型。此模型用于从该种子生成新的输入。为了克服符号执行的局限性，Shen等人使用神经网络来解决困难的分支条件。</p>
<p>fuzz的对象通常是解析某种文件格式的解码器程序。许多文件格式都有相应的编码程序，可以看作是文件格式的隐式模型。MutaGen利用编码器程序中包含的隐式模型来生成新的测试用例。与大多数基于变异的fuzzer不同，MutaGen变异编码器程序。Specifically, to produce a new test case MutaGen computes a dynamic program slice of the encoder program and runs it. The underlying idea is that the program slices will slightly change the behavior of the encoder program so that it produces test cases that are slightly malformed.</p>
<h4 id="model-less-mutation-based-fuzzers">Model-less (Mutation-based) Fuzzers</h4>
<p>大多数无模型fuzzer使用种子来生成新的输入。种子通常是PUT支持的类型的结构良好的输入：文件、网络包或UI事件序列。通过对有效文件的一小部分进行变异，通常可以生成一个新的测试用例，该测试用例大部分是有效的，但也包含异常值以触发PUT崩溃。</p>
<p>Bit-Flipping：翻转bit位。</p>
<p>Arithmetic Mutation：AFL和honggfuzz采用了算数变异，它们将选定的字节序列视为整数，并对其执行简单的算术运算后替换。</p>
<p>Block-based Mutation：将随机生成的块插入种子的随机位置；从种子中删除随机选择的块；用随机值替换随机选择的块；随机重组随机块序列的顺序；通过附加随机块来调整种子大小；从种子中取出随机块后插入另一种子的随机块。</p>
<p>Dictionary-based Mutation：一些fuzzer使用一组预定义的特殊值进行替换。例如，AFL、honggfuzz和LibFuzzer在对整数进行变异时使用0、−1和1等值。Radamsa使用Unicode字符串，GPF使用格式化字符（如%x和%s）来改变字符串。</p>
<h4 id="white-box-fuzzers">White-box Fuzzers</h4>
<p>白盒fuzzer也可以分为基于模型的fuzzer和无模型的fuzzer。尽管许多白盒fuzzer（包括Godefroid等人的开创性工作）使用动态符号执行来生成测试用例，但并非所有白盒fuzzer都是动态符号执行器。一些fuzzer利用白盒程序分析来查找PUT接受的输入信息，以便与黑盒或灰盒模糊一起使用。</p>
<p>传统符号执行以符号变元作为输入来运行程序，在执行PUT时构建符号表达式，每当它到达一条条件分支指令时，它就在产生两个符号状态，一个用于真分支，另一个用于假分支。对于每条路径，符号解释器为执行过程中遇到的每条分支指令建立一个条件约束（或路径谓词）。通过查询SMT solver获得路径公式的解，从而生成具体的输入。动态符号执行是传统符号执行的一种变体，符号执行和具体执行同时进行，因此动态符号执行也称为concolic (concrete + symbolic)测试。具体的执行状态可以降低符号约束的复杂性。</p>
<p>与灰盒或黑盒方法相比，动态符号执行速度较慢，因为要检测和分析PUT的每条指令。一种常见的策略是缩小其使用范围，例如，让用户指定代码中不感兴趣的部分，或者交替使用白盒模糊和灰盒模糊。QSYM试图通过实现一个快速的concolic执行引擎来改进灰盒模糊和白盒模糊之间的集成。DigFuzz通过首先估计使用灰盒模糊的每条路径的执行概率来优化灰盒模糊和白盒模糊之间的切换。</p>
<p>一些fuzzer利用静态或动态程序分析技术来增强fuzz的有效性。这些技术通常涉及fuzzing的两个阶段：预处理阶段代价高昂的程序分析，以获得有关PUT的有用信息；在程序分析的指导下生成测试用例。</p>
<p>例如，TaintScope使用细粒度的污点分析来查找热字节，即流入关键系统调用或API调用的输入字节。Dowser在编译过程中执行静态分析，根据启发式方法查找可能包含bug的循环，它查找包含指针解引用的循环。然后通过污点分析计算输入字节和候选循环之间的关系。最后，Dowser运行动态符号执行，同时仅使关键字节具有符号性，从而提高了性能。VUzzer和GRT利用静态和动态分析技术从PUT中提取控制流和数据流特征，并使用它们指导输入生成。</p>
<p>Angora和RedQueen首先运行每个种子，然后使用这些信息生成使用较轻工具运行的输入，从而降低了分析成本。Angora使用污点分析将每个路径约束与相应的字节相关联。然后它执行一个受梯度下降算法启发的搜索，以引导其突变来解决这些约束。另一方面，RedQueen试图通过检测所有比较运算并查找它们的操作数与给定输入之间的对应关系来检测PUT中如何使用输入。一旦找到匹配项，就可以用它来求解约束。</p>
<p>fuzz的一个实际挑战是绕过校验和验证。例如，当PUT在解析输入之前计算输入的校验和时，许多测试用例将被PUT拒绝。TaintScope提出了一种校验和感知模糊技术，该技术通过污点分析识别校验和测试指令，并对PUT进行修补以绕过校验和验证。一旦发现程序崩溃就为输入生成正确的校验和，以生成一个使未修改的PUT崩溃的测试用例。Caballero等人提出了一种称为缝合动态符号执行的技术，这种技术可以在存在校验和的情况下生成测试用例。</p>
<p>T-Fuzz扩展了这一思想，有效地穿透了所有类型的条件分支。它首先构建一组无需修改程序逻辑即可进行转换的分支，称为非关键检查（Non-Critical Checks，NCCs）。当fuzz活动停止发现新路径时，它选择一个NCC，对其进行转换，然后在修改后的PUT上重新启动fuzz活动。当T-Fuzz在一个修改后的PUT上用发现崩溃后，就会用符号执行在原来的PUT上重建崩溃。</p>
<h3 id="input-evaluation">INPUT EVALUATION</h3>
<p>生成输入后，fuzzer对输入执行PUT，并对结果进行评估。</p>
<h4 id="bug-oracles">Bug Oracles</h4>
<p>fuzzer通常将crash作为检测标准，但是这无法检测到某些内存漏洞。例如，如果堆栈缓冲区溢出用一个有效的内存地址覆盖堆栈上的指针，程序可能会运行到一个无效的结果，但fuzzer不会检测到这一点。研究人员提出了各种有效的程序转换来检测那些不安全或不需要的程序行为并中止程序，这种工具称为sanitizers。</p>
<p>Memory and Type Safety：内存错误可以分为空间上的和时间上的。当指针在它要指向的对象之外解引用时，就会发生空间内存错误，例如缓冲区溢出和下溢。当指针不再有效后被访问时，会发生时间内存错误，例如UAF。</p>
<p>Address Sanitizer(ASan)是一种快速内存错误检测器，ASan能够检测到空间和时间内存错误。ASan使用了一个影子内存，它会在解引用之前快速检查每个内存地址的有效性，从而检测到许多（但不是所有）不安全的内存访问，即使它们不会使原始程序崩溃。MEDS通过利用64位平台上的大内存空间，在分配的对象之间创建大量不可访问的内存区域，对ASan进行了改进，这些不可访问区域使被损坏的指针更有可能指向无效内存并导致崩溃。SoftBound/CETS是另一种内存错误检测器。SoftBound/CETS将边界和时间信息与每个指针相关联，从而可以在理论上检测所有的空间和时间内存错误。然而这种完整性带来了更高的平均开销。</p>
<p>Caves，TypeSan和HexType在编译时检测C++中错误的类型转化。另一类内存安全保护是控制流完整性(CFI)，CFI可以用来检测非法修改程序控制流的测试用例。</p>
<p>未定义的行为：Memory Sanitizer(MSAN)在编译期间使用程序来检测由C和C++中未初始化的内存使用引起的未定义行为。与ASan类似，MSan使用一个表示每个可寻址位是否初始化的阴影内存。Memory Sanitizer大约有150%的开销。Undefined Behavior Sanitizer(UBSan)在编译时修改程序以检测未定义的行为，UBSan可以检测各种各样的未定义行为，例如使用未对齐的指针、被零除、解引用空指针和整数溢出。Thread Sanitizer(TSan)是一种编译时修改，用于检测数据争用。当两个线程同时访问一个共享内存位置并且至少有一个访问是写访问时，就会发生数据争用。这样的错误会导致数据损坏，并且由于不确定性而极难重现。</p>
<p>输入验证：KameleonFuzz通过使用真实的web浏览器解析输入，提取DOM树，并将其与表示成功攻击的手动指定模式进行比较，来检测成功的XSS攻击。4SQLi使用类似的技巧来检测SQL注入。因为不可能从web应用程序响应可靠地检测SQL注入，4SQLi使用一个数据库代理来拦截目标web应用程序和数据库之间的通信，以检测输入是否触发了有害行为。</p>
<p>语义差异：语义错误通常是通过一种称为差异测试（differential testing）的技术发现的，这种技术比较相似（但不完全相同）程序的行为。一些fuzzer使用了差异测试来识别类似程序之间的差异，这些差异很可能表明存在bug。Jung等人引入了黑盒差分模糊测试，它使用对单个程序上的多个输入进行差分测试，以将PUT的输入到其输出之间的突变映射。这些映射用于识别信息泄漏。</p>
<h4 id="triage">Triage</h4>
<p>Triage是分析和报告那些违规测试用例的过程。分类可以分为三个步骤：重复数据消除、优先级排序和测试用例最小化。</p>
<p>理想情况下，重复数据消除会返回一组测试用例，每个测试用例都会触发一个唯一的bug。三种主要的重复数据消除实现：stack backtrace hashing，coveragebased deduplication，and semantics-aware deduplication。</p>
<p>stack backtrace hashing：程序会在崩溃时记录stack backtrace，并根据其内容计算一个hash值。有些实现只对函数的名称或地址进行hash运算，而其他实现则同时对名称和偏移量或行数进行hash运算。现在某些实现会产生两个hash：一个主hash和一个次hash。主hash很可能将不同的崩溃分组在一起，因为它只对函数名进行散列，而次散列更精确，可用于细分。stack backtrace hashing的基本假设是：类似的stack backtrace是由类似的bug引起的，反之亦然。但这是缺乏理论证明的。</p>
<p>coveragebased deduplication：AFL记录每次执行PUT时的边缘覆盖率，并测量每条边缘的粗略命中计数。如果crash覆盖了之前没到达的边缘，或crash未覆盖所有早期crash中存在的边缘，则认为该crash是唯一的。</p>
<p>semantics-aware deduplication：RETracer通过分析core dump来检查是哪个指针导致了崩溃，并递归地标识哪个指令将坏值赋给了它，最终找到一个具有最大帧级别的函数并利用该函数分类crash。vantonder等人利用自动程序修复技术将crash的测试用例映射到bug，作为程序语义变化的函数。</p>
<p>优先级排序（Prioritization，又称fuzzer-taming问题）是根据违规测试用例的严重性和唯一性对其进行排序或分组的过程，优先级排序也可以看作确定crash的可利用性。最早的可利用性排名系统之一是微软的!exploitable，!exploitable采用了几种启发式方法和简化的污点分析，按以下严重程度进行分类：EXPLOITABLE，PROBABLY_EXPLOITABLE，UNKNOWN，NOT_LIKELY_EXPLOITABLE。</p>
<p>分类的另一个重要部分是测试用例最小化。测试用例最小化将识别出一个违规测试用例中触发违规所必需的部分，并有选择地生成一个比原始测试用例更小、更简单但仍然会导致违规的测试用例。事实上，许多现有的最小化程序都是受delta debugging的启发。BFF包括一个针对模糊化的最小化算法，该算法试图最小化与原始种子文件不同的比特数。AFL还包括一个测试用例最小化器，它试图通过机会主义地将字节设置为零并缩短测试用例的长度来简化测试用例。Lithium是一个通用的测试用例最小化工具，它通过尝试移除相邻行或字节的块来最小化文件，这些块的大小是按指数递减的。还有各种各样的测试用例缩减器，它们不是专门为fuzz设计的，如delta debugging和C/C++文件的CurDue。</p>
<h3 id="configuration-updating">CONFIGURATION UPDATING</h3>
<p>CONFUPDATE函数在区分黑盒，灰盒和白盒fuzzer的行为方面起着关键作用。</p>
<p>黑盒fuzzer除了评估bug oracle外，不会执行任何程序自省，至多有些fuzzer将违规测试用例添加到种子集。例如，BFF将此功能称为崩溃回收。</p>
<p>相比之下，灰盒和白盒fuzzer有更复杂的CONFUPDATE函数实现，这允许它们合并新的模糊配置或删除可能已被取代的旧配置。CONFUPDATE允许在一个模糊迭代期间收集的信息被所有未来的迭代使用。例如，白盒模糊器通常为生成的每个新测试用例创建一个新的模糊配置。</p>
<h4 id="evolutionary-seed-pool-update">Evolutionary Seed Pool Update</h4>
<p>进化算法（EA）是一种基于启发式的方法，在fuzzing的上下文中，EA维护着一个有前途个体（即种子）的种子库，随着新个体的发现，这些个体在fuzzing的过程中不断进化。EA最重要的一步是向配置集C添加一个新配置，这发生CONFUPDATE中。大多数基于EA的fuzzer使用节点或分支覆盖率作为适应度函数：如果测试用例发现了新的节点或分支，则将其添加到种子池中。由于可到达路径的数量可以比种子的数量大几个数量级，因此种子池被设计成所有可到达路径的不同子选择，以表示当前对PUT的探索。</p>
<p>基于EA的fuzzer中的一个常见策略是细化适应度函数，以便它能够检测到更细微和更细粒度的改进指标。例如，AFL通过记录分支被执行的次数来细化其适应度函数定义。STADS提出了一个受生态学启发的统计框架，以估计如果fuzzing继续下去，将会发现多少新的配置。</p>
<p>另一种常见的策略是，在计算复杂的分支条件时，度量满足的条件的分数。例如，LAF-INTEL简单地将多字节比较分解为几个分支，从而检测新种子何时通过中间字节比较。LibFuzzer、honggfuzz、go fuzz和Steelix对所有比较进行数据化，并将任何在比较方面取得进展的测试用例添加到种子库中。类似的想法也被发布为一个用于clang的独立的工具模块。Steelix检查哪些输入偏移会影响比较指令。Angora通过考虑每个分支的调用上下文，改进了AFL的适应度标准。DeepXplore利用神经元覆盖率作为适应度函数，将模糊化应用于神经网络测试。</p>
<blockquote>
<p>VUzzer is an EA-based fuzzer whose fitness function relies on the results of a custom program analysis, which determines weights for each basic block. Specifically, VUzzer first uses a built-in program analysis to classify basic blocks as either normal or error-handling (EH). For a normal block, its weight is inversely proportional to the probability that a random walk on the CFG containing this block visits it according to transition probabilities defined by VUzzer. This favors configurations exercising normal blocks deemed rare by the aforementioned random walk. The weight of EH blocks is negative, which discourages the execution of error handling (EH) blocks. This assumes that traversing an EH block signals a lower chance of exercising a vulnerability since bugs often coincide with unhandled errors.</p>
</blockquote>
<h2 id="fuzzing-a-survey">Fuzzing: a survey</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/Cybersecurity18_Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<h3 id="background-1">Background</h3>
<p>静态分析：静态分析通常在源代码上执行，有时也在目标代码上执行。静态分析通过对词法、语法、语义特征的分析，以及对数据流的分析、模型检查，可以发现隐藏的bug。静态分析的优点是检测速度快。分析人员可以使用静态分析工具快速检查目标代码。然而，由于缺乏易用的漏洞检测模型，静态分析工具容易产生大量的误报。</p>
<p>动态分析：动态分析工具通过对程序运行状态的监控和分析，可以准确地检测程序错误。动态分析的优点是精度高，缺点是动态分析中目标程序的调试、分析和运行需要大量的人工参与，导致效率低下。</p>
<p>符号执行：符号执行将程序的输入符号化，同时为每个执行路径维护一组约束，然后使用约束求解器来求解约束，获得该路径的输入或者判断该路径不可达。从技术上讲，符号执行可以覆盖程序中的任何执行路径。但也存在许多局限性。首先是路径爆炸问题，随着程序规模的增大可能会超出约束求解器的求解能力，选择性符号执行是一种折衷方案。其次是与环境的相互作用，在符号执行中，当目标程序执行与符号执行环境之外的组件（如系统调用、处理信号等）交互时，可能会出现一致性问题。</p>
<p>模糊测试：从概念上讲，Fuzzing从生成大量输入到目标应用程序开始，通过将生成的输入反馈到目标应用程序并监视执行状态来检测异常。</p>
<h3 id="types-of-fuzzers">Types of fuzzers</h3>
<p>根据测试用例的生成方法，fuzzer可以分为基于生成的和基于变异的。</p>
<p>根据对源代码的依赖程度和程序分析的程度，模糊器可分为白盒、灰盒和黑盒。</p>
<p>根据程序探索策略的不同，模糊程序可分为定向模糊程序和基于覆盖的模糊程序。</p>
<p>根据程序执行状态监控与测试用例生成之间是否存在反馈，模糊程序可分为哑模糊程序和智能模糊程序。</p>
<h3 id="coverage-based-fuzzing">Coverage-based fuzzing</h3>
<p>在程序分析中，程序由基本块组成。基本块是具有单个入口和出口的代码段，基本块中的指令将按顺序执行，并且只执行一次。在代码覆盖率度量中，现有的方法以基本块为最佳粒度。其原因包括：基本块是程序执行的最小相干单元；测量函数或指令会导致信息丢失或冗余；基本块可以通过第一条指令的地址来识别，基本块信息可以通过代码插桩来获取。</p>
<p>目前，有两种基于基本块的基本度量选择，简单地计算执行的基本块和计算基本块之间的转换。在后一种方法中，程序被解释为一个图，顶点表示基本块，边表示基本块之间的过渡。后者记录边，前者记录顶点。实验表明，简单地计算执行的基本块会导致严重的信息丢失。</p>
<p>AFL首次将边缘测量方法引入到基于覆盖的模糊处理中，其通过轻量级程序插桩获得覆盖信息。根据是否提供源代码，AFL提供了两种插桩模式：编译内插桩和外部插桩。</p>
<p>在编译内插桩模式下，根据使用的编译器，AFL同时提供gcc模式和llvm模式，在生成二进制代码时，它将插入代码片段。在外部模式下，AFL提供qemu模式，当基本块转换为TCG块时，它将插入代码片段。</p>
<p><img src="/png/2021-03-03-18-00-05.png"></p>
<p>上图中的算法给出了基于覆盖的模糊器的一般工作过程。</p>
<p>测试从初始种子输入开始，如果没有初始种子，则fuzzer将自己构造一个种子输入集。在主模糊循环中，fuzzer会首先选择一个有趣的种子，用于后续的变异和测试用例生成。然后驱动目标程序在fuzzer的监视下执行生成的测试用例。然后收集那些触发crash的测试用例，并将其他有趣的测试用例添加到种子池中。对于基于覆盖的模糊化，增加了代码覆盖率的测试用例被认为是有趣的。主模糊循环在预先配置的时间用尽后或收到中止信号时停止。</p>
<p>fuzzer跟踪执行有两个目的，代码覆盖率和安全违规。代码覆盖率信息用于进行彻底的程序状态探索，安全违规跟踪用于更好地发现bug。AFL通过代码插桩和AFL位图跟踪代码覆盖率。安全违规追踪可以在许多Sanitizer的帮助下进行，比如AddressSanitizer，DataFlowsanitizer，ThreadSanitizer，LeakSanitizer等。</p>
<p><img src="/png/2021-03-03-18-07-52.png"></p>
<p>上图显示了AFL的工作过程。在主模糊循环中，AFL会优先选择最快和最小的种子；然后根据变异策略对种子文件进行变异，生成一组测试用例，AFL目前采用了一些随机修改和测试用例拼接方法，包括可变长度和步进的顺序位翻转、小整数的顺序加减和已知有趣整数（如0、1、INT_MAX等）的顺序插入；执行测试用例并跟踪程序状态。收集覆盖信息以确定有趣的测试用例，即到达新控制流边缘的测试用例。有趣的测试用例被添加到下一轮运行的种子池中。</p>
<h4 id="how-to-get-initial-inputs">How to get initial inputs?</h4>
<p>大多数基于覆盖率的模糊器都采用了基于变异的测试用例生成策略，而这种生成策略的效率很大程度上取决于初始种子输入的质量。具体来说，良好的初始输入可以节省构建种子所需的时间，良好的初始输入可以满足复杂文件格式的要求，基于良好的初始输入的变异更可能产生能够到达更深和难以到达的路径的测试用例，良好的初始输入可以在多个测试过程中重用。</p>
<p>收集种子输入的常用方法包括使用标准样本、从互联网获取和使用现有的POC样本。过多的种子输入会造成第一次试运行的时间浪费，AFL提供了一个工具，它可以提取实现相同代码覆盖率的最小输入集。</p>
<h4 id="how-to-generate-testcases">How to generate testcases?</h4>
<p>Rawat等人提出了Vuzzer，一种集成静态和动态分析的应用程序感知灰盒模糊器。种子输入的变异涉及两个关键问题：在哪里变异以及变异使用什么值。具体来说，Vuzzer在主模糊循环之前通过静态分析提取影响控制流的立即值、魔数和其他特征字符串。在程序执行过程中，Vuzzer利用动态污点分析技术来收集影响控制流分支的信息，包括特定值和相应的偏移量。Vuzzer通过对收集到的值进行变异和在识别的位置进行变异，可以生成更符合分支判断条件的测试用例，并通过魔数的验证。但是，Vuzzer仍然无法在程序中通过其他类型的验证，例如基于hash的校验和。此外，Vuzzer的插桩、污点分析和主模糊回路是基于Pin（Luk等人）实现的，与AFL相比，测试速度相对较慢。</p>
<p>Wang等人提出了数据驱动种子生成解决方案Skyfire。Skyfire通过爬取网罗上的输入，然后从中学习probabilistic context-sensitive grammar（PCSG），并利用所学知识生成结构良好的输入。实验表明，Skyfire生成的测试用例比AFL生成的测试用例覆盖了更多的代码，发现了更多的bug。研究还证明了测试用例的质量是影响模糊化效率和有效性的重要因素。</p>
<p>来自微软研究院的Godefroid等人使用基于神经网络的统计机器学习技术自动生成测试用例。具体来说，他们首先通过机器学习技术从一堆有效的输入中学习输入格式，然后利用所学的知识指导测试用例的生成。来自微软的Rajpal等人利用神经网络从过去的模糊探索中学习，并预测输入文件中哪个字节会发生变异。Nichols等人使用新一代对抗性网络（GAN）模型帮助用新的种子文件重新初始化系统。实验表明，GAN比LSTM更快、更有效，有助于发现更多的代码路径。</p>
<h4 id="how-to-select-seed-from-the-pool">How to select seed from the pool?</h4>
<p>良好的种子选择策略可以显著提高模糊效率。通过良好的种子选择策略，模糊程序可以优先选择更有用的种子，包括覆盖更多的代码和更容易触发漏洞，减少重复执行路径的浪费，节省计算资源，以最佳方式选择覆盖更深层、更易受攻击代码的种子，并帮助更快地识别隐藏的漏洞。AFL倾向于更小更快的测试用例来追求更快的测试速度。</p>
<p>Böhme等人提出了AFLFast，一种基于覆盖的灰盒模糊器。他们观察到大多数测试用例集中在相同的少数路径上。例如，在PNG处理程序中，通过随机变异生成的大多数测试用例都是无效的，并触发错误处理路径。在模糊化过程中，AFLFast测量执行路径的频率，将路径划分为高频路径和低频路径，对模糊次数较少的种子进行优先排序，并将更多的能量分配给执行低频率路径的种子。</p>
<p>Rawat等人整合静态和动态分析，以确定难以深入的路径，并优先考虑深入路径的种子。Vuzzer的种子选择策略可以帮助发现隐藏在深路径中的漏洞。</p>
<p>AFLGo（Böhme等人）和QTEP（Wang等人）采用定向选择策略。AFLGo将一些易受攻击的代码定义为目标位置，并以最佳方式选择更接近目标位置的testcase。AFLGo论文中提到了四类易受攻击的代码，包括补丁、程序崩溃缺乏足够的跟踪信息、静态分析工具验证的结果和敏感信息相关的代码片段。通过适当的定向算法，AFLGo可以在感兴趣的代码上分配更多的测试资源。QTEP利用静态代码分析来检测易出错的源代码，并对包含更多错误代码的种子进行优先级排序。AFLGo和QTEP在很大程度上依赖于静态分析工具的有效性。然而，目前静态分析工具的误报率仍然很高，无法给出准确的验证。</p>
<p>已知漏洞的特征也可用于种子选择策略。SlowFuzz（Petsios等人）针对的是算法复杂性漏洞，这种漏洞通常伴随着非常高的计算资源消耗而出现。因此，SlowFuzz更喜欢消耗更多资源（如cpu时间和内存）的种子。然而，收集消耗资源的信息会带来很大的开销，降低模糊处理的效率。例如，为了收集cpu时间，SlowFuzz计算执行的指令数。此外，SlowFuzz对资源消耗信息的准确性要求很高。</p>
<h4 id="how-to-efficiently-test-applications">How to efficiently test applications?</h4>
<p>目标应用程序由主模糊循环中的模糊程序反复启动和完成。AFL使用forkserver方法，该方法为已经加载的程序创建一个相同的克隆，并在每次运行时重用该克隆。此外，AFL还提供持久模式（persistent mode）和并行模式（parallel mode），前者有助于避免众所周知的运行缓慢的execve系统调用和链接过程的开销，后者有助于在多核系统上并行测试。Intel的处理器跟踪PT（James 2013）技术被用于内核模糊化，以节省覆盖率跟踪带来的开销。Xu等人（2017）旨在解决多核机器上并行模糊的性能瓶颈。通过设计和实现三个新的操作原语，他们表明这项工作可以大大加快最先进的模糊器，如AFL和LibFuzzer。</p>
<h3 id="techniques-integrated-in-fuzzing">Techniques integrated in fuzzing</h3>
<p>采用随机变异方法的盲模糊策略会导致大量无效测试用例，效率低下。目前最先进的模糊程序通常采用智能模糊策略，通过程序分析技术收集程序控制流和数据流信息，从而利用收集到的信息来改进测试用例的生成。智能模糊程序生成的测试用例具有更好的针对性，更能满足程序对数据结构和逻辑判断的要求。</p>
<p><img src="/png/2021-03-03-18-30-10.png"></p>
<p>上表总结了模糊化中集成的主要技术，并列出了这些技术的代表性的工作。包括：静态分析、污点分析、代码插桩、机器学习和符号执行。</p>
<h4 id="testcase-generation-1">Testcase generation</h4>
<p>机器学习技术和格式化方法被用来解决这个问题。Work（Godefroid等人2017）使用机器学习技术，特别是递归神经网络，来学习输入文件的语法，从而使用学习的语法生成符合格式的测试用例。Work（Wang等人2017）使用了格式方法，具体来说，它定义了一个probabilistic context-sensitive grammar，并提取格式知识来生成良好的格式种子输入。</p>
<p>更先进的模糊程序采用了基于变异的模糊策略。在盲变异模糊化过程中，fuzzer随机修改具有随机值或几个特殊值的种子字节，这被证明是非常低效的。在基于覆盖率的模糊化中，应该首先修改可能影响控制流传动的字节。污点分析技术用于跟踪字节对控制流的影响，以定位突变种子的关键字节（Rawat等人2017）。</p>
<p>模糊化过程在某些分支中经常被阻塞，包括验证和检查，例如魔数的验证。通过采用逆向工程和污点分析等技术扫描二进制代码，从条件判断语句中收集特殊值，并将收集到的值作为变异过程中的候选值，从而通过一些关键的验证和检查，如magic bytes和version check。微软的研究人员也尝试利用机器学习技术，如深度神经网络（DNN），根据先前的LSTM的模糊化经验，预测哪些字节发生变异，以及在变异中使用什么值。</p>
<h4 id="program-execution">Program execution</h4>
<p>在执行阶段涉及到的两个关键问题是如何引导模糊化过程以及如何探索新的路径。</p>
<p>模糊化过程通常被引导以覆盖更多的代码并更快地发现错误，因此需要路径执行信息。在基于覆盖的模糊处理中，检测技术用于记录路径执行情况和计算覆盖信息。对于有向模糊，采用模式识别等静态分析技术对目标代码进行指定和识别，使其更易受到攻击。静态分析技术也可用于收集控制流信息，例如路径深度，可作为指导策略中的另一个参考（Rawat et al.2017）。通过插桩收集的路径执行信息可以帮助指导模糊化过程。在执行信息采集中还采用了一些新的系统功能和硬件功能。Intel Processor Trace（Intel PT）是Intel processors提供的一项新功能，它可以通过触发和过滤功能公开准确而详细的活动跟踪，以帮助隔离重要的跟踪（James 2013）。Intel PT具有执行速度快、不依赖源代码等优点，可以准确、高效地跟踪执行过程。在KAFL（Schumilo et al.2017）中，该特性被用于操作系统内核的模糊化，并被证明是非常有效的。</p>
<p>测试执行的另一个关注点是探索新的路径。在程序的控制流中，模糊程序需要经过复杂的条件判断。程序分析技术包括静态分析、污点分析等，可以用来识别执行过程中的阻塞点，从而进行后续求解。符号执行技术在路径探索中具有天然的优势。通过求解约束集，符号执行技术可以计算满足特定条件要求的值。TaintScope（Wang et al.2010）利用符号执行技术来解决总是阻碍模糊化过程的校验和验证问题。Driller（Stephens等人，2016）利用concolic执行绕过条件判断，发现更深层次的bug。</p>
<h3 id="fuzzing-towards-different-applications">Fuzzing towards different applications</h3>
<h4 id="file-format-fuzzing">File format fuzzing</h4>
<p>最常用的文档文件、图像和媒体文件都是标准格式的文件。目前对模糊化的研究主要集中在文件格式的模糊化上，提出了很多模糊化工具，如Peach（PeachTech 2017）、最先进的AFL及其扩展（Rawat et al.2017；Böhme et al.2017、2017）。</p>
<p>文件格式模糊化的一个重要分支是web浏览器上的模糊化，浏览器处理的文件类型已经从传统的HTML、CSS、JS文件扩展到其他类型的文件，比如pdf、svg和其他由浏览器扩展处理的文件格式。针对web浏览器的著名模糊工具包括Grinder框架（Stephenless 2016）、COMRaider（Zimmer 2013）、BF3（Aldeid 2013）等。</p>
<h4 id="kernel-fuzzing">Kernel fuzzing</h4>
<p>操作系统内核的模糊化一直是一个困难的问题，涉及到许多挑战。首先，内核中的崩溃和挂起会导致整个系统的崩溃，如何捕获崩溃是一个问题。其次，fuzzer通常在ring3中运行，如何与内核交互是另一个问题，当前与内核通信的最佳实践是调用内核API函数。</p>
<p>通常，操作系统内核是通过随机调用带有随机生成的参数值的内核API函数来模糊化的，内核模糊器可分为两类：基于知识的模糊器和覆盖引导的模糊器。</p>
<p>基于知识的模糊器在模糊化过程中利用了关于内核API函数的知识。内核API函数调用的模糊化面临两个主要挑战：API调用的参数应具有符合API规范的随机但格式良好的值；内核API调用的顺序应看起来有效（Han和Cha 2017）。该方面代表作品包括Trinity（Jones 2010）和IMF（Han和Cha 2017）。Trinity是一个类型感知的内核模糊器。在Trinity中，测试用例是基于参数类型生成的，此外还提供了某些值的范围，以帮助生成格式良好的测试用例。IMF试图学习API执行的正确顺序和API调用之间的值依赖性，并将所学的知识用于测试用例的生成。</p>
<p>覆盖引导的内核模糊器的代表性工作包括syzkaller（Vyukov 2015）、TriforceAFL（Hertz 2015）和kAFL（Schumilo等人，2017）。Syzkaller通过编译为内核提供工具，并在一组QEMU虚拟机上运行内核。在模糊化过程中，覆盖率和安全违规都会被跟踪。TriforceAFL是AFL的一个修改版本，它通过QEMU全系统仿真支持内核模糊化。KAFL利用新的硬件特性Intel PT来跟踪覆盖率，其只跟踪内核代码。实验表明，KAFL比Triforce快40倍左右，大大提高了效率。</p>
<h4 id="fuzzing-of-protocols">Fuzzing of protocols</h4>
<p>具有代表性的协议模糊器包括SPIKE，它提供了一组工具，允许用户快速创建网络协议压力测试器。Serge Gorbunov和Arnold Rosenbloom提出了AutoFuzz（Gorbunov和Rosenbloom 2010），它通过构造一个有限状态自动机来学习协议的实现，并进一步利用所学的知识来生成测试用例。Greg Banks等人提出了SNOOZE（Banks等人，2006），它用状态模糊方法识别协议缺陷。Joeri de Ruiter的工作（de Ruiter and Poll 2015）提出了一种协议状态模糊化方法，该方法在状态机中描述TLS的工作状态，并按照逻辑流程进行模糊化处理。以前的工作通常采用有状态的方法对协议工作过程进行建模，并根据协议规范生成测试用例。</p>
<h2 id="fuzzing-state-of-the-art">Fuzzing: State of the Art</h2>
<p><a href="https://wcventure.github.io/FuzzingPaper/Paper/TRel18_Fuzzing.pdf" target="_blank" rel="noopener">在线pdf</a>.</p>
<h3 id="state-of-the-art-in-fuzzing">STATE OF THE ART IN FUZZING</h3>
<h4 id="seeds-generation-and-selection">Seeds Generation and Selection</h4>
<p>Rebert等人测试了六种选择算法：</p>
<ol type="1">
<li>Peach的集覆盖算法。</li>
<li>一种随机种子选择算法。</li>
<li>最小集覆盖（与minset相同，可通过贪心算法计算）。</li>
<li>按种子大小加权的最小集覆盖。</li>
<li>按执行时间加权的最小集覆盖。</li>
<li>一个hotset算法（fuzz对每个种子文件进行t秒的测试，根据发现的唯一bug的数量对它们进行排序，并返回列表中最前面的几个种子文件）。</li>
</ol>
<p>通过在Amazon弹性计算云上花费650个CPU日来对10个应用程序进行fuzzing，他们得出了以下结论。</p>
<ol type="1">
<li>采用启发式算法的算法性能优于完全随机抽样。</li>
<li>在这六种算法中，无权minset算法的性能最好。</li>
<li>在实践中，缩减的种子文件集比原始种子文件集的执行效率更高。</li>
<li>缩减的种子集可以应用于解析同一文件类型的不同应用程序。</li>
</ol>
<p>Kargen和Shahmehri声称，通过对生成程序的机器代码执行突变，而不是直接对格式良好的输入执行突变，得到的测试输入更接近被测试程序所期望的格式，从而产生更好的代码覆盖率。</p>
<p>为了测试复杂的软件（例如，PDF阅读器），Liang等人利用字体文件的结构信息来选择其中属于异类字体的种子文件。</p>
<p>Skyfire接受一个种子输入库和语法，并使用大量现有样本中的知识为处理高度结构化输入的模糊程序生成分布良好的种子输入。</p>
<p>有一种算法，在给定一个程序和一个种子输入的情况下，最大限度地增加黑盒变异模糊的bug。其主要思想是利用符号分析对程序种子对的执行轨迹进行分析来获得种子各个位之间的依赖关系，然后使用这种依赖关系来计算该程序种子对的概率最优变异率。</p>
<p>考虑到模糊化是概率分析中coupon collector’s problem的一个实例，Arcuri等人提出并证明了随机测试抽样的预期测试用例数的非平凡的最优下界，以覆盖预定义的目标，尽管在实践中如何实现界目标还没有给出。</p>
<h4 id="input-validation-and-coverage">Input Validation and Coverage</h4>
<p>完整性验证：如果输入存在校验和机制，则普通的变异将导致输入无法通过验证。</p>
<p>Wang等人提出了一种新的方法来解决这个问题，并开发了一个名为TaintScope的模糊程序。TaintScope首先使用动态污点分析和预定义规则来检测可能污染目标程序中敏感应用程序编程接口（api）的潜在校验和点和热输入字节。然后，它变异热字节来创建新的测试用例，并更改校验和点，让所有创建的测试用例通过完整性验证。最后，通过符号执行和约束求解，确定了导致目标程序崩溃的测试用例的校验和值。通过这种方式，它可以创建既能通过完整性验证又能导致程序崩溃的测试用例。</p>
<p>给定一组样本输入，Hoschele和Zeller使用动态污点跟踪每个输入字符的数据流，并将这些输入片段聚合成词汇和语法实体。结果得到了反映有效输入结构的上下文无关文法，为以后的模糊化过程提供了帮助。为了减轻基于覆盖率的模糊程序对进行魔数检测的路径的限制，Steelix利用轻量级静态分析和二进制插桩，不仅向模糊程序提供覆盖率信息，还向模糊程序提供比较进度信息。这样的程序状态信息将告诉模糊程序魔数在测试输入中的位置，以及如何执行突变以有效地匹配魔术字节。</p>
<p>格式验证：网络协议、编译器、解释器等对输入格式有严格的要求，不符合格式要求的输入将在程序执行开始时被拒绝，这个问题的大多数解决方案是利用输入特定的知识或语法。</p>
<p>Ruiter和Poll评估了九种常用的传输层安全（transport layer security，TLS）协议的实现，它们使用黑盒模糊技术结合状态机学习。他们提供了一个抽象消息列表（也称为输入字母表），可以通过测试线束将其转换为发送到被测试系统的具体消息。Dewey等人提出了一种通过约束逻辑编程（CLP）生成使用复杂类型系统的井式程序的新方法，并将其应用于生成Rust或JavaScript程序。Cao等人首先调查了Android系统服务的输入验证情况，并针对Android设备构建了一个输入验证漏洞扫描器。这个扫描器可以创建半有效的参数，这些参数可以通过目标系统服务方法实现的初步检查。</p>
<p>环境验证：只有在特定环境下（即特定配置、特定运行时状态/条件等），许多软件漏洞才会暴露出来。</p>
<p>Dai等人提出了一种配置模糊技术，正在运行的应用程序的配置会在某些执行点发生变化，以检查只有在某些情况下才会出现的漏洞。FuzzDroid还可以自动生成一个Android执行环境，在该环境中，应用程序会暴露其恶意行为。FuzzDroid通过一种基于搜索的算法，将一组可扩展的静态和动态分析结合起来，将应用程序导向一个可配置的目标位置。</p>
<p>输入覆盖率：Tsankov等人定义了半有效输入覆盖（SVCov），这是模糊测试的第一个覆盖标准。只要有效输入可以由一组有限的约束定义，该准则就适用。</p>
<p>通过增加SVCov下的覆盖率，他们在一个成熟的Internet密钥交换（IKE）实现中发现了一个以前未知的漏洞。为了解决现有语法推理算法的严重缓慢和过度泛化的缺点，Bastani等人提出了一种合成无上下文语法的算法，该算法从一组输入示例和对程序的黑盒访问中对有效程序输入的语言进行编码。与许多通过目标程序崩溃来确定输入是否有效的方法不同，ArtFuzz旨在捕捉非崩溃缓冲区溢出漏洞。它利用类型信息并动态地发现可能的内存布局来帮助模糊化过程。如果超出内存布局中标识的缓冲区边界，则会报告错误。</p>
<p>Groce等人提出了一种低成本和有效的方法，称为swarm testing，通过增加（随机生成的）测试用例的多样性提高效率，该方法使用不同的测试配置群，每种配置都故意省略某些API调用或输入特性。此外，为了减轻无法专注于被测系统的一部分，定向群测试利用群测试并记录过去测试结果的统计数据，生成针对任何给定源代码元素的新随机测试。根据观察，开发人员有时会在提交的补丁中附带一个测试用例，该测试用例可以部分地执行新代码，并且该测试用例可以很容易地用作符号探索的起点，Marinescu和Cadar提供了一种自动生成测试套件的方法，以实现软件补丁的高覆盖率。</p>
<h4 id="handling-crash-inducing-test-cases">Handling Crash-Inducing Test Cases</h4>
<p>考虑到大量的测试用例集合，每一个都可能引发程序错误，Chen等人提出了一种基于排名的方法，通过这种方法，引入差异的测试用例将排在列表的首位。与传统的聚类方法相比，这种基于排序的方法更为实用。因此，测试人员可以专注于分析顶级碰撞诱发测试用例。除了直接过滤崩溃诱导测试用例外，还有其他一些方法可以帮助减少昂贵的手工工作，例如生成独特的崩溃诱导测试用例、修剪测试用例和提供有用的调试信息。</p>
<p>崩溃诱导测试用例的唯一性可以通过目标线程的调用堆栈和导致错误的指令的地址来确定，如果两个不同的测试用例导致目标程序以相同的调用堆栈崩溃，则这两个测试用例很可能对应同一个bug，因此，只需保留其中一个用于手动分析。相反，如果它们导致目标程序在同一位置崩溃，但堆栈跟踪不同，则它们很可能对应两个不同的错误，因此两者都值得单独分析。与记录调用堆栈相比，跟踪执行路径是确定唯一性的更简单但更不可靠的方法。AFL是最流行的fuzzer之一，如果发现一个新的路径或者没有找到一个公共路径，它会将一个导致崩溃的测试用例视为唯一的。这种易于实现的方法类似于执行路径记录方法。</p>
<p>在模糊化过程中，定期对生成的测试用例进行裁剪，可以提高整体效率，从而减少人工分析碰撞诱导测试用例的工作量。修剪的原则很简单：被处理的对象的行为应该与原始对象相同；换句话说，它们应该遵循相同的执行路径。修剪的一般步骤是依次从测试用例中删除数据块并重新评估测试用例的其余部分；那些不能影响执行路径的数据块将被修剪。</p>
<p>评估模糊输出的可利用性通常需要代码分析和调试工作，这些工作可以受益于专用工具，如GDB、Valgrind、AddressSanitizer等。这些工具提供目标程序的运行时上下文（如调用堆栈和寄存器的状态、故障诱导指令的地址等），或者可以检测特定类型的程序错误，如内存错误，在工具的帮助下测试人员能够更有效地发现和评估程序错误。此外，Pham等人提出了一种生成到达给定潜在崩溃位置的输入的方法。</p>
<h4 id="leveraging-runtime-information">Leveraging Runtime Information</h4>
<p>符号执行和动态污点分析经常被用来使模糊化变得更有效，因为它们可以提供大量的运行时信息（如代码覆盖率、污点数据流）并帮助模糊化发现隐藏的bug，然而这也阻碍了模糊化追求更高的效率。</p>
<p>路径爆炸是符号执行中一个固有的也是最困难的问题，因为目标程序中的条件分支通常非常多，即使是一个小规模的应用程序也会产生大量的执行路径。</p>
<p>从程序分析方法和路径搜索算法两个方面，研究了几种常见的改善方法。</p>
<ul>
<li>函数摘要用于描述低级函数的属性，以便高级函数可以重用它们以减少执行路径的数量。</li>
<li>冗余路径剪枝用于避免执行那些与某些先前覆盖的路径具有相同副作用的路径。例如，Boonstoppel等人提出了一种通过跟踪目标程序执行的读写操作来检测和丢弃大量冗余路径的技术。这种技术背后的主要思想是，如果一条路径在与一些先前探索的路径相同的条件下到达一个程序点，那么导致相同后续效果的路径就可以被剪除。</li>
<li>合并不同路径上获得的状态也可以减少路径搜索空间，但这种方法加重了求解器的负担。</li>
<li>随机路径选择和自动部分循环摘要在实践中被证明是成功的，主要是因为它们避免了在遇到一些可以快速创建新状态的紧循环时被卡住。</li>
<li>另一个例子是控制流图（CFG）定向路径选择，它利用静态控制流图来指导测试用例生成，以探索最近的未覆盖分支。</li>
<li>代际搜索会探索每个扩展执行的所有子路径，对它们进行评分，最后为下一个执行选择一个得分最高的路径。</li>
<li>考虑到现有的基于覆盖率的灰盒模糊工具访问了高密度区域中过多的状态，Bohme等人提出并实施了几种策略，通过访问更多隐藏在低密度区域中的状态，迫使AFL为高密度区域中的状态生成较少的输入。</li>
<li>为了缓解路径爆炸问题，DeepFuzz为执行路径分配了概率，并应用了一种新的搜索启发式算法，该算法可以有效地延迟路径爆炸进入被测二进制文件的更深层。</li>
<li>给定一组现有的测试用例，Zhang等人利用测试用例缩减和优先级排序方法来提高种子符号执行的效率，目标是尽快获得增量覆盖。</li>
</ul>
<p>符号执行的不精确性主要是由复杂的程序结构（如指针）建模、库或系统调用以及约束求解引起的。为了使符号执行切实可行，需要在上述区域中执行一些简化方法。开发人员的关键是在可扩展性和精确性之间找到一个平衡点。</p>
<p>CUTE简化了指针操作，在处理符号指针变量时只考虑等式和不等式谓词。在KLEE中，指针被视为数组。当指针p间接引用N个对象时，KLEE将当前状态复制N次，并且在每个状态下，它在p不超出相应对象的边界的前提下执行正确的读或写操作。对于库或者系统调用等源代码中不存在的符号值它将使用具体的值代替。此外，约束求解还加入了大量的约束优化（例如Sage使用无关约束限制、本地约束缓存、翻转计数限制等，以提高生成约束时的内存使用率和速度）甚至是输入语法（例如Godefroid等人提出了一种通过符号执行直接生成基于输入语法的约束的方法，这些约束的可满足性将通过一个定制的约束求解器进行验证，该求解器还利用了输入语法，因此可以生成高度结构化的输入）。</p>
<p>为了对可能导致符号执行不精确的浮点代码进行模糊测试，Godefroid和Kinder结合了轻量级局部路径不敏感的浮点指令可能静态分析和高精度全程序路径敏感的非浮点指令必须动态分析。Fu和Su把测试浮点代码的问题变成了在整个搜索空间中应用无约束规划计算函数最小点的解的问题。他们从浮点代码中导出了一个表示函数，其中任何一个最小点都是一个测试输入，保证执行被测试程序的一个新分支。</p>
<p>当隐式数据流中的数据传输与控制流、数组操作等被完全忽略时，就会发生Undertainting。在从纯文本格式到富文本格式的转换期间，输入变量的值被转移到输出数组中，而不需要直接赋值，因此分析会不完全。Kang等人在解决这个问题上取得了进展。根据他们的实验，所有隐式数据流的污点传播也会导致不可接受的大覆盖，他们只关注完全保持信息的隐式流的污染传播。</p>
<p>当污染传播没有以更细粒度的粒度实现时，就会发生Overtainting。它会引起taint explosion和false positive。Yadegari等人提出了一种在比特级实现污点传播的方法缓解问题。另一种解决此问题的方法是使用欠近似检查存在的for some path属性。Godefroid提出了一种新的测试生成方法，其中测试是从一阶逻辑公式的有效性证明中派生出来的，而不是像大多数现有方法那样满足无量词一阶逻辑公式的赋值。</p>
<h4 id="scalability-in-fuzzing">Scalability in Fuzzing</h4>
<p>面对现实世界中应用程序的规模和复杂性，现代模糊程序要么是可扩展但不能有效地探测目标程序中更深层次的bug；要么是不可扩展但能够深入某一类应用程序。</p>
<p>一些方法利用了应用程序感知模糊或云服务方法的模糊来解决这个问题。Rawat等人提出了一种应用程序感知的进化模糊策略，它不需要任何应用程序或输入格式的先验知识。为了最大化覆盖范围并探索更深的路径，他们利用基于静态和动态分析的控制流和数据流功能来推断应用程序的基本属性，这使得与应用程序无关的方法相比，能够更快地生成感兴趣的输入。</p>
<p>提高可扩展性的一种方法是缩小分析范围。回归分析是一个众所周知的例子，其中程序版本之间的差异是缩小分析范围的基础。DiSE结合了两个阶段：静态分析和符号执行。受影响的程序指令集在第一阶段生成。静态分析生成的信息随后被用于指导符号执行，以仅探索受更改影响的程序部分，从而潜在地避免大量未受影响的执行路径。</p>
<p>要以可扩展的方式测试移动应用程序，每个测试输入都需要在各种上下文中运行，例如：设备异构性、无线网络速度、位置和不可预测的传感器输入。每个上下文的值范围（例如位置）可能非常大。Liang等人介绍了Caiipa，这是一种云服务，用于以可扩展的方式在扩展的移动上下文空间上测试应用程序，并在虚拟机和真实设备集群上实现，可以模拟移动应用程序的各种上下文组合。移动漏洞发现管道（MVDP）也是一个针对Android和iOS设备的分布式黑盒模糊系统。</p>
<h3 id="tools-in-different-application-areas">TOOLS IN DIFFERENT APPLICATION AREAS</h3>
<p><img src="/png/2021-03-03-21-47-15.png"></p>
<p><img src="/png/2021-03-03-22-21-41.png"></p>
<h4 id="general-purpose-fuzzers">General Purpose Fuzzers</h4>
<p>Peach是一种众所周知的通用模糊器，其最常见的目标是驱动程序、文件解析器、网络协议、嵌入式设备、系统等。它由以下组件构成：Peach Pits，预定义的输入格式定义，可以作为单个Pit或一组相关的Pits使用；test passes，可以加权变异子以执行更多的测试用例；minset，有助于减少测试用例覆盖率的文件计数。Peach在这方面起着关键的作用，因为它有许多突出的特性，比如威胁检测、现成的模糊定义（Peach-Pits）和可扩展的测试选项。但是，Peach中也存在一些问题（特别是在开源版本中）。一个主要问题是，使用Peach提供的语法来描述目标文件格式，构建Pit文件非常耗时。基于Peach，eFuzz测试了基于通信协议DLMS/COSEM（欧洲使用的标准协议）的智能计量装置是否存在可能的故障。Honggfuzz也是基于Peach的。</p>
<p>beSTORM是一个商业黑盒模糊器。它可以用来测试目标应用程序的安全性或者检查联网软硬件产品的质量。beSTORM采用的模糊化策略是首先测试可能的、常见的故障诱导区域，然后扩展到几乎无限的攻击变化范围；因此它可以快速交付结果。beSTORM可用于协议、应用程序、硬件、文件、WIFI和嵌入式设备安全保证（EDSA）的测试。例如，它能够在实现edsa402标准的应用程序中发现bug。</p>
<h4 id="fuzzers-for-compilers-and-interpreters">Fuzzers for Compilers and Interpreters</h4>
<p>jsfunfuzz是一个基于语法的黑盒模糊器，专为Mozilla的SpiderMonkey JavaScript引擎设计。它是第一个公开的JavaScript fuzzer。自2007年开发以来，它在SpiderMonkey中发现了2000多个bug。它将差异测试与目标应用程序的详细知识结合起来；因此，它可以有效地发现不同JavaScript引擎中与正确性相关的bug和崩溃触发bug。但是，对于每一个新的语言特性，jsfunfuzz都必须调整自己以响应模糊化过程中的新特性。</p>
<p>Csmith由Yang等人于2011年提出，它是一个编译器，它根据C99标准对随机生成的具有指定语法的C程序进行编译。它利用随机差异测试来帮助发现由潜在的未定义行为和其他特定于C的问题引起的错误。Csmith已经使用多年，并且在商业和开源C编译器（例如GNU编译器集合GCC、低级虚拟机LLVM）中发现了数百个以前未知的bug。它是一个开源项目。尽管Csmith是一个实用的fuzzer，它擅长生成错误诱导测试用例，但它并不像其他fuzzer那样，根据重要性对发现的bug进行优先级排序。因此，测试人员必须花费大量时间来确定每个bug的新颖性和严重性。</p>
<p>Holler等人在2012年提出了LangFuzz。LangFuzz并不针对特定的语言。到目前为止，它已经在JavaScript和超文本预处理器（PHP）上进行了测试。在应用到JavaScript引擎之后，LangFuzz在SpiderMonkey中发现了500多个以前未知的bug。应用于PHP解释器，它还发现了18个可能导致崩溃的新缺陷。LangFuzz使用随机生成和代码变异两种方法来创建测试用例，但将变异作为主要技术。它被设计成一个独立于语言的模糊器，但是要使它适应一种新的语言需要一些必要的改变。</p>
<p>Lidbury等人提出了CLsmith，利用随机差分测试和等价模输入（EMI）测试对许多核心编译器进行模糊化，并发现和报告了50多个OpenCL编译器错误，这在商业实现中是最多的。具体来说，他们对多核环境进行随机差分测试，以生成确定性的、可通信的、功能丰富的OpenCL内核，并提出和评估了dead-by-construction代码的注入，以便在OpenCL环境下进行EMI测试。</p>
<p>这一类的其他Fuzzer包括MongoDB的JavaScript Fuzzer，它在两个发布周期内检测到了近200个bug；Ifuzzer是另一个使用遗传编程的JavaScript解释器Fuzzer。</p>
<h4 id="fuzzers-for-application-software">Fuzzers for Application Software</h4>
<p>SAGE是由微软开发的著名的白盒模糊器。它用于模糊x86平台上运行的大型文件读取应用程序（如DocumentParser、MediaPlayer、图像处理器等）。结合concolic执行和启发式搜索算法，最大限度地提高代码覆盖率。如今，微软正在推广一个名为Springfield的在线模糊化项目。它提供了多种方法，包括微软的白盒模糊技术来发现客户上传的二进制程序中的错误。SAGE的未来工作包括改进其搜索方法、提高其符号执行的精度以及提高其约束求解能力以发现更多错误。</p>
<p>AFL是一个著名的基于代码覆盖率模的糊器。它通过代码插桩收集运行时路径覆盖率的信息。对于开源应用程序，插桩是在编译时引入的，对于二进制文件，插桩是在运行时通过修改的QEMU引入的。能够探索新的执行路径的测试用例有更多的机会在下一轮的变异中被选择。实验结果表明，AFL能够有效地发现实际用例中的错误，如文件压缩库、常见图像解析等。AFL支持C、C++、Objor C或可执行程序，并在Linux上像OS一样工作。此外，还有一些扩展AFL应用场景的工作，如TriforceAFL用于模糊内核系统调用，WinAFL将AFL移植到Windows，ORACLE使用AFL模糊一些文件系统。虽然AFL是高效和易于使用的，但仍有改进的空间。与许多其他暴力模糊器一样，当实际输入数据被压缩、加密或与校验和绑定时，AFL提供了有限的代码覆盖率。此外，AFL在处理64位二进制文件时需要更多的时间，不支持直接对网络服务进行模糊化。</p>
<p>QuickFuzz利用Haskell的QuickCheck（著名的基于属性的随机测试库）和Hackage（社区Haskell软件库）以及现成的位级变异模糊器，为十几种常见的文件格式提供自动模糊化，没有提供外部输入文件集，也没有为所涉及的文件类型开发模型。QuickFuzz混合使用基于语法和基于变异的模糊技术来发现目标应用程序中的意外行为，从而生成无效输入。</p>
<p>为了测试服务器端软件，Davis等人提出Node.fz，它为事件驱动程序设置了模糊程序，具体体现为服务器端Node.js程序。Node.fz随机干扰执行Node.js程序，允许Node.js开发人员探索各种可能的时间表。这类工作还包括Dfuzzer，它是D-bus服务的模糊程序。</p>
<p>为了测试移动应用程序，近年来出现了一些模糊程序，如Droid FF、memory-leak fuzzer、DroidFuzzer、intent fuzzer和Android应用程序的Android Ripper MFT工具。</p>
<h4 id="fuzzers-for-network-protocols">Fuzzers for Network Protocols</h4>
<p>Sulley是一个针对网络协议的开源模糊框架。它利用一种基于块的方法来生成单独的请求，它为用户提供了构建协议描述所需的大量数据格式。在测试之前，用户应该使用这些格式来定义所有必要的块，这些块将在模糊过程中进行变异和合并，以创建新的测试用例。Sulley可以对检测到的故障进行分类，并行工作，并跟踪到触发故障的测试用例的唯一序列。但是，目前没有得到很好的维护。Boofuzz是Sulley的继任者。</p>
<p>Somorovsky提出了TLS-Attacker，一个用于评估TLS库安全性的开源框架。TLS-Attacker允许安全工程师创建定制的TLS消息流，并通过使用简单的接口来测试其库的行为，任意修改消息内容。它成功地在广泛使用的TLS库中发现了几个漏洞，包括OpenSSL、Botan和MatrixSSL。</p>
<p>T-Fuzz是一个基于模型的模糊器，用于电信协议的健壮性测试，Secfuzz用于IKE协议，SNOOZE和KiF都用于VOIP/SIP协议。</p>
<h4 id="fuzzers-for-os-kernels">Fuzzers for OS Kernels</h4>
<p>近年来，Trinity在内核模糊化领域得到了广泛的关注。其用于生成系统调用参数的方法如下所述：如果系统调用期望某个数据类型作为参数（如描述符），则传递一个参数；如果系统调用仅接受某个值作为参数（如flag字段），则它具有可传递的所有有效标志的列表；如果系统调用只接受一个范围的值，则传递给参数的随机值通常适合该范围。Trinity支持多种体系结构，包括x86-64、SPARC-64、S390x、S390、PowerPC-64、PowerPC-32、MIPS、IA-64、i386、ARM、Aarch64和Alpha。</p>
<p>Syzkaller是另一个针对Linux内核的fuzzer。它依赖于预定义的模板，这些模板指定每个系统调用的参数域。与Trinity不同，它还利用代码覆盖率信息来指导模糊化过程。因为Syzkaller结合了覆盖率引导和基于模板的技术，所以它确实比仅提供用于系统调用的参数使用模式更好。这一工具正在积极开发中，但早期的结果令人印象深刻。</p>
<p>IOCTL Fuzzer是一个设计用于自动搜索Windows内核驱动程序漏洞的工具。目前，它支持Windows7（x32和x64）、2008Server、2003Server、Vista和XP。如果IOCTL操作符合配置文件中指定的条件，fuzzer将用随机生成的数据替换其输入字段。</p>
<p>Schumilo等人以独立于操作系统和硬件辅助的方式提出了覆盖率引导的内核模糊化。它们利用hypervisor来产生覆盖率，利用Intel的处理器跟踪技术来提供运行代码的控制流信息。他们开发了一个名为Kernel-AFL(kAFL)的框架来评估Linux、MacOS和Windows内核组件的可靠性或安全性。在众多的崩溃中，他们发现了Linux的ext4驱动程序、MacOS的HFS和APFS文件系统以及Windows的NTFS驱动程序中的一些缺陷。</p>
<p>为了发现COTS操作系统的漏洞，Kim等人提出了CAB-FUZZ，这是一种实用的concolic testing工具，用于探索最有可能触发bug的相关路径。这种模糊优先考虑数组和循环的边界状态，并开发与COTS操作系统交互的真实程序，以构造适当的上下文，从而在没有调试信息的情况下探索深层和复杂的内核状态。它在Windows7和WindowsServer2008中发现了21个未公开的独特崩溃，包括三个关键漏洞。这些发现的漏洞中有5个已经存在了14年，甚至在Windows XP的初始版本中也可能被触发。</p>
<h4 id="fuzzers-for-embedded-devices-drivers-and-components">Fuzzers for Embedded Devices, Drivers and Components</h4>
<p>Kim等人提出了使用API级别的concolic testing自动生成模糊语法，并实现了一个工具（名为YMIR）来自动对ActiveX控件进行白盒模糊测试。它将ActiveX控件作为输入，并将模糊语法作为输出。API级别的concolic测试在库函数级别而不是指令级别收集约束，因此可能更快、更不准确。</p>
<p>vUSBf首次在2014年欧洲Black Hat上提出。它是一个模糊USB驱动程序的框架。该框架实现了一个基于内核虚拟机（Linux）和QEMU的USB重定向协议的虚拟USB模糊器。它允许使用简单的XML配置动态定义数百万个测试用例。每项测试都使用独特的标识进行标记，因此是可重复的。它可以触发Linux内核和设备驱动程序中的以下错误：空指针取消引用、内核分页请求、内核死机、错误页状态和分段错误。在这一领域还有一些其他的工作，比如VDF，一个经济高效的USB测试框架，针对虚拟设备的进化模糊器。</p>
<blockquote>
<p>Besides the aforementioned fuzzers, there are also many other practical tools, including perf_fuzzer for perf_event_open() system call, libFuzzer for library, Modbus/TCP Fuzzer for internetworked industrial systems, a fuzzer for I/O buses, a fuzzer for digital certificates, Gaslight for memory forensics frameworks, etc. Moreover, along with memory error detectors (e.g., Clang’s AddressSanitizer, MemorySanitizer, etc.), fuzzers can be reinforced to expose more hidden bugs rather than shallow bugs.</p>
</blockquote>
<h3 id="future-directions-1">FUTURE DIRECTIONS</h3>
<h4 id="input-validation-and-coverage-1">Input Validation and Coverage</h4>
<p>许多研究针对这个问题并取得了令人印象深刻的进展，例如针对字符串错误，针对整数错误，针对电子邮件过滤器，以及针对缓冲区错误。该领域的开放性问题包括处理FP操作（例如，Csmith，著名的C编译器fuzzer，不生成FP程序），将现有技术应用于其他语言（例如，将CLP应用于C语言）等。此外，Rawat等人证明，通过分析应用程序行为推断输入属性是一种可行的方法以及可扩展的策略来提高模糊性能，也是该领域未来研究的一个很有前途的方向。</p>
<h4 id="smart-fuzzing">Smart Fuzzing</h4>
<p>许多其他的程序分析技术被合并到智能模糊化中，例如concolic执行、动态污点分析等等。这些技术虽然带来了许多好处，但也带来了一些问题：如路径爆炸、concolic testing中的符号执行不精确以及动态污染分析中的undertainting，overtainting等。此外，以一种可扩展和有效的方式进行模糊化仍然是一个挑战。Bounimova等人提出了大规模运行白盒模糊化的关键挑战，包括符号执行、约束生成和求解、长运行状态空间搜索、多样性、容错性和始终使用等方面的挑战。这些问题都值得深入研究。</p>
<h4 id="filtering-fuzzing-outputs">Filtering Fuzzing Outputs</h4>
<p>在软件开发生命周期中，修复bug的时间和预算通常是有限的。因此，开发人员主要关心的是如何解决这些约束条件下的严重缺陷。例如，Podgurski等人提出了对报告的软件故障进行分类的自动化支持，以便于确定故障优先级和诊断故障原因。Zhang等人提出了基于测试用例相似度度量的测试用例选择方法，以探索深层程序语义。差异测试可能有助于确定评估测试结果的成本。总之，目前对从大量模糊输出中过滤出更重要的故障诱导测试用例的研究很少。这一研究方向具有重要的现实意义。</p>
<h4 id="seedinput-generation-and-selection">Seed/Input Generation and Selection</h4>
<p>模糊化的结果与种子/输入文件的质量有关。因此，如何选择合适的种子文件来发现更多的bug是一个重要的问题。Pacheco等人提出了一种反馈导向的随机测试生成技术，其中执行预先设计的输入，并对照一组契约和过滤器进行检查。执行的结果决定了输入是冗余的、非法的、违反合同的还是对生成更多输入有用的。然而，在大量的实验中，Arcuri和Briand表明，ART在计算测试用例之间的距离时，即使是在一些琐碎的问题上也是非常低效的。Classfuzz使用一组预定义的变异算子对种子类文件进行变异，采用马尔可夫链蒙特卡罗抽样来指导变异算子的选择，并将覆盖唯一性作为接受代表性变异算子的准则。Shastry等人提出通过静态分析程序控制和数据流来自动构建输入字典，并将输入字典提供给现成的fuzzer来影响输入生成。设计和实现更有效、更合理、更准确的种子生成和选择算法是一个开放的研究问题。</p>
<h4 id="combining-different-testing-methods">Combining Different Testing Methods</h4>
<p>黑盒和白盒/灰盒模糊方法各有优缺点。因此，如何将这些技术结合起来，构建一个既有效又高效的模糊器是一个有趣的研究方向。在这方面有一些尝试，例如，symfush使用白盒技术增强了基于黑盒突变的模糊化，这有助于根据给定的程序种子对计算最佳突变率。从微观角度看，SYMFUZZ有两个主要步骤来生成测试用例，每个步骤使用不同的模糊技术，即白盒模糊和黑盒模糊。然而，从宏观上看，这种方法也可以看作是灰盒模糊。由于其黑盒模糊过程的变异率是在白盒模糊过程中计算出来的，因此整个模糊过程利用了目标程序的部分知识，可视为灰盒模糊。将模糊技术与其他测试技术相结合也是一个有趣的方向。Chen等人报道了变质测试，这是一种相对较新的测试方法，它可以从多个程序执行的输入和输出中发现以前未知的错误，表明使用不同的视角和多种方法相结合可以帮助软件测试获得更高的可靠性或安全性。Garn和Simos展示了一种综合的方法的适用性，该方法利用组合测试和模糊技术对Linux内核的系统调用接口进行测试。</p>
<h4 id="combining-other-techniques-with-fuzzing">Combining Other Techniques With Fuzzing</h4>
<p>fuzzer受到测试覆盖范围和合适测试用例可用性的限制。由于静态分析可以对易受攻击的代码模式执行更广泛的搜索，从fuzzer发现的少数程序故障开始，Shastry等人实现了一个简单但有效的匹配排序算法，该算法使用测试覆盖率数据将注意力集中在包含未测试代码的匹配上，并演示了静态分析可以有效地完成模糊化。静态分析技术，如符号执行和控制/数据流分析，可以为模糊化提供有用的结构信息；然而，模糊化的符号执行有一些局限性，因此留下了一些开放的问题：只检查泛型属性，没有发现与指定行为的许多偏差；许多程序并不完全服从符号执行，因为它们会产生硬约束，使得程序的某些部分仍然没有被发现。Havrikov提出了一种组合方法，通过这种方法，模糊可以从不同的轻量级分析中获益。分析利用了目标程序之外的多个信息源，例如输入和执行（例如，以扩展上下文无关语法的形式描述目标输入格式）或硬件计数器。</p>
<p>机器学习技术有助于为基于语法的模糊化自动生成输入语法。优化理论也可以用来建立有效的模糊搜索策略。在一些研究中使用了遗传规划或算法来指导他们的模糊程序。Dai等人提出了一种新的UI模糊技术，旨在运行应用程序，从而可以执行不同的执行路径，这种方法要求测试人员构建一个全面的网络配置文件。我们相信，在改进现有的组合方法和利用其他模糊技术方面仍有一定的空间。</p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/fuzz/" rel="tag"><i class="fa fa-tag"></i> fuzz</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/2cb5ce06/" rel="next" title="IS-crypto-非对称加密-RSA的攻击方式">
                <i class="fa fa-chevron-left"></i> IS-crypto-非对称加密-RSA的攻击方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/ed03f22a/" rel="prev" title="CS-BASIC-compiler-principles-属性文法和语法制导翻译">
                CS-BASIC-compiler-principles-属性文法和语法制导翻译 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/apple-touch-icon.png" alt="w4rd3n">
            
              <p class="site-author-name" itemprop="name">w4rd3n</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">174</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/hitworld" title="GitHub &rarr; https://github.com/hitworld" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#fuzzing-challenges-and-reflections"><span class="nav-number">1.</span> <span class="nav-text">Fuzzing: Challenges and Reflections</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#blackbox-fuzzing"><span class="nav-number">1.1.</span> <span class="nav-text">Blackbox fuzzing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#greybox-fuzzing"><span class="nav-number">1.2.</span> <span class="nav-text">Greybox fuzzing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#whitebox-fuzzing"><span class="nav-number">1.3.</span> <span class="nav-text">Whitebox fuzzing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#other-fuzzing-tools"><span class="nav-number">1.4.</span> <span class="nav-text">Other fuzzing tools</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#challenges"><span class="nav-number">1.5.</span> <span class="nav-text">Challenges</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#automation"><span class="nav-number">1.5.1.</span> <span class="nav-text">Automation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#c.1-more-software.-how-can-we-fuzz-efficiently-more-types-of-software-systems"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">[C.1] More Software. How can we fuzz efficiently more types of software systems?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c.2-more-bug-types.-how-can-the-fuzzer-identify-more-types-of-vulnerabilities"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">[C.2] More Bug Types. How can the fuzzer identify more types of vulnerabilities?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c.3-more-difficult-bugs.-how-can-we-find-deep-bugs-for-which-efficient-oracles-exist-but-which-nevertheless-evade-detection"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">[C.3] More Difficult Bugs. How can we find &quot;deep bugs&quot; for which efficient oracles exist, but which nevertheless evade detection?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c.4-more-empirical-studies.-what-is-the-nature-of-vulnerabilities-that-have-evaded-discovery-despite-long-fuzzing-campaigns"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">[C.4] More Empirical Studies. What is the nature of vulnerabilities that have evaded discovery despite long fuzzing campaigns?</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#the-human-component"><span class="nav-number">1.5.2.</span> <span class="nav-text">The Human Component</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#c.5-human-in-the-loop.-how-can-fuzzers-leverage-the-ingenuity-of-the-auditor"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">[C.5] Human-In-The-Loop. How can fuzzers leverage the ingenuity of the auditor?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c.6-usability.-how-can-we-improve-the-usability-of-fuzzing-tools"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">[C.6] Usability. How can we improve the usability of fuzzing tools?</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzing-theory"><span class="nav-number">1.5.3.</span> <span class="nav-text">Fuzzing Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#c.7-how-can-we-assess-residual-security-risk-if-the-fuzzing-campaign-was-unsuccessful"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">[C.7] How can we assess residual security risk if the fuzzing campaign was unsuccessful?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c.8-what-are-the-theoretical-limitations-of-blackbox-greybox-and-whitebox-fuzzing"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">[C.8] What are the theoretical limitations of blackbox, greybox, and whitebox fuzzing?</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#evaluation-and-benchmarks"><span class="nav-number">1.5.4.</span> <span class="nav-text">Evaluation and Benchmarks</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sok-the-progress-challenges-and-perspectives-of-directed-greybox-fuzzing"><span class="nav-number">2.</span> <span class="nav-text">SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#introduction"><span class="nav-number">2.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#background"><span class="nav-number">2.2.</span> <span class="nav-text">Background</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#terminology"><span class="nav-number">2.2.1.</span> <span class="nav-text">Terminology</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#coverage-guide-greybox-fuzzing"><span class="nav-number">2.2.2.</span> <span class="nav-text">Coverage-guide Greybox Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#directed-greybox-fuzzing"><span class="nav-number">2.2.3.</span> <span class="nav-text">Directed Greybox Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#difference-between-cgf-and-dgf"><span class="nav-number">2.2.4.</span> <span class="nav-text">Difference between CGF and DGF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#application-of-dgf"><span class="nav-number">2.2.5.</span> <span class="nav-text">Application of DGF</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#assessment-of-the-state-of-the-art-works"><span class="nav-number">2.3.</span> <span class="nav-text">Assessment of the-state-of-the-art Works</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#directed-type"><span class="nav-number">2.3.1.</span> <span class="nav-text">Directed Type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#input-optimization"><span class="nav-number">2.3.2.</span> <span class="nav-text">Input Optimization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seed-prioritization"><span class="nav-number">2.3.3.</span> <span class="nav-text">Seed Prioritization</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#distance"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">Distance</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#similarity-coverage"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">Similarity &amp; Coverage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#probability"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">Probability</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#power-assignment"><span class="nav-number">2.3.4.</span> <span class="nav-text">Power Assignment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mutator-scheduling"><span class="nav-number">2.3.5.</span> <span class="nav-text">Mutator Scheduling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data-flow-analysis"><span class="nav-number">2.3.6.</span> <span class="nav-text">Data-flow Analysis</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#challenges-and-solutions"><span class="nav-number">2.4.</span> <span class="nav-text">Challenges and Solutions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#binary-code-support"><span class="nav-number">2.4.1.</span> <span class="nav-text">Binary Code Support</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#automatic-target-identification"><span class="nav-number">2.4.2.</span> <span class="nav-text">Automatic target identification</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#differentiated-weight-metric"><span class="nav-number">2.4.3.</span> <span class="nav-text">Differentiated weight metric</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#global-optimum-deviation"><span class="nav-number">2.4.4.</span> <span class="nav-text">Global Optimum Deviation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#missing-indirect-calls"><span class="nav-number">2.4.5.</span> <span class="nav-text">Missing Indirect Calls</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exploration-exploitation-coordination"><span class="nav-number">2.4.6.</span> <span class="nav-text">Exploration-exploitation coordination</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#discussion"><span class="nav-number">2.5.</span> <span class="nav-text">Discussion</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#multi-targets-relationship-exploitation"><span class="nav-number">2.5.1.</span> <span class="nav-text">Multi-targets Relationship Exploitation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#technology-integration"><span class="nav-number">2.5.2.</span> <span class="nav-text">Technology Integration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#implementation-limitation"><span class="nav-number">2.5.3.</span> <span class="nav-text">Implementation Limitation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#efficiency-improvement"><span class="nav-number">2.5.4.</span> <span class="nav-text">Efficiency Improvement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#future-research-suggestions"><span class="nav-number">2.5.5.</span> <span class="nav-text">Future research suggestions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fuzzing-hack-art-and-science-cacm-2020"><span class="nav-number">3.</span> <span class="nav-text">Fuzzing: Hack, Art, and Science (CACM 2020)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#blackbox-fuzzing-1"><span class="nav-number">3.1.</span> <span class="nav-text">Blackbox Fuzzing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#grammar-based-fuzzing"><span class="nav-number">3.2.</span> <span class="nav-text">Grammar-Based Fuzzing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#whitebox-fuzzing-1"><span class="nav-number">3.3.</span> <span class="nav-text">Whitebox Fuzzing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#other-approaches"><span class="nav-number">3.4.</span> <span class="nav-text">Other Approaches</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#survey-of-directed-fuzzy-technology"><span class="nav-number">4.</span> <span class="nav-text">Survey of Directed Fuzzy Technology</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dse"><span class="nav-number">4.1.</span> <span class="nav-text">DSE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#symbolic-execution-algorithm"><span class="nav-number">4.1.1.</span> <span class="nav-text">Symbolic Execution Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#静态符号执行"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">静态符号执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态符号执行"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">动态符号执行</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#directed-symbolic-execution"><span class="nav-number">4.1.2.</span> <span class="nav-text">Directed Symbolic Execution</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#a-review-of-machine-learning-applications-in-fuzzing"><span class="nav-number">5.</span> <span class="nav-text">A Review of Machine Learning Applications in Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#overview-of-fuzzing"><span class="nav-number">5.1.</span> <span class="nav-text">OVERVIEW OF FUZZING</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pre-fuzzing-program-knowledge"><span class="nav-number">5.1.1.</span> <span class="nav-text">Pre-Fuzzing: Program Knowledge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stage-1-generate-inputs"><span class="nav-number">5.1.2.</span> <span class="nav-text">Stage 1: Generate Inputs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stage-2-select-inputs"><span class="nav-number">5.1.3.</span> <span class="nav-text">Stage 2: Select Inputs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stage-3-monitor-program"><span class="nav-number">5.1.4.</span> <span class="nav-text">Stage 3: Monitor Program</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stage-4-evaluate-inputs"><span class="nav-number">5.1.5.</span> <span class="nav-text">Stage 4: Evaluate Inputs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#post-fuzzing-interesting-program-states"><span class="nav-number">5.1.6.</span> <span class="nav-text">Post-Fuzzing: Interesting Program States</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#applications-of-machine-learning-to-fuzzing"><span class="nav-number">5.2.</span> <span class="nav-text">APPLICATIONS OF MACHINE LEARNING TO FUZZING</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#generate-inputs"><span class="nav-number">5.2.1.</span> <span class="nav-text">Generate Inputs</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#genetic-algorithms"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">Genetic Algorithms</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#deep-learning-and-neural-networks"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">Deep Learning and Neural Networks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reinforcement-learning"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">Reinforcement Learning</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#machine-learning-for-symbolic-execution"><span class="nav-number">5.2.1.4.</span> <span class="nav-text">Machine Learning for Symbolic Execution</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#post-fuzzing-interesting-program-states-1"><span class="nav-number">5.2.2.</span> <span class="nav-text">Post-Fuzzing: Interesting Program States</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seed-selection"><span class="nav-number">5.2.3.</span> <span class="nav-text">Seed selection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#input-and-corpus-minimization"><span class="nav-number">5.2.4.</span> <span class="nav-text">Input and Corpus Minimization</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#a-systematic-review-of-fuzzing-based-on-machine-learning-techniques"><span class="nav-number">6.</span> <span class="nav-text">A systematic review of fuzzing based on machine learning techniques</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#applying-machine-learning-techniques-for-different-fuzzing-steps"><span class="nav-number">6.1.</span> <span class="nav-text">Applying Machine Learning Techniques for Different Fuzzing Steps</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#seed-file-generation"><span class="nav-number">6.1.1.</span> <span class="nav-text">Seed file generation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#testcase-generation"><span class="nav-number">6.1.2.</span> <span class="nav-text">Testcase generation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#testcase-filter"><span class="nav-number">6.1.3.</span> <span class="nav-text">Testcase filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mutation-operator-selection"><span class="nav-number">6.1.4.</span> <span class="nav-text">Mutation operator selection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fitness-function"><span class="nav-number">6.1.5.</span> <span class="nav-text">Fitness function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exploitability-analysis"><span class="nav-number">6.1.6.</span> <span class="nav-text">Exploitability analysis</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#analysis-of-machine-learning-based-fuzzing-model"><span class="nav-number">6.2.</span> <span class="nav-text">Analysis of Machine Learning Based Fuzzing Model</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#selection-of-machine-learning-algorithm"><span class="nav-number">6.2.1.</span> <span class="nav-text">Selection of machine learning algorithm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pre-processing-method"><span class="nav-number">6.2.2.</span> <span class="nav-text">Pre-processing method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#datasets"><span class="nav-number">6.2.3.</span> <span class="nav-text">Datasets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#evaluation-metrics"><span class="nav-number">6.2.4.</span> <span class="nav-text">Evaluation metrics</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hyperparameters-setting"><span class="nav-number">6.2.5.</span> <span class="nav-text">Hyperparameters setting</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#performance-evaluation-of-fuzzing-model-based-on-machine-learning"><span class="nav-number">6.3.</span> <span class="nav-text">Performance Evaluation of Fuzzing Model Based on Machine Learning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#future-directions"><span class="nav-number">6.4.</span> <span class="nav-text">Future Directions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#the-art-science-and-engineering-of-fuzzing-a-survey"><span class="nav-number">7.</span> <span class="nav-text">The Art, Science, and Engineering of Fuzzing: A Survey</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#systemization-taxonomy-and-test-programs"><span class="nav-number">7.1.</span> <span class="nav-text">SYSTEMIZATION, TAXONOMY, AND TEST PROGRAMS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#preprocess"><span class="nav-number">7.2.</span> <span class="nav-text">PREPROCESS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#instrumentation"><span class="nav-number">7.2.1.</span> <span class="nav-text">Instrumentation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#execution-feedback"><span class="nav-number">7.2.2.</span> <span class="nav-text">Execution Feedback</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#thread-scheduling"><span class="nav-number">7.2.3.</span> <span class="nav-text">Thread Scheduling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#in-memory-fuzzing"><span class="nav-number">7.2.4.</span> <span class="nav-text">In-Memory Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seed-selection-1"><span class="nav-number">7.2.5.</span> <span class="nav-text">Seed Selection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seed-trimming"><span class="nav-number">7.2.6.</span> <span class="nav-text">Seed Trimming</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#preparing-a-driver-application"><span class="nav-number">7.2.7.</span> <span class="nav-text">Preparing a Driver Application</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scheduling"><span class="nav-number">7.3.</span> <span class="nav-text">SCHEDULING</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#black-box-fcs-algorithms"><span class="nav-number">7.3.1.</span> <span class="nav-text">Black-box FCS Algorithms</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#grey-box-fcs-algorithms"><span class="nav-number">7.3.2.</span> <span class="nav-text">Grey-box FCS Algorithms</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#input-generation"><span class="nav-number">7.4.</span> <span class="nav-text">INPUT GENERATION</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#model-based-generation-based-fuzzers"><span class="nav-number">7.4.1.</span> <span class="nav-text">Model-based (Generation-based) Fuzzers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#model-less-mutation-based-fuzzers"><span class="nav-number">7.4.2.</span> <span class="nav-text">Model-less (Mutation-based) Fuzzers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#white-box-fuzzers"><span class="nav-number">7.4.3.</span> <span class="nav-text">White-box Fuzzers</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#input-evaluation"><span class="nav-number">7.5.</span> <span class="nav-text">INPUT EVALUATION</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bug-oracles"><span class="nav-number">7.5.1.</span> <span class="nav-text">Bug Oracles</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#triage"><span class="nav-number">7.5.2.</span> <span class="nav-text">Triage</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#configuration-updating"><span class="nav-number">7.6.</span> <span class="nav-text">CONFIGURATION UPDATING</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#evolutionary-seed-pool-update"><span class="nav-number">7.6.1.</span> <span class="nav-text">Evolutionary Seed Pool Update</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fuzzing-a-survey"><span class="nav-number">8.</span> <span class="nav-text">Fuzzing: a survey</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#background-1"><span class="nav-number">8.1.</span> <span class="nav-text">Background</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#types-of-fuzzers"><span class="nav-number">8.2.</span> <span class="nav-text">Types of fuzzers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#coverage-based-fuzzing"><span class="nav-number">8.3.</span> <span class="nav-text">Coverage-based fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#how-to-get-initial-inputs"><span class="nav-number">8.3.1.</span> <span class="nav-text">How to get initial inputs?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#how-to-generate-testcases"><span class="nav-number">8.3.2.</span> <span class="nav-text">How to generate testcases?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#how-to-select-seed-from-the-pool"><span class="nav-number">8.3.3.</span> <span class="nav-text">How to select seed from the pool?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#how-to-efficiently-test-applications"><span class="nav-number">8.3.4.</span> <span class="nav-text">How to efficiently test applications?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#techniques-integrated-in-fuzzing"><span class="nav-number">8.4.</span> <span class="nav-text">Techniques integrated in fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#testcase-generation-1"><span class="nav-number">8.4.1.</span> <span class="nav-text">Testcase generation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#program-execution"><span class="nav-number">8.4.2.</span> <span class="nav-text">Program execution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fuzzing-towards-different-applications"><span class="nav-number">8.5.</span> <span class="nav-text">Fuzzing towards different applications</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#file-format-fuzzing"><span class="nav-number">8.5.1.</span> <span class="nav-text">File format fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kernel-fuzzing"><span class="nav-number">8.5.2.</span> <span class="nav-text">Kernel fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzing-of-protocols"><span class="nav-number">8.5.3.</span> <span class="nav-text">Fuzzing of protocols</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fuzzing-state-of-the-art"><span class="nav-number">9.</span> <span class="nav-text">Fuzzing: State of the Art</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#state-of-the-art-in-fuzzing"><span class="nav-number">9.1.</span> <span class="nav-text">STATE OF THE ART IN FUZZING</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#seeds-generation-and-selection"><span class="nav-number">9.1.1.</span> <span class="nav-text">Seeds Generation and Selection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#input-validation-and-coverage"><span class="nav-number">9.1.2.</span> <span class="nav-text">Input Validation and Coverage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#handling-crash-inducing-test-cases"><span class="nav-number">9.1.3.</span> <span class="nav-text">Handling Crash-Inducing Test Cases</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#leveraging-runtime-information"><span class="nav-number">9.1.4.</span> <span class="nav-text">Leveraging Runtime Information</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scalability-in-fuzzing"><span class="nav-number">9.1.5.</span> <span class="nav-text">Scalability in Fuzzing</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tools-in-different-application-areas"><span class="nav-number">9.2.</span> <span class="nav-text">TOOLS IN DIFFERENT APPLICATION AREAS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#general-purpose-fuzzers"><span class="nav-number">9.2.1.</span> <span class="nav-text">General Purpose Fuzzers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzers-for-compilers-and-interpreters"><span class="nav-number">9.2.2.</span> <span class="nav-text">Fuzzers for Compilers and Interpreters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzers-for-application-software"><span class="nav-number">9.2.3.</span> <span class="nav-text">Fuzzers for Application Software</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzers-for-network-protocols"><span class="nav-number">9.2.4.</span> <span class="nav-text">Fuzzers for Network Protocols</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzers-for-os-kernels"><span class="nav-number">9.2.5.</span> <span class="nav-text">Fuzzers for OS Kernels</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuzzers-for-embedded-devices-drivers-and-components"><span class="nav-number">9.2.6.</span> <span class="nav-text">Fuzzers for Embedded Devices, Drivers and Components</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#future-directions-1"><span class="nav-number">9.3.</span> <span class="nav-text">FUTURE DIRECTIONS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#input-validation-and-coverage-1"><span class="nav-number">9.3.1.</span> <span class="nav-text">Input Validation and Coverage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#smart-fuzzing"><span class="nav-number">9.3.2.</span> <span class="nav-text">Smart Fuzzing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filtering-fuzzing-outputs"><span class="nav-number">9.3.3.</span> <span class="nav-text">Filtering Fuzzing Outputs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seedinput-generation-and-selection"><span class="nav-number">9.3.4.</span> <span class="nav-text">Seed/Input Generation and Selection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#combining-different-testing-methods"><span class="nav-number">9.3.5.</span> <span class="nav-text">Combining Different Testing Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#combining-other-techniques-with-fuzzing"><span class="nav-number">9.3.6.</span> <span class="nav-text">Combining Other Techniques With Fuzzing</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-gg-circle"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">w4rd3n</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">897k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">13:35</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "no3Ip4mNLc3JyF1AeTy8LrAm-gzGzoHsz",
                'X-LC-Key': "UvlYMzpJKw0Jrw61V5BA5ifU",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  
  

  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>;
  <script>
  //$("body").backstretch("/images/background.jpg");
  </script>
  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
